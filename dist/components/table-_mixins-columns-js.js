"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/table-_mixins-columns-js"],{

/***/ "./src/components/table/_mixins/columns.js":
/*!*************************************************!*\
  !*** ./src/components/table/_mixins/columns.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  props: {\n    /**\n     * An array of objects with at least the property 'field' that can replace the html '<bbns-column></bbns-column>' or extend them.\n     * @prop {Array} [[]] columns\n     */\n    columns: {\n      type: Array,\n      default: function () {\n        return [];\n      }\n    }\n  },\n  data() {\n    return {\n      /**\n       * The group of columns.\n       * @data {Object} [[{name: 'left',width: 0,visible: 0,cols: []},{name: 'main',width: 0,visible: 0,cols: []},{name: 'right',width: 0,visible: 0,cols: []}]] groupCols\n       */\n      groupCols: [{\n        name: 'left',\n        width: 0,\n        visible: 0,\n        cols: []\n      }, {\n        name: 'main',\n        width: 0,\n        visible: 0,\n        cols: []\n      }, {\n        name: 'right',\n        width: 0,\n        visible: 0,\n        cols: []\n      }],\n      /**\n       * @data {Array} [[]] cols\n       */\n      cols: []\n    };\n  },\n  computed: {\n    /**\n     * Return an array of shown fields (the hidden ones are excluded).\n     * @computed shownFields\n     * @returns {Array}\n     */\n    shownFields() {\n      let r = [];\n      bbn.fn.each(this.cols, a => {\n        if (!a.invisible) {\n          r.push(a.field);\n        }\n      });\n      return r;\n    },\n    allFields() {\n      const res = [];\n      for (let i = 0; i < this.cols.length; i++) {\n        if (this.cols[i].field && !res.includes(this.cols[i].field)) {\n          res.push(this.cols[i].field);\n        }\n      }\n      return res;\n    },\n    /**\n     * The current columns of the table.\n     * @computed currentColumns\n     * @returns {Array}\n     */\n    currentColumns() {\n      let r = [];\n      bbn.fn.each([].concat(this.groupCols), (a, i) => {\n        bbn.fn.each(a.cols, b => {\n          r.push(bbn.fn.extend(true, {}, b, {\n            fixed: i !== 1,\n            isLeft: i === 0,\n            isRight: i === 2,\n            realWidth: b.realWidth ? b.realWidth + 'px' : 'auto'\n          }));\n        });\n      });\n      return r;\n    }\n  },\n  methods: {\n    /**\n     * Returns the configuration for the cells of the titles of grouped columns.\n     * @method titleGroupsCells\n     * @param {Number} groupIndex\n     * @returns {Array}\n     */\n    titleGroupsCells(groupIndex) {\n      if (this.titleGroups) {\n        let cells = [],\n          group = null,\n          corresp = {},\n          beforeWidth = 0;\n        bbn.fn.each(this.groupCols, (c, i) => {\n          if (i === groupIndex) {\n            return false;\n          }\n          beforeWidth += c.width;\n        });\n        bbn.fn.each(this.groupCols[groupIndex].cols, a => {\n          if (!a.invisible) {\n            if (a.group === group) {\n              cells[cells.length - 1].colspan++;\n              cells[cells.length - 1].width += a.realWidth;\n              if (a.left !== undefined) {\n                if (cells[cells.length - 1].left === undefined || a.left < cells[cells.length - 1].left) {\n                  cells[cells.length - 1].left = a.left;\n                }\n              }\n              if (a.right !== undefined) {\n                if (cells[cells.length - 1].right === undefined || a.right < cells[cells.length - 1].right) {\n                  cells[cells.length - 1].right = a.right;\n                }\n              }\n            } else {\n              if (corresp[a.group] === undefined) {\n                let idx = bbn.fn.search(this.titleGroups, 'value', a.group);\n                if (idx > -1) {\n                  corresp[a.group] = idx;\n                }\n              }\n              if (corresp[a.group] !== undefined) {\n                cells.push({\n                  text: this.titleGroups[corresp[a.group]].text || '&nbsp;',\n                  style: this.titleGroups[corresp[a.group]].style || {},\n                  cls: this.titleGroups[corresp[a.group]].cls || '',\n                  colspan: 1,\n                  width: a.realWidth,\n                  left: a.left !== undefined ? a.left : undefined,\n                  right: a.right !== undefined ? a.right : undefined,\n                  contentLeft: beforeWidth\n                });\n              }\n              /*\n              else if ( this.titleGroups.default ){\n                cells.push({\n                  text: this.titleGroups.default.text || '&nbsp;',\n                  style: this.titleGroups.default.style || {},\n                  cls: this.titleGroups.default.cls || '',\n                  colspan: 1,\n                  width: a.realWidth\n                });\n              }\n              */else {\n                cells.push({\n                  text: '&nbsp;',\n                  style: '',\n                  cls: '',\n                  colspan: 1,\n                  width: a.realWidth,\n                  left: a.left !== undefined ? a.left : undefined,\n                  right: a.right !== undefined ? a.right : undefined,\n                  contentLeft: beforeWidth\n                });\n              }\n              group = a.group;\n            }\n          }\n        });\n        return cells;\n      }\n    },\n    initColumns() {\n      const groupCols = [{\n        name: 'left',\n        width: 0,\n        visible: 0,\n        cols: []\n      }, {\n        name: 'main',\n        width: 0,\n        visible: 0,\n        cols: []\n      }, {\n        name: 'right',\n        width: 0,\n        visible: 0,\n        cols: []\n      }];\n      let isAggregated = false;\n      let aggregatedColIndex = false;\n      let aggregatedColTitle = false;\n      let aggregatedColumns = [];\n      const parentStyle = this.$el.offsetParent ? window.getComputedStyle(this.$el.offsetParent) : {};\n      const parentPadding = Math.floor(parseFloat(parentStyle?.paddingLeft || 0) + parseFloat(parentStyle?.paddingRight || 0));\n      const parentWidth = Math.floor(this.$el.offsetParent ? this.$el.offsetParent.getBoundingClientRect().width : this.lastKnownCtWidth) - parentPadding;\n      this.cols.map(a => {\n        a.realWidth = 0;\n      });\n      bbn.fn.each(this.cols, (a, i) => {\n        if (!a.invisible && (!this.groupable || this.group !== i)) {\n          let minWidth = null;\n          let maxWidth = null;\n          if (a.minWidth) {\n            minWidth = this.getDimensionWidth(a.minWidth);\n          }\n          if (a.maxWidth) {\n            maxWidth = this.getDimensionWidth(a.maxWidth);\n          }\n          a.index = i;\n          if (a.invisible) {\n            a.realWidth = 0;\n          } else {\n            if (this.aggregate && a.aggregate) {\n              if (aggregatedColIndex === false) {\n                aggregatedColIndex = i;\n                isAggregated = true;\n              }\n              aggregatedColumns.push(a);\n            }\n            if (a.width) {\n              if (bbn.fn.isString(a.width) && bbn.fn.substr(a.width, -1) === '%') {\n                a.realWidth = Math.floor(parentWidth * this.getDimensionWidth(a.width) / 100);\n                if (a.realWidth < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {\n                  a.realWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;\n                }\n              } else {\n                a.realWidth = this.getDimensionWidth(a.width);\n              }\n            } else {\n              a.realWidth = bbn.fn.isMobile() ? this.defaultColumnWidthMobile : this.defaultColumnWidth;\n            }\n            if (minWidth && a.realWidth < minWidth) {\n              a.realWidth = minWidth;\n            }\n            if (maxWidth && a.realWidth > maxWidth) {\n              a.realWidth = maxWidth;\n            }\n            if (a.buttons !== undefined) {\n              this.colButtons = i;\n            }\n            if (a.fixed) {\n              if (a.fixed === 'left' || a.fixed !== 'right' && this.fixedDefaultSide === 'left') {\n                if (a.buttons !== undefined) {\n                  //colButtons = groupCols[0].cols.length;\n                }\n                groupCols[0].cols.push(a);\n                if (!a.invisible) {\n                  groupCols[0].visible++;\n                }\n              } else {\n                if (a.buttons !== undefined) {\n                  //colButtons = groupCols[0].cols.length + groupCols[1].cols.length + groupCols[2].cols.length;\n                }\n                groupCols[2].cols.push(a);\n                if (!a.invisible) {\n                  groupCols[2].visible++;\n                }\n              }\n            } else {\n              if (a.buttons !== undefined) {\n                //colButtons = groupCols[0].cols.length + groupCols[1].cols.length;\n              }\n              groupCols[1].cols.push(a);\n              if (!a.invisible) {\n                groupCols[1].visible++;\n              }\n            }\n          }\n        }\n      });\n      let firstGroup = groupCols[0].visible ? 0 : 1;\n      if (this.selection) {\n        let o = {\n          isExpander: false,\n          isSelection: true,\n          label: ' ',\n          filterable: false,\n          width: 40,\n          realWidth: 40\n        };\n        if (firstGroup === 0) {\n          o.fixed = true;\n          o.isLeft = true;\n        }\n        groupCols[firstGroup].cols.unshift(o);\n        groupCols[firstGroup].visible++;\n      }\n      if (this.hasExpander) {\n        let o = {\n          isExpander: true,\n          isSelection: false,\n          label: ' ',\n          filterable: false,\n          width: 30,\n          realWidth: 30\n        };\n        if (firstGroup === 0) {\n          o.fixed = true;\n          o.isLeft = true;\n        }\n        groupCols[firstGroup].cols.unshift(o);\n        groupCols[firstGroup].visible++;\n      }\n      bbn.fn.each(groupCols, a => {\n        a.sum = bbn.fn.sum(a.cols, 'realWidth');\n      });\n      this.groupCols.splice(0, this.groupCols.length, ...groupCols);\n    },\n    /**\n     * Returns the columns configuration.\n     * @method getColumnsConfig\n     * @returns {Array}\n     */\n    getColumnsConfig() {\n      return JSON.parse(JSON.stringify(this.cols));\n    },\n    /**\n     * Adds the given column to table's configuration\n     * @method addColumn\n     * @param {Object} obj\n     */\n    addColumn(obj) {\n      if (!obj) {\n        return;\n      }\n      let def = this.defaultObject();\n      if (obj.aggregate && !Array.isArray(obj.aggregate)) {\n        obj.aggregate = [obj.aggregate];\n      }\n      for (let n in obj) {\n        def[bbn.fn.camelize(n)] = obj[n];\n      }\n      if (!!obj.buttons) {\n        def.filterable = false;\n        def.sortable = false;\n      }\n      def.ready = false;\n      this.cols.push(def);\n    },\n    getColOptions(data, col, idx) {\n      if (col.options) {\n        return bbn.fn.isFunction(col.options) ? col.options(data, col, idx) : col.options;\n      }\n      return {};\n    }\n  },\n  watch: {\n    columns() {\n      bbn.fn.log(\"WATCH COLUMNS\");\n      if (this.ready) {\n        this.cols.splice(0, this.cols.length);\n        if (this.columns.length) {\n          bbn.fn.each(this.columns, a => this.addColumn(a));\n        }\n        if (this.defaultConfig.invisible === null) {\n          let tmp = [];\n          let initColumn = [];\n          bbn.fn.each(this.cols, (a, i) => {\n            if (a.invisible) {\n              tmp.push(a.field || i);\n            } else if (initColumn.length <= 10) {\n              initColumn.push(i);\n            }\n          });\n          this.defaultConfig.invisible = tmp;\n        }\n        this.init();\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/_mixins/columns.js?");

/***/ })

}]);