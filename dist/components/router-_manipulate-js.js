"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/router-_manipulate-js"],{

/***/ "./src/components/router/_manipulate.js":
/*!**********************************************!*\
  !*** ./src/components/router/_manipulate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   closeAll: () => (/* binding */ closeAll),\n/* harmony export */   closeAllBut: () => (/* binding */ closeAllBut),\n/* harmony export */   closeTab: () => (/* binding */ closeTab),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   pin: () => (/* binding */ pin),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   unpin: () => (/* binding */ unpin)\n/* harmony export */ });\n/**\n * Removes an element from the views\n * \n * @method remove\n * @param {*} misc Index, URL or element\n * @param {Boolean} noCfg If set to true will not trigger the storage saving\n * @fires getIndex\n * @fires remove\n * @emit close\n * @return {Boolean}\n */\nasync function remove(misc, force) {\n  let idx = this.getIndex(misc);\n  if (idx > -1) {\n    /** @var {Event} onBeforeClose beforeClose event, cancelable only if not force */\n    let onBeforeClose = new Event('beforeClose', {\n      cancelable: !force\n    });\n    /** @var {Event} onClose close event, cancelable only if not force */\n    let onClose = new Event('close');\n    this.$emit('beforeClose', idx, onBeforeClose);\n    //bbn.fn.log(\"REMOVING \" + this.views[idx].url)\n    if (force || !onBeforeClose.defaultPrevented) {\n      if (!force && !this.ignoreDirty && this.isDirty && this.views[idx].dirty) {\n        this.confirm(this.confirmLeave, () => {\n          // Looking for dirty ones in registered forms of each container\n          let forms = this.urls[this.views[idx].url].forms;\n          if (Array.isArray(forms) && forms.length) {\n            bbn.fn.each(forms, (f, k) => {\n              f.reset();\n            });\n          }\n          return this.close(idx, true);\n        });\n      } else if (this.views[idx] && !this.views[idx].real) {\n        bbn.fn.log([\"ERMOVE FROM ROUTER \" + idx, force]);\n        this.$emit('close', idx, onClose);\n        this.views.splice(idx, 1);\n        bbn.fn.log([\"ERMOVE FROM ROUTER \" + idx, bbn.fn.numProperties(this.urls), this.views.length]);\n        this.fixIndexes();\n        await this.$forceUpdate();\n        await this.$nextTick();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n/**\n * Adds an object with a valid url to the views.\n * @method add\n * @param {Object} obj\n * @param {Number} idx\n * @fires getFullBaseURL\n * @fires search\n * @fires isValidIndex\n * @fires getDefaultView\n */\nasync function add(obj, idx) {\n  let index;\n  //obj must be an object with property url\n  if (bbn.fn.isObject(obj) && bbn.fn.isString(obj.url)) {\n    obj.url = bbn.fn.replaceAll('//', '/', obj.url);\n    // This is a component\n    if (obj.$options) {\n      if (!obj.current && !obj.currentURL) {\n        if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj.url ? obj.url + '/' : '')) === 0) {\n          obj.currentURL = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);\n        } else {\n          obj.currentURL = obj.url;\n        }\n      }\n      /*\n      else {\n        if (obj.currentURL) {\n          obj.currentURL = bbn.fn.replaceAll(obj.currentURL);\n        }\n      }\n      */\n      let obj2 = bbn.fn.extend(true, {}, obj.$options.propsData),\n        props = obj.$options.props;\n      bbn.fn.iterate(props, (v, i) => {\n        if (!(i in obj2) && 'default' in v) {\n          obj2[i] = v.default;\n        }\n      });\n      bbn.fn.iterate(this.getDefaultView(), (a, n) => {\n        if (obj2[n] === undefined) {\n          obj2[n] = a;\n        }\n      });\n      obj2.real = true;\n\n      // ---- ADDED 16/12/20 (Mirko) ----\n      if (!obj2.current) {\n        if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj2.url ? obj2.url + '/' : '')) === 0) {\n          obj2.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);\n        } else {\n          obj2.current = obj2.url;\n        }\n      } else if (obj2.current !== obj2.url && obj2.current.indexOf(obj2.url + '/') !== 0) {\n        obj2.current = obj2.url;\n      }\n      if (!obj2.current) {\n        obj2.current = obj2.url;\n      }\n      if (obj2.content) {\n        obj2.loaded = true;\n      }\n      // ---- END ----\n\n      if (obj2.real && !this.hasRealContainers) {\n        this.hasRealContainers = true;\n      }\n      if (obj2.url === '') {\n        this.hasEmptyURL = true;\n      }\n      if (this.search(obj2.url) === false) {\n        if (this.isValidIndex(idx)) {\n          this.views.splice(idx, 0, obj2);\n        } else if (this.hasRealContainers && this.first !== 'real' && !obj2.real) {\n          idx = bbn.fn.search(this.views, {\n            real: true\n          });\n          this.views.splice(idx, 0, obj2);\n        } else {\n          this.views.push(obj2);\n        }\n      }\n    } else {\n      if (!obj.current) {\n        if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj.url ? obj.url + '/' : '')) === 0) {\n          obj.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);\n        } else {\n          obj.current = obj.url;\n        }\n      } else if (obj.current !== obj.url && obj.current.indexOf(obj.url + '/') !== 0) {\n        obj.current = obj.url;\n      }\n      if (!obj.current) {\n        obj.current = obj.url;\n      }\n      if (obj.content) {\n        obj.loaded = true;\n      }\n      obj.events = {};\n      if (obj.menu === undefined) {\n        obj.menu = [];\n      }\n      index = this.search(obj.url);\n      if (index !== false) {\n        let o = this.views[index],\n          cn = this.urls[this.views[index].url];\n        if (idx === undefined) {\n          idx = index;\n        }\n        if (cn && this.isValidIndex(idx)) {\n          cn.currentIndex = idx;\n        }\n        if (obj.real) {\n          return;\n        }\n        bbn.fn.iterate(obj, (a, n) => {\n          if (o[n] !== a) {\n            // Each new property must be set with $set\n            this.$set(o, n, a);\n          }\n        });\n      } else {\n        let isValid = this.isValidIndex(idx);\n        obj.selected = false;\n        obj.idx = isValid ? idx : this.views.length;\n        bbn.fn.iterate(this.getDefaultView(), (a, n) => {\n          if (obj[n] === undefined) {\n            // Each new property must be set with $set\n            this.$set(obj, n, a);\n          }\n        });\n        obj.uid = obj.url + '-' + bbn.fn.randomString();\n        if (this.single && this.views.length) {\n          await this.remove(0, true);\n          obj.idx = 0;\n          isValid = false;\n        }\n        if (isValid) {\n          this.views.splice(obj.idx, 0, obj);\n        } else if (this.hasRealContainers && this.first !== 'real' && !obj.real) {\n          idx = bbn.fn.search(this.views, {\n            real: true\n          });\n          this.views.splice(idx, 0, obj);\n        } else {\n          this.views.push(obj);\n        }\n      }\n    }\n    this.fixIndexes();\n  }\n}\n/**\n * Moves a container within the router, changes its idx.\n * \n * @method move\n * @param {Number} from The index of the container to move\n * @param {Number} to   The index to which the container must go\n * @returns \n */\nfunction move(from, to) {\n  if (!bbn.fn.isNumber(from, to) || from === to || !this.views[from] || !this.views[to]) {\n    return;\n  }\n  bbn.fn.move(this.views, from, to);\n  let selectedOk = false;\n  if (from === this.selected) {\n    this.selected = to;\n    selectedOk = true;\n  }\n  for (let i = Math.min(from, to); i <= Math.max(from, to); i++) {\n    if (this.views[i].idx !== i) {\n      if (!selectedOk && this.selected === this.views[i].idx) {\n        this.selected = i;\n      }\n      this.views[i].idx = i;\n    }\n  }\n  this.setConfig();\n}\n/**\n * @method close\n * @param {Number}  idx   The index of the container to close\n * @param {Boolean} force Will close the container without prevention\n * @param {Boolean} noCfg If set to true will not trigger the storage saving\n * @fires remove\n * @fires getIndex\n * @fires activateIndex\n * @fires setConfig\n * @return {Boolean}\n */\nfunction close(idx, force, noCfg) {\n  bbn.fn.log(\"CLOSING CT\");\n  let res = this.remove(idx, force);\n  if (res) {\n    if (this.selected > idx) {\n      this.selected--;\n    } else if (idx === this.selected) {\n      this.selectClosest(idx);\n    }\n    if (!noCfg) {\n      this.setConfig();\n    }\n  }\n  return res;\n}\n/**\n * @method closeAll\n * @fires close\n */\nfunction closeAll(force) {\n  for (let i = this.views.length - 1; i >= 0; i--) {\n    if (!this.views[i].fixed && !this.views[i].pinned) {\n      this.close(i, force, true);\n    }\n  }\n  this.setConfig();\n}\n/**\n * @method closeallBut\n * @param {Number} idx\n * @fires close\n */\nfunction closeAllBut(idx, force) {\n  for (let i = this.views.length - 1; i >= 0; i--) {\n    if (!this.views[i].fixed && !this.views[i].pinned && i !== idx) {\n      this.close(i, force, true);\n    }\n  }\n  this.setConfig();\n}\nfunction closeTab(idx) {\n  this.close(this.tabsList[idx].idx);\n}\n\n/**\n * @method pin\n * @param {Number} idx\n * @fires isValidIndex\n * @fires setConfig\n * @emit beforePin\n * @emit pin\n */\nfunction pin(idx) {\n  if (this.isValidIndex(idx)) {\n    let ev = new CustomEvent('beforePin', {\n      cancelable: true\n    });\n    this.$emit('beforePin', idx, ev);\n    if (!ev.defaultPrevented) {\n      this.views[idx].pinned = true;\n      this.setConfig();\n      this.$emit('pin', idx);\n    }\n  }\n}\n\n/**\n * @method unpin\n * @param {Number} idx\n * @fires isValidIndex\n * @fires setConfig\n * @emit beforeUnpin\n * @emit unpin\n */\nfunction unpin(idx) {\n  if (this.isValidIndex(idx)) {\n    let ev = new CustomEvent('beforeUnpin', {\n      cancelable: true\n    });\n    this.$emit('beforeUnpin', idx, ev);\n    if (!ev.defaultPrevented) {\n      this.views[idx].pinned = false;\n      this.setConfig();\n      this.$emit('unpin', idx);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/router/_manipulate.js?");

/***/ })

}]);