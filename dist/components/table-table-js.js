/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/table-table-js"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/table/table.less":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/table/table.less ***!
  \**********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.bbn-table .bbn-table-toolbar .bbn-header {\n  border-top: 0;\n  border-right: 0;\n  border-left: 0;\n}\n.bbn-table .bbn-table-container {\n  z-index: 0;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td,\n.bbn-table .bbn-table-container table.bbn-table-table tr th {\n  border-collapse: collapse;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td.bbn-table-fixed-cell,\n.bbn-table .bbn-table-container table.bbn-table-table tr th.bbn-table-fixed-cell {\n  position: sticky;\n  position: -webkit-sticky;\n  z-index: 1;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td.bbn-table-fixed-cell.bbn-table-fixed-cell-left:not(.bbn-table-fixed-cell-left-last),\n.bbn-table .bbn-table-container table.bbn-table-table tr th.bbn-table-fixed-cell.bbn-table-fixed-cell-left:not(.bbn-table-fixed-cell-left-last),\n.bbn-table .bbn-table-container table.bbn-table-table tr td.bbn-table-fixed-cell.bbn-table-fixed-cell-right,\n.bbn-table .bbn-table-container table.bbn-table-table tr th.bbn-table-fixed-cell.bbn-table-fixed-cell-right {\n  border-right: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td:not(.bbn-table-fixed-cell):not(:last-child),\n.bbn-table .bbn-table-container table.bbn-table-table tr th:not(.bbn-table-fixed-cell):not(:last-child) {\n  border-right: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td.bbn-table-cell-first,\n.bbn-table .bbn-table-container table.bbn-table-table tr th.bbn-table-cell-first {\n  border-left: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td:last-of-type,\n.bbn-table .bbn-table-container table.bbn-table-table tr th:last-of-type {\n  border-right: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table tr td:first-of-type,\n.bbn-table .bbn-table-container table.bbn-table-table tr th:first-of-type {\n  border-left: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > thead tr {\n  height: 39px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > thead tr th {\n  border-top: 0px;\n  position: relative;\n  padding: 0.5rem;\n  font-weight: bold;\n  vertical-align: middle;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > thead tr th:not(.bbn-table-fixed-cell-left-last) {\n  border-right: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > thead tr th i.bbn-table-sortable-icon {\n  position: absolute;\n  left: 50%;\n  bottom: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr {\n  border: 0;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr.bbn-widget {\n  box-sizing: border-box;\n  border-left-width: 0;\n  border-right-width: 0;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr:last-child td {\n  border-bottom: 0px;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td {\n  overflow: hidden;\n  box-sizing: border-box;\n  border-top: 0px;\n  padding: 0;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td > div {\n  overflow: hidden;\n  height: 100%;\n  width: 100%;\n  word-break: break-word;\n  box-sizing: border-box;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td > div > .bbn-table-expander {\n  line-height: 1rem;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td > div > .bbn-table-expander i:focus {\n  color: red;\n  outline: 0;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td > div .bbn-table-dirty {\n  width: 0px;\n  height: 0px;\n  border-style: solid;\n  border-width: 3px;\n  border-color: red transparent transparent red;\n  padding: 0;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td > div .bbn-table-dirty:before {\n  content: \"\\\\a0\";\n  display: inline-block;\n  width: 0;\n  float: left;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td.bbn-buttons-flex .bbn-block div {\n  display: flex!important;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td.bbn-buttons-flex .bbn-block div .bbn-button.bbn-button-icon-only {\n  margin: 0.1rem 0.1rem !important;\n  height: 2rem;\n  width: 2rem;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td.bbn-buttons-flex.bbn-c .bbn-block div {\n  justify-content: center;\n}\n.bbn-table .bbn-table-container table.bbn-table-table > tbody > tr td.bbn-buttons-flex.bbn-r .bbn-block div {\n  justify-content: flex-end;\n}\n.bbn-table .bbn-table-container .bbn-scrollbar {\n  z-index: 2;\n}\n.bbn-table > div.bbn-table-footer {\n  clear: both;\n  overflow: hidden;\n  position: relative;\n  border-style: solid;\n  border-width: 0.0833rem;\n  line-height: 2rem;\n  padding: 0.333rem 0.25rem;\n}\n.bbn-table .toolbar-buttons {\n  padding: 0.3rem 0;\n}\n.bbn-table .toolbar-buttons button {\n  margin: 0 0.3rem;\n}\n.bbn-table-column-picker ul {\n  list-style: none;\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/table.less?./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/components/table/table.html":
/*!*****************************************!*\
  !*** ./src/components/table/table.html ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Module\nvar code = \"<div :class=\\\"[{'bbn-overlay': scrollable, 'bbn-block': !scrollable}, componentClass, 'bbn-bordered']\\\">\\n  <div :class=\\\"{'bbn-overlay': scrollable, 'bbn-flex-height': scrollable, 'bbn-block': !scrollable}\\\"\\n       :style=\\\"scrollable && groupCols.length ? {} : {\\n         width: totalWidth\\n       }\\\"\\n       bbn-if=\\\"cols.length\\\">\\n    <div bbn-if=\\\"hasToolbar\\\"\\n         class=\\\"bbn-table-toolbar bbn-w-100\\\"\\n         ref=\\\"toolbar\\\">\\n      <bbn-toolbar bbn-if=\\\"toolbarButtons.length || (search && !isString(toolbar) && !isObject(toolbar))\\\"\\n                   :source=\\\"toolbarButtons\\\"\\n                   :slot-before=\\\"toolbarSlotBefore\\\">\\n        <slot name=\\\"toolbar\\\"></slot>\\n        <template bbn-slot:right>\\n          <div bbn-if=\\\"search\\\"\\n               class=\\\"bbn-hsmargin\\\">\\n            <bbn-input :nullable=\\\"true\\\"\\n                       button-right=\\\"nf nf-fa-search\\\"\\n                       class=\\\"bbn-wide\\\"\\n                       bbn-model=\\\"searchValue\\\"/>\\n           </div>\\n        </template>\\n      </bbn-toolbar>\\n      <div bbn-elseif=\\\"typeof toolbar === 'function'\\\"\\n           bbn-html=\\\"toolbar()\\\"/>\\n      <component bbn-else\\n                 :is=\\\"toolbar\\\"/>\\n    </div>\\n    <div :class=\\\"['bbn-w-100', 'bbn-table-container', {'bbn-flex-fill': scrollable}]\\\">\\n      <div bbn-if=\\\"initStarted || isLoading\\\"\\n           class=\\\"bbn-overlay bbn-middle bbn-background\\\"\\n           style=\\\"z-index: 5\\\">\\n        <bbn-loadicon class=\\\"bbn-vmiddle\\\"\\n                      :size=\\\"24\\\"/>\\n        <span class=\\\"bbn-xl bbn-b bbn-left-sspace\\\"\\n              bbn-text=\\\"_('Loading') + '...'\\\"/>\\n      </div>\\n      <bbn-scroll bbn-elseif=\\\"currentColumns.length\\\"\\n                  :scrollable=\\\"scrollable\\\"\\n                  :autoresize=\\\"false\\\"\\n                  class=\\\"bbn-w-100\\\"\\n                  ref=\\\"scroll\\\"\\n                  :offset-y=\\\"$refs.thead ? [$refs.thead.getBoundingClientRect().height, 0] : [0,0]\\\"\\n                  @resize=\\\"resizeWidth\\\">\\n        <table :style=\\\"{width: totalWidth}\\\"\\n               ref=\\\"table\\\"\\n               aria-describedby=\\\"table\\\"\\n               class=\\\"bbn-table-table\\\">\\n          <colgroup>\\n            <template bbn-for=\\\"(groupCol, groupIndex) in groupCols\\\">\\n              <col bbn-for=\\\"(col, i) in groupCol.cols\\\"\\n                  bbn-show=\\\"!col.hidden\\\"\\n                  :style=\\\"{width: col.realWidth + 'px'}\\\"\\n                  :key=\\\"groupIndex + '-'+ i\\\">\\n            </template>\\n          </colgroup>\\n          <thead bbn-if=\\\"titles\\\" ref=\\\"thead\\\">\\n            <tr bbn-if=\\\"titleGroups\\\">\\n              <template bbn-for=\\\"(groupCol, groupIndex) in groupCols\\\">\\n                <th bbn-for=\\\"(col, i) in titleGroupsCells(groupIndex)\\\"\\n                    :colspan=\\\"col.colspan\\\"\\n                    scope=\\\"colgroup\\\"\\n                    :style=\\\"{\\n                      zIndex: (col.left !== undefined) || (col.right !== undefined) ? 4 : 3,\\n                      top: '0px',\\n                      left: col.left !== undefined ? (col.left + 'px') : '',\\n                      right: col.right !== undefined ? (col.right + 'px') : '',\\n                      width: col.width + 'px'\\n                    }\\\"\\n                    :class=\\\"['bbn-table-fixed-cell', {\\n                      'bbn-table-fixed-cell-left': groupIndex === 0,\\n                      'bbn-table-fixed-cell-left-last': (groupIndex === 0) && !titleGroupsCells(groupIndex)[i+1],\\n                      'bbn-table-fixed-cell-right': groupIndex === 2,\\n                      'bbn-table-cell-first': (groupIndex === 1)\\n                        && titleGroupsCells(groupIndex).length\\n                        && (i === 0)\\n                    }]\\\"\\n                    :title=\\\"col.text\\\">\\n                  <component bbn-if=\\\"col.component\\\"\\n                            :is=\\\"col.component\\\"\\n                            :source=\\\"col\\\"/>\\n                  <div class=\\\"bbn-100 bbn-table-title-group\\\" bbn-else>\\n                    <div :class=\\\"[col.cls, 'bbn-ellipsis']\\\"\\n                        :style=\\\"col.style\\\"\\n                        bbn-html=\\\"col.text\\\"\\n                    ></div>\\n                  </div>\\n                </th>\\n              </template>\\n            </tr>\\n            <!-- Titles -->\\n            <tr>\\n              <template bbn-for=\\\"(groupCol, groupIndex) in groupCols\\\">\\n                <th bbn-for=\\\"(col, i) in groupCol.cols\\\"\\n                    bbn-show=\\\"!col.hidden\\\"\\n                    :style=\\\"{\\n                      left: col.left !== undefined ? (col.left + 'px') : '',\\n                      right: col.right !== undefined ? (col.right + 'px') : '',\\n                      width: col.realWidth + 'px',\\n                      zIndex: (col.left !== undefined) || (col.right !== undefined) ? 4 : 3,\\n                      top: titleGroups ? '39px' : '0px'\\n                    }\\\"\\n                    :class=\\\"['bbn-table-fixed-cell', {\\n                      'bbn-table-fixed-cell-left': groupIndex === 0,\\n                      'bbn-table-fixed-cell-left-last': (groupIndex === 0) && !groupCol.cols[i+1],\\n                      'bbn-table-fixed-cell-right': groupIndex === 2,\\n                      'bbn-table-cell-first': (groupIndex === 1)\\n                        && groupCols[0].cols.length\\n                        && (i === 0)\\n                    }]\\\"\\n                    :title=\\\"col.ftitle || col.title || col.field || ' '\\\">\\n                  <i :class=\\\"{\\n                      nf: true,\\n                      'nf nf-mdi-filter_variant': true,\\n                      'bbn-p': true,\\n                      'bbn-red': hasFilter(col)\\n                    }\\\"\\n                    bbn-if=\\\"showFilterOnColumn(col)\\\"\\n                    @click=\\\"showFilter(col, $event)\\\"/>\\n                  <div bbn-if=\\\"col.isSelection\\\" :title=\\\"_('Check all')\\\">\\n                    <bbn-checkbox bbn-model=\\\"allRowsChecked\\\"/>\\n                  </div>\\n                  <div bbn-elseif=\\\"col.isExpander\\\" :title=\\\"_('Expand all')\\\">\\n                    <!-- @todo an icon for expanding all/none -->\\n                  </div>\\n                  <component bbn-elseif=\\\"col.tcomponent\\\"\\n                            :is=\\\"col.tcomponent\\\"\\n                            :source=\\\"col\\\"/>\\n                  <span class=\\\"bbn-p\\\"\\n                        bbn-elseif=\\\"sortable && (col.sortable !== false) && !col.buttons\\\"\\n                        @click=\\\"sort(col)\\\">\\n                    <span bbn-if=\\\"col.encoded\\\"\\n                          bbn-text=\\\"col.title || col.field || ' '\\\"\\n                          :title=\\\"col.ftitle || col.title || col.field\\\"/>\\n                    <span bbn-else\\n                          bbn-html=\\\"col.title || col.field || ' '\\\"\\n                          :title=\\\"col.ftitle || col.title || col.field || ' '\\\"/>\\n                  </span>\\n                  <span bbn-else>\\n                    <span bbn-if=\\\"col.encoded\\\"\\n                          bbn-text=\\\"col.title || col.field || ' '\\\"\\n                          :title=\\\"col.ftitle || col.title || col.field || ' '\\\"/>\\n                    <span bbn-else\\n                          bbn-html=\\\"col.title || col.field || ' '\\\"\\n                          :title=\\\"col.ftitle || col.title || col.field || ' '\\\"/>\\n                  </span>\\n                  <i bbn-if=\\\"isSorted(col)\\\"\\n                    :class=\\\"{\\n                      'bbn-table-sortable-icon': true,\\n                      'nf nf-fa-caret_up': isSorted(col).dir === 'ASC',\\n                      'nf nf-fa-caret_down': isSorted(col).dir === 'DESC',\\n                  }\\\"/>\\n                </th>\\n              </template>\\n            </tr>\\n          </thead>\\n          <tbody ref=\\\"tbody\\\"\\n                 :class=\\\"{\\n                   'bbn-overlay': ((!filteredData.length && !tmpRow) || isLoading) && !!scrollable\\n                 }\\\">\\n            <tr bbn-if=\\\"(!filteredData.length && !tmpRow) || isLoading\\\"\\n                :class=\\\"{\\n                  'bbn-overlay': !!scrollable,\\n                  'bbn-middle': !!scrollable\\n                }\\\"\\n                :style=\\\"{\\n                  paddingTop: $refs.thead && !!scrollable ? $refs.thead.getBoundingClientRect().height + 'px' : 0,\\n                  maxWidth: !!scrollable ? lastKnownWidth + 'px' : '',\\n                  left: !!scrollable && getRef('scroll') ? getRef('scroll').currentX + 'px' : ''\\n                }\\\">\\n              <td :colspan=\\\"currentColumns ? currentColumns.length : 1\\\">\\n                <div class=\\\"bbn-spadded bbn-background bbn-c\\\">\\n                  <div bbn-if=\\\"!isLoading\\\"\\n                       bbn-html=\\\"noData || ' '\\\"/>\\n                  <div bbn-elseif=\\\"loader\\\"\\n                       class=\\\"bbn-vmiddle\\\">\\n                    <bbn-loadicon class=\\\"bbn-vmiddle\\\"\\n                                  :size=\\\"24\\\"/>\\n                    <span class=\\\"bbn-xl bbn-b bbn-left-sspace\\\"\\n                          bbn-text=\\\"currentLoaderText\\\"/>\\n                  </div>\\n                </div>\\n              </td>\\n            </tr>\\n            <tr bbn-for=\\\"(d, i) in items\\\"\\n                :key=\\\"d.rowKey\\\"\\n                @focusout=\\\"focusout(i)\\\"\\n                :class=\\\"[{\\n                  'bbn-alt': !groupable && (d.expanderIndex !== undefined) ?\\n                    !!(d.expanderIndex % 2) :\\n                    !!(d.rowIndex % 2),\\n                  'bbn-header': !!(d.aggregated || d.groupAggregated),\\n                }, getTrClass(d.data)]\\\"\\n                :style=\\\"getTrStyle(d.data)\\\"\\n                ref=\\\"rows\\\">\\n              <!-- Group lines just have the cell with the expander and a single big cell -->\\n              <template bbn-if=\\\"groupable && d.group && currentColumns && currentColumns.length\\\">\\n                <td :class=\\\"[getTrClass(d.data), (currentColumns[0].fixed ? ' ' + cssRuleName + ' bbn-table-fixed-cell bbn-table-fixed-cell-left' : '')]\\\"\\n                    :style=\\\"[{\\n                      left: currentColumns[0].left !== undefined ? currentColumns[0].left + 'px' : '',\\n                      width: currentColumns[0].realWidth\\n                    }, getTrStyle(d.data)]\\\">\\n                  <div @click=\\\"toggleExpanded(d.index)\\\"\\n                      class=\\\"bbn-table-expander bbn-p bbn-unselectable bbn-spadded bbn-c\\\"\\n                      bbn-if=\\\"d.expander\\\"\\n                      @keydown.space=\\\"toggleExpanded(d.index)\\\"\\n                      tabindex=\\\"0\\\">\\n                    <i :class=\\\"'nf nf-fa-caret_' + (isExpanded(d) ? 'down' : 'right') + ' bbn-lg'\\\"\\n                    ></i>\\n                  </div>\\n                </td>\\n                <td :class=\\\"currentClass(cols[group], d.data, i) + (currentColumns[0].fixed ? ' ' + cssRuleName + ' bbn-table-fixed-cell bbn-table-cell-left' : '')\\\"\\n                    :style=\\\"{\\n                      left: currentColumns[1].left !== undefined ? currentColumns[1].left + 'px' : 'auto',\\n                      width: 'auto',\\n                      borderRight: '0px',\\n                      overflow: 'unset'\\n                  }\\\">\\n                  <div :class=\\\"[currentClass(cols[group], d.data, i), {'bbn-spadded': !cols[group].component}]\\\"\\n                        :style=\\\"{\\n                          width: lastKnownWidth - groupCols[currentColumns[0].isLeft ? 0 : 1].cols[0].realWidth - borderLeft - borderRight + 'px',\\n                          backgroundColor: 'transparent !important'\\n                        }\\\">\\n                    <component bbn-if=\\\"cols[group].component\\\"\\n                              :is=\\\"cols[group].component\\\"\\n                              class=\\\"bbn-spadded\\\"\\n                              :source=\\\"d.data\\\"/>\\n                    <div bbn-else\\n                          bbn-html=\\\"render(d.data, cols[group], d.index) + (d.expanded ? '' : ' (' + d.num + ')')\\\"/>\\n                  </div>\\n                </td>\\n                <td :colspan=\\\"currentColumns.length - 2\\\"\\n                    style=\\\"border-left: 0px\\\"\\n                    :class=\\\"getTrClass(d.data)\\\"/>\\n              </template>\\n              <template bbn-elseif=\\\"d.expansion\\\">\\n                <td :class=\\\"[getTrClass(d.data), (currentColumns[0].fixed ? ' ' + cssRuleName + ' bbn-table-fixed-cell bbn-table-fixed-cell-left' : '')]\\\"\\n                    :style=\\\"{\\n                      left: currentColumns[0].left !== undefined ? currentColumns[0].left + 'px' : '',\\n                      width: currentColumns[0].realWidth\\n                    }\\\"/>\\n                <td :class=\\\"[getTrClass(d.data), (currentColumns[1].fixed ? ' ' + cssRuleName + ' bbn-table-fixed-cell bbn-table-fixed-cell-left' : '')]\\\"\\n                    :style=\\\"{\\n                      left: currentColumns[1].left !== undefined ? currentColumns[1].left + 'px' : '',\\n                      width: currentColumns[1].realWidth\\n                    }\\\"\\n                    bbn-if=\\\"d.selection\\\">\\n                  <div class=\\\"bbn-block bbn-spadded\\\">\\n                    <div class=\\\"bbn-c bbn-w-100\\\">\\n                      <bbn-checkbox :checked=\\\"d.selected\\\"\\n                                    :value=\\\"true\\\"\\n                                    :novalue=\\\"false\\\"\\n                                    :strict=\\\"true\\\"\\n                                    @click.stop\\n                                    @beforechange=\\\"beforeSelect(i, ...arguments)\\\"\\n                                    @change=\\\"checkSelection(i)\\\"\\n                                    class=\\\"bbn-middle bbn-flex\\\"/>\\n                    </div>\\n                  </div>\\n                </td>\\n                <td :class=\\\"[\\n                      getTrClass(d.data),\\n                      (currentColumns[0].fixed ? ' ' + cssRuleName + ' bbn-table-fixed-cell bbn-table-cell-left' : '')\\n                    ]\\\"\\n                    :style=\\\"{\\n                      left: currentColumns[1].left !== undefined ? currentColumns[1].left + 'px' : 'auto',\\n                      width: 'auto',\\n                      borderRight: '0px',\\n                      overflow: 'unset'\\n                    }\\\">\\n                  <div class=\\\"bbn-block\\\"\\n                        :style=\\\"{\\n                          width: lastKnownWidth - groupCols[currentColumns[0].isLeft ? 0 : 1].cols[0].realWidth - borderLeft - borderRight + 'px',\\n                          backgroundColor: 'transparent !important'\\n                        }\\\">\\n                    <component bbn-if=\\\"typeof(expander) !== 'function'\\\"\\n                              :is=\\\"expander\\\"\\n                              class=\\\"bbn-spadded\\\"\\n                              :source=\\\"d.data\\\" />\\n                    <component bbn-elseif=\\\"(typeof(expander(d)) === 'object')\\\"\\n                              :is=\\\"expander(d)\\\"\\n                              :source=\\\"d.data\\\"/>\\n                    <div bbn-else\\n                          bbn-html=\\\"expander(d.data, i)\\\"/>\\n                  </div>\\n                </td>\\n                <td :colspan=\\\"currentColumns.length - 2\\\"\\n                    :style=\\\"[getTrStyle(d.data), {borderLeft: 0}]\\\"\\n                    :class=\\\"getTrClass(d.data)\\\"/>\\n              </template>\\n              <td bbn-elseif=\\\"d.full\\\"\\n                  :colspan=\\\"currentColumns.length\\\">\\n                <component bbn-if=\\\"d.component\\\"\\n                           :is=\\\"d.component\\\"\\n                           bbn-bind=\\\"d.options || {}\\\"\\n                           :source=\\\"mapper ? mapper(d.data) : d.data\\\"/>\\n                <div bbn-else\\n                      bbn-html=\\\"render(d.data, d.options || {}, i)\\\"/>\\n              </td>\\n              <td bbn-elseif=\\\"d.footer && groupFooter && groupable\\\"\\n                  :colspan=\\\"currentColumns.length\\\">\\n                <div bbn-if=\\\"typeof groupFooter === 'function'\\\"\\n                      bbn-html=\\\"groupFooter(d.data)\\\"/>\\n                <component bbn-else\\n                            :is=\\\"groupFooter\\\"\\n                            :source=\\\"d.data\\\"/>\\n              </td>\\n              <template bbn-else>\\n                <td bbn-for=\\\"(col, index) in currentColumns\\\"\\n                    :class=\\\"[currentClass(col, d.data, i), cssRuleName, {\\n                      'bbn-table-fixed-cell': !!col.fixed,\\n                      'bbn-table-fixed-cell-left': col.isLeft,\\n                      'bbn-table-fixed-cell-left-last': col.isLeft\\n                        && (!currentColumns[index+1] || !currentColumns[index+1].isLeft),\\n                      'bbn-table-fixed-cell-right': col.isRight,\\n                      'bbn-table-cell-first': !col.isLeft && !col.isRight && ((index === 0) || (!!currentColumns[index-1].isLeft)),\\n                      'bbn-table-edit-buttons': !!col.buttons && isEdited(d.data, col, i),\\n                      'bbn-table-buttons': !!col.buttons\\n                    }]\\\"\\n                    :tabindex=\\\"editable && (col.editable !== false) ? 0 : -1\\\"\\n                    @focusin=\\\"focusin(i, $event)\\\"\\n                    @click=\\\"clickCell(col, index, d.index)\\\"\\n                    @dblclick=\\\"dbclickCell(col, index, d.index, d.data, i)\\\"\\n                    :style=\\\"{\\n                      left: col.left !== undefined ? (col.left + 'px') : 'auto',\\n                      right: col.right !== undefined ? (col.right + 'px') : 'auto',\\n                      width: col.realWidth\\n                    }\\\"\\n                    :ref=\\\"'td' + i\\\">\\n                  <div class=\\\"bbn-block bbn-spadded\\\"\\n                        :style=\\\"{maxHeight: currentMaxRowHeight}\\\">\\n                    <!-- Checkboxes -->\\n                    <div bbn-if=\\\"col.isSelection\\\" class=\\\"bbn-c bbn-w-100\\\">\\n                      <bbn-checkbox bbn-if=\\\"d.selection\\\"\\n                                    :checked=\\\"d.selected\\\"\\n                                    :value=\\\"true\\\"\\n                                    :novalue=\\\"false\\\"\\n                                    :strict=\\\"true\\\"\\n                                    @click.stop\\n                                    @beforechange=\\\"beforeSelect(i, ...arguments)\\\"\\n                                    @change=\\\"checkSelection(i)\\\"\\n                                    class=\\\"bbn-middle bbn-flex\\\"/>\\n                    </div>\\n                    <!-- Aggregate -->\\n                    <template bbn-elseif=\\\"d.aggregated || d.groupAggregated\\\">\\n                      <span bbn-if=\\\"col.isAggregatedTitle\\\"\\n                            :class=\\\"d.aggregated ? 'bbn-b' : ''\\\"\\n                            bbn-text=\\\"aggregateExp[d.name]\\\"/>\\n                      <div bbn-elseif=\\\"col.aggregate\\\"\\n                          bbn-html=\\\"render(d.data, col, i)\\\"/>\\n                      <span bbn-else> </span>\\n                      <!-- The row is an aggregate and there are no other cells -->\\n                    </template>\\n                        <!-- Expander -->\\n                    <div bbn-elseif=\\\"col.isExpander\\\"\\n                        @click=\\\"toggleExpanded(d.index)\\\"\\n                        class=\\\"bbn-table-expander bbn-lg bbn-p bbn-unselectable bbn-c\\\">\\n                      <i :class=\\\"'nf nf-fa-caret_' + (isExpanded(d) ? 'down' : 'right') + ' bbn-unselectable'\\\"\\n                        bbn-if=\\\"d.expander\\\"\\n                        tabindex=\\\"0\\\"/>\\n                      <span bbn-else>&nbsp;</span>\\n                    </div>\\n                    <template bbn-else>\\n                      <span class=\\\"bbn-table-dirty bbn-top-left\\\"\\n                            bbn-if=\\\"isDirty(d, col, i)\\\"/>\\n                      <div bbn-if=\\\"isEdited(d.data, col, i)\\\">\\n                        <div bbn-if=\\\"(editMode === 'inline') && (editable !== 'nobuttons') && (col.index === colButtons)\\\">\\n                          <bbn-button :text=\\\"_('Save')\\\"\\n                                      :disabled=\\\"!isEditedValid\\\"\\n                                      icon=\\\"nf nf-fa-save\\\"\\n                                      :notext=\\\"true\\\"\\n                                      @focusin.stop\\n                                      @click.prevent.stop=\\\"saveInline\\\"\\n                                      style=\\\"margin: 0 .1rem\\\"/>\\n                          <bbn-button :text=\\\"_('Cancel')\\\"\\n                                      icon=\\\"nf nf-fa-times\\\"\\n                                      :notext=\\\"true\\\"\\n                                      @focusin.stop\\n                                      @click.prevent.stop=\\\"cancel\\\"\\n                                      style=\\\"margin: 0 0.1rem\\\"/>\\n                        </div>\\n                        <component bbn-elseif=\\\"(editMode === 'inline') && isValidField(col.field) && (col.editable !== false)\\\"\\n                                    bbn-bind=\\\"getEditableOptions(col, d.data)\\\"\\n                                    :is=\\\"getEditableComponent(col, d.data)\\\"\\n                                    @click.stop\\n                                    bbn-model=\\\"editedRow[col.field]\\\"\\n                                    style=\\\"width: 100%\\\"/>\\n                        <!--<bbn-field bbn-elseif=\\\"(editMode === 'inline') && isValidField(col.field) && (col.editable !== false)\\\"\\n                                    bbn-bind=\\\"col\\\"\\n                                    mode=\\\"write\\\"\\n                                    @click.stop\\n                                    bbn-model=\\\"editedRow[col.field]\\\"\\n                                    style=\\\"width: 100%\\\"/>-->\\n                        <bbn-field bbn-elseif=\\\"isValidField(col.field) && !col.render && !col.buttons\\\"\\n                                  bbn-bind=\\\"col\\\"\\n                                  @click.stop\\n                                  :key=\\\"d.rowKey\\\"\\n                                  :value=\\\"d.data[col.field]\\\"\\n                                  :data=\\\"d.data\\\"/>\\n                        <div bbn-elseif=\\\"!col.buttons && col.render\\\"\\n                              bbn-html=\\\"col.render(d.data, col, i)\\\"/>\\n                        <div bbn-elseif=\\\"!col.buttons\\\"\\n                              bbn-html=\\\"render(d.data, col, i)\\\"/>\\n                        <div bbn-else> </div>\\n                      </div>\\n                      <component bbn-elseif=\\\"col.component\\\"\\n                                :is=\\\"col.component\\\"\\n                                bbn-bind=\\\"getColOptions(d.data, col, i)\\\"\\n                                :source=\\\"col.mapper ? col.mapper(d.data) : d.data\\\"/>\\n                      <template bbn-elseif=\\\"col.buttons && (buttonMode === 'dropdown')\\\">\\n                        <bbn-dropdown :source=\\\"buttonSource(d.data, col, i)\\\"\\n                                      :placeholder=\\\"col.title.trim() === '' ? _('Action') : col.title\\\"\\n                                      @select=\\\"_execCommand(button, d.data, col, i, $event)\\\"/>\\n                      </template>\\n                      <template bbn-elseif=\\\"col.buttons && (buttonMode === 'menu')\\\">\\n                        <bbn-context :source=\\\"buttonSource(d.data, col, i)\\\"\\n                                      @select=\\\"(item, idx, dataIndex, ev, floater) => onButtonsMenuSelect(item, d.data, col, i, ev, floater)\\\">\\n                          <span class=\\\"bbn-iblock bbn-lg\\\">\\n                            <i :class=\\\"buttonIcon\\\"/>\\n                          </span>\\n                        </bbn-context>\\n                      </template>\\n                      <template bbn-elseif=\\\"col.buttons && (colButtons === col.index)\\\">\\n                        <bbn-button bbn-for=\\\"(button, bi) in buttonSource(d.data, col, i)\\\"\\n                                    :key=\\\"bi\\\"\\n                                    bbn-bind=\\\"button\\\"\\n                                    @focusin.prevent.stop\\n                                    @focusout.prevent.stop\\n                                    @click.prevent.stop=\\\"_execCommand(button, d.data, col, i, $event)\\\"\\n                                    style=\\\"margin: 0 .1rem\\\"/>\\n                      </template>\\n                      <template bbn-elseif=\\\"col.buttons\\\">\\n                        <bbn-button bbn-for=\\\"(button, bi) in (Array.isArray(col.buttons) ? col.buttons : col.buttons(d.data, col, i))\\\"\\n                                    :key=\\\"bi\\\"\\n                                    bbn-bind=\\\"button\\\"\\n                                    @focusin.prevent.stop\\n                                    @focusout.prevent.stop\\n                                    @click.prevent.stop=\\\"_execCommand(button, d.data, col, i, $event)\\\"\\n                                    style=\\\"margin: 0 .1rem\\\"/>\\n                      </template>\\n                      <div bbn-else\\n                            bbn-html=\\\"render(d.data, col, i)\\\"></div>\\n                      <table-dots bbn-if=\\\"col.dots\\\"\\n                                  :source=\\\"{\\n                                        column: col,\\n                                        index: index,\\n                                        dataIndex: d.index,\\n                                        data: d.data,\\n                                        itemIndex: i\\n                                      }\\\"/>\\n                    </template>\\n                  </div>\\n                </td>\\n              </template>\\n            </tr>\\n          </tbody>\\n        </table>\\n      </bbn-scroll>\\n    </div>\\n    <!-- Footer -->\\n    <bbn-pager class=\\\"bbn-table-footer bbn-no-border-right bbn-no-border-left bbn-no-border-bottom\\\"\\n               bbn-if=\\\"hasPager\\\"\\n               :item-name=\\\"itemName\\\"\\n               ref=\\\"pager\\\"\\n               :page-name=\\\"pageName\\\"\\n               :buttons=\\\"footerButtons\\\"/>\\n    <component bbn-elseif=\\\"(typeof footer === 'string') || (typeof footer === 'object')\\\"\\n               :is=\\\"footer\\\"\\n               class=\\\"bbn-table-footer bbn-no-border-right bbn-no-border-left bbn-no-border-bottom\\\"/>\\n    <div bbn-elseif=\\\"(typeof footer === 'function') && footer()\\\"\\n         bbn-html=\\\"footer()\\\"\\n         class=\\\"bbn-table-footer bbn-no-border-right bbn-no-border-left bbn-no-border-bottom\\\"/>\\n  </div>\\n  <bbn-floater bbn-if=\\\"currentFilter\\\"\\n               class=\\\"bbn-table-floating-filter bbn-widget\\\"\\n               :element=\\\"filterElement\\\"\\n               @close=\\\"currentFilter = false\\\"\\n               :auto-hide=\\\"true\\\"\\n               :scrollable=\\\"true\\\"\\n               :left=\\\"floatingFilterX\\\"\\n               :top=\\\"floatingFilterY\\\">\\n    <bbn-filter bbn-bind=\\\"getFilterOptions()\\\"\\n                @set=\\\"onSetFilter\\\"\\n                @unset=\\\"unsetCurrentFilter\\\"\\n                class=\\\"bbn-w-100\\\"/>\\n    <div bbn-if=\\\"multifilter\\\"\\n         class=\\\"bbn-table-filter-link bbn-p bbn-b bbn-i bbn-w-100 bbn-bottom-padded bbn-left-padded bbn-right-padded bbn-r\\\"\\n         @click=\\\"openMultiFilter\\\">\\n      <i class=\\\"zmdi zmdi-filter-list\\\"/>\\n      <span bbn-text=\\\"_('Open the full filter')\\\"/>\\n    </div>\\n  </bbn-floater>\\n  <bbn-popup ref=\\\"popup\\\" bbn-if=\\\"inTable === false\\\"/>\\n  <bbn-floater bbn-if=\\\"focusedElement && (editMode === 'inline') && editedRow\\\"\\n               class=\\\"bbn-widget\\\"\\n               :element=\\\"focusedElement\\\"\\n               :scrollable=\\\"true\\\"\\n               tabindex=\\\"-1\\\"\\n               :left=\\\"focusedElementX\\\"\\n               :top=\\\"focusedElementY\\\">\\n        <bbn-button :text=\\\"_('Save')\\\"\\n                    :disabled=\\\"!isEditedValid\\\"\\n                    icon=\\\"nf nf-fa-save\\\"\\n                    :notext=\\\"true\\\"\\n                    @click.prevent.stop=\\\"saveInline\\\"\\n                    style=\\\"margin: 0 .1rem\\\"\\n                    tabindex=\\\"-1\\\"/>\\n        <bbn-button :text=\\\"_('Cancel')\\\"\\n                    icon=\\\"nf nf-fa-times\\\"\\n                    :notext=\\\"true\\\"\\n                    @click.prevent.stop=\\\"cancel\\\"\\n                    style=\\\"margin: 0 .1rem\\\"\\n                    tabindex=\\\"-1\\\"/>\\n  </bbn-floater>\\n</div>\\n\";\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/table.html?");

/***/ }),

/***/ "./src/components/table/table.less":
/*!*****************************************!*\
  !*** ./src/components/table/table.less ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_table_less__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/less-loader/dist/cjs.js!./table.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/table/table.less\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_table_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_table_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_table_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_table_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/table.less?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/components/table/_i18n lazy recursive ^\\.\\/table\\..*\\.lang$":
/*!****************************************************************************************!*\
  !*** ./src/components/table/_i18n/ lazy ^\.\/table\..*\.lang$ strict namespace object ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./table.fr.lang\": [\n\t\t\"./src/components/table/_i18n/table.fr.lang\",\n\t\t\"src_components_table__i18n_table_fr_lang\"\n\t],\n\t\"./table.it.lang\": [\n\t\t\"./src/components/table/_i18n/table.it.lang\",\n\t\t\"src_components_table__i18n_table_it_lang\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__.t(id, 1 | 16);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./src/components/table/_i18n lazy recursive ^\\\\.\\\\/table\\\\..*\\\\.lang$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/_i18n/_lazy_^\\.\\/table\\..*\\.lang$_strict_namespace_object?");

/***/ }),

/***/ "./src/components/table/table.js":
/*!***************************************!*\
  !*** ./src/components/table/table.js ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _table_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./table.html */ \"./src/components/table/table.html\");\n/* harmony import */ var _table_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./table.less */ \"./src/components/table/table.less\");\n/**\r\n * @file bbn-table component\r\n *\r\n * @description  bbn-table is a powerful component of wide configuration that offers vast customizations.\r\n * The source obtains it by giving a url to retrieve data or directly supplying an array.\r\n * It allows you to easily modify the content by entering new data in the input field corresponding to the type of column being defined.\r\n * The table rows can be sorted by clicking on a column header.\r\n * Table elements can be filtered with the help of a built-in filters in the column headings or using a multifilter panel and a reset by removing a filter or all filters with just one click.\r\n * It's possible to create fixed areas that will keep their position by always having them available during scrolling.\r\n * It gives the possibility to group the data.\r\n * These are some examples of what can be done with this component, from the few configuration lines we can express considerable work complexity.\r\n *\r\n * @author BBN Solutions\r\n *\r\n * @copyright BBN Solutions\r\n */\nconst cpDef = {\n  /**\r\n   * @mixin bbn.cp.mixins.basic\r\n   * @mixin bbn.cp.mixins.resizer\r\n   * @mixin bbn.cp.mixins.editableList\r\n   * @mixin bbn.cp.mixins.list\r\n   * @mixin bbn.cp.mixins.dataEditor\r\n   * @mixin bbn.cp.mixins.localStorage\r\n   * @mixin bbn.cp.mixins.observer\r\n   * @mixin bbn.cp.mixins.data\r\n   */\n  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.editableList, bbn.cp.mixins.list, bbn.cp.mixins.config, bbn.cp.mixins.dataEditor, bbn.cp.mixins.localStorage, bbn.cp.mixins.observer, bbn.cp.mixins.keepCool, bbn.cp.mixins.data],\n  iface() {\n    return {\n      config: {\n        name: 'bbns-column',\n        data: 'columns',\n        props: {\n          /**\r\n           * The width of the component.\r\n           * @prop {String|Number} width\r\n           * @memberof fieldComponent\r\n           */\n          width: {\n            type: [String, Number]\n          },\n          /**\r\n           * The min-width of the component.\r\n           * @prop {String|Number} minWidth\r\n           * @memberof fieldComponent\r\n           */\n          minWidth: {\n            type: [String, Number]\n          },\n          /**\r\n           * The max-width of the component.\r\n           * @prop {String|Number} maxWidth\r\n           * @memberof fieldComponent\r\n           */\n          maxWidth: {\n            type: [String, Number]\n          },\n          /**\r\n           * The render of the component.\r\n           * @prop {String|Function} render\r\n           * @memberof fieldComponent\r\n           */\n          render: {\n            type: [String, Function]\n          },\n          /**\r\n           * The title of the component.\r\n           * @prop {String|Number} title\r\n           * @memberof fieldComponent\r\n           */\n          title: {\n            type: [String, Number]\n          },\n          /**\r\n           * The full title of the component.\r\n           * @prop {String} ftitle\r\n           * @memberof fieldComponent\r\n           */\n          ftitle: {\n            type: String\n          },\n          /**\r\n           * @prop {String|Object} tcomponent\r\n           * @memberof fieldComponent\r\n           */\n          tcomponent: {\n            type: [String, Object]\n          },\n          /**\r\n           * The icon of the component.\r\n           * @prop {String} icon\r\n           * @memberof fieldComponent\r\n           */\n          icon: {\n            type: String\n          },\n          /**\r\n           * The classes added to the component.\r\n           * @prop {String|Function} cls\r\n           * @memberof fieldComponent\r\n           */\n          cls: {\n            type: [String, Function]\n          },\n          /**\r\n           * The component's type.\r\n           * @prop {String} type\r\n           * @memberof fieldComponent\r\n           */\n          type: {\n            type: String\n          },\n          /**\r\n           * The component's field.\r\n           * @prop {String} field\r\n           * @memberof fieldComponent\r\n           */\n          field: {\n            type: String\n          },\n          /**\r\n           * Defines if the component has to be fixed.\r\n           * @prop {Boolean|String} [false] fixed\r\n           * @memberof fieldComponent\r\n           */\n          fixed: {\n            type: [Boolean, String],\n            default: false\n          },\n          /**\r\n           * Defines if the component has to be hidden.\r\n           * @prop {Boolean} hidden\r\n           * @memberof fieldComponent\r\n           */\n          hidden: {\n            type: Boolean\n          },\n          /**\r\n           * Defines if the componenent has to be encoded.\r\n           * @prop {Boolean} [false] encoded\r\n           * @memberof fieldComponent\r\n           */\n          encoded: {\n            type: Boolean,\n            default: false\n          },\n          /**\r\n           * Defines if the componenent has to be sortable.\r\n           * @prop {Boolean|Function} [true] sortable \r\n           * @memberof fieldComponent\r\n           */\n          sortable: {\n            type: [Boolean, Function],\n            default: true\n          },\n          /**\r\n           * Defines if the componenent has to be editable.\r\n           * @prop {Boolean|Function} [true] editable \r\n           * @memberof fieldComponent\r\n           */\n          editable: {\n            type: [Boolean, Function],\n            default: true\n          },\n          /**\r\n           * Defines if the componenent has to be filterable.\r\n           * @prop {Boolean|Function} [true] filterable \r\n           * @memberof fieldComponent\r\n           */\n          filterable: {\n            type: [Boolean, Function],\n            default: true\n          },\n          /**\r\n           * Defines if the componenent has to be resizable.\r\n           * @prop {Boolean|Function} [true] resizable \r\n           * @memberof fieldComponent\r\n           */\n          resizable: {\n            type: [Boolean, Function],\n            default: true\n          },\n          /**\r\n           * Defines if the componenent has to be showable.\r\n           * @prop {Boolean|Function} [true] showable \r\n           * @memberof fieldComponent\r\n           */\n          showable: {\n            type: [Boolean, Function],\n            default: true\n          },\n          /**\r\n           * Defines if the componenent can have a null value.\r\n           * @prop {Boolean|Function} nullable \r\n           * @memberof fieldComponent\r\n           */\n          nullable: {\n            type: [Boolean, Function]\n          },\n          /**\r\n           * The buttons of the component.\r\n           * @prop {Array|Function} buttons \r\n           * @memberof fieldComponent\r\n           */\n          buttons: {\n            type: [Array, Function]\n          },\n          /**\r\n           * The source of the component.\r\n           * @prop {Array|Object|String|Function} source \r\n           * @memberof fieldComponent\r\n           */\n          source: {\n            type: [Array, Object, String, Function]\n          },\n          /**\r\n           * Defines if the the value of the component is required.\r\n           * @prop {Boolean|Function} required \r\n           * @memberof fieldComponent\r\n           */\n          required: {\n            type: [Boolean, Function]\n          },\n          /**\r\n           * Defines the precision of the component.\r\n           * @prop {Number} [0] precision \r\n           * @memberof fieldComponent\r\n           */\n          precision: {\n            type: Number\n          },\n          /**\r\n           * Defines the number of decimals for the component.\r\n           * @prop {Number} [0] decimals \r\n           * @memberof fieldComponent\r\n           */\n          decimals: {\n            type: Number\n          },\n          /**\r\n           * Defines the precision of the component.\r\n           * @prop {Number} [0] precision \r\n           * @memberof fieldComponent\r\n           */\n          unit: {\n            type: String\n          },\n          /**\r\n           * Defines the options of the component.\r\n           * @prop {Object|Function} options\r\n           * @memberof fieldComponent\r\n           */\n          options: {\n            type: [Object, Function],\n            default() {\n              return {};\n            }\n          },\n          /**\r\n           * Defines the editor of the component.\r\n           * @prop {String|Object} editor\r\n           * @memberof fieldComponent\r\n           */\n          editor: {\n            type: [String, Object]\n          },\n          /**\r\n           * Defines the maxLength of the component.\r\n           * @prop {Number} maxLength \r\n           * @memberof fieldComponent\r\n           */\n          maxLength: {\n            type: Number\n          },\n          /**\r\n           * Defines the max number of chars visible in reading.\r\n           * @prop {Number} maxVisible \r\n           * @memberof fieldComponent\r\n           */\n          maxVisible: {\n            type: Number\n          },\n          /**\r\n           * Defines the sqlType of the component.\r\n           * @prop {String} sqlType \r\n           * @memberof fieldComponent\r\n           */\n          sqlType: {\n            type: String\n          },\n          /**\r\n           * @prop {String|Array} aggregate\r\n           * @memberof fieldComponent\r\n           */\n          aggregate: {\n            type: [String, Array]\n          },\n          /**\r\n           * Define a component to use.\r\n           * @prop {String|Object} component\r\n           * @memberof fieldComponent\r\n           */\n          component: {\n            type: [String, Object]\n          },\n          /**\r\n           * A function to map the data of the component.\r\n           * @prop {Function} mapper\r\n           * @memberof fieldComponent\r\n           */\n          mapper: {\n            type: Function\n          },\n          /**\r\n           * Defines the group of the component.\r\n           * @prop {String} group\r\n           * @memberof fieldComponent\r\n           */\n          group: {\n            type: String\n          }\n        }\n      }\n    };\n  },\n  beforeCreate() {\n    bbn.fn.log([\"BEFORE CREATE\", this.$el, this.$slots, this.$el.bbnSlots, this.closest('bbn-anon')]);\n  },\n  props: {\n    /**\r\n     * True if the columns has to have titles.\r\n     * @prop {Boolean} [true] titles\r\n     */\n    titles: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * The message to show when the table has no data.\r\n     * @prop {String} ['<h3>' + bbn._('No Data') + '</h3>'] noData\r\n     */\n    noData: {\n      default: '<h3>' + bbn._('No Data') + '</h3>'\n    },\n    /**\r\n     * If the property 'group' is given to one or more columns in the table (ex: group=\"test\"), it defines the title of a group of columns. (ex: titleGroups=\"[{value: 'test', text: 'My group'}]\").\r\n     * @prop {Array|Function} titleGroups\r\n     */\n    titleGroups: {\n      type: [Array, Function]\n    },\n    /**\r\n     * Defines the behaviour of the table about the scroll.\r\n     * @prop {Boolean} [true] scrollable\r\n     */\n    scrollable: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Set to true allows the table to be resizable.\r\n     * @prop {Boolean} [false] resizable\r\n     */\n    resizable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Set to true shows a button at the bottom right of the table that opens a column picker for the table.\r\n     * @prop {Boolean} [false] showable\r\n     */\n    showable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Set to true shows a save icon that allows to save the current configuration of the table at the bottom right of the table.\r\n     * @prop {Boolean} [false] saveable\r\n     */\n    saveable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Set to true allows the table to be groupable according to the props groupBy.\r\n     * @prop {Boolean} [false] groupable\r\n     */\n    groupable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * In case of Ajax table, set to true will make an Ajax call to group the table by a field.\r\n     * @prop {Boolean} [true] serverGrouping\r\n     */\n    serverGrouping: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Set to false will make an Ajax call for the grouping.\r\n     * @prop {Boolean} [true] localGrouping\r\n     */\n    localGrouping: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Defines the minimum columns width.\r\n     * @prop {Number} [30] minimumColumnWidth\r\n     */\n    minimumColumnWidth: {\n      type: Number,\n      default: 30\n    },\n    /**\r\n     * Defines the minimum columns width for mobile devices.\r\n     * @prop {Number} [100] minimumColumnWidthMobile\r\n     */\n    minimumColumnWidthMobile: {\n      type: Number,\n      default: 100\n    },\n    /**\r\n     * Defines the default columns width.\r\n     * @prop {Number} [150] defaultColumnWidth\r\n     */\n    defaultColumnWidth: {\n      type: Number,\n      default: 150\n    },\n    /**\r\n     * A function to define css class(es) for each row.\r\n     * @prop {Function} trClass\r\n     */\n    trClass: {\n      type: [String, Function, Object]\n    },\n    /**\r\n     * A function to define css style(s) for each row.\r\n     * @prop {Function} trStyle\r\n     */\n    trStyle: {\n      type: [String, Function, Object]\n    },\n    /**\r\n     * Defines the message to show in the confirm when an action is made on the row.\r\n     * @prop {String|Function|Boolean} confirmMessage\r\n     */\n    confirmMessage: {\n      type: [String, Function, Boolean],\n      default: bbn._('Are you sure you want to delete this row?')\n    },\n    /**\r\n     * Defines the expander of the rows.\r\n     * @prop  {Object|String|Function} expander\r\n     */\n    expander: {\n      type: [Object, String, Function]\n    },\n    /**\r\n     * Customize the loading text or hide it\r\n     * @prop {String|Boolean} [true] loader\r\n     */\n    loader: {\n      type: [String, Boolean],\n      default: true\n    },\n    /**\r\n     * If one or more columns have the property fixed set to true it defines the side of the fixed column(s).\r\n     * @prop {String} ['left'] fixedDefaultSide\r\n     */\n    fixedDefaultSide: {\n      type: String,\n      default: 'left'\n    },\n    /**\r\n     * Defines the toolbar of the table.\r\n     * @prop {Array|Object|String|Function} toolbar\r\n     */\n    toolbar: {\n      type: [Array, Object, String, Function]\n    },\n    /**\r\n     * An array of objects with at least the property 'field' that can replace the html '<bbns-column></bbns-column>' or extend them.\r\n     * @prop {Array} [[]] columns\r\n     */\n    columns: {\n      type: Array,\n      default: function () {\n        return [];\n      }\n    },\n    /**\r\n     * The index of the property to group by the table referred to the object of data of the row.\r\n     * @prop {Number} groupBy\r\n     */\n    groupBy: {\n      type: Number\n    },\n    /**\r\n     * The list of expanded rows based on a specific value (ex. group field) and not on the row index\r\n     * @prop {Array|Function} expandedValues\r\n     */\n    expandedValues: {\n      type: [Array, Function]\n    },\n    /**\r\n     * In a grouped table, if set to true defines that all rows will be expanded. If an array is given defines which row(s) of the table will be expanded.\r\n     * @prop {Boolean|Array} [[]] expanded\r\n     */\n    expanded: {\n      type: [Boolean, Array],\n      default() {\n        return [];\n      }\n    },\n    /**\r\n     * Defines the footer of the table.\r\n     * Allowed values are the name or the object of a component, a boolean or a function (to inject custom html)\r\n     * @prop {String|Object|Boolean|Function} footer\r\n     */\n    footer: {\n      type: [String, Object, Boolean, Function],\n      default: true\n    },\n    /**\r\n     * Defines the footer for a group of rows.\r\n     * Allowed values are the name or the object of a component or a function (to inject custom html)\r\n     * @prop {String|Object|Function} groupFooter\r\n     */\n    groupFooter: {\n      type: [String, Object, Function]\n    },\n    /**\r\n     * @todo desc\r\n     * @prop {Object} [{tot: 'Total',med: 'Average',num: 'Count',max: 'Maximum',min: 'Minimum'}] aggregateExp\r\n     */\n    aggregateExp: {\n      type: Object,\n      default() {\n        return {\n          tot: bbn._('Total'),\n          med: bbn._('Average'),\n          num: bbn._('Count'),\n          max: bbn._('Maximum'),\n          min: bbn._('Minimum')\n        };\n      }\n    },\n    /**\r\n     * @prop {String|Array} aggregate\r\n     */\n    aggregate: {\n      type: [String, Array]\n    },\n    /**\r\n     * @todo desc\r\n     * @prop {Object} loadedConfig\r\n     */\n    loadedConfig: {\n      type: Object\n    },\n    /**\r\n     * Shows the footer's arrows as buttons\r\n     * @prop {Boolean} [true] footerButtons\r\n     */\n    footerButtons: {\n      type: Boolean,\n      default() {\n        return !bbn.fn.isMobile() || bbn.fn.isTabletDevice();\n      }\n    },\n    /**\r\n     * The name of the `page` word as used in the pager interface.\r\n     * @prop {String} ['Page'] pageName\r\n     */\n    pageName: {\n      type: String,\n      default: bbn._(\"page\")\n    },\n    /**\r\n     * The name of the `record` word as used in the pager interface.\r\n     * @prop {String} ['Record(s)'] itemName\r\n     */\n    itemName: {\n      type: String,\n      default: bbn._(\"rows\")\n    },\n    /**\r\n     * The way `buttons` should be displayed, either as buttons, dropdown or as a menu.\r\n     * @prop {String} ['buttons'] buttonMode\r\n     */\n    buttonMode: {\n      type: String,\n      default: 'buttons',\n      validator(v) {\n        return ['buttons', 'dropdown', 'menu'].includes(v);\n      }\n    },\n    /**\r\n     * The name of the `record` word as used in the pager interface.\r\n     * @prop {String} ['nf nf-mdi-dots_vertical'] buttonIcon\r\n     */\n    buttonIcon: {\n      type: String,\n      default: 'nf nf-mdi-dots_vertical'\n    },\n    /**\r\n     * Allows you to see the contents of a cell in a popup\r\n     * @prop {Boolean} [false] zoomable\r\n     */\n    zoomable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * The max row height value\r\n     * @prop {Number} maxRowHeight\r\n     */\n    maxRowHeight: {\n      type: Number\n    },\n    /**\r\n     * Property sloBefore for the toolbar\r\n     * @prop {Boolean} toolbarSlotBefore\r\n     */\n    toolbarSlotBefore: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data() {\n    return {\n      initialConfig: null,\n      isTable: null,\n      /**\r\n       * @data {Boolean} [false] _observerReceived\r\n       */\n      _observerReceived: false,\n      allRowsChecked: false,\n      /**\r\n       * The group of columns.\r\n       * @data {Object} [[{name: 'left',width: 0,visible: 0,cols: []},{name: 'main',width: 0,visible: 0,cols: []},{name: 'right',width: 0,visible: 0,cols: []}]] groupCols\r\n       */\n      groupCols: [{\n        name: 'left',\n        width: 0,\n        visible: 0,\n        cols: []\n      }, {\n        name: 'main',\n        width: 0,\n        visible: 0,\n        cols: []\n      }, {\n        name: 'right',\n        width: 0,\n        visible: 0,\n        cols: []\n      }],\n      /**\r\n       * @data {Boolean} [false] initReady\r\n       */\n      initReady: false,\n      /**\r\n       * The current configuration object.\r\n       * @data {Object} [{}] currentConfig\r\n       */\n      currentConfig: {},\n      /**\r\n       * The saved configuration.\r\n       * @data {Boolean} [false] savedConfig\r\n       */\n      savedConfig: false,\n      /**\r\n       * The default confuguration\r\n       * @data {Object} defaultConfig\r\n       */\n      defaultConfig: bbn.fn.extend({\n        filters: this.filters,\n        limit: this.limit,\n        order: this.order,\n        hidden: this.hidden || null\n      }, this.loadedConfig || {}),\n      /**\r\n       * @data {Boolean} [false] editedFilter\r\n       */\n      editedFilter: false,\n      /**\r\n       * @data {Number} [0] floatingFilterX\r\n       */\n      floatingFilterX: 0,\n      /**\r\n       * @data {Number} [0] floatingFilterY\r\n       */\n      floatingFilterY: 0,\n      /**\r\n       * @data {Number} [0] floatingFilterTimeOut\r\n       */\n      floatingFilterTimeOut: 0,\n      /**\r\n       * @data {Array} currentHidden\r\n       */\n      currentHidden: this.hidden || [],\n      /**\r\n       * @data {Boolean|Number} [false] group\r\n       */\n      group: this.groupBy === undefined ? false : this.groupBy,\n      /**\r\n       * @data {Array} [[]] cols\r\n       */\n      cols: [],\n      /**\r\n       * @data {Boolean} [false] table\r\n       */\n      table: false,\n      /**\r\n       * @data {Boolean} [false] colButtons\r\n       */\n      colButtons: false,\n      /**\r\n       * @data {} [null] scrollableContainer\r\n       */\n      scrollableContainer: null,\n      /**\r\n       * @data {Boolean} [true] hiddenScroll\r\n       */\n      hiddenScroll: true,\n      /**\r\n       * @data {Array} [[]] popups\r\n       */\n      popups: [],\n      /**\r\n       * @data {Boolean} [false] isAggregated\r\n       */\n      isAggregated: false,\n      /**\r\n       * @data {Array} [[]] aggregatedColumns\r\n       */\n      aggregatedColumns: [],\n      /**\r\n       * @data {Boolean} [false] updaterTimeout\r\n       */\n      updaterTimeout: false,\n      /**\r\n       * @data {Boolean} allExpanded\r\n       */\n      allExpanded: this.expanded === true ? true : false,\n      /**\r\n       * @data {Boolean} [false] groupInit\r\n       */\n      groupInit: false,\n      /**\r\n       * @data {Array} currentExpanded\r\n       */\n      currentExpanded: Array.isArray(this.expanded) ? this.expanded : [],\n      /**\r\n       * @data {Array} currentExpandedValues\r\n       */\n      currentExpandedValues: Array.isArray(this.expandedValues) ? this.expandedValues : [],\n      /**\r\n       * @data {Boolean} [false] focusedRow\r\n       */\n      focusedRow: false,\n      /**\r\n       * @data {} [null] rowIndexTimeOut\r\n       */\n      rowIndexTimeOut: null,\n      /**\r\n       * @data {String} containerPadding\r\n       */\n      containerPadding: (bbn.fn.getScrollBarSize() ? bbn.fn.getScrollBarSize() : '0') + 'px',\n      /**\r\n       * @data {bbnCp} [null] container\r\n       */\n      container: null,\n      /**\r\n       * The current scroll top position.\r\n       * @data {Number} [0] currentScrollTop\r\n       */\n      currentScrollTop: 0,\n      /**\r\n       * @data [null] marginStyleSheet\r\n       */\n      marginStyleSheet: null,\n      /**\r\n       * @data {String} [bbn.fn.randomString().toLowerCase()] cssRuleName\r\n       */\n      cssRuleName: bbn.fn.randomString().toLowerCase(),\n      /**\r\n       * @data {String} [false] initStarted\r\n       */\n      initStarted: false,\n      /**\r\n       * @data [null] inTable\r\n       */\n      inTable: null,\n      /**\r\n       * @data [null] filterElement\r\n       */\n      filterElement: null,\n      /**\r\n       * @data {Boolean} [false] hasScrollX \r\n       */\n      hasScrollX: false,\n      /**\r\n       * @data {Boolean} [false] hasScrollY\r\n       */\n      hasScrollY: false,\n      /**\r\n       * @data {Number} [0] borderLeft\r\n       */\n      borderLeft: 0,\n      /**\r\n       * @data {Number} [0] borderRight\r\n       */\n      borderRight: 0,\n      /**\r\n       * @data {DOMElement} [undefined] focusedElement\r\n       */\n      focusedElement: null,\n      /**\r\n       * @data {Number} [0] focusedElementX Horizontal coordinate of focused element\r\n       */\n      focusedElementX: 0,\n      /**\r\n       * @data {Number} [0] focusedElementY Vertical coordinate of focused element\r\n       */\n      focusedElementY: 0,\n      /**\r\n       * @data {Boolean} [false] isTableDataUpdating Will be set to true during the whole update process\r\n       */\n      isTableDataUpdating: false,\n      /**\r\n       * The text shown during loading\r\n       * @data {String} ['Loading...'] currentLoaderText\r\n       */\n      currentLoaderText: bbn.fn.isString(this.loader) ? this.loader : bbn._('Loading') + '...',\n      /**\r\n       * True if the table is resizing its width\r\n       * @data {Boolean} [false] isResizingWidth\r\n       */\n      isResizingWidth: false,\n      /**\r\n       * The portal element for the buttons' floater (menu mode)\r\n       * @data {HTMLElement} [document.body] portalElement\r\n       */\n      portalElement: document.body\n    };\n  },\n  computed: {\n    realButtons() {\n      if (this.cols.length && this.cols[this.colButtons] && this.cols[this.colButtons].buttons) {\n        if (bbn.fn.isFunction(this.cols[this.colButtons].buttons)) {\n          return this.cols[this.colButtons].buttons.bind(this.$origin);\n        } else if (bbn.fn.isArray(this.cols[this.colButtons].buttons)) {\n          let res = [];\n          bbn.fn.each(this.cols[this.colButtons].buttons, a => {\n            if (bbn.fn.isString(a)) {\n              switch (a) {\n                case 'edit':\n                  res.push({\n                    text: bbn._('Edit'),\n                    action: 'edit',\n                    icon: 'nf nf-fa-edit'\n                  });\n                  break;\n                case 'copy':\n                  res.push({\n                    text: bbn._(\"Copy\"),\n                    action: 'copy',\n                    icon: 'nf nf-fa-copy'\n                  });\n                  break;\n                case 'delete':\n                  res.push({\n                    text: bbn._(\"Delete\"),\n                    action: 'remove',\n                    icon: 'nf nf-fa-times'\n                  });\n                  break;\n              }\n            } else {\n              if (bbn.fn.isFunction(a.action)) {\n                a.action = a.action.bind(this.$origin);\n              }\n              res.push(a);\n            }\n          });\n          if (this.cols[this.colButtons].notext) {\n            bbn.fn.each(res, a => {\n              a.notext = true;\n              return a;\n            });\n          }\n          return res;\n        }\n      }\n      return [];\n    },\n    /**\r\n     * The array of selected values if the table is selectable.\r\n     * @computed selectedValues\r\n     * @returns {Array}\r\n     */\n    selectedValues() {\n      return this.currentSelected.map(a => {\n        return this.uid ? this.currentData[a].data[this.uid] : this.currentData[a].data;\n      });\n    },\n    /**\r\n     * The container width.\r\n     * @computed containerWidth\r\n     * @returns {String}\r\n     */\n    containerWidth() {\n      if (!this.groupCols || !this.groupCols[1] || !this.groupCols[1].width || !this.lastKnownCtWidth) {\n        return '0px';\n      }\n      return this.lastKnownCtWidth - this.groupCols[0].width - this.groupCols[2].width + 'px';\n    },\n    /**\r\n     * The total width.\r\n     * @computed totalWidth\r\n     * @returns {String}\r\n     */\n    totalWidth() {\n      if (!this.groupCols || !this.groupCols[1] || !this.groupCols[1].width || !this.lastKnownCtWidth) {\n        return '0px';\n      }\n      return this.groupCols[0].width + this.groupCols[1].width + this.groupCols[2].width + 'px';\n    },\n    /**\r\n     * Return true if the table has the prop toolbar defined.\r\n     * @computed hasToolbar\r\n     * @returns {Boolean}\r\n     */\n    hasToolbar() {\n      return this.toolbarButtons.length || bbn.fn.isObject(this.toolbar) || bbn.fn.isFunction(this.toolbar) || bbn.fn.isString(this.toolbar);\n    },\n    /**\r\n     * @computed hasPager\r\n     * @return {Boolean}\r\n     */\n    hasPager() {\n      return (this.pageable || this.saveable || this.filterable || this.isAjax || this.showable) && this.footer === true;\n    },\n    /**\r\n     * Return an array of shown fields (the hidden ones are excluded).\r\n     * @computed shownFields\r\n     * @returns {Array}\r\n     */\n    shownFields() {\n      let r = [];\n      bbn.fn.each(this.cols, a => {\n        if (a.field && !a.hidden) {\n          r.push(a.field);\n        }\n      });\n      return r;\n    },\n    /**\r\n     * Return the json string of currentConfig.\r\n     * @computed jsonConfig\r\n     * @returns {String}\r\n     */\n    jsonConfig() {\n      let cfg = this.currentConfig;\n      if (this.currentHidden.length > this.cols.length / 2) {\n        bbn.fn.log(\"WE ARE IN!!!!\");\n        cfg = bbn.fn.createObject(cfg);\n        cfg.shown = this.allFields.filter(x => !cfg.hidden.includes(x));\n        bbn.fn.log(cfg);\n        delete cfg.hidden;\n      }\n      return JSON.stringify(this.currentConfig);\n    },\n    /**\r\n     * Return true if the saved config is identic to the jsonConfig.\r\n     * @computed isSaved\r\n     * @returns {Boolean}\r\n     */\n    isSaved() {\n      return this.jsonConfig === this.savedConfig;\n    },\n    /**\r\n     * Return true if the json string of currentConfig is different from initialConfig\r\n     * @computed isChanged\r\n     * @returns {Boolean}\r\n     */\n    isChanged() {\n      return this.jsonConfig !== this.initialConfig;\n    },\n    /**\r\n     * Return an array with the object(s) button for the toolbar.\r\n     * @computed toolbarButtons\r\n     * @returns {Array}\r\n     */\n    toolbarButtons() {\n      let r = [],\n        ar = [];\n      if (this.toolbar) {\n        ar = bbn.fn.isFunction(this.toolbar) ? this.toolbar() : Array.isArray(this.toolbar) ? this.toolbar.slice() : [];\n        if (!Array.isArray(ar)) {\n          ar = [];\n        }\n        bbn.fn.each(ar, a => {\n          let o;\n          if (bbn.fn.isString(a)) {\n            switch (a) {\n              case 'insert':\n                o = {\n                  text: bbn._('Add'),\n                  action: this.insert,\n                  icon: 'nf nf-fa-plus'\n                };\n                break;\n              case 'export':\n                o = {};\n                break;\n              case 'print':\n                o = {};\n                break;\n              // separator or other toolbar param\n              default:\n                o = a;\n            }\n          } else if (bbn.fn.isObject(a)) {\n            o = bbn.fn.clone(a);\n          }\n          if (o && bbn.fn.isObject(o) && bbn.fn.isString(o.action)) {\n            o.action = () => {\n              this._execCommand(a);\n            };\n          }\n          if (!o) {\n            throw Error(bbn._(\"Wrong parameter for toolbar\"));\n          }\n          r.push(o);\n        });\n      }\n      return r;\n    },\n    allFields() {\n      const res = [];\n      for (let i = 0; i < this.cols.length; i++) {\n        if (this.cols[i].field && !res.includes(this.cols[i].field)) {\n          res.push(this.cols[i].field);\n        }\n      }\n      return res;\n    },\n    /**\r\n     * Return false if a required field of a column is missing.\r\n     * @computed isEditedValid\r\n     * @returns {Boolean}\r\n     */\n    isEditedValid() {\n      let ok = true;\n      if (this.tmpRow) {\n        bbn.fn.each(this.columns, a => {\n          if (a.field && a.required && !this.tmpRow[a.field]) {\n            ok = false;\n            return false;\n          }\n        });\n      }\n      return ok;\n    },\n    /**\r\n     * Return the number of visible columns of the table.\r\n     * @computed numVisible\r\n     * @returns {number}\r\n     */\n    numVisible() {\n      return this.cols.length - bbn.fn.count(this.cols, {\n        hidden: true\n      }) + (this.hasExpander ? 1 : 0) + (this.selection ? 1 : 0);\n    },\n    /**\r\n     * Return the object scroller.\r\n     * @computed scroller\r\n     * @returns {Object}\r\n     */\n    scroller() {\n      return bbn.cp.isComponent(this.$refs.scroller) ? this.$refs.scroller : null;\n    },\n    /**\r\n     * Return an array of objects containing the data of the row and other information about the current view of the table.\r\n     * @computed items\r\n     * @fires _checkConditionsOnValue\r\n     * @fires expandedValues\r\n     * @fires isExpanded\r\n     * @returns {Array}\r\n     */\n    items() {\n      if (!this.cols.length) {\n        return [];\n      }\n      // The final result\n      let res = [],\n        isGroup = this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field,\n        groupField = isGroup ? this.cols[this.group].field : false,\n        // The group value will change each time a row has a different value on the group's column\n        currentGroupValue,\n        /* @todo Not sure of what it does ! */\n        currentLink,\n        // the data is put in a new array with its original index\n        o,\n        rowIndex = 0,\n        end = this.pageable ? this.currentLimit : this.currentData.length,\n        aggregates = {},\n        aggregateModes = [],\n        aggIndex = 0,\n        i = 0,\n        data = this.filteredData;\n      // Aggregated\n      if (this.isAggregated) {\n        aggregateModes = bbn.fn.isArray(this.aggregate) ? this.aggregate : [this.aggregate];\n        bbn.fn.each(this.aggregatedColumns, a => {\n          aggregates[a.field] = {\n            tot: 0,\n            num: 0,\n            min: false,\n            max: false,\n            groups: []\n          };\n        });\n      }\n      // Paging locally\n      if (this.pageable && (!this.isAjax || !this.serverPaging)) {\n        i = this.start;\n        end = this.start + this.currentLimit > data.length ? data.length : this.start + this.currentLimit;\n      }\n      // Grouping (and sorting) locally\n      let pos;\n      if (isGroup && (this.isAjax && this.serverGrouping || !this.isAjax && this.localGrouping) && (pos = bbn.fn.search(this.currentOrder, {\n        field: this.cols[this.group].field\n      })) !== 0) {\n        // First ordering the data\n        let orders = [{\n          field: this.cols[this.group].field,\n          dir: pos > 0 ? this.currentOrder[pos].dir : 'asc'\n        }];\n        if (this.sortable && this.currentOrder.length) {\n          orders = orders.concat(JSON.parse(JSON.stringify(this.currentOrder)));\n        }\n        data = bbn.fn.multiorder(data, orders.map(item => {\n          item.field = 'data.' + item.field;\n          return item;\n        }));\n      }\n      // Sorting locally\n      else if (this.sortable && this.currentOrder.length && (!this.serverSorting || !this.isAjax)) {\n        // If there is a source, we sort based on the text (not the value), so we replace temporary the values\n        // with the text + a boundary + the value just the time of sorting\n        if (bbn.fn.count(this.cols, {\n          source: undefined\n        }, '!==')) {\n          /** @var will contain the original value of the column to reset it once the array is sorted */\n          let tmpData = {};\n          bbn.fn.each(this.cols, function (col) {\n            if (col.source && col.field) {\n              tmpData[col.field] = {};\n              bbn.fn.each(data, function (d) {\n                tmpData[col.field][d.index] = d.data[col.field];\n                d.data[col.field] = d.data[col.field] ? bbn.fn.getField(col.source, col.sourceText ? col.sourceText : 'text', col.sourceValue ? col.sourceValue : 'value', d.data[col.field]) || '' : '';\n              });\n            }\n          });\n          data = bbn.fn.multiorder(data, JSON.parse(JSON.stringify(this.currentOrder)).map(item => {\n            item.field = 'data.' + item.field;\n            return item;\n          }));\n          bbn.fn.each(this.cols, col => {\n            if (col.source && col.field) {\n              bbn.fn.each(data, (d, i) => {\n                d.data[col.field] = tmpData[col.field][d.index];\n              });\n            }\n          });\n        } else {\n          data = bbn.fn.multiorder(data, JSON.parse(JSON.stringify(this.currentOrder)).map(item => {\n            item.field = 'data.' + item.field;\n            return item;\n          }));\n        }\n      }\n\n      // A new row being edited\n      if (this.tmpRow) {\n        res.push({\n          index: -1,\n          rowIndex: 0,\n          rowKey: this.isAjax ? '-1-' + this.hashCfg : -1,\n          data: this.tmpRow,\n          selected: false,\n          expander: false\n        });\n        this.editedIndex = -1;\n        rowIndex++;\n      }\n\n      // If there's a group that will be the row index of its 1st value (where the expander is)\n      let currentGroupIndex = -1,\n        currentGroupRow = -1,\n        isExpanded = false,\n        groupNumCheckboxes = 0,\n        groupNumChecked = 0,\n        lastInGroup = false,\n        expanderIndex = 0;\n      while (data[i] && i < end) {\n        let a = data[i].data;\n        // True if the element is the last of its group\n        lastInGroup = isGroup && (!data[i + 1] || data[i + 1].data[groupField] !== currentGroupValue);\n        // Is a new group\n        if (isGroup && currentGroupValue !== a[groupField]) {\n          groupNumCheckboxes = 0;\n          // If the row doesn't have the column\n          if (a[groupField] === undefined || bbn.fn.isNull(a[groupField]) || a[groupField] === '') {\n            currentGroupValue = null;\n            currentGroupIndex = -1;\n            isExpanded = true;\n          } else {\n            isExpanded = false;\n            currentGroupValue = a[groupField];\n            currentGroupIndex = data.index;\n            currentGroupRow = res.length;\n            let tmp = {\n              group: true,\n              index: data[i].index,\n              value: currentGroupValue,\n              data: a,\n              rowIndex: rowIndex,\n              rowKey: data[i].key,\n              expander: true,\n              num: bbn.fn.count(data, 'data.' + this.cols[this.group].field, currentGroupValue)\n            };\n            // Expanded is true: all is opened\n            if (this.allExpanded) {\n              isExpanded = true;\n              if (this.currentExpandedValues.indexOf(currentGroupValue) === -1) {\n                this.currentExpandedValues.push(currentGroupValue);\n              }\n            }\n            // expandedValues is a function, which will be executed on each value\n            else if (bbn.fn.isFunction(this.expandedValues)) {\n              if (this.expandedValues(currentGroupValue) && this.currentExpandedValues.indexOf(currentGroupValue) === -1) {\n                isExpanded = true;\n              }\n            }\n            // The current group value should be opened\n            else if (this.currentExpandedValues.indexOf(currentGroupValue) > -1) {\n              isExpanded = true;\n            }\n            currentLink = res.length;\n            if (!isExpanded && data[i - 1] && currentGroupValue === data[i - 1].data[groupField]) {\n              if (res.length) {\n                res.push(tmp);\n              }\n            } else {\n              tmp.expanded = isExpanded;\n              if (this.expander) {\n                expanderIndex = tmp.index;\n              }\n              res.push(tmp);\n              rowIndex++;\n            }\n          }\n        } else if (this.expander) {\n          let exp = bbn.fn.isFunction(this.expander) ? this.expander(data[i], i) : this.expander;\n          isExpanded = exp ? this.currentExpanded.includes(data[i].index) || this.allExpanded : false;\n          if (!isGroup) {\n            let tmp = {\n              index: data[i].index,\n              data: a,\n              rowIndex: rowIndex,\n              rowKey: data[i].key,\n              expander: true,\n              expanded: isExpanded\n            };\n            expanderIndex = tmp.index;\n            if (this.selection && (!bbn.fn.isFunction(this.selection) || this.selection(tmp))) {\n              tmp.selected = !this.uid && this.currentSelected.includes(data[i].index) || this.uid && this.currentSelected.includes(data[i].data[this.uid]);\n              tmp.selection = true;\n              groupNumCheckboxes++;\n              if (tmp.selected) {\n                groupNumChecked++;\n              }\n            }\n            res.push(tmp);\n            rowIndex++;\n          }\n        }\n        if (!isGroup || isExpanded || !currentGroupValue || this.expander && (!bbn.fn.isFunction(this.expander) || this.expander(data[i], i))) {\n          o = {\n            index: data[i].index,\n            data: a,\n            rowIndex: rowIndex,\n            rowKey: data[i].key\n          };\n          if (isGroup) {\n            if (!currentGroupValue) {\n              o.expanded = true;\n            } else {\n              o.isGrouped = true;\n              o.link = currentLink;\n              o.rowKey = o.rowIndex + '-' + o.rowKey;\n            }\n          }\n          if (this.expander && (!bbn.fn.isFunction(this.expander) || this.expander(data[i], i))) {\n            o.expansion = true;\n            o.expanderIndex = expanderIndex;\n            o.rowKey = rowIndex + '-' + data[i].key;\n          }\n          if (this.selection && (!o.isGrouped && !this.expander || o.isGrouped && !o.expander || o.isGrouped && o.expansion) && (!bbn.fn.isFunction(this.selection) || this.selection(o))) {\n            o.selected = !this.uid && this.currentSelected.includes(data[i].index) || this.uid && this.currentSelected.includes(data[i].data[this.uid]);\n            o.selection = true;\n            groupNumCheckboxes++;\n            if (o.selected) {\n              groupNumChecked++;\n            }\n          }\n          res.push(o);\n          rowIndex++;\n          if (isGroup && this.groupable && this.groupFooter && !this.expander && (!data[i + 1] || data[i + 1].data[groupField] !== data[i].data[groupField])) {\n            res.push({\n              index: data[i].index,\n              data: bbn.fn.filter(data, v => {\n                return v.data[groupField] === data[i].data[groupField];\n              }),\n              rowIndex: rowIndex,\n              rowKey: data[i].key,\n              isGrouped: true,\n              footer: true,\n              selection: false,\n              expander: false\n            });\n            rowIndex++;\n          }\n        } else {\n          end++;\n        }\n        // Group or just global aggregation\n        if (aggregateModes.length) {\n          bbn.fn.each(this.aggregatedColumns, ac => {\n            let aggr = aggregates[ac.field];\n            aggr.num++;\n            aggr.tot += parseFloat(a[ac.field]);\n            if (aggr.min === false) {\n              aggr.min = parseFloat(a[ac.field]);\n            } else if (aggr.min > parseFloat(a[ac.field])) {\n              aggr.min = parseFloat(a[ac.field]);\n            }\n            if (aggr.max === false) {\n              aggr.max = parseFloat(a[ac.field]);\n            } else if (aggr.max < parseFloat(a[ac.field])) {\n              aggr.max = parseFloat(a[ac.field]);\n            }\n            if (isGroup && currentGroupValue) {\n              let searchRes = bbn.fn.search(aggr.groups, {\n                value: currentGroupValue\n              });\n              if (searchRes === -1) {\n                searchRes = aggr.groups.length;\n                aggr.groups.push({\n                  value: currentGroupValue,\n                  tot: 0,\n                  num: 0,\n                  min: false,\n                  max: false\n                });\n              }\n              let b = aggr.groups[searchRes];\n              b.num++;\n              b.tot += parseFloat(a[ac.field]);\n              if (b.min === false) {\n                b.min = parseFloat(a[ac.field]);\n              } else if (b.min > parseFloat(a[ac.field])) {\n                b.min = parseFloat(a[ac.field]);\n              }\n              if (b.max === false) {\n                b.max = parseFloat(a[ac.field]);\n              } else if (b.max < parseFloat(a[ac.field])) {\n                b.max = parseFloat(a[ac.field]);\n              }\n              if (isExpanded && (!data[i + 1] || i === end - 1 || currentGroupValue !== data[i + 1].data[this.cols[this.group].field])) {\n                let b = aggr.groups[aggr.groups.length - 1];\n                b.med = b.tot / b.num;\n                bbn.fn.each(aggregateModes, c => {\n                  let tmp = {};\n                  tmp[ac.field] = b[c];\n                  res.push({\n                    index: data[i] ? data[i].index : 0,\n                    rowIndex: rowIndex,\n                    rowKey: 'a' + aggIndex + '-' + (data[i] ? data[i].key : rowIndex),\n                    groupAggregated: true,\n                    link: currentLink,\n                    value: currentGroupValue,\n                    name: c,\n                    data: tmp\n                  });\n                  rowIndex++;\n                  aggIndex++;\n                });\n              }\n            }\n            if (!data[i + 1] || i === end - 1) {\n              aggr.med = aggr.tot / aggr.num;\n              bbn.fn.each(aggregateModes, c => {\n                let tmp = {};\n                tmp[ac.field] = aggr[c];\n                res.push({\n                  index: data[i] ? data[i].index : 0,\n                  rowIndex: rowIndex,\n                  rowKey: 'a' + aggIndex + '-' + (data[i] ? data[i].key : rowIndex),\n                  aggregated: true,\n                  name: c,\n                  data: tmp\n                });\n                rowIndex++;\n                aggIndex++;\n              });\n            }\n          });\n        }\n        if (isGroup && this.selection && lastInGroup && groupNumCheckboxes) {\n          res[currentGroupRow].selection = true;\n          res[currentGroupRow].selected = groupNumChecked === groupNumCheckboxes;\n        }\n        i++;\n      }\n      let fdata = [];\n      res.forEach(d => {\n        //if (d.group || d.expander || this.isExpanded(d) || d.aggregated || (this.isExpanded(d) && d.groupAggregated)) {\n        if (d.group || d.expander || this.isExpanded(d) || d.aggregated || this.isExpanded(d) && d.groupAggregated || !!d.isFooter || !d.expander && !!d.expansion && this.isExpanded(bbn.fn.getRow(res, {\n          index: d.expanderIndex,\n          expander: true\n        })) && (!bbn.fn.isFunction(this.expander) || !!this.expander(d))) {\n          if (fdata.length) {\n            d.rowIndex = fdata[fdata.length - 1].rowIndex + 1;\n          }\n          fdata.push(d);\n        }\n      });\n      return fdata;\n    },\n    /**\r\n     * Returns true if an expander is defined or if the table is groupable and the group is 'number'.\r\n     * @computed hasExpander\r\n     * @returns {Boolean}\r\n     */\n    hasExpander() {\n      return this.expander || this.groupable && typeof this.group === 'number' && this.cols[this.group];\n    },\n    /**\r\n     * The current columns of the table.\r\n     * @computed currentColumns\r\n     * @returns {Array}\r\n     */\n    currentColumns() {\n      let r = [];\n      bbn.fn.each([].concat(this.groupCols), (a, i) => {\n        bbn.fn.each(a.cols, b => {\n          r.push(bbn.fn.extend(true, {}, b, {\n            fixed: i !== 1,\n            isLeft: i === 0,\n            isRight: i === 2,\n            realWidth: b.realWidth ? b.realWidth + 'px' : 'auto'\n          }));\n        });\n      });\n      return r;\n    },\n    /**\r\n     * Indicates whether the column for the expander should be shown\r\n     * @computed expanderColumnVisible\r\n     * @returns {Boolean}\r\n     */\n    expanderColumnVisible() {\n      if (this.items && this.items.length) {\n        return !!this.items.filter(i => !!i.expander).length;\n      }\n      return false;\n    },\n    currentMaxRowHeight() {\n      return !!this.maxRowHeight ? this.maxRowHeight + 'px' : 'auto';\n    }\n  },\n  methods: {\n    isString: bbn.fn.isString,\n    isObject: bbn.fn.isObject,\n    buttonSource() {\n      if (bbn.fn.isFunction(this.realButtons)) {\n        return this.realButtons(...arguments);\n      }\n      if (bbn.fn.isArray(this.realButtons)) {\n        return this.realButtons;\n      }\n      return [];\n    },\n    convertActions(arr, data, col, idx) {\n      return bbn.fn.map(arr, a => {\n        let b = bbn.fn.clone(a);\n        if (a.action && bbn.fn.isFunction(a.action)) {\n          b.action = e => {\n            this._execCommand(a, data, col, idx, e);\n          };\n        }\n        return b;\n      });\n    },\n    getTrClass(row) {\n      if (bbn.fn.isFunction(this.trClass)) {\n        return this.trClass(row);\n      }\n      if (this.trClass) {\n        return this.trClass;\n      }\n      return '';\n    },\n    getTrStyle(row) {\n      if (bbn.fn.isFunction(this.trStyle)) {\n        return this.trStyle(row);\n      }\n      if (this.trStyle) {\n        return this.trStyle;\n      }\n      return '';\n    },\n    /**\r\n     * Normalizes the row's data.\r\n     * @method _defaultRow\r\n     * @param initialData\r\n     * @returns {Object}\r\n     */\n    _defaultRow(initialData) {\n      let res = {},\n        data = initialData ? bbn.fn.clone(initialData) : {};\n      bbn.fn.each(this.cols, function (a) {\n        if (a.field) {\n          if (data[a.field] !== undefined) {\n            res[a.field] = data[a.field];\n          } else if (a.default !== undefined) {\n            res[a.field] = bbn.fn.isFunction(a.default) ? a.default() : a.default;\n          } else if (a.nullable) {\n            res[a.field] = null;\n          } else if (a.type) {\n            switch (a.type) {\n              case 'number':\n              case 'money':\n                res[a.field] = a.min > 0 ? a.min : 0;\n                break;\n              default:\n                res[a.field] = '';\n            }\n          } else {\n            res[a.field] = '';\n          }\n          if (bbn.fn.isArray(res[a.field])) {\n            res[a.field] = res[a.field].slice();\n          } else if (res[a.field] instanceof Date) {\n            res[a.field] = new Date(res[a.field].getTime());\n          } else if (null !== res[a.field] && typeof res[a.field] === 'object') {\n            res[a.field] = bbn.fn.clone(res[a.field]);\n          }\n        }\n      });\n      return res;\n    },\n    /**\r\n     * Prepares the data to export the table to CSV.\r\n     * @method _export\r\n     * @returns {Array}\r\n     */\n    _export() {\n      let span = window.document.createElement('span');\n      let cols = {};\n      let res = [];\n      bbn.fn.each(this.currentData, a => {\n        let o = bbn.fn.clone(a.data);\n        let row = [];\n        bbn.fn.each(this.cols, b => {\n          if (!b.hidden && !b.buttons && b.field) {\n            if (typeof o[b.field] === 'string') {\n              span.innerHTML = o[b.field];\n              row.push(span.textContent.trim());\n            } else {\n              row.push(o[b.field]);\n            }\n          }\n        });\n        res.push(row);\n      });\n      return res;\n    },\n    /**\r\n     * Executes the action of the button.\r\n     *\r\n     * @method _execCommand\r\n     * @param {Object} button\r\n     * @param {Object} data\r\n     * @param {Object} col\r\n     * @param {Number} index\r\n     * @param {Event} ev\r\n     * @returns {Function|Boolean}\r\n     */\n    _execCommand(button, data, col, index, ev) {\n      if (ev) {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n      }\n      //bbn.fn.log(\"EXEC COMMAND\");\n      if (button.action) {\n        if (bbn.fn.isFunction(button.action)) {\n          return button.action(data, col, index);\n        } else if (typeof button.action === 'string') {\n          switch (button.action) {\n            case 'csv':\n              return this.exportCSV();\n            case 'excel':\n              return this.exportExcel();\n            case 'insert':\n              return this.insert(data, {\n                title: bbn._('New row creation')\n              }, -1);\n            case 'select':\n              return this.select(index);\n            case 'edit':\n              return this.edit(data, {\n                title: bbn._('Row edition')\n              }, index);\n            case 'add':\n              return this.add(data);\n            case 'copy':\n              return this.copy(data, {\n                title: bbn._('Row copy')\n              }, index);\n            case 'delete':\n              return this.remove(index);\n          }\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Exports to csv and download the given filename.\r\n     * @method exportCSV\r\n     * @param {String} filename\r\n     * @param {String} valSep\r\n     * @param {String} rowSep\r\n     * @param {String} valEsc\r\n     * @fires _export\r\n     */\n    exportCSV(filename, valSep, rowSep, valEsc) {\n      let data = bbn.fn.toCSV(this._export(), valSep, rowSep, valEsc);\n      if (!filename) {\n        filename = 'export-' + bbn.fn.dateSQL().replace('/:/g', '-') + '.csv';\n      }\n      bbn.fn.downloadContent(filename, data, 'csv');\n    },\n    /**\r\n     * Exports to excel.\r\n     * @method exportExcel\r\n     * @fires getPostData\r\n     */\n    exportExcel() {\n      if (this.isAjax && !this.isLoading) {\n        if (this.pageable) {\n          this.getPopup({\n            title: bbn._('Warning'),\n            content: '<div class=\"bbn-padded bbn-c\">' + bbn._('What do you want to export?') + '</div>',\n            buttons: [{\n              text: bbn._('Cancel'),\n              action: () => {\n                this.getPopup().close();\n              }\n            }, {\n              text: bbn._('This view'),\n              action: () => {\n                bbn.fn.postOut(this.source, this.getExcelPostData(true));\n                this.getPopup().close();\n              }\n            }, {\n              text: bbn._('All'),\n              action: () => {\n                bbn.fn.postOut(this.source, this.getExcelPostData());\n                this.getPopup().close();\n              }\n            }],\n            width: 300\n          });\n        } else {\n          this.confirm(bbn._('Are you sure you want to export to Excel?'), () => {\n            bbn.fn.postOut(this.source, this.getExcelPostData());\n          });\n        }\n      }\n    },\n    /**\r\n     * @method getExcelPostData\r\n     * @param {Boolean} currentView \r\n     * @returns {Object}\r\n     */\n    getExcelPostData(currentView) {\n      let cols = bbn.fn.filter(bbn.fn.extend(true, [], this.cols), c => {\n          return this.shownFields.includes(c.field) && (c.export === undefined || !c.export.excluded) || c.export && !c.export.excluded;\n        }),\n        data = {\n          excel: {\n            fields: bbn.fn.map(cols, c => {\n              return {\n                field: c.field,\n                // check if is present a custom 'title' on column's export property\n                title: c.export && c.export.title ? c.export.title : c.title || '',\n                // check if is present a custom 'type' on column's export property\n                type: c.export && c.export.type ? c.export.type : c.type || 'string',\n                hidden: c.export && c.export.hidden !== undefined ? +c.export.hidden : !this.shownFields.includes(c.field) ? 1 : 0,\n                format: c.export && c.export.format ? c.export.format : null\n              };\n            })\n          },\n          // the current fields\n          fields: bbn.fn.map(cols.slice(), f => {\n            return f.field;\n          }),\n          limit: currentView ? this.currentLimit : 50000,\n          start: currentView ? this.start : 0,\n          data: this.getPostData()\n        };\n      if (this.sortable) {\n        data.order = this.currentOrder;\n      }\n      if (this.isFilterable) {\n        data.filters = this.currentFilters;\n      }\n      return data;\n    },\n    /**\r\n     * Opens a popup showing the database query.\r\n     * @method showQuery \r\n     */\n    showQuery() {\n      if (this.currentQuery) {\n        this.getPopup({\n          title: bbn._('Database query and parameters'),\n          scrollable: true,\n          component: {\n            template: `\n<div class=\"bbn-block bbn-spadded\">\n  <h3 @click=\"showValues = !showValues\"\n      bbn-text=\"showValues ? _('Hide the values') : _('Show the values')\"\n      class=\"bbn-p\"></h3>\n  <ol class=\"bbn-space-bottom\" bbn-if=\"showValues\">\n    <li bbn-for=\"v in source.values\" bbn-text=\"v\"></li>\n  </ol>\n  <pre bbn-text=\"source.query\"></pre>\n</div>\n              `,\n            props: ['source'],\n            data() {\n              return {\n                showValues: false\n              };\n            }\n          },\n          closable: true,\n          source: {\n            query: this.currentQuery,\n            values: this.currentQueryValues\n          }\n        });\n      }\n    },\n    /**\r\n     * Returns true if a column is editable.\r\n     * @method isEditable\r\n     * @param {Object} row\r\n     * @param {Object} col\r\n     * @param {Number} index\r\n     * @returns {Boolean}\r\n     */\n    isEditable(row, col, index) {\n      if (!this.editable) {\n        return false;\n      }\n      if (bbn.fn.isFunction(col.editable)) {\n        return col.editable(row, col, index);\n      }\n      return col.editable !== false;\n    },\n    /**\r\n     * Returns true if the given row is edited.\r\n     * @method isEdited\r\n     * @param {Object} data\r\n     * @param {Object} col\r\n     * @param {Number} idx\r\n     * @fires isEditable\r\n     * @returns {Boolean}\r\n     */\n    isEdited(data, col, idx) {\n      return this.isEditable(data, col, idx) && this.editMode === 'inline' && this.items[idx].index === this.editedIndex;\n    },\n    /**\r\n     * Returns the configuration for the cells of the titles of grouped columns.\r\n     * @method titleGroupsCells\r\n     * @param {Number} groupIndex\r\n     * @returns {Array}\r\n     */\n    titleGroupsCells(groupIndex) {\n      if (this.titleGroups) {\n        let cells = [],\n          group = null,\n          corresp = {};\n        bbn.fn.each(this.groupCols[groupIndex].cols, a => {\n          if (!a.hidden) {\n            if (a.group === group) {\n              cells[cells.length - 1].colspan++;\n              cells[cells.length - 1].width += a.realWidth;\n              if (a.left !== undefined) {\n                if (cells[cells.length - 1].left === undefined || a.left < cells[cells.length - 1].left) {\n                  cells[cells.length - 1].left = a.left;\n                }\n              }\n              if (a.right !== undefined) {\n                if (cells[cells.length - 1].right === undefined || a.right < cells[cells.length - 1].right) {\n                  cells[cells.length - 1].right = a.right;\n                }\n              }\n            } else {\n              if (corresp[a.group] === undefined) {\n                let idx = bbn.fn.search(this.titleGroups, 'value', a.group);\n                if (idx > -1) {\n                  corresp[a.group] = idx;\n                }\n              }\n              if (corresp[a.group] !== undefined) {\n                cells.push({\n                  text: this.titleGroups[corresp[a.group]].text || '&nbsp;',\n                  style: this.titleGroups[corresp[a.group]].style || {},\n                  cls: this.titleGroups[corresp[a.group]].cls || '',\n                  colspan: 1,\n                  width: a.realWidth,\n                  left: a.left !== undefined ? a.left : undefined,\n                  right: a.right !== undefined ? a.right : undefined\n                });\n              }\n              /*\r\n              else if ( this.titleGroups.default ){\r\n                cells.push({\r\n                  text: this.titleGroups.default.text || '&nbsp;',\r\n                  style: this.titleGroups.default.style || {},\r\n                  cls: this.titleGroups.default.cls || '',\r\n                  colspan: 1,\r\n                  width: a.realWidth\r\n                });\r\n              }\r\n              */else {\n                cells.push({\n                  text: '&nbsp;',\n                  style: '',\n                  cls: '',\n                  colspan: 1,\n                  width: a.realWidth,\n                  left: a.left !== undefined ? a.left : undefined,\n                  right: a.right !== undefined ? a.right : undefined\n                });\n              }\n              group = a.group;\n            }\n          }\n        });\n        return cells;\n      }\n    },\n    /**\r\n     * Returns true if the table has currentFilters defined for the given column.\r\n     * @method hasFilter\r\n     * @param {Object} col The column\r\n     * @returns {Boolean}\r\n     */\n    hasFilter(col) {\n      if (col.field) {\n        for (let i = 0; i < this.currentFilters.conditions.length; i++) {\n          if (this.currentFilters.conditions[i].field === col.field) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    /**\r\n     * The behavior of the component at mouseMove.\r\n     * @method moveMouse\r\n     * @param {Event} e\r\n     * @fires keepCool\r\n     * @fires checkFilterWindow\r\n     */\n    moveMouse(e) {\n      this.keepCool(() => {\n        this.checkFilterWindow(e);\n      }, 'moveMouse');\n    },\n    /**\r\n     * Handles the floatingFilterTimeOut.\r\n     * @method checkFilterWindow\r\n     * @param {Event} e\r\n     */\n    checkFilterWindow(e) {\n      if (this.currentFilter) {\n        if (this.floatingFilterTimeOut) {\n          clearTimeout(this.floatingFilterTimeOut);\n        }\n        if (e.clientX < this.floatingFilterX || e.clientX > this.floatingFilterX + 600 || e.clientY < this.floatingFilterY || e.clientY > this.floatingFilterY + 200) {\n          if (!this.floatingFilterTimeOut) {\n            this.floatingFilterTimeOut = setTimeout(() => {\n              this.currentFilter = false;\n              this.editedFilter = false;\n            }, 500);\n          }\n        } else {\n          this.floatingFilterTimeOut = 0;\n        }\n      }\n    },\n    /**\r\n     * Returns the options for the bind of the table filter.\r\n     *\r\n     * @method getFilterOptions\r\n     * @fires getColFilters\r\n     * @returns {Object}\r\n     */\n    getFilterOptions() {\n      if (this.currentFilter) {\n        let o = this.editorGetComponentOptions(this.currentFilter);\n        if (o.field) {\n          o.conditions = this.getColFilters(this.currentFilter);\n        }\n        if (o.conditions.length) {\n          o.value = o.conditions[0].value;\n          o.operator = o.conditions[0].operator;\n          this.editedFilter = o.conditions[0];\n        }\n        o.multi = false;\n        return o;\n      }\n    },\n    /**\r\n     * Opens the popup containing the multifilter.\r\n     * @method openMultiFilter\r\n     */\n    openMultiFilter() {\n      this.currentFilter = false;\n      let table = this;\n      this.getPopup({\n        title: bbn._('Multiple filters'),\n        component: {\n          template: `<bbn-scroll><bbn-filter bbn-bind=\"source\" @change=\"changeConditions\" :multi=\"true\"></bbn-filter></bbn-scroll>`,\n          props: ['source'],\n          methods: {\n            changeConditions(o) {\n              table.currentFilters.logic = o.logic;\n              table.currentFilters.conditions = o.conditions;\n            }\n          }\n        },\n        width: '90%',\n        height: '90%',\n        source: {\n          fields: bbn.fn.filter(this.cols, a => {\n            return a.filterable !== false && !a.buttons;\n          }),\n          conditions: this.currentFilters.conditions,\n          logic: this.currentFilters.logic\n        }\n      });\n    },\n    /**\r\n     * Returns the filter of the given column.\r\n     * @method getColFilters\r\n     * @param {Object} col\r\n     * @returns {Object}\r\n     */\n    getColFilters(col) {\n      let r = [];\n      if (col.field) {\n        bbn.fn.each(this.currentFilters.conditions, a => {\n          if (a.field === col.field) {\n            r.push(a);\n          }\n        });\n      }\n      return r;\n    },\n    /**\r\n     * Shows the filter of the column.\r\n     * @method showFilter\r\n     * @param {Object} col\r\n     * @param {Event} ev\r\n     */\n    showFilter(col, ev) {\n      //bbn.fn.log(ev);\n      this.filterElement = ev.target;\n      this.floatingFilterX = ev.pageX - 10 < 0 ? 0 : ev.pageX - 10 + 600 > this.$el.clientWidth ? this.$el.clientWidth - 600 : ev.pageX - 10;\n      this.floatingFilterY = ev.pageY - 10 < 0 ? 0 : ev.pageY - 10 + 200 > this.$el.clientHeight ? this.$el.clientHeight - 200 : ev.pageY - 10;\n      this.currentFilter = col;\n    },\n    /**\r\n     * Returns the list of the showable columns\r\n     * @method pickableColumnList\r\n     * @returns {Array}\r\n     */\n    pickableColumnList() {\n      return this.cols.slice().map(a => {\n        return a.showable !== false;\n      });\n    },\n    /**\r\n     * Opens the popup containing the column picker.\r\n     * @method openColumnsPicker\r\n     */\n    openColumnsPicker() {\n      let table = this;\n      this.getPopup({\n        title: bbn._(\"Columns' picker\"),\n        height: '90%',\n        width: '90%',\n        component: {\n          template: `\n<div class=\"bbn-table-column-picker\">\n  <bbn-form ref=\"scroll\"\n            :source=\"formData\"\n            :scrollable=\"true\"\n            :prefilled=\"true\"\n            @success=\"applyColumnsShown\">\n    <div class=\"bbn-padded\">\n      <ul bbn-if=\"source.titleGroups\">\n        <li bbn-for=\"(tg, idx) in source.titleGroups\">\n          <h3>\n            <bbn-checkbox :checked=\"allVisible(tg.value)\"\n                          @change=\"checkAll(tg.value)\"\n                          :label=\"tg.text\"/>\n          </h3>\n          <ul>\n            <li bbn-for=\"(col, i) in source.cols\"\n                bbn-if=\"!col.fixed && (col.group === tg.value) && (col.showable !== false) && (col.title || col.ftitle)\">\n              <bbn-checkbox :checked=\"shownCols[i]\"\n                            @change=\"check(col, i)\"\n                            :label=\"col.ftitle || col.title\"\n                            :contrary=\"true\"/>\n            </li>\n          </ul>\n        </li>\n      </ul>\n      <ul bbn-else>\n        <li bbn-for=\"(col, i) in source.cols\"\n            bbn-if=\"!col.fixed && (col.showable !== false) && (col.title || col.ftitle)\">\n          <bbn-checkbox :checked=\"shownCols[i]\"\n                        @change=\"check(col, i)\"\n                        :label=\"col.ftitle || col.title\"\n                        :contrary=\"true\"/>\n        </li>\n      </ul>\n    </div>\n  </bbn-form>\n</div>\n`,\n          props: ['source'],\n          data() {\n            let shownColumns = this.source.cols.map(a => !a.hidden);\n            return {\n              table: table,\n              formData: {\n                changed: false\n              },\n              shownCols: shownColumns\n            };\n          },\n          methods: {\n            applyColumnsShown() {\n              let toShow = [],\n                toHide = [];\n              bbn.fn.each(this.source.cols, (a, i) => {\n                if (a.hidden == this.shownCols[i]) {\n                  if (this.shownCols[i]) {\n                    toShow.push(i);\n                  } else {\n                    toHide.push(i);\n                  }\n                }\n              });\n              if (toShow.length) {\n                table.show(toShow);\n              }\n              if (toHide.length) {\n                table.show(toHide, true);\n              }\n            },\n            allVisible(group) {\n              let ok = true;\n              //bbn.fn.log(\"allVisible\", group);\n              bbn.fn.each(this.source.cols, (a, i) => {\n                if (a.showable !== false && a.group === group && !a.fixed) {\n                  if (!this.shownCols[i]) {\n                    ok = false;\n                    //bbn.fn.log(\"NOT ALL VISIBLE!!!!!!!!!!!!!!!!!!!!!!\", a);\n                    return false;\n                  }\n                }\n              });\n              return ok;\n            },\n            check(col, index) {\n              this.$set(this.shownCols, index, !this.shownCols[index]);\n            },\n            checkAll(group) {\n              let show = !this.allVisible(group),\n                shown = [];\n              bbn.fn.each(this.source.cols, (a, i) => {\n                if (a.showable !== false && a.group === group && !a.fixed) {\n                  if (this.shownCols[i] != show) {\n                    this.shownCols.splice(i, 1, show);\n                  }\n                }\n              });\n              this.$forceUpdate();\n              //bbn.fn.log('forceupdate3');\n            }\n          },\n          watch: {\n            shownCols: {\n              deep: true,\n              handler() {\n                this.formData.changed = true;\n              }\n            }\n          }\n        },\n        source: {\n          cols: this.cols,\n          titleGroups: this.titleGroups\n        }\n      });\n    },\n    /**\r\n     * Returns wheter or not the cell is grouped.\r\n     * @method isGroupedCell\r\n     * @param {Number} groupIndex\r\n     * @param {Object} row\r\n     * @returns {Boolean}\r\n     */\n    isGroupedCell(groupIndex, row) {\n      if (this.groupable && row.group) {\n        if (this.groupCols[0].width > 200) {\n          return groupIndex === 0;\n        } else {\n          return groupIndex === 1;\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Returns the current configuration of the table.\r\n     * @method getConfig\r\n     * @returns {Object}\r\n     */\n    getConfig() {\n      return {\n        searchValue: this.searchValue,\n        limit: this.currentLimit,\n        order: this.currentOrder,\n        filters: this.currentFilters,\n        hidden: this.currentHidden\n      };\n    },\n    /**\r\n     * Returns the columns configuration.\r\n     * @method getColumnsConfig\r\n     * @returns {Array}\r\n     */\n    getColumnsConfig() {\n      return JSON.parse(JSON.stringify(this.cols));\n    },\n    onSave() {\n      this.$emit('save', JSON.parse(this.jsonConfig));\n    },\n    /**\r\n     * Sets the current config of the table.\r\n     * @method setConfig\r\n     * @param {Object} cfg\r\n     * @param {Boolean} no_storage\r\n     * @fires getConfig\r\n     * @fires setStorage\r\n     */\n    setConfig(cfg, no_storage) {\n      if (cfg === false) {\n        cfg = bbn.fn.clone(this.defaultConfig);\n      } else if (cfg === true) {\n        cfg = this.getConfig();\n      }\n      if (cfg && cfg.limit) {\n        if (this.filterable && cfg.filters && this.currentFilters !== cfg.filters) {\n          this.currentFilters = cfg.filters;\n        }\n        if (this.pageable && this.currentLimit !== cfg.limit) {\n          this.currentLimit = cfg.limit;\n        }\n        if (this.search) {\n          this.searchValue = cfg.searchValue || '';\n        }\n        if (this.sortable && this.currentOrder !== cfg.order) {\n          if (bbn.fn.isObject(cfg.order)) {\n            let currentOrder = [];\n            bbn.fn.iterate(cfg.order, (v, n) => {\n              currentOrder.push({\n                field: n,\n                dir: v.toUpperCase() === 'DESC' ? 'DESC' : 'ASC'\n              });\n            });\n            this.currentOrder = currentOrder;\n          } else if (bbn.fn.isArray(cfg.order)) {\n            this.currentOrder = cfg.order;\n          }\n        }\n        if (this.showable) {\n          if (cfg.hidden !== undefined && !bbn.fn.isSame(cfg.hidden, this.currentHidden)) {\n            this.currentHidden = cfg.hidden;\n          } else if (cfg.shown !== undefined && !bbn.fn.isSame(this.allFields.filter(x => !cfg.shown.includes(x)), this.currentHidden)) {\n            bbn.fn.warning(\"WAR!!!\");\n            this.currentHidden = this.allFields.filter(x => !cfg.shown.includes(x));\n          }\n          bbn.fn.each(this.cols, (a, i) => {\n            let isHidden = this.currentHidden.indexOf(a.field || i) > -1;\n            if (a.hidden !== isHidden) {\n              //bbn.fn.log(\"CHANGING HIDDEN\");\n              //this.cols[i].hidden = hidden;\n              this.$set(this.cols[i], 'hidden', isHidden);\n            }\n          });\n        }\n        this.currentConfig = {\n          searchValue: this.searchValue,\n          limit: this.currentLimit,\n          order: this.currentOrder,\n          filters: this.currentFilters,\n          hidden: this.currentHidden\n        };\n        if (!no_storage) {\n          let cfg = this.currentConfig;\n          if (this.cols.length > 10 && this.currentHidden?.length > this.cols.length / 2) {\n            cfg = bbn.fn.extend({}, cfg);\n            cfg.shown = this.allFields.filter(x => !cfg.hidden.includes(x));\n            delete cfg.hidden;\n          }\n          this.setStorage(cfg);\n        }\n      }\n    },\n    /**\r\n     * Saves the current configuration.\r\n     * @method save\r\n     */\n    save() {\n      this.savedConfig = this.jsonConfig;\n    },\n    beforeSelect(index, ev) {\n      this.$emit('beforeselect', ev, index, this.items[index]);\n    },\n    /**\r\n     * Emits 'select',  'unselect' or 'toggle' at change of checkbox of the row in a selectable table.\r\n     * @method checkSelection\r\n     * @param {Number}  index\r\n     * @param {Boolean} index\r\n     * @emit unselect\r\n     * @emit select\r\n     * @emit toggle\r\n     */\n    checkSelection(index, state) {\n      if (this.cancelSelection) {\n        this.cancelSelection = false;\n        return;\n      }\n      let row = this.items[index];\n      if (row) {\n        if (this.groupable && row.group) {\n          if (row.expanded) {\n            bbn.fn.fori((d, i) => {\n              if (d && d.selection && d.data[this.cols[this.group].field] === row.value) {\n                this.checkSelection(i, state);\n              }\n            }, this.items, index + row.num, index + 1);\n          }\n        } else if (row.selection) {\n          let idx = this.currentSelected.indexOf(this.uid ? this.currentData[row.index].data[this.uid] : row.index);\n          let isSelected = false;\n          let toggled = false;\n          if (idx > -1) {\n            if ([undefined, false].includes(state)) {\n              toggled = true;\n              this.$emit('unselect', row.data);\n              this.currentSelected.splice(idx, 1);\n            }\n          } else if ([undefined, true].includes(state)) {\n            toggled = true;\n            this.$emit('select', row.data);\n            this.currentSelected.push(this.uid ? this.currentData[row.index].data[this.uid] : row.index);\n            isSelected = true;\n          }\n          if (toggled) {\n            this.$emit('toggle', isSelected, this.currentData[row.index].data);\n          }\n        }\n      }\n    },\n    /**\r\n     * Refresh the current data set.\r\n     *\r\n     * @method updateData\r\n     * @param withoutOriginal\r\n     * @fires _removeTmp\r\n     * @fires init\r\n     */\n    updateData(withoutOriginal) {\n      /** Mini reset?? */\n      this.isTableDataUpdating = true;\n      this.allRowsChecked = false;\n      this.currentExpanded = [];\n      this._removeTmp();\n      this.editedRow = false;\n      this.editedIndex = false;\n      this.$forceUpdate();\n      //bbn.fn.log('forceupdate4');\n      return bbn.cp.mixins.list.methods.updateData.apply(this, [withoutOriginal]).then(() => {\n        if (this.currentData.length && this.selection && this.currentSelected.length && !this.uid) {\n          this.currentSelected = [];\n        }\n        if (this.editable) {\n          this.originalData = JSON.parse(JSON.stringify(this.currentData.map(a => {\n            return a.data;\n          })));\n        }\n        this.$forceUpdate();\n        const pager = this.getRef('pager');\n        if (pager) {\n          pager.$forceUpdate();\n        }\n        this.isTableDataUpdating = false;\n      });\n    },\n    /**\r\n     * Return true if the given row is changed from originalData.\r\n     * @method isDirty\r\n     * @param {Object} row\r\n     * @param {Object} col\r\n     * @param {Number} idx\r\n     */\n    isDirty(row, col, idx) {\n      return this.isBatch && col && row.index !== this.editedIndex && !row.aggregated && !row.groupAggregated && col.editable !== false && col.field && this.originalData && this.originalData[row.index] && row.data[col.field] != this.originalData[row.index][col.field];\n    },\n    /**\r\n     * Returns the css class of the given column.\r\n     * @method currentClass\r\n     * @param {Object} column\r\n     * @param {Object} data\r\n     * @param {Number} index\r\n     */\n    currentClass(column, data, index) {\n      let tr = this.trClass ? bbn.fn.isFunction(this.trClass) ? this.trClass(data) : this.trClass : '';\n      if (column.cls) {\n        return (!!tr ? tr + ' ' : '') + (bbn.fn.isFunction(column.cls) ? column.cls(data, index, column) : column.cls);\n      }\n      return tr || '';\n    },\n    /**\r\n     * Returns true if the given column is sorted.\r\n     * @method isSorted\r\n     * @param {Object} col\r\n     */\n    isSorted(col) {\n      if (this.sortable && col.sortable !== false && !col.buttons && col.field) {\n        let idx = bbn.fn.search(this.currentOrder, {\n          field: col.field\n        });\n        if (idx > -1) {\n          return this.currentOrder[idx];\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Sorts the given column.\r\n     * @method sort\r\n     * @param {Object} col\r\n     * @fires updateData\r\n     */\n    sort(col) {\n      if (!this.isLoading && this.sortable && col.field && col.sortable !== false) {\n        let f = col.field,\n          pos = bbn.fn.search(this.currentOrder, {\n            field: f\n          });\n        if (pos > -1) {\n          if (this.currentOrder[pos].dir === 'ASC') {\n            this.currentOrder[pos].dir = 'DESC';\n          } else {\n            this.currentOrder.splice(0, this.currentOrder.length);\n          }\n        } else {\n          this.currentOrder.splice(0, this.currentOrder.length);\n          this.currentOrder.push({\n            field: f,\n            dir: 'ASC'\n          });\n        }\n        if (this.isAjax) {\n          this.updateData();\n        }\n      }\n    },\n    /**\r\n     * Deprecated. Not removed for backwards compatibility.\r\n     * @method updateTable\r\n     */\n    updateTable() {\n      return;\n    },\n    /**\r\n     * Renders a cell according to column's config.\r\n     * @method render\r\n     * @param {Object} data\r\n     * @param {Object} column\r\n     * @param {Number} index\r\n     * @fires renderData\r\n     * @returns {Function}\r\n     */\n    render(data, column, index) {\n      let value = data && this.isValidField(column.field) ? data[column.field] : undefined;\n      if (column.render) {\n        return column.render(data, column, index, value);\n      }\n      return this.renderData(data, column, index);\n    },\n    /**\r\n     * Resets configuration of the table.\r\n     * @method reset\r\n     * @param noCfg\r\n     * @fires setConfig\r\n     * @fires init\r\n     */\n    reset(noCfg) {\n      this.initReady = false;\n      this.$emit('reset', this);\n      if (!noCfg) {\n        this.setConfig(false);\n      }\n      this.init();\n    },\n    /**\r\n     * Adds the given column to table's configuration\r\n     * @method addColumn\r\n     * @param {Object} obj\r\n     */\n    addColumn(obj) {\n      if (!obj) {\n        return;\n      }\n      let def = this.defaultObject();\n      if (obj.aggregate && !Array.isArray(obj.aggregate)) {\n        obj.aggregate = [obj.aggregate];\n      }\n      for (let n in obj) {\n        def[bbn.fn.camelize(n)] = obj[n];\n      }\n      if (!!obj.buttons) {\n        def.filterable = false;\n        def.sortable = false;\n      }\n      this.cols.push(def);\n    },\n    /**\r\n     * Return true if the cell is before aggregated cells.\r\n     * @method isBeforeAggregated\r\n     * @param {Number} groupIndex\r\n     * @param {Number} idx\r\n     * @returns {Boolean}\r\n     */\n    isBeforeAggregated(groupIndex, idx) {\n      return this.isAggregated && (this.groupCols[groupIndex].cols[idx + 1] && this.groupCols[groupIndex].cols[idx + 1].field === this.isAggregated || !this.groupCols[groupIndex].cols[idx + 1] && this.groupCols[groupIndex + 1] && this.groupCols[groupIndex + 1].cols[0] && this.groupCols[groupIndex + 1].cols[0].field === this.isAggregated);\n    },\n    /**\r\n     * Returns an object of numbers as width and height based on whatever unit given.\r\n     * \r\n     * @method getDimensions\r\n     * @param {Number} width\r\n     * @param {Number} height\r\n     * @return {Number}\r\n     */\n    getDimensionWidth(width) {\n      if (bbn.fn.isNumber(width) && width) {\n        return parseInt(width);\n      }\n      let parent = this.$el || this.$root.$el;\n      let r = 0;\n      if (parent && width) {\n        if (!parent.insertAdjacentElement) {\n          return 0;\n        }\n        let el = document.createElement('div');\n        el.style.position = 'absolute';\n        el.style.opacity = 0;\n        el.className = 'bbn-reset';\n        el.style.width = this.formatSize(width);\n        try {\n          parent.insertAdjacentElement('beforeend', el);\n        } catch (e) {\n          bbn.fn.log(\"Error while inserting adjacent element for dimensioncalculation\", e, this.$el);\n          return 0;\n        }\n        r = el.offsetWidth || el.clientWidth || 0;\n        el.remove();\n      }\n      return r;\n    },\n    /**\r\n     * Resizes the table.\r\n     * @method resizeWidth\r\n     * @returns {bbnCp}\r\n     */\n    resizeWidth() {\n      bbn.fn.log('resizeWidth');\n      let currentTot = this.groupCols[0].width + this.groupCols[1].width + this.groupCols[2].width,\n        parentWidth = this.$el.offsetParent ? this.$el.offsetParent.getBoundingClientRect().width : this.lastKnownCtWidth,\n        diff = parentWidth - this.borderLeft - this.borderRight - currentTot,\n        numDynCols = this.currentColumns.filter(c => c.width === undefined && !c.isExpander && !c.isSelection && !c.hidden).length,\n        numStaticCols = this.currentColumns.filter(c => !!c.width && !c.isExpander && !c.isSelection && !c.hidden).length,\n        newWidth = numDynCols || numStaticCols ? diff / (numDynCols || numStaticCols) : 0;\n      if (newWidth) {\n        window.bbn.fn.log(['inside table', diff, newWidth, numDynCols, numStaticCols]);\n        this.isResizingWidth = true;\n        bbn.fn.each(this.groupCols, (groupCol, groupIdx) => {\n          let sum = 0,\n            sumRight = 0,\n            sumLeft = 0;\n          bbn.fn.each(groupIdx !== 2 ? groupCol.cols : groupCol.cols.slice().reverse(), col => {\n            if (!col.hidden) {\n              if (!col.isExpander && !col.isSelection && (!!numDynCols && col.width === undefined || !numDynCols && !!numStaticCols && !!col.width)) {\n                let tmp = col.realWidth + newWidth;\n                if (col.width !== undefined && (!bbn.fn.isString(col.width) || bbn.fn.isNumber(bbn.fn.substr(col.width, -1)))) {\n                  if (tmp < parseFloat(col.width)) {\n                    tmp = parseFloat(col.width);\n                  }\n                } else if (tmp < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {\n                  tmp = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;\n                }\n                let minWidth = this.getDimensionWidth(col.minWidth);\n                let maxWidth = this.getDimensionWidth(col.maxWidth);\n                if (col.minWidth && tmp < minWidth) {\n                  tmp = minWidth;\n                }\n                if (col.maxWidth && tmp > maxWidth) {\n                  tmp = maxWidth;\n                }\n                this.$set(col, 'realWidth', tmp);\n              }\n              sum += col.realWidth;\n              if (groupIdx === 0) {\n                this.$set(col, 'left', sumLeft);\n                sumLeft += col.realWidth;\n              }\n              if (groupIdx === 2) {\n                this.$set(col, 'right', sumRight);\n                sumRight += col.realWidth;\n              }\n            }\n          });\n          this.$set(this.groupCols[groupIdx], 'width', sum);\n          sum = 0;\n          sumLeft = 0;\n          sumRight = 0;\n        });\n        this.isResizingWidth = false;\n      }\n      return this;\n    },\n    /**\r\n     * Returns if the given row is expanded.\r\n     * @method isExpanded\r\n     * @param {Object} d\r\n     * @returns {boolean}\r\n     */\n    isExpanded(d) {\n      if (this.allExpanded) {\n        return true;\n      }\n      if (!this.expander && (this.group === false || !this.groupable)) {\n        return true;\n      }\n      if (this.expander && !this.groupable) {\n        return this.currentExpanded.includes(d.index);\n      }\n      if (this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field) {\n        if (d.data[this.cols[this.group].field] !== undefined) {\n          return this.currentExpandedValues.includes(d.data[this.cols[this.group].field]);\n        }\n        return true;\n      }\n      if ((d.isGrouped || d.groupAggregated) && this.currentExpanded.includes(d.link)) {\n        return true;\n      }\n      return false;\n    },\n    /**\r\n     * Toggles the expander of the row corresponding to the given idx.\r\n     * @method toggleExpanded\r\n     * @param {Number} idx\r\n     */\n    toggleExpanded(idx) {\n      if (this.currentData[idx]) {\n        if (this.allExpanded) {\n          bbn.fn.each(this.items, item => {\n            if (!this.groupable) {\n              if (!this.currentExpanded.includes(item.index)) {\n                this.currentExpanded.push(item.index);\n              }\n            } else if (this.group !== false && this.cols[this.group] && this.cols[this.group].field && item.data[this.cols[this.group].field] !== undefined && !this.currentExpandedValues.includes(item.data[this.cols[this.group].field])) {\n              this.currentExpandedValues.push(item.data[this.cols[this.group].field]);\n            }\n          });\n          this.allExpanded = false;\n        }\n        if (this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field && this.currentData[idx].data[this.cols[this.group].field] !== undefined) {\n          let groupValue = this.currentData[idx].data[this.cols[this.group].field],\n            groupIndex = this.currentExpandedValues.indexOf(groupValue);\n          if (groupIndex > -1) {\n            this.currentExpandedValues.splice(groupIndex, 1);\n          } else {\n            this.currentExpandedValues.push(groupValue);\n          }\n        } else {\n          let i = this.currentExpanded.indexOf(idx);\n          if (i > -1) {\n            this.currentExpanded.splice(i, 1);\n          } else {\n            this.currentExpanded.push(idx);\n          }\n        }\n      }\n    },\n    /**\r\n     * Returns wheter or not the given row has the expander.\r\n     * @method rowHasExpander\r\n     * @param d\r\n     * @returns {Boolean}\r\n     */\n    rowHasExpander(d) {\n      if (this.hasExpander) {\n        if (!bbn.fn.isFunction(this.expander)) {\n          return true;\n        }\n        return !!this.expander(d);\n      }\n      return false;\n    },\n    /**\r\n     * Returns true if the given index is selected.\r\n     * @method isSelected\r\n     * @param {Number} index\r\n     * @returns {Boolean}\r\n     */\n    isSelected(index) {\n      return this.selection && (!this.uid && this.currentSelected.includes(index) || this.uid && this.currentSelected.includes(this.currentData[index].data[this.uid]));\n    },\n    /**\r\n     * Returns true if the given row has td.\r\n     *\r\n     * @method hasTd\r\n     * @param {Object} data\r\n     * @param {Number} colIndex\r\n     * @param {Number} groupIndex\r\n     */\n    hasTd(data, colIndex, groupIndex) {\n      let tdIndex = colIndex;\n      for (let i = 0; i < groupIndex; i++) {\n        tdIndex += this.groupCols[groupIndex].cols.length;\n      }\n      if (data.selection) {\n        if (tdIndex === 0) {\n          return false;\n        } else if (data.group || data.expander) {\n          if (tdIndex === 1) {\n            return false;\n          }\n        }\n      }\n      if (data.group || data.expander) {\n        if (tdIndex === 0) {\n          return false;\n        }\n      }\n      if (data.group || data.expansion) {\n        return false;\n      }\n      if (data.hidden) {\n        return false;\n      }\n      return true;\n    },\n    /**\r\n     * Initializes the table.\r\n     * @method init\r\n     * @param {Boolean} with_data\r\n     * @fires updateData\r\n     */\n    init(with_data) {\n      bbn.fn.warning(\"INIT TABLE\");\n      this.initStarted = true;\n      this.setContainerMeasures();\n      this.setResizeMeasures();\n      let groupCols = [{\n          name: 'left',\n          width: 0,\n          visible: 0,\n          cols: []\n        }, {\n          name: 'main',\n          width: 0,\n          visible: 0,\n          cols: []\n        }, {\n          name: 'right',\n          width: 0,\n          visible: 0,\n          cols: []\n        }],\n        numUnknown = 0,\n        colButtons = false,\n        isAggregated = false,\n        aggregatedColIndex = false,\n        aggregatedColTitle = false,\n        aggregatedColumns = [],\n        parentWidth = this.$el.offsetParent ? this.$el.offsetParent.getBoundingClientRect().width : this.lastKnownCtWidth;\n      this.groupCols.splice(0, this.groupCols.length, ...groupCols);\n      bbn.fn.each(this.cols, a => {\n        a.realWidth = 0;\n      });\n      bbn.fn.each(this.cols, (a, i) => {\n        if (!a.hidden && (!this.groupable || this.group !== i)) {\n          let minWidth = null;\n          let maxWidth = null;\n          if (a.minWidth) {\n            minWidth = this.getDimensionWidth(a.minWidth);\n          }\n          if (a.maxWidth) {\n            maxWidth = this.getDimensionWidth(a.maxWidth);\n          }\n          a.index = i;\n          if (a.hidden) {\n            a.realWidth = 0;\n          } else {\n            if (this.aggregate && a.aggregate) {\n              if (aggregatedColIndex === false) {\n                aggregatedColIndex = i;\n                isAggregated = true;\n              }\n              aggregatedColumns.push(a);\n            }\n            if (a.width) {\n              if (bbn.fn.isString(a.width) && bbn.fn.substr(a.width, -1) === '%') {\n                a.realWidth = Math.floor(parentWidth * this.getDimensionWidth(a.width) / 100);\n                if (a.realWidth < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {\n                  a.realWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;\n                }\n              } else {\n                a.realWidth = this.getDimensionWidth(a.width);\n              }\n            } else {\n              a.realWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;\n              numUnknown++;\n            }\n            if (minWidth && a.realWidth < minWidth) {\n              a.realWidth = minWidth;\n            }\n            if (maxWidth && a.realWidth > maxWidth) {\n              a.realWidth = maxWidth;\n            }\n            if (a.buttons !== undefined) {\n              colButtons = i;\n            }\n            if (a.fixed) {\n              if (a.fixed === 'left' || a.fixed !== 'right' && this.fixedDefaultSide === 'left') {\n                if (a.buttons !== undefined) {\n                  //colButtons = groupCols[0].cols.length;\n                }\n                groupCols[0].cols.push(a);\n                if (!a.hidden) {\n                  groupCols[0].visible++;\n                }\n              } else {\n                if (a.buttons !== undefined) {\n                  //colButtons = groupCols[0].cols.length + groupCols[1].cols.length + groupCols[2].cols.length;\n                }\n                groupCols[2].cols.push(a);\n                if (!a.hidden) {\n                  groupCols[2].visible++;\n                }\n              }\n            } else {\n              if (a.buttons !== undefined) {\n                //colButtons = groupCols[0].cols.length + groupCols[1].cols.length;\n              }\n              groupCols[1].cols.push(a);\n              if (!a.hidden) {\n                groupCols[1].visible++;\n              }\n            }\n          }\n        }\n      });\n      let firstGroup = groupCols[0].visible ? 0 : 1;\n      if (this.selection) {\n        let o = {\n          isExpander: false,\n          isSelection: true,\n          title: ' ',\n          filterable: false,\n          width: 40,\n          realWidth: 40\n        };\n        if (firstGroup === 0) {\n          o.fixed = true;\n          o.isLeft = true;\n        }\n        groupCols[firstGroup].cols.unshift(o);\n        groupCols[firstGroup].visible++;\n      }\n      if (this.hasExpander) {\n        let o = {\n          isExpander: true,\n          isSelection: false,\n          title: ' ',\n          filterable: false,\n          width: 30,\n          realWidth: 30\n        };\n        if (firstGroup === 0) {\n          o.fixed = true;\n          o.isLeft = true;\n        }\n        groupCols[firstGroup].cols.unshift(o);\n        groupCols[firstGroup].visible++;\n      }\n      let tot = 0;\n      bbn.fn.each(groupCols, a => {\n        a.sum = bbn.fn.sum(a.cols, 'realWidth');\n        tot += a.sum;\n      });\n      let styles = window.getComputedStyle(this.$el),\n        borderLeft = styles.getPropertyValue('border-left-width').slice(0, -2),\n        borderRight = styles.getPropertyValue('border-right-width').slice(0, -2),\n        toFill = parentWidth - borderLeft - borderRight - tot;\n      this.borderLeft = borderLeft;\n      this.borderRight = borderRight;\n      // We must arrive to 100% minimum\n      if (toFill > 0) {\n        if (numUnknown) {\n          let newWidth = toFill / numUnknown;\n          if (newWidth < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {\n            newWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;\n          }\n          let maxPreAggregatedWidth = 0;\n          bbn.fn.each(this.cols, (a, i) => {\n            if (!a.hidden) {\n              if (!a.width) {\n                a.realWidth = newWidth + (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth);\n              }\n              if (isAggregated && i < aggregatedColIndex && a.realWidth >= maxPreAggregatedWidth) {\n                maxPreAggregatedWidth = a.realWidth;\n                aggregatedColTitle = a;\n              }\n            }\n          });\n        }\n        // Otherwise we dispatch it through the existing column\n        else {\n          let num = this.numVisible;\n          let ignore = 0;\n          if (this.hasExpander) {\n            num--;\n            ignore++;\n          }\n          if (this.selection) {\n            num--;\n            ignore++;\n          }\n          //let bonus = Math.floor(toFill / num * 100) / 100;\n          let bonus = toFill / num;\n          let maxPreAggregatedWidth = 0;\n          bbn.fn.each(this.cols, (a, i) => {\n            if (!a.hidden && i >= ignore) {\n              a.realWidth += bonus;\n              if (isAggregated && i < aggregatedColIndex && a.realWidth >= maxPreAggregatedWidth) {\n                maxPreAggregatedWidth = a.realWidth;\n                aggregatedColTitle = a;\n              }\n            }\n          });\n        }\n      }\n      if (aggregatedColTitle) {\n        aggregatedColTitle.isAggregatedTitle = true;\n      }\n      let sum = 0,\n        sumLeft = 0,\n        sumRight = 0;\n      bbn.fn.each(groupCols, (a, i) => {\n        bbn.fn.each(i !== 2 ? a.cols : a.cols.slice().reverse(), c => {\n          if (!c.hidden) {\n            sum += c.realWidth;\n            if (i === 0) {\n              c.left = sumLeft;\n              sumLeft += c.realWidth;\n            } else if (i === 2) {\n              c.right = sumRight;\n              sumRight += c.realWidth;\n            }\n          }\n        });\n        a.width = sum;\n        sum = 0;\n        sumLeft = 0;\n        sumRight = 0;\n      });\n      this.groupCols.splice(0, this.groupCols.length, ...groupCols);\n      this.colButtons = colButtons;\n      this.isAggregated = isAggregated;\n      this.aggregatedColumns = aggregatedColumns;\n      this.resizeWidth();\n      this.initReady = true;\n      if (with_data) {\n        this.$once('dataloaded', () => {\n          this.initStarted = false;\n        });\n        this.updateData();\n      } else {\n        this.initStarted = false;\n      }\n      this.$forceUpdate();\n      //bbn.fn.log('forceupdate5');\n    },\n    /**\r\n     * Prevents default if enter or tab keys are pressed.\r\n     * @method keydown\r\n     * @param {Event} e\r\n     */\n    keydown(e) {\n      if (this.isBatch && this.editedRow && e.which === 9 || e.which === 13) {\n        e.preventDefault();\n      }\n    },\n    /**\r\n     * Show or hide the given column index.\r\n     * @method show\r\n     * @param {Array} colIndexes\r\n     * @param {Boolean} hide\r\n     * @fires $forceUpdate\r\n     * @fires setConfig\r\n     * @fires init\r\n     */\n    show(colIndexes, hide) {\n      if (!Array.isArray(colIndexes)) {\n        colIndexes = [colIndexes];\n      }\n      bbn.fn.each(colIndexes, colIndex => {\n        if (this.cols[colIndex]) {\n          if (this.cols[colIndex].hidden && !hide || !this.cols[colIndex].hidden && hide) {\n            let idx = this.currentHidden.indexOf(colIndex);\n            if (hide && idx === -1) {\n              this.currentHidden.push(colIndex);\n            } else if (!hide && idx > -1) {\n              this.currentHidden.splice(idx, 1);\n            }\n          }\n        }\n      });\n      this.$forceUpdate();\n      //bbn.fn.log('forceupdate1');\n      this.setConfig(true);\n      this.init(true);\n    },\n    /**\r\n     * If no editor is given to the table returns the correct component to edit the field basing on the column type.\r\n     *\r\n     * @method getEditableComponent\r\n     * @param {Object} col\r\n     * @param {Object} data\r\n     * @return {String}\r\n     */\n    getEditableComponent(col, data) {\n      if (col.editor) {\n        return col.editor;\n      }\n      if (col.type) {\n        switch (col.type) {\n          case \"date\":\n            return 'bbn-datepicker';\n          case \"email\":\n            return 'bbn-input';\n          case \"url\":\n            return 'bbn-input';\n          case \"number\":\n            return 'bbn-numeric';\n          case \"money\":\n            return 'bbn-numeric';\n          case \"bool\":\n          case \"boolean\":\n            return 'bbn-checkbox';\n        }\n      }\n      if (col.source) {\n        return 'bbn-dropdown';\n      }\n      return 'bbn-input';\n    },\n    /**\r\n     * Returns the object of properties to bind with the editable component.\r\n     * @method getEditableOptions\r\n     * @param {Object} col\r\n     * @param {Object} data\r\n     * @returns {Object}\r\n     */\n    getEditableOptions(col, data) {\n      let res = col.options ? bbn.fn.isFunction(col.options) ? col.options(data, col) : col.options : {};\n      if (!res.name && col.field) {\n        res.name = col.field;\n      }\n      if (col.type) {\n        switch (col.type) {\n          case \"date\":\n            break;\n          case \"email\":\n            bbn.fn.extend(res, {\n              type: 'email'\n            });\n            break;\n          case \"url\":\n            bbn.fn.extend(res, {\n              type: 'url'\n            });\n            break;\n          case \"number\":\n            break;\n          case \"money\":\n            break;\n          case \"bool\":\n          case \"boolean\":\n            bbn.fn.extend(res, {\n              value: 1,\n              novalue: 0\n            });\n            break;\n        }\n      }\n      if (col.source) {\n        bbn.fn.extend(res, {\n          source: col.source\n        });\n      } else if (col.editor) {\n        res.source = data;\n      }\n      return res;\n    },\n    updatePager() {\n      if (this.hasPager) {\n        this.getRef('pager').$forceUpdate();\n      }\n    },\n    /**\r\n     * Returns the html element of the given row index.\r\n     * @method getTr\r\n     * @param {Number} i\r\n     * @returns {String}\r\n     */\n    getTr(i) {\n      let row = false;\n      if (bbn.fn.isNumber(i)) {\n        bbn.fn.each(this.getRef('tbody').rows, tr => {\n          if (tr.getAttribute('index') == i) {\n            row = tr;\n            return true;\n          }\n        });\n      }\n      return row;\n    },\n    /**\r\n     * Returns an object of the default values for the different types of fields.\r\n     * @method defaultObject\r\n     * @returns {Object}\r\n     */\n    defaultObject() {\n      let o = {};\n      bbn.fn.iterate(bbn.cp.mixins.field.props, (v, n) => {\n        if (v.default !== undefined) {\n          o[n] = bbn.fn.isFunction(v.default) ? v.default() : v.default;\n        }\n      });\n      return o;\n    },\n    /**\r\n     * Returns true if the filter should be shown on the given column.\r\n     * @method showFilterOnColumn\r\n     * @param {Object} col\r\n     * @returns {Boolean}\r\n     */\n    showFilterOnColumn(col) {\n      if (!this.filterable || col.filterable === false || col.hideFilter) {\n        return false;\n      }\n      if (col.filterable === true) {\n        return true;\n      }\n      return !col.buttons && col.field;\n    },\n    /**\r\n     * Focuses the given row index.\r\n     * @method focusRow\r\n     * @param {Event} ev\r\n     * @param {Number} idx\r\n     */\n    focusRow(ev, idx) {\n      if (ev.target.tagName !== 'BUTTON') {\n        this.focusedRow = idx;\n      }\n    },\n    /**\r\n     * Blurs the given row index.\r\n     * @method blurRow\r\n     * @param {Event} ev\r\n     * @param {Number} idx\r\n     */\n    blurRow(ev, idx) {\n      if (ev.target.tagName !== 'BUTTON') {\n        this.focusedRow = false;\n      }\n    },\n    /**\r\n     * @method clickCell\r\n     * @param {Object} col\r\n     * @param {Number} colIndex\r\n     * @param {Number} dataIndex\r\n     * @emits click-row\r\n     * @emits click-cell\r\n     */\n    clickCell(col, colIndex, dataIndex) {\n      if (this.filteredData[dataIndex]) {\n        this.$emit('click-row', this.filteredData[dataIndex].data, dataIndex);\n        this.$emit('click-cell', col, colIndex, dataIndex);\n      }\n    },\n    /**\r\n     * @method dbclickCell\r\n     * @param {Object} col\r\n     * @param {Number} colIndex\r\n     * @param {Number} dataIndex\r\n     */\n    dbclickCell(col, colIndex, dataIndex, data, itemIndex, force) {\n      if (this.zoomable && (!!col.zoomable || force)) {\n        let obj = {\n          title: col.title || col.ftitle,\n          minHeight: '20%',\n          minWidth: '20%'\n        };\n        if (!!col.component) {\n          obj.component = col.component;\n          obj.source = bbn.fn.isFunction(col.mapper) ? col.mapper(data) : data;\n          obj.componentOptions = col.options;\n        } else if (bbn.fn.isFunction(col.render)) {\n          obj.content = `<div class=\"bbn-spadded\">${col.render(data, col, itemIndex)}</div>`;\n        } else {\n          obj.content = `<div class=\"bbn-spadded\">${data.text}</div>`;\n        }\n        this.getPopup().open(obj);\n      }\n    },\n    /**\r\n     * Removes the focus from the given row.\r\n     * @param {Number} idx \r\n     */\n    focusout(idx) {\n      this.clickedTd = null;\n      if (idx === undefined || idx === this.focusedRow) {\n        this.focused = false;\n        //this.focusedElement = undefined;\n        setTimeout(() => {\n          if (!this.focused) {\n            this.focusedRow = false;\n          }\n        }, 50);\n      }\n    },\n    /**\r\n     * Focuses the given row.\r\n     * @param {Number} idx \r\n     * @param {Event} e \r\n     */\n    focusin(idx, e) {\n      if (!e.target.closest('td') || !e.target.closest('td').classList.contains('bbn-table-buttons') || e.target.closest('td').classList.contains('bbn-table-edit-buttons')) {\n        this.focused = true;\n        this.clickedTd = e.target;\n        //this.setFocusedElement(e)\n        if (this.focusedRow !== idx) {\n          this.focusedRow = idx;\n        }\n      }\n    },\n    listOnBeforeMount() {},\n    checkAll() {\n      bbn.fn.each(this.items, (a, i) => {\n        this.checkSelection(i, true);\n      });\n    },\n    uncheckAll() {\n      bbn.fn.each(this.items, (a, i) => {\n        this.checkSelection(i, false);\n      });\n    },\n    getDataIndex(itemIndex) {\n      return this.items[itemIndex] ? this.items[itemIndex].index : -1;\n    },\n    setFocusedElement(ev) {\n      if (this.editable && this.editMode === 'inline' && (this.tmpRow || this.editedRow) && ev.target.tagName !== 'TR' && ev.target.tagName !== 'TD') {\n        let e = ev.target.closest('td'),\n          pos = e.getBoundingClientRect();\n        this.focuseElementX = pos.x;\n        this.focusedElementY = pos.y - pos.height;\n        this.focusedElement = ev.target;\n      }\n    },\n    getColOptions(data, col, idx) {\n      if (col.options) {\n        return bbn.fn.isFunction(col.options) ? col.options(data, col, idx) : col.options;\n      }\n      return {};\n    },\n    /**\r\n     * The method called on a column resize (by user)\r\n     * @method onUserResize\r\n     * @param {Event} e\r\n     * @fires $forceUpdate\r\n     */\n    onUserResize(e) {\n      let d = e.target._bbn.directives.resizable.options.data,\n        nextCol = this.groupCols[d.groupColIndex].cols[d.columnIndex + 1],\n        nextColSize = nextCol ? nextCol.realWidth + e.detail.movement : 0;\n      if (d.column.realWidth !== e.detail.size && e.detail.size >= this.defaultColumnWidth && (!nextCol || nextColSize >= this.defaultColumnWidth)) {\n        this.groupCols[d.groupColIndex].cols[d.columnIndex].realWidth = e.detail.size;\n        if (nextCol) {\n          this.groupCols[d.groupColIndex].cols[d.columnIndex + 1].realWidth = nextColSize;\n        }\n        this.$forceUpdate();\n      }\n    },\n    onButtonsMenuSelect(item, data, col, i, ev, floater) {\n      ev.preventDefault();\n      this._execCommand(item, data, col, i, ev);\n      floater.closeAll();\n    }\n  },\n  /**\r\n   * Adds bbns-column from the slot and sets the initial configuration of the table.\r\n   * @event created\r\n   * @fires addColumn\r\n   * @fires setConfig\r\n   * @fires getStorage\r\n   */\n  created() {\n    this.componentClass.push('bbn-resize-emitter');\n    // Adding bbns-column from the slot\n    if (this.$slots.default) {\n      //bbn.fn.log(\"SLOTS TABLE CREATED\", this.$slots, this.$el.bbnSlots);\n      for (let node of this.$slots.default) {\n        if (node.bbnSchema?.tag === 'tr') {\n          this.hasTrSlot = true;\n          break;\n        }\n      }\n    }\n    if (this.columns.length) {\n      bbn.fn.each(this.columns, a => this.addColumn(a));\n    }\n    if (this.defaultConfig.hidden === null) {\n      let tmp = [];\n      let initColumn = [];\n      bbn.fn.each(this.cols, (a, i) => {\n        if (a.hidden) {\n          tmp.push(i);\n        } else if (initColumn.length <= 10) {\n          initColumn.push(i);\n        }\n      });\n      this.defaultConfig.hidden = tmp;\n    }\n    this.setConfig(false, true);\n    this.initialConfig = this.jsonConfig;\n    this.savedConfig = this.initialConfig;\n    let cfg = this.getStorage();\n    if (cfg) {\n      this.setConfig(cfg, true);\n    }\n    this.$on('addTmp', () => {\n      let scroll = this.getRef('scroll');\n      if (bbn.cp.isComponent(scroll) && bbn.fn.isFunction(scroll.scrollStartY) && bbn.fn.isFunction(scroll.scrollStartX)) {\n        scroll.scrollStartY();\n        scroll.scrollStartX();\n      }\n    });\n  },\n  beforeDestroy() {\n    bbn.fn.log(\"DESTROYING TABLE\");\n  },\n  /**\r\n   * After the initialization of the component sets the property ready on true.\r\n   * @event mounted\r\n   * @fires init\r\n   * @fires updateData\r\n   */\n  mounted() {\n    bbn.fn.log(\"TABLE MOUNTED\");\n    this.container = this.getRef('container');\n    this.marginStyleSheet = document.createElement('style');\n    document.body.appendChild(this.marginStyleSheet);\n    this.isTable = !!this.closest('bbn-table');\n    let floater = this.closest('bbn-floater');\n    if (floater) {\n      if (floater.ready) {\n        this.init();\n        this.$once('dataloaded', () => {\n          this.ready = true;\n          this.setResizeEvent();\n          floater.onResize();\n        });\n      } else {\n        floater.$on('ready', () => {\n          this.init();\n          this.$once('dataloaded', () => {\n            this.ready = true;\n            this.setResizeEvent();\n            floater.onResize();\n          });\n        });\n      }\n      if (this.isAutobind) {\n        this.updateData();\n      }\n    } else {\n      this.$once('dataloaded', () => {\n        this.ready = true;\n      });\n      this.init(!!this.isAutobind);\n    }\n  },\n  watch: {\n    columns() {\n      if (this.ready) {\n        this.cols.splice(0, this.cols.length);\n        if (this.columns.length) {\n          bbn.fn.each(this.columns, a => this.addColumn(a));\n        }\n        if (this.defaultConfig.hidden === null) {\n          let tmp = [];\n          let initColumn = [];\n          bbn.fn.each(this.cols, (a, i) => {\n            if (a.hidden) {\n              tmp.push(i);\n            } else if (initColumn.length <= 10) {\n              initColumn.push(i);\n            }\n          });\n          this.defaultConfig.hidden = tmp;\n        }\n        this.init();\n      }\n    },\n    /**\r\n     * Updates the data.\r\n     * @watch observerValue\r\n     * @fires updateData\r\n     */\n    /*observerValue(newVal) {\r\n      if ((newVal !== this._observerReceived) && !this.editedRow) {\r\n        this._observerReceived = newVal;\r\n        //bbn.fn.log(\"watch observerValue\");\r\n        this.updateData();\r\n      }\r\n    },*/\n    /**\r\n     * Updates the data.\r\n     * @watch observerDirty\r\n     * @fires updateData\r\n     */\n    observerDirty(v) {\n      if (v && !this.editedRow) {\n        this.observerDirty = false;\n        this.updateData();\n      }\n    },\n    allRowsChecked(v) {\n      if (v) {\n        this.checkAll();\n      } else if (!this.isTableDataUpdating) {\n        this.uncheckAll();\n      }\n    },\n    /**\r\n     * Forces the update of the component.\r\n     * @watch currentHidden\r\n     * @fires setConfig\r\n     */\n    currentHidden: {\n      deep: true,\n      handler() {\n        if (this.ready) {\n          this.setConfig(true);\n          this.$forceUpdate();\n          //bbn.fn.log('forceupdate2');\n        }\n      }\n    },\n    /**\r\n     * @watch group\r\n     * @fires init\r\n     */\n    group() {\n      this.currentExpandedValues = [];\n      this.currentExpanded = [];\n      this.init();\n    },\n    /**\r\n     * @watch focusedRow\r\n     * @fires isModified\r\n     * @fires edit\r\n     * @emit change\r\n     * @emit focus\r\n     * @emit focusout\r\n     */\n    focusedRow(newIndex, oldIndex) {\n      if (bbn.fn.isNumber(oldIndex)) {\n        this.$emit('focusout', oldIndex, this.items[oldIndex] ? this.items[oldIndex].index : undefined);\n      }\n      if (this.items[newIndex]) {\n        this.$emit('focus', this.items[newIndex].data, newIndex, this.items[newIndex].index);\n      }\n      if (this.editable && this.editMode === 'inline') {\n        if (bbn.fn.isNumber(oldIndex) && this.items[oldIndex]) {\n          let idx = this.items[oldIndex].index;\n          if (this.editedIndex === idx && (idx === -1 || this.isModified(idx))) {\n            if (this.autoSave) {\n              this.saveInline();\n            } else if (this.autoReset) {\n              this.cancel();\n            } else {\n              this.$emit('change', this.items[oldIndex].data, idx);\n            }\n          }\n        }\n        this.editedRow = false;\n        if (bbn.fn.isNumber(newIndex) && this.items[newIndex] && !this.items[newIndex].group && !this.items[newIndex].expander) {\n          let comeFromAfter = bbn.fn.isNumber(oldIndex) && newIndex === oldIndex - 1;\n          this.$nextTick(() => {\n            this.edit(this.items[newIndex].data, null, newIndex);\n            this.$nextTick(() => {\n              let ele = this.clickedTd || this.getTr(newIndex);\n              let nextInputs = ele ? ele.querySelectorAll('input') : [];\n              let nextInput;\n              bbn.fn.each(nextInputs, a => {\n                if (a.offsetWidth) {\n                  nextInput = a;\n                  if (!comeFromAfter) {\n                    return false;\n                  }\n                }\n              });\n              if (nextInput) {\n                nextInput.focus();\n              }\n            });\n          });\n        }\n      }\n    },\n    /**\r\n     * @watch lastKnownCtWidth\r\n     * @fires resizeWidth\r\n     */\n    lastKnownCtWidth() {\n      if (this.groupCols.length && !this.initStarted && (this.groupCols[0].cols.length || this.groupCols[1].cols.length || this.groupCols[2].cols.length)) {\n        this.resizeWidth();\n      }\n    },\n    currentPage() {\n      this.updatePager();\n    },\n    numPages() {\n      this.updatePager();\n    }\n  },\n  components: {\n    /**\r\n     * @component table-dots\r\n     */\n    tableDots: {\n      name: 'table-dots',\n      template: `\n<div class=\"bbn-c bbn-lg\"\n     @click=\"table.dbclickCell(source.column, source.index, source.dataIndex, source.data, source.itemIndex, true)\"\n     :style=\"{display: visible ? 'block !important' : 'none !important'}\">\n  <i class=\"nf nf-mdi-dots_horizontal bbn-p bbn-primary-text-alt\"/>\n</div>\n        `,\n      props: {\n        /**\r\n         * @prop {Object} source\r\n         * @memberof bbn-table-dots\r\n         */\n        source: {\n          type: Object\n        }\n      },\n      data() {\n        return {\n          /**\r\n          * @data {Boolean} [false] visible\r\n          * @memberof bbn-table-dots\r\n          */\n          visible: false,\n          /**\r\n          * @data {bbnCp} table\r\n          * @memberof bbn-table-dots\r\n          */\n          table: this.closest('bbn-table')\n        };\n      },\n      methods: {\n        /**\r\n         * @method {Object} checkVisibility\r\n         * @memberof bbn-table-dots\r\n         */\n        checkVisibility() {\n          if (this.table.maxRowHeight && this.table.zoomable) {\n            let td = this.$el.closest('td');\n            if (!!td && !!td.firstElementChild && !!td.firstElementChild.firstElementChild) {\n              let styleFirst = window.getComputedStyle(td.firstElementChild),\n                styleSecond = window.getComputedStyle(td.firstElementChild.firstElementChild);\n              this.visible = parseFloat(styleSecond.height) + parseFloat(styleFirst.paddingTop) + parseFloat(styleFirst.paddingBottom) > this.table.maxRowHeight;\n              if (this.visible) {\n                td.firstElementChild.firstElementChild.style.setProperty('height', 'calc(' + this.table.maxRowHeight + 'px - 2.3rem)');\n                td.firstElementChild.firstElementChild.style.overflow = 'hidden';\n              }\n            }\n          } else {\n            this.visible = false;\n          }\n        }\n      },\n      /**\r\n       * @event mounted\r\n       * @memberof bbn-table-dots\r\n       * @fires checkVisibility\r\n       */\n      mounted() {\n        this.checkVisibility();\n      }\n    }\n  }\n};\n\n\nlet cpLang = {};\nif (bbn.env.lang) {\n  try {\n    const lang = bbn.env.lang || 'en';\n    cpLang = await __webpack_require__(\"./src/components/table/_i18n lazy recursive ^\\\\.\\\\/table\\\\..*\\\\.lang$\")(`./table.${lang}.lang`);\n    if (cpLang.default) {\n      cpLang = cpLang.default;\n    }\n  } catch (err) {}\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'bbn-table',\n  definition: cpDef,\n  template: _table_html__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  style: _table_less__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  lang: cpLang\n});\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/table.js?");

/***/ })

}]);