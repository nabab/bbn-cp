"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/container-_mixins-selection-js"],{

/***/ "./src/components/container/_mixins/selection.js":
/*!*******************************************************!*\
  !*** ./src/components/container/_mixins/selection.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  props: {\n    /**\n     * The index of the container\n     * @prop {Number} idx\n     */\n    idx: {\n      type: Number\n    },\n    /**\n     * The timestamp of the last activation\n     * @prop {Number} last\n     */\n    last: {\n      type: Number\n    },\n    /**\n     * A unique id for the container that will ben used as index by the router\n     * @prop {String} uid\n     */\n    uid: {\n      type: String\n    },\n    /**\n     * Defines if the component has to be selected.\n     * @prop {Boolean|Number} [false] selected\n     */\n    selected: {\n      type: [Boolean, Number],\n      default: false\n    }\n  },\n  data() {\n    return {\n      isLoading: false\n    };\n  },\n  computed: {\n    isTabSelected() {\n      if (!this.router) {\n        return false;\n      }\n      if (this.currentPane) {\n        return this.currentPane.tabs[this.currentPane.selected] === this.currentView;\n      }\n      return this.router.selected === this.currentIndex;\n    }\n  },\n  methods: {\n    /**\n     * Shows the container.\n     * \n     * @method show\n     */\n    show(url) {\n      //bbn.fn.log([url, \"CHANGING SELECTED BY SHOWING \" + this.currentIndex, this.currentIndex, this.currentView.idx]);\n      if (!this.isPane && this.currentIndex !== undefined) {\n        this.router.selected = this.currentIndex;\n        if (this.visual && this.router.visualShowAll) {\n          this.router.visualShowAll = false;\n        }\n      }\n      if (bbn.fn.isString(url) && !url.indexOf(this.currentURL)) {\n        this.setCurrent(url);\n      }\n    },\n    close() {\n      if (!this.isPane) {\n        this.router.close(this.currentIndex);\n      }\n    },\n    onShow() {\n      //bbn.fn.log([\"ON SHOW\", this.isVisible, this.router?.selected, this.currentIndex, this.isLoaded, this.isLoading, this.ready]);\n      this.$nextTick(() => {\n        if (this.isVisible && this.router) {\n          if (!this.isLoaded && !this.isLoading) {\n            this.loadView(this.currentCurrent);\n          } else if (!this.ready) {\n            this.onResize();\n            this.init();\n          }\n          this.router.navigate();\n        }\n      });\n    },\n    /**\n     * @method load\n     * @param {String} url\n     * @param {Boolean} force\n     * @fires search\n     * @fires add\n     * @fires parseURL\n     * @fires callRouter\n     * @fires navigate\n     * @fires activate\n     * @emit update\n    */\n    async loadView(url, force, index) {\n      if (!url) {\n        throw new Error(bbn._(\"Impossible to get the view without an URL\"));\n      }\n      bbn.fn.log(\"LOADING VIEW \" + url);\n      if (this.isLoading) {\n        return;\n      }\n      let finalURL = this.router.fullBaseURL + url;\n      //bbn.fn.warning(\"ROUTING \" + url + ' / CURRENT: ' + this.router.currentURL + ' / FULL: ' + this.router.getFullCurrentURL() + ' / FINAL: ' + finalURL);\n      this.isLoading = true;\n      if (!this.currentView.pane) {\n        //bbn.fn.log([\"GETTING VIEW \" + finalURL, url, this.router.parseURL(url), this.router.baseURL, this.getFullCurrentURL()]);\n        //this.currentURL = url;\n      }\n      this.router.$emit('update', this.router.views);\n      this.router.$emit(\"load\", url);\n      let dataObj = this.router.postBaseUrl ? {\n        _bbn_baseURL: this.router.fullBaseURL\n      } : {};\n      let response;\n      try {\n        response = await this.post(finalURL, dataObj);\n        this.isLoading = false;\n      }\n      // Abort\n      catch (e) {\n        bbn.fn.warning(\"ABORTED\");\n        this.isLoading = false;\n        /*\n        let idx = this.search(url);\n        if (idx !== false) {\n          let url = this.currentView.url;\n          if (this.urls[url]) {\n            this.callRouter(finalURL, url);\n            this.$nextTick(() => {\n              this.close(idx);\n            });\n            return;\n          }\n        }\n        */\n      }\n      if (response?.status === 200) {\n        const d = response.data;\n        //bbn.fn.log([\"RESPONSE\", d.url, d, dataObj, this.$el]);\n        let callRealInit = true;\n        if (!d.label && d.title) {\n          d.label = d.title;\n          delete d.title;\n        }\n        if (!d.label || d.label === bbn._('Loading')) {\n          let label = bbn._('Untitled');\n          let num = 0;\n          while (bbn.fn.search(this.router.views, a => a.label.indexOf(label) === 0) > -1) {\n            num++;\n            label = bbn._('Untitled') + ' ' + num;\n          }\n          d.label = label;\n        }\n        this.currentTitle = d.label;\n        const oldUrl = d.url;\n        const oldCurrent = d.url;\n        d.url = this.router.parseURL(d.url || finalURL);\n        if (d.url !== this.currentURL) {\n          this.currentURL = d.url;\n          this.router.updateBaseURL();\n          if (!d.url) {\n            bbn.fn.log(\"OLD URL \" + oldUrl, \"OLD CUR \" + oldCurrent, \"NEW URL \" + d.url, \"NEW CUR \" + finalURL);\n            debugger;\n          }\n          //bbn.fn.log(\"CHANGING URL TO \" + d.url + ' / ' + this.router.baseURL);\n          if (this.currentCurrent.indexOf(d.url)) {\n            this.setCurrent(d.url);\n          }\n        }\n        if (Object.hasOwn(d, 'data')) {\n          this.currentSource = d.data;\n        }\n        if (Object.hasOwn(d, 'script')) {\n          this.currentScript = d.script;\n        }\n        if (Object.hasOwn(d, 'css')) {\n          this.currentCss = d.css;\n        }\n        if (Object.hasOwn(d, 'content')) {\n          this.currentContent = d.content;\n        }\n        if (Object.hasOwn(d, 'bcolor')) {\n          this.currentBcolor = d.bcolor;\n        }\n        if (Object.hasOwn(d, 'fcolor')) {\n          this.currentFcolor = d.fcolor;\n        }\n        if (Object.hasOwn(d, 'icon')) {\n          this.currentIcon = d.icon;\n        }\n        if (Object.hasOwn(d, 'options')) {\n          this.currentOptions = d.options;\n        }\n        if (Object.hasOwn(d, 'scrollable')) {\n          this.currentScrollable = d.scrollable;\n        }\n        if (Object.hasOwn(d, 'component')) {\n          this.currentComponent = d.component;\n        }\n        if (Object.hasOwn(d, 'notext')) {\n          this.currentNotext = d.notext;\n        }\n        if (Object.hasOwn(d, 'menu')) {\n          this.currentMenu = d.menu;\n        }\n        if (Object.hasOwn(d, 'advert')) {\n          this.currentAdvert = d.advert;\n        }\n        if (Object.hasOwn(d, 'help')) {\n          this.currentHelp = d.help;\n        }\n        if (Object.hasOwn(d, 'imessages')) {\n          this.currentImessages = d.imessages;\n        }\n        this.isLoaded = true;\n        this.init();\n      }\n    },\n    selectionMounted() {\n      //bbn.fn.warning(\"SELECTION MOUNTED\");\n      if (!this.router.ready) {\n        //bbn.fn.warning(\"ROUTER NOT READY\");\n        this.router.$on('ready', () => {\n          //bbn.fn.warning(\"ROUTER ON READY\");\n          this.selectionMounted();\n        });\n      } else {\n        if (this.router.urls[this.uid]) {\n          //bbn.fn.warning(\"SELECTION EXISTING\");\n          return;\n        }\n\n        //bbn.fn.warning(\"ROUTER REGISTERING FOR \" + this.url);\n        this.router.register(this);\n        this.$nextTick(() => {\n          if (this.currentSelected) {\n            this.show();\n            this.onShow();\n          }\n          this.init();\n        });\n      }\n    },\n    /**\n     * Initializes the component.\n     * \n     * @method init\n     */\n    init() {\n      if (this.router && this.isVisible && (this.real || this.isLoaded && !this.ready)) {\n        //bbn.fn.log(\"INIT \" + this.currentURL, this.real,this.currentScript, this.currentView )\n        let res;\n        if (this.currentScript) {\n          //bbn.fn.log(this.currentScript);\n          res = typeof this.currentScript === 'string' ? eval(this.currentScript) : this.currentScript;\n          //bbn.fn.log(\"************************************\", res);\n          // if evaluating the script property returns a function that will be onMount\n          if (bbn.fn.isFunction(res)) {\n            this.onMount = res;\n            this.isComponent = false;\n          }\n          // Otherwise if it's an object we assume it is a component\n          else if (res && typeof res === 'object') {\n            if (!res.props) {\n              res.props = bbn.fn.createObject();\n            }\n            if (!res.props.source) {\n              res.props.source = {\n                type: Object\n              };\n            }\n            if (!res.mixins) {\n              res.mixins = [];\n            }\n            if (!res.mixins.includes(bbn.cp.mixins.basic)) {\n              res.mixins.push(bbn.cp.mixins.basic);\n            }\n            this.componentDefinition = bbn.cp.normalizeComponent(res, 'bbn-container-' + this.getFullURL());\n\n            //bbn.fn.log(\"YUUUU\", res, this.componentDefinition, this.currentContent)\n            this.componentDefinition.template = this.currentContent;\n            this.isComponent = true;\n          }\n        } else if (this.currentContent) {\n          this.isComponent = false;\n        }\n        if (this.isComponent) {\n          // We create a local component with a random name,\n          // the content as template\n          // and the object returned as component definition\n          // Adding also a few funciton to interact with the tab\n          let cont = this;\n          const definition = bbn.fn.extend(true, res ? res : {}, {\n            template: '<div class=\"' + (this.router?.scrollContent ? '' : 'bbn-w-100') + '\">' + this.currentView.content + '</div>',\n            methods: {\n              getContainer() {\n                if (!this._bbn_container) {\n                  this._bbn_container = this.closest('bbn-container');\n                }\n                return this._bbn_container;\n              },\n              getTab() {\n                return this.getContainer();\n              },\n              addMenu() {\n                return this.getContainer().addMenu.apply(this.router, arguments);\n              },\n              deleteMenu() {\n                return this.getContainer().deleteMenu.apply(this.router, arguments);\n              }\n            },\n            props: {\n              source: {\n                type: Object\n              }\n            }\n          });\n          if (!definition.props) {\n            definition.props = bbn.fn.createObject();\n          }\n          if (!definition.props.source) {\n            definition.props.source = {\n              type: Object\n            };\n          }\n          if (!definition.mixins) {\n            definition.mixins = [];\n          }\n          if (!definition.mixins.includes(bbn.cp.mixins.basic)) {\n            definition.mixins.push(bbn.cp.mixins.basic);\n          }\n          this.componentDefinition = bbn.cp.normalizeComponent(definition, 'bbn-container-' + this.getFullURL());\n          // The local anon component gets defined\n          this.$options.components[this.componentName] = this.componentDefinition;\n        } else {\n          this.isComponent = false;\n        }\n        if (bbn.env.path.indexOf('#') !== -1) {\n          let scroll = this.getRef('scroll');\n          /**\n           * @todo  Does it mean the scroll manage the hash? Check it out\n           */\n          if (scroll && (scroll.currentY || scroll.currentX)) {\n            return;\n          }\n          let hash = bbn.env.path.split('#')[1];\n          if (hash) {\n            hash = '#' + hash;\n            location.hash = null;\n            location.hash = hash;\n          }\n        }\n        if (this.visual) {\n          this.setScreenshot();\n        }\n        this.ready = true;\n      }\n    },\n    /**\n     * Fires the parent's method reload.\n     * \n     * @method reload\n     * @fires router.reload\n     */\n    reload() {\n      this.popups.splice(0);\n      this.$nextTick(() => {\n        this.router.reload(this.currentIndex);\n      });\n    }\n  },\n  watch: {\n    isTabSelected(v) {\n      if (v) {\n        this.show();\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/container/_mixins/selection.js?");

/***/ })

}]);