"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/container-_mixins-selection-js"],{

/***/ "./src/components/container/_mixins/selection.js":
/*!*******************************************************!*\
  !*** ./src/components/container/_mixins/selection.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  props: {\n    /**\n     * The index of the container\n     * @prop {Number} idx\n     */\n    idx: {\n      type: Number\n    },\n    /**\n     * The timestamp of the last activation\n     * @prop {Number} last\n     */\n    last: {\n      type: Number\n    },\n    /**\n     * A unique id for the container that will ben used as index by the router\n     * @prop {String} uid\n     */\n    uid: {\n      type: String,\n      default() {\n        return bbn.fn.randomString();\n      }\n    },\n    /**\n     * Defines if the component has to be selected.\n     * @prop {Boolean|Number} [false] selected\n     */\n    selected: {\n      type: [Boolean, Number],\n      default: false\n    }\n  },\n  methods: {\n    /**\n     * Shows the container.\n     * \n     * @method show\n     */\n    show() {\n      if (!this.isPane) {\n        this.router.selected = this.currentIndex;\n        if (this.visual && this.router.visualShowAll) {\n          this.router.visualShowAll = false;\n        }\n      }\n    },\n    close() {\n      if (!this.isPane) {\n        this.router.close(this.currentIndex);\n      }\n    },\n    /**\n     * @method load\n     * @param {String} url\n     * @param {Boolean} force\n     * @fires search\n     * @fires add\n     * @fires parseURL\n     * @fires callRouter\n     * @fires navigate\n     * @fires activate\n     * @emit update\n    */\n    async getView(url, force, index) {\n      if (url) {\n        let finalURL = this.router.fullBaseURL + url;\n        this.isLoading = true;\n        if (!this.currentView.pane) {\n          this.currentURL = this.router.parseURL(url);\n        }\n        this.router.$emit('update', this.router.views);\n        this.router.$emit(\"load\", finalURL);\n        let dataObj = this.router.postBaseUrl ? {\n          _bbn_baseURL: this.router.fullBaseURL\n        } : {};\n        let response;\n        try {\n          response = await this.post(finalURL, dataObj);\n        }\n        // Abort\n        catch (e) {\n          bbn.fn.warning(\"ABORTED\");\n          this.isLoading = false;\n          /*\n          let idx = this.search(this.parseURL(finalURL));\n          if (idx !== false) {\n            let url = this.currentView.url;\n            if (this.urls[url]) {\n              this.callRouter(finalURL, url);\n              this.$nextTick(() => {\n                this.close(idx);\n              });\n              return;\n            }\n          }\n          */\n        }\n        if (response?.status === 200) {\n          const d = response.data;\n          let callRealInit = true;\n          if (!d.title || d.title === bbn._('Loading')) {\n            let title = bbn._('Untitled');\n            let num = 0;\n            while (bbn.fn.search(this.views, {\n              title: title\n            }) > -1) {\n              num++;\n              title = bbn._('Untitled') + ' ' + num;\n            }\n            d.title = title;\n          }\n          this.currentTitle = d.title;\n          if (!d.current && d.url) {\n            d.current = d.url;\n          }\n          if (d.current) {\n            this.currentURL = d.current;\n          }\n          if (d.data) {\n            this.currentSource = d.data;\n          }\n          if (d.script) {\n            this.currentScript = d.script;\n          }\n          if (d.content) {\n            this.currentContent = d.content;\n          }\n          this.isLoaded = true;\n          this.init();\n\n          /*\n          if (d.url) {\n            d.url = this.parseURL(d.url);\n          }\n          if (!d.url) {\n            d.url = url;\n          }\n          //bbn.fn.warning(\"URLS\", url, d.url);\n          if (url.indexOf(d.url) === 0) {\n            d.current = url;\n            //bbn.fn.warning(\"CURRENT DEFINED AS \" + d.current);\n          }\n          else {\n            bbn.fn.warning(url + ' != ' + d.url);\n            let searchIdx = this.search(url);\n            if (searchIdx !== false) {\n              idx = searchIdx;\n              bbn.fn.log(\"REMOVED\");\n              this.remove(searchIdx, true);\n            }\n          }\n           if (d.data && bbn.fn.numProperties(d.data)) {\n            d.source = d.data;\n            delete d.data;\n          }\n           if ((d.url !== d.current) && this.urls[d.current]) {\n            let currentIndex = this.urls[d.current].currentIndex;\n            //bbn.fn.warning(\"DELETING VIEW CASE.... \" + d.url + ' / ' + d.current + ' ' + currentIndex);\n            //bbn.fn.log([d.url, this.urls[d.current], this.urls[d.url], Object.keys(this.urls), bbn.fn.search(this.views, {idx: this.urls[d.current].idx})]);\n            this.remove(currentIndex, true).then(() => {\n              const onRegister = url => {\n                //bbn.fn.log([\"REGISTERED\", url]);\n                if (url === d.url) {\n                  this.$off('registered', onRegister);\n                  let view = bbn.fn.getRow(this.views, { url: url });\n                  if ((this.selected === view.idx) || view.pane) {\n                    this.realInit(url);\n                  }\n                }\n              };\n              this.$on('registered', onRegister);\n              let o = bbn.fn.extend(view || bbn.fn.createObject(), d, { loading: false, load: true, real: view?.real || false, loaded: true });\n              //bbn.fn.log([\"BEFORE\", this.views.length, Object.keys(this.urls)]);\n              this.add(o, currentIndex).then(() => {\n                //bbn.fn.log(this.search(o.url), o);\n                let searchIndex = this.search(o.url);\n                //bbn.fn.log(\"Looking for \" + o.url);\n                if (searchIndex !== false) {\n                  //this.activateIndex(searchIndex);\n                  this.selected = searchIndex;\n                }\n              });\n            })\n            //callRealInit = false;\n           }\n          else {\n            this.$forceUpdate().then(() => {\n              let o = bbn.fn.extend(view || bbn.fn.createObject(), d, { loading: false, load: true, real: view?.real || false, loaded: true });\n              let searchIndex = this.search(o.url);\n              //bbn.fn.log(\"Looking for \" + o.url);\n              if ((searchIndex !== false) && this.urls[this.views[searchIndex].url]) {\n                //this.remove(searchIndex);\n                bbn.fn.warning(\"FOUND AND NOT REMOVED \" + searchIndex);\n                idx = searchIndex;\n                this.urls[this.currentView.url].isLoaded = true;\n                this.urls[this.currentView.url].dirty = false;\n                this.urls[this.currentView.url].ready = false;\n                this.urls[this.currentView.url].init();\n               }\n              else {\n                //bbn.fn.warning(\"ADDEDD \" + idx);\n                //bbn.fn.log(\"ADDING AFTER LOAD\");\n                this.add(o, idx);\n              }\n               if (o.title && !o.pane) {\n                this.currentTitle = o.title;\n              }\n              //this.$forceUpdate();\n              this.$nextTick(() => {\n                if (callRealInit) {\n                  this.realInit(d.url);\n                }\n              })\n            })\n           }\n          */\n        } else {\n          this.isLoading = false;\n          /*\n          let idx = this.search(this.parseURL(finalURL));\n          if (idx !== false) {\n            let url = this.currentView.url;\n            if (this.urls[url]) {\n              this.urls[url].errorStatus = response?.status || 500;\n              this.urls[url].setTitle(bbn._(\"Error\"));\n              this.urls[url].setIcon(\"nf nf-fa-warning\");\n              if (this.selected === idx) {\n                await this.callRouter(finalURL, url);\n              }\n            }\n          }\n          */\n        }\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/container/_mixins/selection.js?");

/***/ })

}]);