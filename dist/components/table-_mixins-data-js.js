"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/table-_mixins-data-js"],{

/***/ "./src/components/table/_mixins/data.js":
/*!**********************************************!*\
  !*** ./src/components/table/_mixins/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  data() {\n    return {\n      /**\n       * @data {Boolean} [false] isTableDataUpdating Will be set to true during the whole update process\n       */\n      isTableDataUpdating: false,\n      /**\n       * @data {Boolean} [false] _observerReceived\n       */\n      _observerReceived: false\n    };\n  },\n  computed: {\n    /**\n     * Return an array of objects containing the data of the row and other information about the current view of the table.\n     * @computed items\n     * @fires _checkConditionsOnValue\n     * @fires expandedValues\n     * @fires isExpanded\n     * @returns {Array}\n     */\n    items() {\n      if (!this.cols.length) {\n        return [];\n      }\n      // The final result\n      const cp = this;\n      let res = [],\n        isGroup = this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field,\n        groupField = isGroup ? this.cols[this.group].field : false,\n        // The group value will change each time a row has a different value on the group's column\n        currentGroupValue,\n        /* @todo Not sure of what it does ! */\n        currentLink,\n        // the data is put in a new array with its original index\n        o,\n        rowIndex = 0,\n        end = this.pageable ? this.currentLimit : this.currentData.length,\n        aggregates = {},\n        aggregateModes = [],\n        aggIndex = 0,\n        i = 0,\n        data = this.filteredData;\n      // Aggregated\n      // Paging locally\n      if (this.pageable && (!this.isAjax || !this.serverPaging)) {\n        i = this.start;\n        end = this.start + this.currentLimit > data.length ? data.length : this.start + this.currentLimit;\n      }\n      // Grouping (and sorting) locally\n      let pos;\n      if (isGroup && (this.isAjax && this.serverGrouping || !this.isAjax && this.localGrouping) && (pos = bbn.fn.search(this.currentOrder, {\n        field: this.cols[this.group].field\n      })) !== 0) {\n        // First ordering the data\n        let orders = [{\n          field: this.cols[this.group].field,\n          dir: pos > 0 ? this.currentOrder[pos].dir : 'asc'\n        }];\n        if (this.sortable && this.currentOrder.length) {\n          orders = orders.concat(JSON.parse(JSON.stringify(this.currentOrder)));\n        }\n        data = bbn.fn.multiorder(data, orders.map(item => {\n          item.field = 'data.' + item.field;\n          return item;\n        }));\n      }\n      // Sorting locally\n      else if (this.sortable && this.currentOrder.length && (!this.serverSorting || !this.isAjax)) {\n        // If there is a source, we sort based on the text (not the value), so we replace temporary the values\n        // with the text + a boundary + the value just the time of sorting\n        if (bbn.fn.count(this.cols, {\n          source: undefined\n        }, '!==')) {\n          /** @var will contain the original value of the column to reset it once the array is sorted */\n          let tmpData = {};\n          bbn.fn.each(this.cols, col => {\n            if (col.source && col.field) {\n              tmpData[col.field] = {};\n              bbn.fn.each(data, d => {\n                tmpData[col.field][d.index] = this.getProp(d.data, col.field);\n                //d.data[col.field] = d.data[col.field] ? bbn.fn.getField(col.source, col.sourceText ? col.sourceText : 'text', col.sourceValue ? col.sourceValue : 'value', d.data[col.field]) || '' : '';\n              });\n            }\n          });\n          data = bbn.fn.multiorder(data, JSON.parse(JSON.stringify(this.currentOrder)).map(item => {\n            item.field = 'data.' + item.field;\n            return item;\n          }));\n          bbn.fn.each(this.cols, col => {\n            if (col.source && col.field) {\n              bbn.fn.each(data, (d, i) => {\n                //d.data[col.field] = tmpData[col.field][d.index];\n              });\n            }\n          });\n        } else {\n          data = bbn.fn.multiorder(data, JSON.parse(JSON.stringify(this.currentOrder)).map(item => {\n            item.field = 'data.' + item.field;\n            return item;\n          }));\n        }\n      }\n      return data;\n    }\n  },\n  methods: {\n    isRowVisible(row, index) {\n      if (this.isGroupActive) {}\n    },\n    /**\n     * Refresh the current data set.\n     *\n     * @method updateData\n     * @param withoutOriginal\n     * @fires _removeTmp\n     * @fires init\n     */\n    updateData(withoutOriginal) {\n      /** Mini reset?? */\n      this.isTableDataUpdating = true;\n      this.allRowsChecked = false;\n      this.currentExpanded = [];\n      this.editedRow = false;\n      this.editedIndex = false;\n      this.$forceUpdate();\n      //bbn.fn.log('forceupdate4');\n      return bbn.cp.mixins.list.methods.updateData.apply(this, [withoutOriginal]).then(() => {\n        if (this.currentData.length && this.selection && this.currentSelected.length && !this.uid) {\n          this.currentSelected = [];\n        }\n        if (this.editable) {\n          this.originalData = JSON.parse(JSON.stringify(this.currentData.map(a => {\n            return a.data;\n          })));\n        }\n        this.isTableDataUpdating = false;\n      });\n    }\n  },\n  watch: {\n    /**\n     * Updates the data.\n     * @watch observerDirty\n     * @fires updateData\n     */\n    observerDirty(v) {\n      bbn.fn.log(\"WATCH OBSDIRY\");\n      if (v && !this.editedRow) {\n        this.confirm(_(\"The data has been modified outside, do you want to reload it?\"), () => {\n          this.observerDirty = false;\n          this.updateData();\n        });\n      }\n    },\n    /**\n     * @watch group\n     * @fires init\n     */\n    group() {\n      this.currentExpandedValues = [];\n      this.currentExpanded = [];\n      this.init();\n    },\n    items(val) {\n      if (this.expanded && !this.currentExpanded.length) {\n        this.currentExpanded = val.map(a => a.index);\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/_mixins/data.js?");

/***/ })

}]);