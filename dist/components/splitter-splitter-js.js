/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/splitter-splitter-js"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/splitter/splitter.less":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/splitter/splitter.less ***!
  \****************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `bbn-splitter {\n  max-width: 100% !important;\n  max-height: 100% !important;\n  overflow: hidden;\n}\nbbn-splitter bbn-pane {\n  box-sizing: border-box !important;\n  position: relative;\n}\nbbn-splitter .bbn-splitter-bar {\n  margin: 0;\n  padding: 0;\n}\nbbn-splitter .bbn-splitter-bar.vertical .bbn-splitter-collapser > div {\n  padding: 0 0.5rem;\n}\nbbn-splitter .bbn-splitter-bar.horizontal .bbn-splitter-collapser > div {\n  padding: 0.5rem 0;\n}\nbbn-splitter .bbn-splitter-bar.bbn-splitter-resizer.vertical {\n  cursor: ns-resize;\n}\nbbn-splitter .bbn-splitter-bar.bbn-splitter-resizer.horizontal {\n  cursor: ew-resize;\n}\nbbn-splitter .bbn-splitter-bar .bbn-splitter-collapser > div {\n  float: left;\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/splitter/splitter.less?./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/components/splitter/splitter.html":
/*!***********************************************!*\
  !*** ./src/components/splitter/splitter.html ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Module\nvar code = `<div :class=\"[\r\n       {\r\n         'bbn-100': fullSize,\r\n         'bbn-w-100': !fullSize && ((panes.lengh <= 1) || !isHorizontal),\r\n         'bbn-h-100': !fullSize && (panes.lengh <= 1) && isHorizontal,\r\n         'bbn-grid': true,\r\n         'bbn-hidden': !ready\r\n       },\r\n       componentClass\r\n     ]\"\r\n     :style=\"splitterStyle\"\r\n     @scroll.prevent.stop=\"preventScroll\"\r\n     bbn-show=\"panes.length\">\r\n  <slot/>\r\n  <!--div bbn-for=\"(rs, i) in resizers\"\r\n       :class=\"[\r\n         'bbn-unselectable',\r\n         'bbn-middle',\r\n         'bbn-splitter-bar',\r\n         'bbn-light',\r\n         'bbn-header',\r\n         currentOrientation,\r\n         {'bbn-splitter-resizer': !!rs.pane2},\r\n         realResizerClass(rs)\r\n       ]\"\r\n       ref=\"resizer\"\r\n       :style=\"{\r\n          gridColumn: isHorizontal ? rs.position : 1,\r\n          gridRow: !isHorizontal ? rs.position : 1,\r\n          minWidth: resizerSize + 'px',\r\n          minHeight: resizerSize + 'px',\r\n          maxWidth: isHorizontal ? resizerSize + 'px' : null,\r\n          maxHeight: isHorizontal ? null : resizerSize + 'px'\r\n        }\"\r\n       @mousedown.prevent.stop=\"resizeStart(\\$event, rs)\"\r\n       @touchstart.passive=\"resizeStart(\\$event, rs)\">\r\n    <div bbn-if=\"areCollapsible(rs.panec1, rs.panec2)\"\r\n         class=\"bbn-splitter-collapser\"\r\n         :style=\"{fontSize: (resizerSize * 0.8) + 'px'}\">\r\n      <div bbn-if=\"isCollapsiblePrev(rs.panec1, rs.panec2)\"\r\n           :class=\"{\r\n             'bbn-w-100': isHorizontal,\r\n             'bbn-h-100': !isHorizontal,\r\n             'bbn-c': true\r\n           }\">\r\n        <i :class=\"{\r\n              'bbn-p': true,\r\n              'nf nf-fa-angle_left': isHorizontal,\r\n              'nf nf-fa-angle_up': !isHorizontal\r\n            }\"\r\n            @click.stop=\"collapse(rs.panec1, rs.panec2)\"\r\n        ></i>\r\n      </div>\r\n      <div bbn-if=\"isCollapsibleNext(rs.panec1, rs.panec2)\"\r\n           :class=\"{\r\n             'bbn-w-100': isHorizontal,\r\n             'bbn-h-100': !isHorizontal,\r\n             'bbn-c': true\r\n           }\">\r\n        <i :class=\"{\r\n             'bbn-p': true,\r\n             'nf nf-fa-angle_right': isHorizontal,\r\n             'nf nf-fa-angle_down': !isHorizontal\r\n           }\"\r\n           @click.stop=\"collapse(rs.panec2, rs.panec1)\"\r\n        ></i>\r\n      </div>\r\n      <div bbn-if=\"isFullyCollapsiblePrev(rs.panec1, rs.panec2, i)\"\r\n           :class=\"{\r\n             'bbn-w-100': isHorizontal,\r\n             'bbn-h-100': !isHorizontal,\r\n             'bbn-c': true\r\n           }\">\r\n        <i :class=\"{\r\n             'bbn-p': true,\r\n             'nf nf-fa-angle_double_left': isHorizontal,\r\n             'nf nf-fa-angle_double_up': !isHorizontal\r\n           }\"\r\n           @click.stop=\"collapse(rs.panec1, rs.panec2, true)\"\r\n        ></i>\r\n      </div>\r\n      <div bbn-if=\"isFullyCollapsibleNext(rs.panec1, rs.panec2, i)\"\r\n           :class=\"{\r\n             'bbn-w-100': isHorizontal,\r\n             'bbn-h-100': !isHorizontal,\r\n             'bbn-c': true\r\n           }\">\r\n        <i :class=\"{\r\n             'bbn-p': true,\r\n             'nf nf-fa-angle_double_right': isHorizontal,\r\n             'nf nf-fa-angle_double_down': !isHorizontal\r\n           }\"\r\n           @click.stop=\"collapse(rs.panec2, rs.panec1, true)\"\r\n        ></i>\r\n      </div>\r\n    </div>\r\n  </div-->\r\n</div>`;\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/splitter/splitter.html?");

/***/ }),

/***/ "./src/components/splitter/splitter.less":
/*!***********************************************!*\
  !*** ./src/components/splitter/splitter.less ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_splitter_less__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/less-loader/dist/cjs.js!./splitter.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/splitter/splitter.less\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_splitter_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_splitter_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_splitter_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_splitter_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/splitter/splitter.less?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/components/splitter/_i18n lazy recursive ^\\.\\/splitter\\..*\\.lang$":
/*!**********************************************************************************************!*\
  !*** ./src/components/splitter/_i18n/ lazy ^\.\/splitter\..*\.lang$ strict namespace object ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./splitter.fr.lang\": [\n\t\t\"./src/components/splitter/_i18n/splitter.fr.lang\",\n\t\t\"src_components_splitter__i18n_splitter_fr_lang\"\n\t],\n\t\"./splitter.it.lang\": [\n\t\t\"./src/components/splitter/_i18n/splitter.it.lang\",\n\t\t\"src_components_splitter__i18n_splitter_it_lang\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__.t(id, 1 | 16);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./src/components/splitter/_i18n lazy recursive ^\\\\.\\\\/splitter\\\\..*\\\\.lang$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/splitter/_i18n/_lazy_^\\.\\/splitter\\..*\\.lang$_strict_namespace_object?");

/***/ }),

/***/ "./src/components/splitter/splitter.js":
/*!*********************************************!*\
  !*** ./src/components/splitter/splitter.js ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _splitter_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./splitter.html */ \"./src/components/splitter/splitter.html\");\n/* harmony import */ var _splitter_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./splitter.less */ \"./src/components/splitter/splitter.less\");\n/**\r\n * @file bbn-splitter component\r\n *\r\n * @description bbn-splitter is a component that can interact dynamically, allowing the division of a layout into resizable areas.\r\n * To do so it needs another component, the \"bbn-pane\" that represents the portion of the single area that the splitter contains.\r\n *\r\n * @copyright BBN Solutions\r\n *\r\n * @author BBN Solutions\r\n * \r\n * @created 15/02/2017\r\n */\nconst cpDef = {\n  /**\r\n   * @mixin bbn.cp.mixins.basic \r\n   * @mixin bbn.cp.mixins.resizer\r\n   */\n  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],\n  props: {\n    /**\r\n     * The orientation of the splitter ('horizontal', 'vertical', 'auto').\r\n     * @prop {String} ['auto'] orientation\r\n     */\n    orientation: {\n      type: String,\n      default: 'auto'\n    },\n    /**\r\n     * Set to true allows the splitter to be resizable. \r\n     * @prop {boolean} [false] resizable\r\n     */\n    resizable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n    * Set to true allows the panes inside the splitter to be collapsible. \r\n    * @prop {boolean} [false] collapsible\r\n    */\n    collapsible: {\n      type: Boolean,\n      default: false\n    },\n    // @todo not used\n    scrollable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Defines the size of the resizer element, width if vertical, height if horizontal.\r\n     * @prop {number} [15] resizerSize\r\n     */\n    resizerSize: {\n      type: Number,\n      default: 15\n    },\n    /**\r\n     * A class name to add on the resizer element.\r\n     * @prop {String|Function} resizerClass\r\n     */\n    resizerClass: {\n      type: [String, Function]\n    },\n    /**\r\n     * The minimum size that can have a pane (non collapsed).\r\n     * @prop {Number} [40] minPaneSize\r\n     */\n    minPaneSize: {\n      type: Number,\n      default: 40\n    },\n    fullSize: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data() {\n    return {\n      /**\r\n       * The timeout used to launch the initial process (reset each time a new pane is added).\r\n       * @data {Number} [0] initTimeout\r\n       */\n      initTimeout: 0,\n      /**\r\n       * Will be set to true once the splitter has been resized.\r\n       * @data {Boolean} [false] isResized\r\n       */\n      isResized: false,\n      /**\r\n       * Will be set to true when the splitter is being resized by the user.\r\n       * @data {Boolean} [false] isResizing\r\n       */\n      isResizing: false,\n      /**\r\n       * An object containing info about current user resizing when it occurs.\r\n       * @data {Boolean} [null] resizeCfg\r\n       */\n      resizeCfg: null,\n      /**\r\n       * An array consisting of each resizer objects (the bars separating resizable panes).\r\n       * @data {Array} [[]] resizers\r\n       */\n      resizers: [],\n      /**\r\n       * The content of the prop orientation.\r\n       * @data {String} currentOrientation\r\n       */\n      currentOrientation: this.orientation,\n      /**\r\n       * The configuration of the panes.\r\n       * @data {Array} [[]] panes\r\n       */\n      panes: [],\n      /**\r\n       * @data {Boolean} [false] isInitiating\r\n       */\n      isInitiating: false\n    };\n  },\n  computed: {\n    splitterStyle() {\n      return {\n        gridTemplateColumns: this.columnsCfg,\n        gridTemplateRows: this.rowsCfg\n      };\n    },\n    isHorizontal() {\n      return this.currentOrientation === 'horizontal';\n    },\n    /**\r\n     * Return true if at least 2 panes are resizable - and so is the splitter.\r\n     * @computed isResizable\r\n     * @return {Boolean}\r\n     */\n    isResizable() {\n      return (this.resizable || this.collapsible) && bbn.fn.count(this.panes, {\n        resizable: true\n      }) >= 2;\n    },\n    /**\r\n     * What will be actually in the CSS for grid-template-columns.\r\n     * @computed columnsCfg\r\n     * @return {String}\r\n     */\n    columnsCfg() {\n      return this.panes.length && this.isHorizontal ? this.getFormatted() : '100%';\n    },\n    /**\r\n     * What will be actually in the CSS for grid-template-rows.\r\n     * @computed rowsCfg\r\n     * @return {String}\r\n     */\n    rowsCfg() {\n      return this.panes.length && !this.isHorizontal ? this.getFormatted() : '100%';\n    },\n    /**\r\n     * X or y depending on the current orientation.\r\n     * @computed currentAxis\r\n     * @return {String}\r\n     */\n    currentAxis() {\n      return this.isHorizontal ? 'x' : 'y';\n    },\n    /**\r\n     * Width or height depending on the current orientation.\r\n     * @computed currentSizeType\r\n     * @return {String}\r\n     */\n    currentSizeType() {\n      return this.isHorizontal ? 'Width' : 'Height';\n    },\n    /**\r\n     * Width or height depending on the current orientation.\r\n     * @computed currentOffsetType\r\n     * @return {String}\r\n     */\n    currentOffsetType() {\n      return this.isHorizontal ? 'left' : 'top';\n    },\n    /**\r\n     * Size of the container as given by bbn.\r\n     * @computed currentSize\r\n     * @return {String}\r\n     */\n    currentSize() {\n      return this['lastKnown' + this.currentSizeType];\n    },\n    /**\r\n     * Available for the panes: difference between currentSize (container's size) and the total of resizers' sizes.\r\n     * @computed availableSize\r\n     * @return {bbn-splitter.computed.currentSize}\r\n     */\n    availableSize() {\n      let availableSize = this.currentSize;\n      bbn.fn.each(this.resizers, () => {\n        availableSize -= this.resizerSize;\n      });\n      return availableSize;\n    }\n  },\n  methods: {\n    /**\r\n     * Returns the calculated grid-template-rows or grid-template-columns as CSS string.\r\n     * @method getFormatted\r\n     * @return {String}\r\n     */\n    getFormatted() {\n      /**\r\n       * The position of the panes, starting at 1; gapos will be created for resizers.\r\n       * \r\n       * @type {Number}\r\n       */\n      let pos = 1;\n      let lastVisibleResizer = false;\n      let tmp = this.panes.map(a => {\n        /**\r\n         * The additions of the 3 differences:\r\n         * - currentDiff is the current difference while resizing\r\n         * - savedDiff is the original difference resulting from other resizings\r\n         * - tmpDiff is the temporary difference applied from other(s) collapsed pane(s)\r\n         * @type {number}\r\n         */\n        let diff = a.currentDiff + a.savedDiff + a.tmpDiff;\n        /**\r\n         * The resulting string for the CSS property.\r\n         * @type {string}\r\n         */\n        let sz = '';\n        // If position is not the one expected it means a resizer is before so it's added as a column\n        while (a.position > pos) {\n          lastVisibleResizer = true;\n          pos++;\n        }\n        // If the pane is collapsed we just mark its size at 0\n        if (a.collapsed) {\n          sz += a.title ? 'max-content' : '0';\n        }\n        // If it's a number it will be a sum with the existing diff\n        else {\n          lastVisibleResizer = false;\n          if (a.addedSize && a.addedSize === 'auto') {\n            sz += 'auto';\n          } else if (a.value) {\n            if (a.addedSize || diff) {\n              sz += 'calc( ';\n              sz += a.value + (a.isNumber ? 'px' : a.isPercent ? '%' : '');\n              if (diff) {\n                sz += ' + ' + diff + 'px';\n              }\n              if (a.addedSize) {\n                sz += ' + ' + (typeof a.addedSize === 'number' ? a.addedSize + 'px' : a.addedSize);\n              }\n              sz += ')';\n            } else if (a.value) {\n              sz += a.value + (a.isNumber ? 'px' : a.isPercent ? '%' : '');\n            }\n          } else {\n            sz += 'auto';\n          }\n        }\n        pos++;\n        return sz;\n      });\n      return tmp.join(' ');\n    },\n    /**\r\n     * Returns the resizer's class according to its resizerClass prop.\r\n     * @method realResizerClass\r\n     * @param resizer\r\n     * @return {String}\r\n     */\n    realResizerClass(resizer) {\n      if (bbn.fn.isFunction(this.resizerClass)) {\n        return this.resizerClass(resizer);\n      }\n      return this.resizerClass || '';\n    },\n    /**\r\n     * Returns orientation based on the largest side.\r\n     * @method getOrientation\r\n     * @return {String}\r\n     */\n    getOrientation() {\n      return this.lastKnownWidth > this.lastKnownHeight ? 'horizontal' : 'vertical';\n    },\n    /**\r\n     * Handles the resize of the splitter\r\n     * @method onResize\r\n     * @fires getOrientation\r\n     */\n    onResize() {\n      if (!this.isResizing) {\n        this.isResizing = true;\n        this.setContainerMeasures();\n        this.setResizeMeasures();\n        if (this.orientation === 'auto') {\n          let o = this.getOrientation();\n          if (o !== this.currentOrientation) {\n            this.currentOrientation = o;\n          }\n        }\n\n        /** @todo so far only fuckin way to make it re-render the right dimensions */\n        window.requestAnimationFrame(() => {\n          let w = this.$el.style.width;\n          let h = this.$el.style.height;\n          this.$el.style.width = '100%';\n          this.$el.style.height = '100%';\n          window.requestAnimationFrame(() => {\n            this.$el.style.width = w;\n            this.$el.style.height = h;\n            this.isResizing = false;\n            this.$emit('resize');\n          });\n        });\n      }\n    },\n    /**\r\n     * Is used when collapsed\r\n     * @todo check it out\r\n     * @ignore\r\n     */\n    updatePositions() {\n      /*\r\n      bbn.fn.each(this.panes, (pane, i) => {\r\n        this.$children[pane.index].$el.style.gridColumn = this.currentOrientation === 'horizontal' ? pane.position : 1;\r\n        this.$children[pane.index].$el.style.gridRow = this.currentOrientation === 'vertical' ? pane.position : 1;\r\n      })\r\n      */\n    },\n    /**\r\n     * Gets the next resizable pane.\r\n     * @method getNextResizable\r\n     * @param {Number} idx \r\n     * @param {Array} arr \r\n     * @return {Boolean|Number}\r\n     */\n    getNextResizable(idx, arr) {\n      for (let i = idx + 1; i < arr.length; i++) {\n        if (this.resizable && arr[i].resizable !== false) {\n          return i;\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Gets the previous resizable pane.\r\n     * @method getPrevResizable\r\n     * @param {Number} idx \r\n     * @param {Array} arr \r\n     * @return {Boolean|Number}\r\n     */\n    getPrevResizable(idx, arr) {\n      for (let i = idx - 1; i >= 0; i--) {\n        if (this.resizable && arr[i].resizable !== false) {\n          return i;\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Gets the next collapsible pane.\r\n     * @method getNextCollapsible\r\n     * @param {Number} idx \r\n     * @param {Array} arr \r\n     * @return {Boolean|Number}\r\n     */\n    getNextCollapsible(idx, arr) {\n      for (let i = idx + 1; i < arr.length; i++) {\n        if (this.collapsible && arr[i].collapsible !== false) {\n          return i;\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Gets the previous collassible pane.\r\n     * @method getPrevCollapsible\r\n     * @param {Number} idx \r\n     * @param {Array} arr \r\n     * @return {Boolean|Number}\r\n     */\n    getPrevCollapsible(idx, arr) {\n      for (let i = idx - 1; i >= 0; i--) {\n        if (this.collapsible && arr[i].collapsible !== false) {\n          return i;\n        }\n      }\n      return false;\n    },\n    /**\r\n     * Triggered by the panes being mounted, analyzes the splitter's content in order to define its panes.\r\n     * @method init\r\n     * @fires getPrevResizable\r\n     * @fires getNextResizable\r\n     * @fires getPrevCollapsible\r\n     * @fires getNextCollapsible\r\n     */\n    async init() {\n      // As we want to execute it only once and as it is triggered multiple times (by each pane)\n      // We add a timeout which cancels the previous one so it should be only triggered once at mount\n      clearTimeout(this.initTimeout);\n      this.initTimeout = setTimeout(async () => {\n        // Emptying the panes array if it's filled\n        this.panes.splice(0, this.panes.length);\n        // position starts at 1\n        let currentPosition = 1;\n        let tmp = [];\n        let hasAuto = false;\n        let hasPercent = false;\n        let hasResizers = false;\n        // If 1st pane is collapsible we add a resizer at the start\n        this.$slots.default.forEach((paneEle, i) => {\n          let pane = paneEle.bbn;\n          // Defining the panes base on the content\n          if (pane?.$options?.name === 'bbn-pane') {\n            let isPercent = false;\n            let isFixed = false;\n            let isNumber = false;\n            let props = paneEle.bbnSchema.props;\n            let resizable = (this.resizable || pane.resizable) && props.resizable !== false;\n            let collapsible = (this.collapsible || props.collapsible) && props.collapsible !== false;\n            let value = parseInt(props.size) || 0;\n            if (props.size) {\n              isFixed = true;\n              //bbn.fn.log(\"SPLITTER SIZE\", props.size);\n              if (props.size === 'auto') {\n                props.size = false;\n                hasAuto = true;\n              } else if (typeof props.size === 'string' && bbn.fn.substr(props.size, -1) === '%') {\n                isPercent = true;\n                hasPercent = true;\n              } else if (typeof props.size === 'string' && bbn.fn.substr(props.size, -2) === 'px') {\n                isNumber = true;\n                props.size = parseInt(props.size);\n              } else if (typeof props.size === 'number') {\n                isNumber = true;\n              }\n            } else {\n              hasAuto = true;\n            }\n            let obj = bbn.fn.extend({\n              index: i,\n              value,\n              currentDiff: 0,\n              savedDiff: 0,\n              addedSize: '',\n              tmpDiff: 0,\n              collapsed: false,\n              isPercent,\n              isFixed,\n              isNumber,\n              resizable,\n              collapsible,\n              isResizable: collapsible || resizable,\n              pane: pane\n            }, props);\n            tmp.push(obj);\n          }\n        });\n        /*\r\n        if ( (idx === 0) && pane.collapsible ){\r\n          this.resizers.push({\r\n            position: pos,\r\n            pane1: {\r\n              obj: this.panes[assoc.index],\r\n              cp: this.find('bbn-pane', assoc.index)\r\n            },\r\n            pane2: {\r\n              obj: pane,\r\n              cp: this.find('bbn-pane', i)\r\n            },\r\n          });\r\n          pos++;\r\n        }\r\n        */\n        let isResizable = bbn.fn.count(tmp, {\n          isResizable: true\n        }) >= 2;\n        let hasPanes = tmp.length > 1;\n        // We will populate resizers\n        if (this.resizers.length) {\n          this.resizers.splice(0, this.resizers.length);\n        }\n        bbn.fn.each(tmp, (pane, idx) => {\n          if (pane.hidden) {\n            return;\n          }\n          let prev, next, prevc, nextc;\n          if (hasPanes && isResizable && pane.isResizable) {\n            prev = this.getPrevResizable(idx, tmp);\n            next = this.getNextResizable(idx, tmp);\n            prevc = this.getPrevCollapsible(idx, tmp);\n            nextc = this.getNextCollapsible(idx, tmp);\n            //bbn.fn.log([\"IN SPLITTER\", prev, prevc, next, nextc, '----'])\n            // First collapsible\n            if (prev !== false || prevc !== false) {\n              //bbn.fn.log([\"------ case 2\", idx + ' position ' + currentPosition]);\n              let o = {\n                position: currentPosition,\n                panec1: false,\n                panec2: false,\n                pane1: false,\n                pane2: false\n              };\n              if (this.resizable && pane.resizable !== false && prev !== false) {\n                o.pane1 = prev;\n                o.pane2 = idx;\n                pane.prevResizable = prev;\n                pane.nextResizable = idx;\n              }\n              if (this.collapsible && pane.collapsible !== false && prevc !== false) {\n                o.panec1 = prevc;\n                o.panec2 = idx;\n                pane.prevCollapsible = prevc;\n                pane.nextCollapsible = idx;\n              }\n              this.resizers.push(o);\n              hasResizers = true;\n              currentPosition++;\n            }\n          }\n          pane.position = currentPosition;\n          /*\r\n          if ( pane.size === undefined ){\r\n            pane.isNumber = true;\r\n            pane.size = Math.floor(this.availableSize / tmp.length) + (idx < tmp.length - 1 ? 0 : this.availableSize % tmp.length)\r\n          }\r\n          */\n          this.panes.push(pane);\n          currentPosition++;\n          if (hasPanes && isResizable && pane.isResizable) {\n            // Last collapsible\n            let o = {\n              position: currentPosition,\n              panec1: false,\n              panec2: false,\n              pane1: false,\n              pane2: false\n            };\n            if (prev === false && next && tmp[idx + 1].resizable === false || prevc === false && nextc && tmp[idx + 1].collapsible === false) {\n              //bbn.fn.log(\"------ case 4\", idx + ' position ' + currentPosition);\n              if (this.resizable && pane.resizable !== false && prev === false && next && tmp[idx + 1].resizable === false) {\n                o.pane1 = idx;\n                o.pane2 = next;\n                pane.prevResizable = idx;\n                pane.nextResizable = next;\n              }\n              if (this.collapsible && pane.collapsible !== false && prevc === false && nextc && tmp[idx + 1].collapsible === false) {\n                o.panec1 = idx;\n                o.panec2 = nextc;\n                pane.prevCollapsible = idx;\n                pane.nextCollapsible = nextc;\n              }\n            }\n            if (o.panec2 || o.pane2) {\n              this.resizers.push(o);\n              hasResizers = true;\n              currentPosition++;\n            }\n          }\n        });\n        if (hasPercent && hasResizers && !hasAuto) {\n          throw bbn._('In a resizable splitter, if a pane has a percentage measure, at least one pane must be meausreless or set at \"auto\"');\n        } else {\n          await this.$forceUpdate();\n          this.ready = true;\n          this.selfEmit(true);\n        }\n      }, 200);\n    },\n    /**\r\n     * Return true if one of the two panes given is collassible.\r\n     * @method areCollapsible\r\n     * @param {Number} idxPane1 \r\n     * @param {Number} idxPane2 \r\n     * @return {Boolean}\r\n     */\n    areCollapsible(idxPane1, idxPane2) {\n      return this.collapsible && this.panes[idxPane1] && this.panes[idxPane2] && (this.panes[idxPane1].collapsible !== false || this.panes[idxPane2].collapsible !== false);\n    },\n    /**\r\n     * Returns true if the previous pane is collapsible.\r\n     * @method isCollapsiblePrev\r\n     * @param {Number} idxPane1 \r\n     * @param {Number} idxPane2 \r\n     * @return {Boolean}\r\n     */\n    isCollapsiblePrev(idxPane1, idxPane2) {\n      return this.collapsible && (this.panes[idxPane2].collapsed || !this.panes[idxPane1].collapsed && (idxPane2 === this.panes.length - 1 || !this.panes[idxPane2].collapsed));\n    },\n    /**\r\n     * Returns true if the next pane is collapsible.\r\n     * @method isCollapsibleNext\r\n     * @param {Number} idxPane1 \r\n     * @param {Number} idxPane2 \r\n     * @return {Boolean}\r\n     */\n    isCollapsibleNext(idxPane1, idxPane2) {\n      return this.collapsible && (this.panes[idxPane1].collapsed || !this.panes[idxPane2].collapsed && (idxPane1 === 0 || !this.panes[idxPane2].collapsed));\n    },\n    /**\r\n     * Returns true if teh previous pane is fully collapsible.\r\n     * @method isFullyCollapsiblePrev\r\n     * @param {Number} idxPane1 \r\n     * @param {Number} idxPane2 \r\n     * @param {Number} idxResizer \r\n     * @return {Boolean}\r\n     */\n    isFullyCollapsiblePrev(idxPane1, idxPane2, idxResizer) {\n      return this.collapsible && this.panes[idxPane2].collapsed && (idxPane2 === this.panes.length - 1 && idxResizer === this.resizers.length - 1 || idxPane1 === idxPane2 - 1 || this.panes[idxPane1 + 1].collapsible !== false);\n    },\n    /**\r\n     * Returns true if the next pane is fully collapsible.\r\n     * @method isFullyCollapsibleNext\r\n     * @param {Number} idxPane1 \r\n     * @param {Number} idxPane2 \r\n     * @param {Number} idxResizer \r\n     * @return {Boolean}\r\n     */\n    isFullyCollapsibleNext(idxPane1, idxPane2, idxResizer) {\n      return this.collapsible && this.panes[idxPane1].collapsed && (idxPane1 === 0 && idxResizer === 0 || idxPane1 === idxPane2 - 1 || this.panes[idxPane2 - 1].collapsible !== false);\n    },\n    /**\r\n     * Handles the resize of panes on dragging the resizer\r\n     * @method resizeDrag\r\n     * @param {Event} e \r\n     */\n    resizeDrag(e) {\n      if (this.isResizing && this.resizeCfg && this.resizeCfg.panes) {\n        e.stopImmediatePropagation();\n        let diff = (e['client' + this.currentAxis.toUpperCase()] || (e.touches.length ? e.touches[0] : e.changedTouches[0])['page' + this.currentAxis.toUpperCase()]) - this.resizeCfg[this.currentOffsetType];\n        if (diff >= this.resizeCfg.max) {\n          diff = this.resizeCfg.max;\n        } else if (diff <= this.resizeCfg.min) {\n          diff = this.resizeCfg.min;\n        }\n        this.panes[this.resizeCfg.resizer.pane1].currentDiff = diff;\n        this.panes[this.resizeCfg.resizer.pane2].currentDiff = -diff;\n      }\n    },\n    /**\r\n     * Ends the resize\r\n     * @method resizeEnd\r\n     * @param {Event} e \r\n     */\n    resizeEnd(e) {\n      if (this.isResizing && this.resizeCfg && this.resizeCfg.panes) {\n        let diff = (e['client' + this.currentAxis.toUpperCase()] || (e.touches.length ? e.touches[0] : e.changedTouches[0])['page' + this.currentAxis.toUpperCase()]) - this.resizeCfg[this.currentOffsetType];\n        if (diff >= this.resizeCfg.max) {\n          diff = this.resizeCfg.max;\n        } else if (diff <= this.resizeCfg.min) {\n          diff = this.resizeCfg.min;\n        }\n        this.panes[this.resizeCfg.resizer.pane1].currentDiff = 0;\n        this.panes[this.resizeCfg.resizer.pane2].currentDiff = 0;\n        this.panes[this.resizeCfg.resizer.pane1].savedDiff = this.panes[this.resizeCfg.resizer.pane1].savedDiff + diff;\n        this.panes[this.resizeCfg.resizer.pane2].savedDiff = this.panes[this.resizeCfg.resizer.pane2].savedDiff - diff;\n        this.isResizing = false;\n        document.body.removeEventListener(\"touchmove\", this.resizeDrag);\n        document.body.removeEventListener(\"mousemove\", this.resizeDrag);\n        document.body.removeEventListener(\"touchend\", this.resizeEnd);\n        document.body.removeEventListener(\"touchcancel\", this.resizeEnd);\n        document.body.removeEventListener(\"mouseup\", this.resizeEnd);\n        document.body.removeEventListener(\"mouseleave\", this.resizeEnd);\n        this.panes[this.resizeCfg.resizer.pane1].pane.selfEmit(true);\n        this.panes[this.resizeCfg.resizer.pane2].pane.selfEmit(true);\n        this.resizeCfg = null;\n      }\n    },\n    /**\r\n     * @ignore\r\n     * @todo Remove this function.\r\n     * Obliged to do that because of sliders (closing one with right orientation moves the splitter!)\r\n     */\n    preventScroll() {\n      this.$el.scrollLeft = 0;\n      this.$el.scrollTop = 0;\n    },\n    /**\r\n     * Starts the resize.\r\n     * @param {Event} e \r\n     * @param {Object} rs \r\n     */\n    resizeStart(e, pane) {\n      bbn.fn.log(pane);\n      if (e.target.tagName.toLowerCase() === 'i') {\n        e.target.click();\n        return;\n      }\n      if (this.isResizable && !this.isResizing && pane.prevResizable) {\n        this.isResizing = true;\n        document.body.addEventListener(\"touchmove\", this.resizeDrag, {\n          passive: true\n        });\n        document.body.addEventListener(\"mousemove\", this.resizeDrag, {\n          passive: true\n        });\n        document.body.addEventListener(\"touchend\", this.resizeEnd);\n        document.body.addEventListener(\"touchcancel\", this.resizeEnd);\n        document.body.addEventListener(\"mouseup\", this.resizeEnd);\n        document.body.addEventListener(\"mouseleave\", this.resizeEnd);\n        let vue1 = pane.prevResizable.pane,\n          vue2 = pane,\n          pos = e.target.getBoundingClientRect(),\n          pos1 = vue1.$el.getBoundingClientRect(),\n          pos2 = vue2.$el.getBoundingClientRect();\n        if (!pane.prevResizable.pane.size && !pane.size) {\n          pane.prevResizable.pane.size = this.currentOrientation === 'horizontal' ? pos1.width : pos1.height;\n          pane.size = this.currentOrientation === 'horizontal' ? pos2.width : pos2.height;\n          this.$forceUpdate();\n        }\n        this.resizeCfg = {\n          resizer: pane,\n          panes: [vue1, vue2],\n          min: -pos1[this.currentSizeType.toLowerCase()] + this.minPaneSize,\n          max: pos2[this.currentSizeType.toLowerCase()] - this.minPaneSize - this.resizerSize\n        };\n        this.resizeCfg[this.currentOffsetType] = pos[this.currentOffsetType];\n        //bbn.fn.log(\"START\", this.resizeCfg, e, \"------------\");\n      }\n    },\n    /**\r\n     * Collapses a collapsible pane.\r\n     * @param {Number} toCollapse \r\n     * @param {Number} toUpdate \r\n     * @param {Boolean} full \r\n     */\n    collapse(toCollapse, toUpdate, full) {\n      if (this.collapsible && this.panes[toCollapse] && this.panes[toUpdate]) {\n        let collapsing = !this.panes[toCollapse].collapsed,\n          smaller = collapsing ? toCollapse : toUpdate,\n          bigger = collapsing ? toUpdate : toCollapse,\n          diff1 = this.panes[smaller].savedDiff,\n          diff2 = this.panes[bigger].savedDiff;\n        //bbn.fn.log(toCollapse, toUpdate, smaller, bigger, diff1, diff2);\n        // Not a full collapse (=- double) but with a already collapsed pane\n        if (!full && (this.panes[toCollapse].collapsed || this.panes[toUpdate].collapsed)) {\n          this.panes[smaller].addedSize = '';\n          this.panes[bigger].addedSize = '';\n          this.panes[smaller].tmpDiff = 0;\n          this.panes[bigger].tmpDiff = 0;\n          this.panes[smaller].collapsed = false;\n          this.panes[smaller].pane.isCollapsed = false;\n          this.panes[bigger].collapsed = false;\n          this.panes[bigger].pane.isCollapsed = false;\n        }\n        // The other is also collapsed and the double arrow is clicked: switching\n        else if (full && this.panes[toUpdate].collapsed === collapsing) {\n          this.panes[bigger].tmpDiff = diff1 - this.resizerSize;\n          this.panes[smaller].tmpDiff = 0;\n          if (this.panes[smaller].size) {\n            this.panes[bigger].addedSize = this.panes[smaller].size;\n          }\n          this.panes[bigger].collapsed = false;\n          this.panes[smaller].collapsed = true;\n          this.panes[bigger].pane.isCollapsed = false;\n          this.panes[smaller].pane.isCollapsed = true;\n        } else {\n          if (this.panes[toCollapse].size && this.panes[toUpdate].size) {\n            this.panes[bigger].addedSize = this.panes[smaller].size;\n          } else {\n            this.panes[bigger].addedSize = 'auto';\n          }\n          this.panes[bigger].tmpDiff = diff1 - this.resizerSize;\n          this.panes[smaller].tmpDiff = 0;\n          this.panes[toCollapse].collapsed = collapsing;\n          this.panes[toCollapse].pane.isCollapsed = collapsing;\n        }\n        this.$nextTick(() => {\n          this.selfEmit();\n        });\n      }\n    },\n    //@todo not used\n    hasExpander(paneIdx, resizerIdx) {\n      return false;\n      let pane = this.panes[paneIdx],\n        paneBefore = this.panes[paneIdx + 1];\n      if (this.collapsible && pane.collapsible !== false && paneBefore && paneBefore.collapsible !== false && paneBefore.resizable !== false) {\n        return true;\n      }\n      return false;\n    },\n    expanderClass(paneIdx, resizerIdx) {\n      return '';\n      /*\r\n      let direction = this.panes[paneIdx].collapsed || (resizerIdx === 1) ?\r\n            (this.currentOrientation === 'horizontal' ? 'right' : 'down') :\r\n            (this.currentOrientation === 'horizontal' ? 'left' : 'up'),\r\n          icon = (resizerIdx === 1) && this.panes[paneIdx].collapsed ? 'angle-double-' : 'angle-',\r\n          cls = 'bbn-p nf nf-fa-' + icon + direction;\r\n      return cls;\r\n      */\n    }\n  },\n  /**\r\n   * Defines the current orientation and forces the update of the component.\r\n   * @event mounted \r\n   * @fires getOrientation\r\n   */\n  mounted() {\n    if (this.currentOrientation === 'auto') {\n      this.currentOrientation = this.getOrientation();\n      this.$forceUpdate();\n    }\n  },\n  updated() {\n    //this.onResize();\n  },\n  watch: {\n    /**\r\n     * Reinitializes the component when the value of the prop orientation changes\r\n     * @watch orientation \r\n     * @param {String} newVal \r\n     * @param {String} oldVal \r\n     */\n    orientation(newVal, oldVal) {\n      if (newVal !== oldVal && newVal !== this.currentOrientation) {\n        this.currentOrientation = newVal === 'auto' ? this.getOrientation() : newVal;\n      }\n    },\n    /**\r\n     * Reinitializes the component when the value of currentOrientation changes\r\n     * @watch currentOrientation\r\n     * @fires init\r\n     */\n    currentOrientation() {\n      this.init();\n    }\n  }\n};\n\n\nlet cpLang = {};\nif (bbn.env.lang) {\n  try {\n    const lang = bbn.env.lang || 'en';\n    cpLang = await __webpack_require__(\"./src/components/splitter/_i18n lazy recursive ^\\\\.\\\\/splitter\\\\..*\\\\.lang$\")(`./splitter.${lang}.lang`);\n    if (cpLang.default) {\n      cpLang = cpLang.default;\n    }\n  } catch (err) {}\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'bbn-splitter',\n  definition: cpDef,\n  template: _splitter_html__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  style: _splitter_less__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  lang: cpLang\n});\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/splitter/splitter.js?");

/***/ })

}]);