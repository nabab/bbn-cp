"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/router-_mixins-navigation-js"],{

/***/ "./src/components/router/_mixins/navigation.js":
/*!*****************************************************!*\
  !*** ./src/components/router/_mixins/navigation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  props: {\n    /**\n     * Set it to true if you want to see the navigation bar (tabs, breadcrumb, or visual).\n     * @prop {Boolean} [false] nav\n     */\n    nav: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Routes automatically after mount.\n     * @prop {Boolean} [true] auto\n     */\n    auto: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * The URL on which the router will be initialized.\n     * @prop {String} ['] url\n     */\n    url: {\n      type: String,\n      default: ''\n    },\n    /**\n     * Defines if the container will be automatically loaded based on URLs.\n     * @prop {Boolean} [true] autoload\n     */\n    autoload: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * The root URL of the router, will be only taken into account for the top parents' router, will be automatically calculated for the children.\n     * @prop {String} ['] root\n     */\n    root: {\n      type: String,\n      default: ''\n    },\n    /**\n     * @prop {String} def\n     */\n    def: {\n      type: String\n    },\n    /**\n     * @prop {Boolean} [false] single\n     */\n    single: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @prop {Boolean} [true] urlNavigation\n     */\n    urlNavigation: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Set it to true if you want to send the variable _baseUrl.\n     * @prop {Boolean} [true] postBaseUrl\n     */\n    postBaseUrl: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * The max length of the history.\n     * @prop {Number} [10] historyMaxLength\n     */\n    historyMaxLength: {\n      type: Number,\n      default: 10\n    }\n  },\n  data() {\n    return {\n      /**\n       * IndexedDb connection (Used by containers)\n       * @return {Object} \n       */\n      db: null,\n      /**\n       * The index of the currently selected view.\n       * @data {Number} [null] selected\n       */\n      selected: null,\n      /**\n       * Set to true each time the router is loading (can only load once at a time).\n       * @data {Boolean} [false] isLoading\n       */\n      isLoading: false,\n      /**\n       * This will remain false until the first routing.\n       * @data {Boolean} [false] routed\n       */\n      routed: false,\n      /**\n       * True while the component is in the action of routing.\n       * @data {Boolean} [false] isRouting\n       */\n      isRouting: false,\n      /**\n       * True if one of the initial containers' URL is an empty string.\n       * @data {Boolean} [false] hasEmptyURL\n       */\n      hasEmptyURL: false,\n      /**\n       * The array of containers defined in the source.\n       * @data {Array} cfgViews\n       */\n      cfgViews: [].concat(this.source),\n      /**\n       * The views from the slot.\n       * @data {Array} [[]] slotViews\n       */\n      slotViews: [],\n      /**\n       * All the views.\n       * @data {Array} [[]] views\n      */\n      views: [],\n      /**\n       * All the URLS of the views.\n       * @data {Object} [{}] urls\n       */\n      urls: {},\n      /**\n       * Current URL of the router.\n       * @data {String} currentURL\n       */\n      currentURL: this.url || '',\n      /**\n       * Relative root of the router (set by user or by parent router).\n       * @data {String} baseURL\n       */\n      baseURL: this.formatBaseURL(this.root),\n      /**\n       * The currently visible container.\n       * @data {bbnCp} [null] activeContainer\n       */\n      activeContainer: null,\n      /**\n       * The navigation history.\n       * @data {Array} [[]] history\n       */\n      history: [],\n      /**\n       * The current title of the selected tab\n       * @data {String} [''] routers\n       */\n      currentTitle: '',\n      /**\n      * An array of the parents router.\n      * @data {Array} [[]] parents\n      */\n      parents: [],\n      /**\n      * An object with each mounted children router.\n      * @data {Object} [{}] routers\n      */\n      routers: {},\n      /**\n      * The direct parent router if there is one.\n      * @data {bbnCp} [null] parent\n      */\n      parent: null,\n      /**\n       * The root router or the current one it's the same.\n       * @data {bbnCp} [null] router\n       */\n      router: null,\n      /**\n       * The container having the router in if there is one.\n       * @data {bbnCp} [null] parentContainer\n       */\n      parentContainer: null\n    };\n  },\n  computed: {\n    selectedTab: {\n      get() {\n        return bbn.fn.search(this.tabsList, {\n          idx: this.selected\n        });\n      },\n      set(v) {\n        //bbn.fn.log(\"SETING SELECTED TAB\");\n        let done = false;\n        let i = v;\n        while (i > -1) {\n          if (this.tabsList[i]) {\n            this.selected = this.tabsList[i].idx;\n            done = true;\n            break;\n          }\n          i--;\n        }\n        if (!done) {\n          i = v;\n          while (i < this.tabsList.length) {\n            if (this.tabsList[i]) {\n              this.selected = this.tabsList[i].idx;\n              done = true;\n              break;\n            }\n            i++;\n          }\n        }\n        if (!done) {\n          this.selected = null;\n        }\n      }\n    },\n    /**\n     * Not only the baseURL but a combination of all the parent's baseURLs.\n     * @computed fullBaseURL\n     * @return {String}\n     */\n    fullBaseURL() {\n      let vm = this,\n        base = '',\n        tmp;\n      while (tmp = vm.baseURL) {\n        base = tmp + base;\n        if (!vm.parents.length) {\n          break;\n        }\n        vm = vm.parents[0];\n      }\n      return base;\n    }\n  },\n  methods: {\n    /**\n     * Given a URL returns the existing path of a corresponding view or false, or the default view if forced.\n     * @method getRoute\n     * @param {String} url\n     * @param {Boolean} force\n     * @fires parseURL\n     * @returns {String|false}\n     */\n    getRoute(url, force) {\n      if (!bbn.fn.isString(url)) {\n        throw Error(bbn._('The bbn-container must have a valid URL defined'));\n      }\n      if (!url && this.hasEmptyURL) {\n        return '';\n      }\n      if (!url && !this.parent) {\n        url = this.parseURL(bbn.env.path);\n      }\n      if (!url && force && this.parent) {\n        url = this.parseURL(this.router.getFullCurrentURL());\n      }\n      if (url) {\n        let bits = url.split('/');\n        while (bits.length) {\n          let st = bits.join('/');\n          if (this.urls[st]) {\n            return this.urls[st].disabled ? '' : st;\n          }\n          bits.pop();\n        }\n      }\n      if (this.def && force) {\n        return this.def;\n      }\n      if (this.views.length && force) {\n        return this.views[0].current;\n      }\n      return false;\n    },\n    /**\n    * Formats a baseURL correctly (without 1st slash and with end slash.\n    * @method formatBaseURL\n    * @param {String} baseURL\n    * @returns {String}\n    */\n    formatBaseURL(baseURL) {\n      while (bbn.fn.substr(baseURL, -1) === '/') {\n        baseURL = bbn.fn.substr(baseURL, 0, baseURL.length - 1);\n      }\n      while (bbn.fn.substr(baseURL, 0, 1) === '/') {\n        baseURL = bbn.fn.substr(baseURL, 1);\n      }\n      return baseURL ? baseURL + '/' : '';\n    },\n    /**\n    * Returns the default object for the view.\n    * @method getDefaultView\n    * @return {Object}\n    */\n    getDefaultView() {\n      return {\n        source: null,\n        title: bbn._(\"Untitled\"),\n        options: null,\n        cached: !this.single && this.nav,\n        scrollable: true,\n        component: null,\n        icon: '',\n        notext: false,\n        content: null,\n        menu: [],\n        loaded: null,\n        fcolor: null,\n        bcolor: null,\n        load: false,\n        pane: false,\n        selected: null,\n        css: '',\n        advert: null,\n        dirty: false,\n        help: null,\n        imessages: [],\n        script: null,\n        fixed: false,\n        pinned: false,\n        url: null,\n        current: null,\n        real: false,\n        cfg: {},\n        events: {},\n        real: false,\n        last: 0\n      };\n    },\n    /**\n    * Sends event beforeRoute (cancellable) and launch real routing.\n    * @method route\n    * @param {String} url\n    * @param {Boolean} force\n    * @fires realRoute\n    * @fires getRoute\n    * @fires load\n    * @emit beforeRoute\n    * @returns {void}\n    */\n    async route(url, force) {\n      //bbn.fn.log(\"ROUTING ON \" + url);\n      if (!bbn.fn.isString(url)) {\n        throw Error(bbn._('The component bbn-container must have a valid URL defined (URL is not a string)'));\n      }\n      url = bbn.fn.replaceAll('//', '/', url);\n      /** @var {Boolean} ok Will prevent the route to happen if false */\n      let ok = true;\n\n      // Looking first in the opened panes if splittable\n      if (this.splittable) {\n        bbn.fn.each(this.currentPanes, a => {\n          bbn.fn.each(a.tabs, (v, i) => {\n            if (url.indexOf(v.url) === 0) {\n              /** @var {bbnCp} container The bbn-container component for the given URL if it's in a pane] */\n              let container = this.urls[v.url];\n              if (!container) {\n                ok = false;\n              }\n              if (a.selected !== i) {\n                a.selected = i;\n                ok = false;\n              }\n              if (v.current !== url) {\n                v.current = url;\n                if (container) {\n                  container.setCurrent(url);\n                }\n              }\n              return false;\n            }\n          });\n          if (!ok) {\n            return false;\n          }\n        });\n      }\n      if (ok && this.ready && (force || !this.activeContainer || url !== this.currentURL)) {\n        let event = new CustomEvent(\"beforeroute\", {\n          bubbles: false,\n          cancelable: true\n        });\n        this.$emit(\"beforeroute\", event, url);\n        if (!event.defaultPrevented) {\n          let bits = url.split('#');\n          url = bits[0];\n          if (url === '' && this.hasEmptyURL) {\n            this.urls[''].setCurrent(url);\n            await this.realRoute('', '', force);\n            return;\n          }\n          // Checks weather the container is already there\n          if (!url) {\n            let idx = this.getRoute('', true);\n            if (idx && this.urls[idx]) {\n              url = this.urls[idx].currentURL;\n            }\n          }\n          let st = url ? this.getRoute(url) : '';\n          /** @todo There is asomething to do here */\n          //bbn.fn.log(\"ROUTING EXECUTING FOR \" + url + \" (CORRESPONDING TO \" + st + \")\");\n          if (!url || !force && this.currentURL === url) {\n            if (bits[1]) {}\n            //bbn.fn.log(\"SAME URL END ROUTING\");\n            return;\n          } else if (url && (!st && this.autoload || this.urls[st] && this.urls[st].load && !this.urls[st].isLoaded)) {\n            this.load(url);\n          }\n          // Otherwise the container is activated ie made visible\n          else {\n            //bbn.fn.log(\"LOADED \" + url);\n            if (!st && this.def && (!url || force)) {\n              st = this.getRoute(this.def);\n              if (st) {\n                url = this.def;\n              }\n            }\n            if (!st && force && this.views.length) {\n              st = this.views[0].url;\n              if (st) {\n                url = this.urls[st] ? this.urls[st].currentURL : st;\n              }\n            }\n            if (st) {\n              if (this.urls[st]) {\n                this.urls[st].setCurrent(url);\n              }\n              await this.realRoute(url, st, force, bits[1]);\n            }\n          }\n        }\n      }\n    },\n    /**\n    * Routes the router.\n    * @method realRoute\n    * @param {String} url The URL to route to\n    * @param {String} st The URL/key of the container on which we will route\n    * @param {Boolean} force\n    * @fires activate\n    * @emit route1\n    */\n    async realRoute(url, st, force, anchor) {\n      if (!bbn.fn.isString(url) && !bbn.fn.isNumber(url)) {\n        throw Error(bbn._('The component bbn-container must have a valid URL defined (URL given to route is not a string)'));\n      }\n      if (this.urls[st]) {\n        //bbn.fn.log(\"REAL ROUTING GOING ON FOR \" + url);\n        if (!this.urls[st].isPane && url !== this.currentURL) {\n          //bbn.fn.log(\"THE URL IS DIFFERENT FROM THE ORIGINAL \" + this.currentURL);\n          this.currentURL = url;\n        }\n        // First routing, triggered only once\n        if (this.urls[st].currentView.pane) {\n          let pane = bbn.fn.getRow(this.currentPanes, {\n            id: this.urls[st].currentView.pane\n          });\n          if (pane && pane.tabs) {\n            let idx = bbn.fn.search(pane.tabs, {\n              url: st\n            });\n            /*\n            if (pane.tabs[idx] && (pane.selected === idx)) {\n              this.activate(url, this.urls[st]);\n            }\n            */\n            if (pane.tabs[idx]) {\n              this.activate(url, this.urls[st]);\n            }\n          }\n        } else {\n          if (!this.routed) {\n            this.routed = true;\n            this.$emit(\"route1\", this);\n            this.$nextTick(this.onResize);\n          }\n          await this.activate(url, this.urls[st]);\n        }\n        if (this.urls[st] && this.urls[st].isLoaded) {\n          this.urls[st].currentURL = url;\n          let child = this.urls[st].find('bbn-router');\n          //bbn.fn.log(\"LOOKING FOR CHILD\", child);\n          if (child) {\n            child.route(bbn.fn.substr(url, st.length + 1), force);\n          } else {\n            let ifr = this.urls[st].find('bbn-frame');\n            if (ifr) {\n              ifr.route(bbn.fn.substr(url, st.length + 1));\n            }\n          }\n        }\n      }\n    },\n    /**\n    * Routes to the next view if any.\n    * @method next\n    * @fires activateIndex\n    */\n    next(force) {\n      let next = this.selected + 1;\n      if (!this.views[next] && force) {\n        next = 0;\n      }\n      if (this.views[next]) {\n        this.activateIndex(next);\n      }\n    },\n    /**\n    * Routes to the previous view if any.\n    * @method prev\n    * @fires activateIndex\n    */\n    prev(force) {\n      let prev = this.selected - 1;\n      if (!this.views[prev] && force) {\n        prev = this.views.length - 1;\n      }\n      if (this.views[prev]) {\n        this.activateIndex(prev);\n      }\n    },\n    /**\n    * Shows the container with the corresponding URL and hide all others.\n    * @method activate\n    * @param url\n    * @param container\n    */\n    activate(url, container) {\n      if (!bbn.fn.isString(url)) {\n        throw Error(bbn._('The component bbn-container must have a valid URL defined (activate)'));\n      }\n      if (!container) {\n        let row = bbn.fn.getRow(this.views, {\n          current: url\n        });\n        if (!row) {\n          row = bbn.fn.getRow(this.views, {\n            url: url\n          });\n        }\n        if (!row) {\n          throw new Error(bbn._(\"Impossible to find a container for the URL %s\", url));\n        }\n        if (!this.urls[row.url]) {\n          throw new Error(bbn._(\"The container for the URL %s is not registered\", row.url));\n        }\n        container = this.urls[row.url];\n      }\n\n      //bbn.fn.log(\"ACTIVATING \" + url + \" AND SENDING FOLLOWING CONTAINER:\", container);\n      if (this.selected !== container.currentIndex) {\n        this.$emit('activate', url);\n        container.setCurrent(url);\n        if (!container.isPane) {\n          this.activeContainer = container;\n        }\n        container.show();\n        // Scrolling tabs\n        if (this.scrollable && this.nav && !this.breadcrumb && !this.isVisual) {\n          let scroll = this.getRef('horizontal-scroll');\n          let tab = this.getRef('tab-' + container.currentIndex);\n          if (scroll?.ready) {\n            scroll.scrollTo(tab);\n          } else if (scroll) {\n            scroll.$on('ready', sc => {\n              setTimeout(() => {\n                sc.scrollTo(this.getRef('tab-' + container.currentIndex));\n              }, 100);\n            });\n          }\n        }\n      } else if (url !== container.currentURL) {\n        if (container.routers) {\n          let rt;\n          bbn.fn.iterate(container.routers, (r, n) => {\n            if (!rt) {\n              rt = r;\n            }\n            if (url.indexOf(r.baseURL) === 0) {\n              rt = r;\n              return false;\n            }\n          });\n          if (rt) {\n            rt.route(url.indexOf(rt.baseURL) === 0 ? bbn.fn.substr(url, rt.baseURL.length) : '');\n          }\n        } else {\n          this.activeContainer.setCurrent(url);\n        }\n      }\n      //bbn.fn.log(\"ACTIVATED \" + url + \" AND ACTIVATED CONTAINER BELOW:\", this.activeContainer);\n    },\n    /**\n    * @method changeURL\n    * @param {String} url\n    * @param {String} title\n    * @param {Boolean} replace\n    * @fires getFullBaseURL\n    */\n    changeURL(url, title, replace) {\n      if (!bbn.fn.isString(url)) {\n        throw Error(bbn._('The component bbn-container must have a valid URL defined (change URL)'));\n      }\n      if (!bbn.env.isInit) {\n        return;\n      }\n      if (title && title !== this.currentTitle) {\n        this.currentTitle = title;\n      }\n      if (url !== this.currentURL) {\n        this.currentURL = url;\n        // Will fire again\n        return;\n      }\n\n      /*\n      bbn.fn.log([\n        \"changeURL\",\n        url,\n        title,\n        this,\n        this.parentContainer ? \n          [\"FROM PQARENT\", this.parentContainer.currentTitle, this.parentContainer.title]\n          : this.currentTitle\n      ]);\n      */\n      // Changing the current property of the view cascades on the container's currentURL\n      if (this.views[this.selected] && (url.indexOf(this.views[this.selected].url + '/') === 0 || url === this.views[this.selected].url)) {\n        this.$set(this.views[this.selected], 'current', url);\n      }\n      if (this.urlNavigation) {\n        if (this.parentContainer) {\n          //this.parentContainer.currentTitle = title + ' < ' + this.parentContainer.title;\n          if (!this.parentContainer.isPane) {\n            this.parent.currentURL = this.baseURL + url;\n          } else {\n            this.parentContainer.currentView.current = this.baseURL + url;\n          }\n        } else if (replace || url !== bbn.env.path) {\n          if (!replace) {\n            //bbn.fn.log(\"NO REPLAACE\", this.getFullBaseURL() + url, bbn.env.path);\n          }\n          if (!replace && (this.getFullBaseURL() + url).indexOf(bbn.env.path) === 0) {\n            //bbn.fn.log(\"REPLACING\");\n            replace = true;\n          }\n          bbn.fn.setNavigationVars(this.getFullBaseURL() + url, this.currentTitle, {}, replace);\n        }\n      }\n    },\n    /**\n    * Returns the baseURL property.\n    * @method getBaseURL\n    * @returns {String}\n    */\n    getBaseURL() {\n      return this.baseURL;\n    },\n    /**\n    * Returns a string of all the baseURL properties till root.\n    * @method getFullBaseURL\n    * @returns {String}\n    */\n    getFullBaseURL() {\n      return this.fullBaseURL;\n    },\n    /**\n    * Returns the full URL from the root router (without the hostname).\n    * @method getFullURL\n    * @fires getFullBaseURL\n    * @returns {String}\n    */\n    getFullURL() {\n      let url = this.getURL();\n      if (url !== false) {\n        return this.getFullBaseURL() + url;\n      }\n      return '';\n    },\n    /**\n    * Returns the current URL of the current router.\n    * @method getCurrentURL\n    * @returns {String}\n    */\n    getCurrentURL() {\n      return this.currentURL;\n    },\n    /**\n    * Returns the full current URL from the root router (without the hostname).\n    * @method getFullCurrentURL\n    * @fires getCurrentURL\n    * @fires getFullBaseURL\n    * @returns {String|Boolean}\n    */\n    getFullCurrentURL() {\n      let url = this.getCurrentURL();\n      if (url !== false) {\n        return this.getFullBaseURL() + url;\n      }\n      return false;\n    },\n    /**\n    * Returns the url relative to the current tabNav from the given url.\n    * @method parseURL\n    * @param fullURL\n    * @returns {String}\n    */\n    parseURL(fullURL) {\n      if (fullURL === undefined) {\n        return '';\n      }\n      if (!bbn.fn.isString(fullURL)) {\n        fullURL = fullURL.toString();\n      }\n      if (fullURL.indexOf(bbn.env.root) === 0) {\n        fullURL = bbn.fn.substr(fullURL, bbn.env.root.length);\n      }\n      fullURL = bbn.fn.removeTrailingChars(fullURL, '/');\n      if (this.fullBaseURL === fullURL + '/') {\n        return '';\n      }\n      if (this.fullBaseURL) {\n        if (fullURL.indexOf(this.fullBaseURL) === 0) {\n          fullURL = bbn.fn.substr(fullURL, this.fullBaseURL.length);\n        } else {\n          fullURL = '';\n        }\n      }\n      return fullURL;\n    },\n    /**\n    * @method isValidIndex\n    * @return {Boolean}\n    */\n    isValidIndex(idx) {\n      return typeof idx === 'number' && this.views[idx] !== undefined;\n    },\n    /**\n    * Activates the default view, or the first one if no default.\n    * @method activateDefault\n    * @fires getIndex\n    * @fires isValidIndex\n    * @fires activate\n    */\n    activateDefault() {\n      let idx = this.getIndex('', true);\n      if (this.isValidIndex(idx)) {\n        this.activate(this.views[idx].current ? this.views[idx].current : this.views[idx].url);\n      }\n    },\n    /**\n    * @method activateIndex\n    * @param {Number} idx\n    * @fires isValidIndex\n    * @fires route\n    */\n    activateIndex(idx) {\n      if (this.isValidIndex(idx)) {\n        this.route(this.urls[this.views[idx].url] ? this.urls[this.views[idx].url].currentURL : this.views[idx].current);\n      }\n    },\n    /**\n    * @method callRouter\n    * @param {String} url\n    * @param st\n    * @fires getFullBaseURL\n    * @fires realRoute\n    */\n    async callRouter(url, st) {\n      if (!bbn.fn.isString(url)) {\n        throw Error(bbn._('The component bbn-container must have a valid URL defined (from callRouter)'));\n      }\n      if (this.parent) {\n        let containers = this.ancestors('bbn-container');\n        url = bbn.fn.substr(this.getFullBaseURL(), this.router.baseURL.length) + url;\n        //bbn.fn.log(\"CALL ROOT ROUTER WITH URL \" + url);\n        // The URL of the last bbn-container as index of the root router\n        await this.router.realRoute(url, containers[containers.length - 1].url, true);\n      } else {\n        await this.realRoute(url, st, true);\n      }\n    },\n    navigationInit() {\n      // All routers above (which constitute the fullBaseURL)\n      this.parents = this.ancestors('bbn-router');\n      // The closest\n      this.parent = this.parents.length ? this.parents[0] : false;\n      // The root\n      this.router = this.parents.length ? this.parents[this.parents.length - 1] : this;\n      // Case where the rooter is not at the root level\n\n      if (this.parent) {\n        this.parentContainer = this.closest('bbn-container');\n        let uri = this.parentContainer.url;\n        if (this.root && uri !== this.root && this.root.indexOf(uri) === 0) {\n          uri = this.root;\n        }\n        this.baseURL = this.formatBaseURL(uri);\n      }\n      // Case where the rooter is at root level\n      else {\n        // Opening the database for the visual mode multiview\n        if (!this.single && bbnRouterCp.db) {\n          bbn.db.open('bbn').then(r => {\n            this.db = r;\n          }, err => {\n            bbn.fn.log(\"Connection error in router\", err);\n          });\n        }\n        window.addEventListener(\"beforeunload\", e => {\n          e = e || window.event;\n          //if ( $(\".bbn-tabnabbn-unsaved\").length ){\n          if (this.isDirty) {\n            // doesn't use that string but a default string...\n            let st = bbn._('You have unsaved data, are you sure you want to leave?');\n            // For IE and Firefox prior to version 4\n            if (e) {\n              e.returnValue = st;\n            }\n            // For Safari\n            return st;\n          }\n        });\n      }\n    },\n    navigationCreated() {\n      /**\n       * @event route\n       * @fires setconfig\n       */\n      this.$on('route', url => {\n        if (this.nav) {\n          this.setConfig();\n          let i = this.history.indexOf(url);\n          if (i > -1) {\n            this.history.splice(i, 1);\n          }\n          this.history.unshift(url);\n          while (this.history.length > this.historyMaxLength) {\n            this.history.pop();\n          }\n        }\n      });\n    }\n  },\n  watch: {\n    currentTitle(v) {\n      if (!this.parent) {\n        document.title = v + ' - ' + bbn.env.siteTitle;\n      }\n    },\n    selected(idx) {\n      if (this.views[idx]) {\n        //bbn.fn.log(\"In selected watcher \" + idx, bbn.fn.filter(this.views, {selected: true}));\n        bbn.fn.map(bbn.fn.filter(this.views, {\n          selected: true\n        }), a => {\n          if (a.idx !== idx) {\n            a.selected = false;\n            if (this.urls[a.url]) {\n              this.urls[a.url].$tick();\n            }\n          }\n        });\n        if (!this.views[idx].selected && !this.views[idx].pane) {\n          this.views[idx].selected = true;\n        }\n        this.views[idx].last = bbn.fn.timestamp();\n        if (this.currentURL !== this.views[idx].current) {\n          //bbn.fn.log(\"CHANGING URL \" + this.currentURL + \" TO \" + this.views[idx].current);\n          this.route(this.views[idx].current);\n        }\n      } else {\n        throw new Error(\"The view with index \" + idx + \" doesn't exist\");\n      }\n    },\n    /**\n     * @watch currentURL\n     * @fires changeURL\n     * @fires search\n     * @emit change\n     * @emit route\n     */\n    currentURL(newVal, oldVal) {\n      if (this.ready) {\n        let idx = this.search(newVal);\n        if (idx !== false) {\n          let v = this.views[idx];\n          let ct = this.urls[v.url];\n          if (!v.pane) {\n            this.selected = idx;\n            if (ct) {\n              this.changeURL(newVal, ct.title);\n            } else if (this.isLoading) {\n              this.changeURL(newVal, bbn._(\"Loading\"));\n            }\n          }\n        }\n        this.$emit('change', newVal);\n        this.$emit('route', newVal);\n      }\n    },\n    /**\n     * @watch url\n     * @fires route\n     */\n    url(newVal) {\n      if (this.ready && newVal && newVal !== this.currentURL) {\n        //bbn.fn.log(\"URL CHANGED FROM WATCHER TO \" + newVal);\n        this.route(newVal);\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/router/_mixins/navigation.js?");

/***/ })

}]);