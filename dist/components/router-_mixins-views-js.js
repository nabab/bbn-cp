"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/router-_mixins-views-js"],{

/***/ "./src/components/router/_mixins/views.js":
/*!************************************************!*\
  !*** ./src/components/router/_mixins/views.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  props: {\n    /**\n     * The views shown at init.\n     * @prop {Array} [[]] source\n     */\n    source: {\n      type: Array,\n      default() {\n        return [];\n      }\n    },\n    maxTotal: {\n      type: Number,\n      default: 25\n    },\n    /**\n     * Decides if real bbn-container are shown before or after the ones in the config or fake container 9bbns-container)\n     * @prop {String} ['real] first\n     */\n    first: {\n      type: String,\n      default: 'real'\n    },\n    /**\n     * Will be passed to router in order to ignore the dirty parameter.\n     * @prop {Boolean} ignoreDirty\n     */\n    ignoreDirty: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data() {\n    return {\n      /**\n       * The list of the dirty containers.\n       * @data {Array} [[]] dirtyContainers\n       */\n      dirtyContainers: []\n    };\n  },\n  computed: {\n    /**\n     * Returns true if there are any unsaved views.\n     * @computed isDirty\n     * @return {Boolean}\n     */\n    isDirty() {\n      return !!this.dirtyContainers.length;\n    },\n    /**\n     * The views to show in the tabs, without the ones in the pane if splittable\n     * @computed tabsList\n     * @return {Array} \n     */\n    tabsList() {\n      return bbn.fn.multiorder(this.splittable ? bbn.fn.filter(this.views, a => !a.pane) : this.views, {\n        fixed: 'desc',\n        pinned: 'desc',\n        idx: 'asc'\n      });\n    }\n  },\n  methods: {\n    /**\n     * Sets the 'dirtyContainers' property with the list of unsaved views\n     * @method retrieveDirtyContainers\n     */\n    retrieveDirtyContainers() {\n      this.dirtyContainers.splice(0, this.dirtyContainers.length);\n      bbn.fn.iterate(this.urls, v => {\n        if (v.dirty) {\n          this.dirtyContainers.push({\n            idx: v.currentIndex,\n            url: v.url\n          });\n        }\n      });\n    },\n    async viewsInit() {\n      let storage = !this.single && this.getStorage(this.parentContainer ? this.parentContainer.getFullURL() : this.storageName);\n      let tmp = [];\n      // ---- ADDED 16/12/20 (Mirko) ----\n      // Adding bbns-container from the slot\n      if (this.$slots.default) {\n        for (let item of this.$slots.default) {\n          let node = item.bbnSchema;\n          //bbn.fn.log(\"ROUTER SLOT\", node, '-------------');\n\n          if (!node.comment && ['bbn-container', 'bbns-container'].includes(node?.tag)) {\n            if (node.props.url === undefined) {\n              throw new Error(bbn._(\"You cannot use containers in router without defining a URL property\"));\n            }\n            if (!this.hasRealContainers) {\n              this.hasRealContainers = true;\n            }\n            if (node.props.url === '') {\n              this.hasEmptyURL = true;\n            }\n            const obj = bbn.fn.createObject(bbn.fn.extend(true, {}, node.props));\n            bbn.fn.iterate(this.getDefaultView(), (a, n) => {\n              if (obj[n] === undefined) {\n                obj[n] = a;\n              }\n            });\n            if (node.tag === 'bbn-container') {\n              obj.real = true;\n            }\n            //let o = {real: true, load: false, loaded: true};\n            //tmp.push(bbn.fn.extend({}, node.componentOptions.propsData, o));\n            tmp.push(obj);\n          }\n        }\n      }\n      // ---- END ----\n\n      bbn.fn.each(this.source, (a, i) => {\n        if (a.url === '') {\n          if (a.load) {\n            throw new Error(bbn._(\"You cannot use containers with empty URL for loading\"));\n          }\n          this.hasEmptyURL = true;\n        }\n        tmp.push(bbn.fn.extendOut(a, {\n          real: false\n        }));\n      });\n\n      //Get config from the storage\n      if (storage && storage.views && tmp) {\n        bbn.fn.each(storage.views, a => {\n          let idx = bbn.fn.search(tmp, {\n            url: a.url\n          });\n          if (idx > -1) {\n            // Static comes only from configuration\n            let isFixed = tmp[idx].fixed;\n            bbn.fn.extend(tmp[idx], a, {\n              fixed: isFixed\n            });\n          } else {\n            tmp.push(a);\n          }\n        });\n      }\n      if (this.first !== 'real') {\n        tmp = bbn.fn.multiorder(tmp, {\n          real: 'desc'\n        });\n      }\n\n      // Getting the default URL\n      let url = this.getDefaultURL();\n\n      // Adding to the views\n      //bbn.fn.warning(\"ROUTER BEFORE MOUNT\");\n      bbn.fn.each(tmp, a => {\n        if (!bbn.fn.isString(a.url)) {\n          throw new Error(bbn._(\"The container must have a valid URL\"));\n        }\n\n        // Setting current if URL starts with default URL\n        if (url && url.indexOf(a.url) === 0) {\n          a.current = url;\n        }\n\n        //bbn.fn.warning(\"ADDING BEFORE MOUNT\");\n        //bbn.fn.log(a);\n        this.add(a);\n      });\n      this.ready = true;\n      await this.$forceUpdate();\n      if (this.$slots.default) {\n        for (let item of this.$slots.default) {\n          if (item.bbnSchema?.tag === 'bbn-container') {\n            let el = this.$refsElements['ct-' + item.bbnSchema.props.url];\n            if (el) {\n              el.parentNode.replaceChild(item, el);\n            }\n          }\n        }\n      }\n      if (!this.views.length) {\n        this.init(url);\n      }\n    },\n    /**\n     * Removes an element from the views\n     * \n     * @method remove\n     * @param {*} misc Index, URL or element\n     * @param {Boolean} noCfg If set to true will not trigger the storage saving\n     * @fires getIndex\n     * @fires remove\n     * @emit close\n     * @return {Boolean}\n     */\n    async remove(misc, force) {\n      let idx = this.getIndex(misc);\n      if (idx > -1) {\n        /** @var {Event} onBeforeClose beforeClose event, cancelable only if not force */\n        let onBeforeClose = new Event('beforeClose', {\n          cancelable: !force\n        });\n        /** @var {Event} onClose close event, cancelable only if not force */\n        let onClose = new Event('close');\n        this.$emit('beforeClose', idx, onBeforeClose);\n        //bbn.fn.log(\"REMOVING \" + this.views[idx].url)\n        if (force || !onBeforeClose.defaultPrevented) {\n          if (!force && !this.ignoreDirty && this.isDirty && this.views[idx].dirty) {\n            this.confirm(this.confirmLeave, () => {\n              // Looking for dirty ones in registered forms of each container\n              let forms = this.urls[this.views[idx].url].forms;\n              if (Array.isArray(forms) && forms.length) {\n                bbn.fn.each(forms, (f, k) => {\n                  f.reset();\n                });\n              }\n              return this.close(idx, true);\n            });\n          } else if (this.views[idx] && !this.views[idx].real) {\n            bbn.fn.log([\"ERMOVE FROM ROUTER \" + idx, force]);\n            this.$emit('close', idx, onClose);\n            this.views.splice(idx, 1);\n            bbn.fn.log([\"ERMOVE FROM ROUTER \" + idx, bbn.fn.numProperties(this.urls), this.views.length]);\n            this.fixIndexes();\n            await this.$forceUpdate();\n            await this.$nextTick();\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    /**\n     * Adds an object with a valid url to the views.\n     * @method add\n     * @param {Object} obj\n     * @param {Number} idx\n     * @fires getFullBaseURL\n     * @fires search\n     * @fires isValidIndex\n     * @fires getDefaultView\n     */\n    async add(obj, idx) {\n      let index;\n      //obj must be an object with property url\n      if (bbn.fn.isObject(obj) && bbn.fn.isString(obj.url)) {\n        obj.url = bbn.fn.replaceAll('//', '/', obj.url);\n        // This is a component\n        if (obj.$options) {\n          if (!obj.current && !obj.currentURL) {\n            if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj.url ? obj.url + '/' : '')) === 0) {\n              obj.currentURL = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);\n            } else {\n              obj.currentURL = obj.url;\n            }\n          }\n          /*\n          else {\n            if (obj.currentURL) {\n              obj.currentURL = bbn.fn.replaceAll(obj.currentURL);\n            }\n          }\n          */\n          let obj2 = bbn.fn.extend(true, {}, obj.$options.propsData),\n            props = obj.$options.props;\n          bbn.fn.iterate(props, (v, i) => {\n            if (!(i in obj2) && 'default' in v) {\n              obj2[i] = v.default;\n            }\n          });\n          bbn.fn.iterate(this.getDefaultView(), (a, n) => {\n            if (obj2[n] === undefined) {\n              obj2[n] = a;\n            }\n          });\n          obj2.real = true;\n\n          // ---- ADDED 16/12/20 (Mirko) ----\n          if (!obj2.current) {\n            if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj2.url ? obj2.url + '/' : '')) === 0) {\n              obj2.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);\n            } else {\n              obj2.current = obj2.url;\n            }\n          } else if (obj2.current !== obj2.url && obj2.current.indexOf(obj2.url + '/') !== 0) {\n            obj2.current = obj2.url;\n          }\n          if (!obj2.current) {\n            obj2.current = obj2.url;\n          }\n          if (obj2.content) {\n            obj2.loaded = true;\n          }\n          // ---- END ----\n\n          if (obj2.real && !this.hasRealContainers) {\n            this.hasRealContainers = true;\n          }\n          if (obj2.url === '') {\n            this.hasEmptyURL = true;\n          }\n          if (this.search(obj2.url) === false) {\n            if (this.isValidIndex(idx)) {\n              this.views.splice(idx, 0, obj2);\n            } else if (this.hasRealContainers && this.first !== 'real' && !obj2.real) {\n              idx = bbn.fn.search(this.views, {\n                real: true\n              });\n              this.views.splice(idx, 0, obj2);\n            } else {\n              this.views.push(obj2);\n            }\n          }\n        } else {\n          if (!obj.current) {\n            if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj.url ? obj.url + '/' : '')) === 0) {\n              obj.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);\n            } else {\n              obj.current = obj.url;\n            }\n          } else if (obj.current !== obj.url && obj.current.indexOf(obj.url + '/') !== 0) {\n            obj.current = obj.url;\n          }\n          if (!obj.current) {\n            obj.current = obj.url;\n          }\n          if (obj.content) {\n            obj.loaded = true;\n          }\n          obj.events = {};\n          if (obj.menu === undefined) {\n            obj.menu = [];\n          }\n          index = this.search(obj.url);\n          if (index !== false) {\n            let o = this.views[index],\n              cn = this.urls[this.views[index].url];\n            if (idx === undefined) {\n              idx = index;\n            }\n            if (cn && this.isValidIndex(idx)) {\n              cn.currentIndex = idx;\n            }\n            if (obj.real) {\n              return;\n            }\n            bbn.fn.iterate(obj, (a, n) => {\n              if (o[n] !== a) {\n                // Each new property must be set with $set\n                this.$set(o, n, a);\n              }\n            });\n          } else {\n            let isValid = this.isValidIndex(idx);\n            obj.selected = false;\n            obj.idx = isValid ? idx : this.views.length;\n            bbn.fn.iterate(this.getDefaultView(), (a, n) => {\n              if (obj[n] === undefined) {\n                // Each new property must be set with $set\n                this.$set(obj, n, a);\n              }\n            });\n            obj.uid = obj.url + '-' + bbn.fn.randomString();\n            if (this.single && this.views.length) {\n              await this.remove(0, true);\n              obj.idx = 0;\n              isValid = false;\n            }\n            if (isValid) {\n              this.views.splice(obj.idx, 0, obj);\n            } else if (this.hasRealContainers && this.first !== 'real' && !obj.real) {\n              idx = bbn.fn.search(this.views, {\n                real: true\n              });\n              this.views.splice(idx, 0, obj);\n            } else {\n              this.views.push(obj);\n            }\n          }\n        }\n        this.fixIndexes();\n      }\n    },\n    /**\n    * Moves a container within the router, changes its idx.\n    * \n    * @method move\n    * @param {Number} from The index of the container to move\n    * @param {Number} to   The index to which the container must go\n    * @returns \n    */\n    move(from, to) {\n      if (!bbn.fn.isNumber(from, to) || from === to || !this.views[from] || !this.views[to]) {\n        return;\n      }\n      bbn.fn.move(this.views, from, to);\n      let selectedOk = false;\n      if (from === this.selected) {\n        this.selected = to;\n        selectedOk = true;\n      }\n      for (let i = Math.min(from, to); i <= Math.max(from, to); i++) {\n        if (this.views[i].idx !== i) {\n          if (!selectedOk && this.selected === this.views[i].idx) {\n            this.selected = i;\n          }\n          this.views[i].idx = i;\n        }\n      }\n      this.setConfig();\n    },\n    /**\n    * @method close\n    * @param {Number}  idx   The index of the container to close\n    * @param {Boolean} force Will close the container without prevention\n    * @param {Boolean} noCfg If set to true will not trigger the storage saving\n    * @fires remove\n    * @fires getIndex\n    * @fires activateIndex\n    * @fires setConfig\n    * @return {Boolean}\n    */\n    close(idx, force, noCfg) {\n      bbn.fn.log(\"CLOSING CT\");\n      let res = this.remove(idx, force);\n      if (res) {\n        if (this.selected > idx) {\n          this.selected--;\n        } else if (idx === this.selected) {\n          this.selectClosest(idx);\n        }\n        if (!noCfg) {\n          this.setConfig();\n        }\n      }\n      return res;\n    },\n    /**\n    * @method closeAll\n    * @fires close\n    */\n    closeAll(force) {\n      for (let i = this.views.length - 1; i >= 0; i--) {\n        if (!this.views[i].fixed && !this.views[i].pinned) {\n          this.close(i, force, true);\n        }\n      }\n      this.setConfig();\n    },\n    /**\n    * @method closeallBut\n    * @param {Number} idx\n    * @fires close\n    */\n    closeAllBut(idx, force) {\n      for (let i = this.views.length - 1; i >= 0; i--) {\n        if (!this.views[i].fixed && !this.views[i].pinned && i !== idx) {\n          this.close(i, force, true);\n        }\n      }\n      this.setConfig();\n    },\n    closeTab(idx) {\n      this.close(this.tabsList[idx].idx);\n    },\n    /**\n    * @method pin\n    * @param {Number} idx\n    * @fires isValidIndex\n    * @fires setConfig\n    * @emit beforePin\n    * @emit pin\n    */\n    pin(idx) {\n      if (this.isValidIndex(idx)) {\n        let ev = new CustomEvent('beforePin', {\n          cancelable: true\n        });\n        this.$emit('beforePin', idx, ev);\n        if (!ev.defaultPrevented) {\n          this.views[idx].pinned = true;\n          this.setConfig();\n          this.$emit('pin', idx);\n        }\n      }\n    },\n    /**\n    * @method unpin\n    * @param {Number} idx\n    * @fires isValidIndex\n    * @fires setConfig\n    * @emit beforeUnpin\n    * @emit unpin\n    */\n    unpin(idx) {\n      if (this.isValidIndex(idx)) {\n        let ev = new CustomEvent('beforeUnpin', {\n          cancelable: true\n        });\n        this.$emit('beforeUnpin', idx, ev);\n        if (!ev.defaultPrevented) {\n          this.views[idx].pinned = false;\n          this.setConfig();\n          this.$emit('unpin', idx);\n        }\n      }\n    }\n  },\n  watch: {\n    /**\n     * @watch dirty\n     */\n    isDirty(v) {\n      if (this.parentContainer) {\n        this.parentContainer.dirty = v;\n      }\n    },\n    source(v, ov) {\n      bbn.fn.each(v, a => {\n        if (!bbn.fn.isString(a.url)) {\n          throw new Error(bbn._(\"The container must have a valid URL\"));\n        }\n\n        // Setting current if URL starts with default URL\n        if (this.currentURL && this.currentURL.indexOf(a.url) === 0) {\n          a.current = this.currentURL;\n        }\n\n        //bbn.fn.warning(bbn._(\"ADDING %s ON WATCH\", a.url));\n        this.add(a);\n      });\n    },\n    views() {\n      this.updateVisualStyleContainer();\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/router/_mixins/views.js?");

/***/ })

}]);