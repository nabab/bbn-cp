"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/table-_mixins-size-js"],{

/***/ "./src/components/table/_mixins/size.js":
/*!**********************************************!*\
  !*** ./src/components/table/_mixins/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  props: {\n    /**\n     * Set to true allows the table to be resizable.\n     * @prop {Boolean} [false] resizable\n     */\n    resizable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines the minimum columns width.\n     * @prop {Number} [30] minimumColumnWidth\n     */\n    minimumColumnWidth: {\n      type: Number,\n      default: 20\n    },\n    /**\n     * Defines the minimum columns width for mobile devices.\n     * @prop {Number} [100] minimumColumnWidthMobile\n     */\n    minimumColumnWidthMobile: {\n      type: Number,\n      default: 100\n    },\n    /**\n     * Defines the default columns width.\n     * @prop {Number} [150] defaultColumnWidth\n     */\n    defaultColumnWidth: {\n      type: Number,\n      default: 150\n    },\n    /**\n     * The max row height value\n     * @prop {Number} maxRowHeight\n     */\n    maxRowHeight: {\n      type: Number\n    }\n  },\n  data() {\n    return {\n      /**\n       * True if the table is resizing its width\n       * @data {Boolean} [false] isResizingWidth\n       */\n      isResizingWidth: false,\n      isResizing: false\n    };\n  },\n  computed: {\n    /**\n     * The container width.\n     * @computed containerWidth\n     * @returns {String}\n     */\n    containerWidth() {\n      if (!this.groupCols || !this.groupCols[1] || !this.groupCols[1].width || !this.offsetParent?.offsetWidth) {\n        return '0px';\n      }\n      return this.offsetParent.offsetWidth - this.groupCols[0].width - this.groupCols[2].width + 'px';\n    },\n    /**\n     * The total width.\n     * @computed totalWidth\n     * @returns {String}\n     */\n    totalWidth() {\n      const sum = bbn.fn.sum(this.groupCols, 'width');\n      if (sum) {\n        return sum + 'px';\n      }\n      return '100%';\n    },\n    currentMaxRowHeight() {\n      return this.maxRowHeight ? this.maxRowHeight + 'px' : 'auto';\n    }\n  },\n  methods: {\n    onResize() {\n      bbn.cp.mixins.resizer.methods.onResize.apply(this);\n      if (this.$isMounted) {\n        this.$nextTick(() => {\n          this.resizeWidth();\n        });\n      }\n    },\n    /**\n     * Returns an object of numbers as width and height based on whatever unit given.\n     * \n     * @method getDimensions\n     * @param {Number} width\n     * @param {Number} height\n     * @return {Number}\n     */\n    getDimensionWidth(width) {\n      if (bbn.fn.isNumber(width) && width) {\n        return parseInt(width);\n      }\n      let parent = this;\n      let r = 0;\n      if (parent && width) {\n        if (!parent.insertAdjacentElement) {\n          return 0;\n        }\n        let el = document.createElement('div');\n        el.style.position = 'absolute';\n        el.style.opacity = 0;\n        el.className = 'bbn-reset';\n        el.style.width = this.formatSize(width);\n        try {\n          parent.insertAdjacentElement('beforeend', el);\n        } catch (e) {\n          bbn.fn.log(\"Error while inserting adjacent element for dimensioncalculation\", e, this.$el);\n          return 0;\n        }\n        r = el.offsetWidth || el.clientWidth || 0;\n        el.parentNode.removeChild(el);\n      }\n      return r;\n    },\n    /**\n     * Resizes the table.\n     * @method resizeWidth\n     * @returns {HTMLElement}\n     */\n    resizeWidth() {\n      if (!this.checkVisibility()) {\n        return;\n      }\n      const table = this.getRef('table');\n      if (!table) {\n        return;\n      }\n      let currentTot = this.groupCols[0].width + this.groupCols[1].width + this.groupCols[2].width;\n      let parentWidth = this.$el.offsetParent ? this.$el.offsetParent.getBoundingClientRect().width : this.$el.offsetWidth;\n      let parentStyle = this.$el.offsetParent ? window.getComputedStyle(this.$el.offsetParent) : {};\n      let parentPadding = parseFloat(parentStyle?.paddingLeft || 0) + parseFloat(parentStyle?.paddingRight || 0);\n      let diff = Math.floor(parentWidth - parentPadding - this.borderLeft - this.borderRight - currentTot);\n      let numDynCols = this.currentColumns.filter(c => c.width === undefined && !c.isExpander && !c.isSelection && !c.invisible).length;\n      let numStaticCols = this.currentColumns.filter(c => !!c.width && !c.isExpander && !c.isSelection && !c.invisible).length;\n      let newWidth = numDynCols || numStaticCols ? Math.floor(diff / (numDynCols || numStaticCols)) : 0;\n      if (newWidth) {\n        this.getRef('table').style.width = currentTot + newWidth + 'px';\n        this.isResizingWidth = true;\n        bbn.fn.each(this.groupCols, (groupCol, groupIdx) => {\n          let sum = 0,\n            sumRight = 0,\n            sumLeft = 0;\n          bbn.fn.each(groupIdx !== 2 ? groupCol.cols : groupCol.cols.slice().reverse(), col => {\n            if (!col.invisible) {\n              if (!col.isExpander && !col.isSelection && (!!numDynCols && col.width === undefined || !numDynCols && !!numStaticCols && !!col.width)) {\n                let tmp = col.realWidth + newWidth;\n                if (col.width !== undefined && (!bbn.fn.isString(col.width) || bbn.fn.isNumber(bbn.fn.substr(col.width, -1)))) {\n                  tmp = col.realWidth;\n                } else if (tmp < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {\n                  tmp = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;\n                }\n                let minWidth = this.getDimensionWidth(col.minWidth);\n                let maxWidth = this.getDimensionWidth(col.maxWidth);\n                if (col.minWidth && tmp < minWidth) {\n                  tmp = minWidth;\n                }\n                if (col.maxWidth && tmp > maxWidth) {\n                  tmp = maxWidth;\n                }\n                col.realWidth = Math.floor(tmp);\n              }\n              sum += col.realWidth;\n              if (groupIdx === 0) {\n                col.left = sumLeft;\n                sumLeft += col.realWidth;\n              }\n              if (groupIdx === 2) {\n                col.right = sumRight;\n                sumRight += col.realWidth;\n              }\n            }\n          });\n          this.groupCols[groupIdx].width = sum;\n          sum = 0;\n          sumLeft = 0;\n          sumRight = 0;\n        });\n        this.isResizingWidth = false;\n      }\n      this.updateStyle();\n      return this;\n    },\n    /**\n     * The method called on a column resize (by user)\n     * @method onUserResize\n     * @param {Event} e\n     * @fires $forceUpdate\n     */\n    onUserResize(e) {\n      if (e.target && e.detail) {\n        let d = e.target._bbn.directives.resizable.options.data,\n          nextCol = this.groupCols[d.groupColIndex].cols[d.columnIndex + 1],\n          nextColSize = nextCol ? nextCol.realWidth + e.detail.movement : 0;\n        if (d.column.realWidth !== e.detail.size && e.detail.size >= this.defaultColumnWidth && (!nextCol || nextColSize >= this.defaultColumnWidth)) {\n          this.groupCols[d.groupColIndex].cols[d.columnIndex].realWidth = Math.floor(e.detail.size);\n          if (nextCol) {\n            this.groupCols[d.groupColIndex].cols[d.columnIndex + 1].realWidth = nextColSize;\n          }\n          this.$forceUpdate();\n        }\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/table/_mixins/size.js?");

/***/ })

}]);