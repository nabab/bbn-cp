/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || []).push([["components/tree-tree-js"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/tree/tree.less":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/tree/tree.less ***!
  \********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.bbn-tree {\n  position: relative;\n  float: left;\n  overflow: hidden;\n  width: 100%;\n  height: 100%;\n  list-style: none;\n}\n.bbn-tree ul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.bbn-tree ul.bbn-tree-child {\n  padding-left: 1.2rem;\n}\n.bbn-tree ul.bbn-tree-root {\n  padding-left: 0.25rem;\n}\n.bbn-tree ul.bbn-tree-helper {\n  position: fixed;\n  z-index: 1000;\n  opacity: 0.7;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n.bbn-tree ul.bbn-tree-helper.bbn-tree-child,\n.bbn-tree ul.bbn-tree-helper.root {\n  padding-left: 1.2rem;\n}\n.bbn-tree ul.bbn-tree-helper.bbn-tree-root {\n  padding-left: 0;\n}\n.bbn-tree .bbn-tree-toggle-enter-active,\n.bbn-tree .bbn-tree-toggle-leave-active {\n  transition: max-height 0.3s;\n  max-height: 500px;\n}\n.bbn-tree .bbn-tree-toggle-enter,\n.bbn-tree .bbn-tree-toggle-leave-to {\n  max-height: 0;\n}\n.bbn-tree .bbn-tree-node {\n  clear: both;\n  margin: 0;\n  box-sizing: content-box;\n}\n.bbn-tree .bbn-tree-node .bbn-tree {\n  height: auto;\n}\n.bbn-tree .bbn-tree-node .bbn-tree-order-top,\n.bbn-tree .bbn-tree-node .bbn-tree-order-bottom {\n  height: 2px;\n  line-height: 2px;\n}\n.bbn-tree .bbn-tree-node .bbn-droppable-over {\n  background-color: var(--secondary-background);\n  color: var(--secondary-text);\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block {\n  display: inline-block;\n  white-space: nowrap;\n  height: auto;\n  min-height: 18px;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block span {\n  display: inline-block;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block.bbn-tree-node-block-no-component span {\n  display: inline-block;\n  vertical-align: middle;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block .bbn-tree-node-block-selectable {\n  padding: 1px;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block .bbn-tree-node-block-expander {\n  width: 0.6rem;\n  padding-left: 0.2rem;\n  font-size: 1.1rem;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block .bbn-tree-node-block-icon {\n  text-align: center;\n  width: 1.3rem;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block .bbn-tree-node-block-icon img {\n  width: 100%;\n  height: auto;\n  vertical-align: middle;\n}\n.bbn-tree .bbn-tree-node span.bbn-tree-node-block .bbn-tree-node-block-title {\n  white-space: nowrap;\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/tree/tree.less?./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/components/tree/tree.html":
/*!***************************************!*\
  !*** ./src/components/tree/tree.html ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Module\nvar code = \"<div :class=\\\"componentClass\\\"\\n     tabindex=\\\"0\\\"\\n     @keydown.up.down.left.right.enter.space.page-down.page-up.end.home.prevent.stop=\\\"keyNav\\\">\\n  <!-- A loader -->\\n  <div bbn-if=\\\"loading\\\" class=\\\"loader\\\">\\n    <bbn-loadicon/> <span bbn-text=\\\"_('Loading')\\\"/>...\\n  </div>\\n  <!-- The container: a scroll if root and scrollable, a div otherwise -->\\n  <bbn-scroll bbn-elseif=\\\"isInit && isLoaded\\\"\\n             bbn-forget=\\\"!isRoot || !scrollable\\\"\\n             ref=\\\"scroll\\\">\\n    <div class=\\\"bbn-tree-helper-container\\\"\\n         bbn-if=\\\"(draggable || sortable) && isRoot\\\"\\n         ref=\\\"helperContainer\\\">\\n      <ul class=\\\"bbn-tree-helper\\\"\\n          ref=\\\"helper\\\"\\n          bbn-show=\\\"!!tree.realDragging\\\"/>\\n    </div>\\n          <!-- start of the list -->\\n      <ul bbn-if=\\\"filteredData.length && (isRoot || $parent.isExpanded)\\\"\\n          :class=\\\"{\\n            'bbn-tree-child': !!level,\\n            'bbn-tree-root': isRoot\\n          }\\\"\\n      ref=\\\"list\\\">\\n        <!-- Tree node component -->\\n        <node inline-template\\n              bbn-for=\\\"(it, i) in filteredData\\\"\\n              :source=\\\"it\\\"\\n              :key=\\\"(it.key ? it.key + '-' : '') + 'node-' + level + '-' + i\\\"\\n              :idx=\\\"it.index\\\"\\n              :component=\\\"it.component || component\\\"\\n              :selectable=\\\"it.selectable !== undefined ? it.selectable : selectable\\\"\\n              :multiple=\\\"it.multiple !== undefined ? it.multiple : multiple\\\"\\n              :level=\\\"level\\\"\\n              :selection=\\\"it.selection !== undefined ? it.selection : selection\\\"\\n              :flat=\\\"flat\\\"\\n              ref=\\\"node\\\"\\n              :quick-filter=\\\"quickFilter\\\"\\n              :sortable=\\\"it.sortable !== undefined ? it.sortable : sortable\\\"\\n              :uid=\\\"uid\\\"\\n              @selectmenu=\\\"clickMenuItem\\\"\\n              @nodeclick=\\\"onNodeClick\\\"\\n              :tree-state=\\\"uid !== undefined ? _getTreeState(it.data[uid]) : {}\\\">\\n          <li :class=\\\"['bbn-tree-node', 'bbn-vxxspadded', 'bbn-unselectable', {\\n                        'bbn-state-active': (isActive && !isSelected) || (tree.draggable && tree.dragging && (tree.dragging === _self)),\\n                        'bbn-state-selected': isSelected\\n                      }]\\\"\\n              bbn-show=\\\"isVisible\\\"\\n              :title=\\\"source.tooltip || textFromText\\\">\\n            <!-- Sortable interface is set at the top -->\\n            <span bbn-if=\\\"sortable && (source.num === 1)\\\"\\n                  :class=\\\"['bbn-w-100', 'bbn-tree-order-top', {\\n                    'bbn-tree-order': tree.dragging && (tree.dragging.parent === parent) && !quickFilter\\n                  }]\\\"\\n                  :style=\\\"{\\n                    visibility: !!tree.dragging\\n                      && !!tree.overNode\\n                      && (tree.dragging.parent === tree.overNode.parent)\\n                      && (tree.overNode.source.num === 1)\\n                      && (tree.dragging.source.num > 1) ? 'visible' : 'hidden'\\n                  }\\\"\\n                  ref=\\\"orderTop\\\"\\n                  @dragover=\\\"drag\\\"\\n                  @dragleave=\\\"leaveDrag\\\"\\n                  @drop=\\\"drop\\\"\\n                  @dragend=\\\"endDrag\\\"\\n                  bbn-droppable:data=\\\"{node: _self}\\\"/>\\n            <!-- The node starts here -->\\n            <span :class=\\\"['bbn-tree-node-block', getCls(source, tree) || '', {'bbn-tree-node-block-no-component': !!component}]\\\">\\n              <!-- The expander -->\\n              <span :class=\\\"['bbn-tree-node-block-expander', {'bbn-p': numChildren}]\\\"\\n                    @click=\\\"if ( !flat && numChildren && (level >= tree.minExpandLevel) ){\\n                      isExpanded = !isExpanded;\\n                    }\\\"\\n                    @mouseover=\\\"if ( !flat && tree.draggable && tree.dragging && numChildren && (level >= tree.minExpandLevel) ){\\n                      isExpanded = true;\\n                    }\\\">\\n                <!-- If there are no children we leave the white space -->\\n                <span bbn-if=\\\"flat || !numChildren || (level < tree.minExpandLevel)\\\">&nbsp;</span>\\n                <i bbn-else\\n                   :class=\\\"['bbn-xs', {\\n                      'nf nf-fa-caret_down': isExpanded,\\n                      'nf nf-fa-caret_right': !isExpanded\\n                    }]\\\"/>\\n              </span>\\n\\n              <!-- The checkobox if selection -->\\n              <span bbn-if=\\\"tree.uid && (tree.selection || !!selection)\\\">\\n                <bbn-checkbox :value=\\\"data[tree.uid]\\\"\\n                              :checked=\\\"isChecked(data[tree.uid])\\\"\\n                              @change=\\\"checkNode\\\"\\n                              :disabled=\\\"isDisabled()\\\"/>\\n              </span>\\n\\n              <!-- The component if given -->\\n              <component bbn-if=\\\"!!component\\\"\\n                          :is=\\\"component\\\"\\n                          :source=\\\"data\\\"/>\\n\\n              <!-- Or the default context -->\\n              <bbn-context bbn-else\\n                            :context=\\\"true\\\"\\n                            :source-action=\\\"false\\\"\\n                            :source=\\\"getMenu\\\"\\n                            @select=\\\"clickMenuItem\\\"\\n                            @open=\\\"isActive = true\\\"\\n                            @close=\\\"isActive = false\\\"\\n                            style=\\\"cursor: unset\\\">\\n                <span @dblclick=\\\"dblClickOnNode\\\"\\n                      @click=\\\"clickOnNode\\\"\\n                      @dragstart=\\\"startDrag\\\"\\n                      @dragover=\\\"drag\\\"\\n                      @dragleave=\\\"leaveDrag\\\"\\n                      @drop=\\\"drop\\\"\\n                      @dragend=\\\"endDrag\\\"\\n                      @mouseup.left=\\\"onMouseUp\\\"\\n                      tabindex=\\\"0\\\"\\n                      bbn-draggable.container.data.mode=\\\"tree.draggable ? {\\n                        mode: 'clone',\\n                        container: tree.getRef('helperContainer'),\\n                        data: {node: _self}\\n                      } : false\\\"\\n                      bbn-droppable:data=\\\"tree.selfDrop ? {node: _self} : false\\\">\\n                  <!-- The item component if given -->\\n                  <component bbn-if=\\\"tree.itemComponent\\\"\\n                             :is=\\\"tree.itemComponent\\\"\\n                             :source=\\\"source\\\"/>\\n                  <!-- Or the default template -->\\n                  <template bbn-else>\\n                    <span bbn-if=\\\"tree.icons\\\"\\n                          class=\\\"bbn-tree-node-block-icon bbn-right-xsmargin\\\">\\n                      <!-- If icon is specifically false we leave the white space -->\\n                      <span bbn-if=\\\"source.icon === false\\\"></span>\\n                      <!-- or if it's an image -->\\n                      <img bbn-elseif=\\\"source.icon && (source.icon.indexOf('data:image') === 0)\\\"\\n                           :src=\\\"source.icon\\\"\\n                           alt=\\\"\\\">\\n                      <!-- or if it's a class icon -->\\n                      <i bbn-elseif=\\\"source.icon\\\"\\n                        :class=\\\"source.icon\\\"\\n                        :style=\\\"iconStyle\\\"/>\\n                    <!-- default icon -->\\n                    <i bbn-else\\n                          :class=\\\"getIcon()\\\"\\n                          :style=\\\"iconStyle\\\"\\n                      ></i>\\n                    </span>\\n                    <!-- The node's text -->\\n                    <span class=\\\"bbn-tree-node-block-title\\\">\\n                      <span bbn-html=\\\"source.text\\\"></span>\\n                    </span>\\n                  </template>\\n                </span>\\n              </bbn-context>\\n            </span>\\n\\n            <!-- If it has children another tree -->\\n            <bbn-tree bbn-if=\\\"numChildren\\\"\\n                      ref=\\\"tree\\\"\\n                      :key=\\\"'tree-' + level + '-' + idx\\\"\\n                      class=\\\"bbn-text\\\"\\n                      :component=\\\"component\\\"\\n                      :source=\\\"tree.isAjax && !tree.hybrid ? tree.source : (data[tree.children] ? data[tree.children] : [])\\\"\\n                      :level=\\\"level + 1\\\"\\n                      :object=\\\"tree.object ? !tree.hybrid : false\\\"\\n                      :autobind=\\\"false\\\"\\n                      :filterable=\\\"isFilterable\\\"\\n                      :flat=\\\"flat\\\"\\n                      :filters=\\\"tree.filters\\\"\\n                      :selectable=\\\"source.selectable !== undefined ? source.selectable : tree.selectable\\\"\\n                      :selection=\\\"source.selection !== undefined ? source.selection : tree.selection\\\"\\n                      :cls=\\\"source.cls !== undefined ? source.cls : tree.cls\\\"\\n                      :quick-filter=\\\"quickFilter\\\"\\n                      :sortable=\\\"source.sortable !== undefined ? source.sortable : tree.sortable\\\"\\n                      :multiple=\\\"source.multiple !== undefined ? source.multiple : tree.multiple\\\"\\n                      :uid=\\\"uid\\\"\\n                      :state=\\\"treeState\\\"\\n                      :opened=\\\"isExpanded\\\"\\n                      :source-text=\\\"tree.sourceText\\\"\\n                      :source-value=\\\"tree.sourceValue\\\"\\n                      :scrollable=\\\"tree.scrollable\\\"/>\\n\\n            <!-- Sortable interface is set at the bottom -->\\n            <span bbn-if=\\\"sortable\\\"\\n                  :class=\\\"['bbn-w-100', 'bbn-tree-order-bottom', {\\n                    'bbn-tree-order': tree.dragging && (tree.dragging.parent === parent) && !quickFilter\\n                  }]\\\"\\n                  :style=\\\"{\\n                    visibility: !!tree.dragging\\n                      && !!tree.overNode\\n                      && (tree.dragging.parent === tree.overNode.parent)\\n                      && (tree.overNode !== tree.dragging) ? 'visible' : 'hidden'\\n                  }\\\"\\n                  ref=\\\"orderBottom\\\"\\n                  @dragover=\\\"drag\\\"\\n                  @dragleave=\\\"leaveDrag\\\"\\n                  @drop=\\\"drop\\\"\\n                  @dragend=\\\"endDrag\\\"\\n                  bbn-droppable:data=\\\"{node: _self}\\\"\\n            ></span>\\n          </li>\\n        </node>\\n      </ul>\\n      </component>\\n  <h2 bbn-elseif=\\\"isRoot\\\"\\n      bbn-html=\\\"_('No items') + '...'\\\"\\n  ></h2>\\n</div>\\n\";\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/tree/tree.html?");

/***/ }),

/***/ "./src/components/tree/tree.less":
/*!***************************************!*\
  !*** ./src/components/tree/tree.less ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_tree_less__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/less-loader/dist/cjs.js!./tree.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/components/tree/tree.less\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_tree_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_tree_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_tree_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_tree_less__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/tree/tree.less?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/components/tree/_i18n lazy recursive ^\\.\\/tree\\..*\\.lang$":
/*!**************************************************************************************!*\
  !*** ./src/components/tree/_i18n/ lazy ^\.\/tree\..*\.lang$ strict namespace object ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./tree.fr.lang\": [\n\t\t\"./src/components/tree/_i18n/tree.fr.lang\",\n\t\t\"src_components_tree__i18n_tree_fr_lang\"\n\t],\n\t\"./tree.it.lang\": [\n\t\t\"./src/components/tree/_i18n/tree.it.lang\",\n\t\t\"src_components_tree__i18n_tree_it_lang\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__.t(id, 1 | 16);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./src/components/tree/_i18n lazy recursive ^\\\\.\\\\/tree\\\\..*\\\\.lang$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/tree/_i18n/_lazy_^\\.\\/tree\\..*\\.lang$_strict_namespace_object?");

/***/ }),

/***/ "./src/components/tree/tree.js":
/*!*************************************!*\
  !*** ./src/components/tree/tree.js ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n/* harmony import */ var _tree_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tree.html */ \"./src/components/tree/tree.html\");\n/* harmony import */ var _tree_less__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tree.less */ \"./src/components/tree/tree.less\");\n/**\r\n * @file bbn-tree component\r\n * @description bbn-tree is the component that is easily implemented by allowing data to be displayed hierarchically using a tree structure.\r\n * The component can contain the data loaded only once or it can be created dynamically by making ajax calls, it also allows (after a correct configuration) to perform operations on them, for example drag & drop.\r\n * @copyright BBN Solutions\r\n * @author BBN Solutions\r\n * @created 10/02/2017\r\n */\nconst cpDef = {\n  /**\r\n   * @mixin bbn.cp.mixins.basic\r\n   * @mixin bbn.cp.mixins.localStorage\r\n   * @mixin bbn.cp.mixins.list\r\n   */\n  mixins: [_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cp.mixins.basic, _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cp.mixins.localStorage, _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cp.mixins.list],\n  statics() {\n    return {\n      NODE_PROPERTIES: ['text', 'icon', 'num', 'numChildren', 'data', 'cls', 'selectedClass', 'activeClass', 'selection', 'selectable', 'multiple', 'filterable', 'sortable', 'selected', 'expanded', 'component', 'tooltip', 'path', 'visible']\n    };\n  },\n  props: {\n    /**\r\n     *  @prop {Boolean} [false] excludedSectionFilter\r\n     */\n    excludedSectionFilter: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * The level until which the tree must be opened.\r\n     * @prop {Number} [0] minExpandLevel\r\n     */\n    minExpandLevel: {\n      type: Number,\n      default: 0\n    },\n    /**\r\n     * True if the whole tree must be opened.\r\n     * @prop {Boolean} [false] opened\r\n     */\n    opened: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * An array of objects representing the nodes.\r\n     * @prop {(Array|String|Object|Function)} source\r\n     */\n    source: {\n      Type: [Array, String, Object, Function]\n    },\n    /**\r\n     * The class given to the node (or a function returning the class name).\r\n     * @prop {(Function|String)} cls\r\n     */\n    cls: {\n      type: [Function, String]\n    },\n    /**\r\n     * A component for the entire node block.\r\n     * @prop {(Function|String|Object)} component\r\n     */\n    component: {\n      type: [Function, String, Object]\n    },\n    /**\r\n     * A component for the node.\r\n     * @prop {(Function|String|Object)} itemComponent\r\n     */\n    itemComponent: {\n      type: [Function, String, Object]\n    },\n    /**\r\n     * Set to true to have the nodes draggable.\r\n     * @prop {Boolean} [false] draggable\r\n     */\n    draggable: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * An array (or a function returning one) of elements for the node context menu.\r\n     * @prop {(Array|Function)} menu\r\n     */\n    menu: {\n      type: [Array, Function]\n    },\n    /**\r\n     * Set to true to use the icon given in the source object of the node.\r\n     * @prop {Boolean} [true] icons\r\n     */\n    icons: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * An string (or a function returning one) for the icon's color.\r\n     * @prop {(String|Function)} iconColor\r\n     */\n    iconColor: {\n      type: [String, Function]\n    },\n    /**\r\n     * The value of the UID to send for the root tree.\r\n     * @prop {(String|Number)} root\r\n     */\n    root: {\n      type: [String, Number]\n    },\n    /**\r\n     * The hierarchy level, root is 0, and for each generation 1 is added to the level.\r\n     * @prop {Number} [0] level\r\n     */\n    level: {\n      type: Number,\n      default: 0\n    },\n    /**\r\n     * Other trees where nodes can be dropped on.\r\n     * @prop {Array} [[]] droppables\r\n     */\n    droppables: {\n      type: Array,\n      default() {\n        return [];\n      }\n    },\n    /**\r\n     * Set to true allows to use an object for the tree items.\r\n     * @prop {Boolean} [false] object\r\n     */\n    object: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * If set to false a draggable tree will not be able to drop on itself.\r\n     * @prop {Boolean} [true] selfDrop\r\n     */\n    selfDrop: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Helper to transform data when passing from one tree to another.\r\n     * @prop {Function} transferData\r\n     */\n    transferData: {\n      type: Function\n    },\n    /**\r\n     * The opened path if there is one.\r\n     * @prop {Array} [[]] path\r\n     */\n    path: {\n      type: Array,\n      default() {\n        return [];\n      }\n    },\n    /**\r\n     * Set to true for a selectable tree.\r\n     * @prop {Boolean} [true] selectable\r\n     */\n    selectable: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * @prop {Boolean} [true] hierarchy\r\n     */\n    hierarchy: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * The string to use as quick filter in the tree.\r\n     * @prop {String} [''] quickFilter\r\n     */\n    quickFilter: {\n      type: String,\n      default: ''\n    },\n    /**\r\n     * The order of items.\r\n     * @prop {Array} [[{field: 'num', dir: 'DESC'}, {field: 'text', dir: 'ASC'}]] order\r\n     */\n    order: {\n      type: Array,\n      default() {\n        return [{\n          field: 'num',\n          dir: 'ASC'\n        }];\n      }\n    },\n    /**\r\n     * @prop {Object} [{}] state\r\n     */\n    state: {\n      type: Object,\n      default() {\n        return {};\n      }\n    },\n    /**\r\n     * Set to true if the prop 'ajax' is true,\r\n     * the tree will make the ajax call only for\r\n     * the source of the root level and will take\r\n     * the current data for the source of other levels\r\n     * @prop {Boolean} [false] hybrid\r\n     */\n    hybrid: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Set to false if you want remove the scroll inside the tree.\r\n     * @prop {Boolean} [true] scrollable\r\n     */\n    scrollable: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data() {\n    return {\n      /**\r\n       * Only for the origin tree.\r\n       * @data {Boolean} [false] isRoot\r\n       */\n      isRoot: false,\n      /**\r\n       * The parent node if not root.\r\n       * @data {Boolean|bbnCp} [false] node\r\n       */\n      node: false,\n      /**\r\n       * The parent tree if not root.\r\n       * @data {Boolean|bbnCp} [false] tree\r\n       */\n      tree: false,\n      /**\r\n       * The URL where to pick the data from if isAjax.\r\n       * @data {String|Boolean} url\r\n       */\n      url: typeof this.source === 'string' ? this.source : false,\n      /**\r\n       * True when the data is currently loading in the current tree.\r\n       * @data {Boolean} [false] loading\r\n       */\n      loading: false,\n      /**\r\n       * True once the data of the tree has been loaded.\r\n       * @data {Boolean} [false] isLoaded\r\n       */\n      isLoaded: false,\n      /**\r\n       * True once the component is mounted.\r\n       * @data {Boolean} [false] isMounted\r\n       */\n      isMounted: false,\n      /**\r\n       * The currently active node component object.\r\n       * @data {Boolean|bbnCp} [false] activeNode\r\n       */\n      activeNode: false,\n      /**\r\n       * The component node object over which the mouse is now.\r\n       * @data {Boolean|bbnCp} [false] overNode\r\n       */\n      overNode: false,\n      /**\r\n       * Dragging state, true if an element is being dragged.\r\n       * @data {Boolean|bbnCp} [false] dragging\r\n       */\n      dragging: false,\n      /**\r\n       * Real dragging will start after the mouse's first move, useful to kow if we are in a select or drag context.\r\n       * @data {Boolean} [false] realDragging\r\n       */\n      realDragging: false,\n      /**\r\n       * An array containing the indexes of checked nodes.\r\n       * @data {Array} [[]] checked\r\n       */\n      checked: [],\n      /**\r\n       * An array containing the indexes of disabled checkbox\r\n       * @data {Array} [[]] disabled\r\n       */\n      disabled: [],\n      /**\r\n       * An array containing the components of expanded nodes.\r\n       * @data {Array} [[]] currentExpanded\r\n       */\n      currentExpanded: [],\n      /**\r\n       * The component node object over which the mouse is now.\r\n       * @data {Boolean|bbnCp} [false] overOrder\r\n       */\n      overOrder: false,\n      /**\r\n       * The array of nodes.\r\n       * @data {Array} [[]] nodes\r\n       */\n      nodes: [],\n      /**\r\n       * The state for the storage.\r\n       * @data {Array} [[]] nodes\r\n       */\n      currentState: {},\n      /**\r\n       * Set to true once it has been loaded.\r\n       * @data {Array} [[]] nodes\r\n       */\n      isInit: false\n    };\n  },\n  computed: {\n    /**\r\n     * The current data of the tree.\r\n     * @computed filteredData\r\n     * @fires _checkConditionsOnItem\r\n     * @return {Array}\r\n     */\n    filteredData() {\n      let ret = [];\n      if (this.currentData.length && this.currentFilters && this.currentFilters.conditions && this.currentFilters.conditions.length && (!this.serverFiltering || !this.isAjax)) {\n        ret = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.filter(this.currentData, a => {\n          return this._checkConditionsOnItem(this.currentFilters, a.data);\n        });\n      } else {\n        ret = this.currentData;\n      }\n      if (this.sortable && this.order.length) {\n        /* ret = bbn.fn.multiorder(ret, bbn.fn.map(this.order, o => {\r\n          let r = bbn.fn.extend(true, {}, o);\r\n          r.field = 'data.' + r.field;\r\n          return r;\r\n        })); */\n        ret = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.multiorder(ret, this.order);\n        ret = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.map(ret, (v, i) => {\n          v.num = i + 1;\n          return v;\n        });\n      }\n      return ret;\n    },\n    /**\r\n     * The selected node.\r\n     * @computed selectedNode\r\n     * @return {Vue|Boolean}\r\n     */\n    selectedNode() {\n      return this.tree && this.tree.currentSelected.length ? this.tree.currentSelected[this.tree.currentSelected.length - 1] : false;\n    },\n    /**\r\n     * Array of droppables trees.\r\n     * @computed droppableTrees\r\n     * @return {Array}\r\n     */\n    droppableTrees() {\n      let r = this.selfDrop ? [this] : [];\n      if (this.droppables.length) {\n        r.push(...this.droppables);\n      }\n      return r;\n    }\n  },\n  methods: {\n    /**\r\n     * Normalizes the list of items basing on it's type.\r\n     * @method _objectMapper\r\n     * @param {Array|Object} items\r\n     * @fires _objectMapper\r\n     * @return {Array}\r\n     */\n    _objectMapper(items) {\n      let res = [];\n      if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isArray(items)) {\n        _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(items, (a, i) => {\n          let numChildren = 0;\n          let o = {\n            text: _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._('Node') + ' ' + i,\n            numChildren: numChildren\n          };\n          if (a !== undefined) {\n            if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isArray(a)) {\n              numChildren = a.length;\n            } else if (typeof a === 'object') {\n              numChildren = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.numProperties(a);\n            } else {\n              o.text = typeof a === 'string' ? a : a.toString();\n            }\n          }\n          if (numChildren) {\n            o.numChildren = numChildren;\n            o[this.children] = this._objectMapper(a);\n          }\n          res.push(o);\n        });\n      } else if (items && typeof items === 'object' && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.numProperties(items)) {\n        _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.iterate(items, (a, n) => {\n          let numChildren = 0;\n          let o = {\n            text: n,\n            numChildren: numChildren\n          };\n          if (a !== undefined) {\n            if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isArray(a)) {\n              numChildren = a.length;\n            } else if (typeof a === 'object') {\n              numChildren = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.numProperties(a);\n            } else {\n              o.text = '<strong>' + o.text + ': </strong>' + a;\n            }\n          }\n          if (numChildren) {\n            o.numChildren = numChildren;\n            o[this.children] = this._objectMapper(a);\n          }\n          res.push(o);\n        });\n      }\n      return res;\n    },\n    _getTreeState(uid) {\n      if (uid !== undefined && this.currentState[uid]) {\n        //bbn.fn.log('CURRENT STATE FOUND', this.currentState[uid][this.children]);\n        //return bbn.fn.clone(this.currentState[uid].items);\n        return this.currentState[uid].items;\n      }\n      return {};\n    },\n    /**\r\n     * A function to normalize the structure of items.\r\n     * @method _map\r\n     * @param {Array} items\r\n     * @fires tree.map\r\n     * @fires _objectMapper\r\n     * @return {Array}\r\n     */\n    _map(items) {\n      if (this.object) {\n        items = this._objectMapper(items.reduce((r, k) => {\n          r[k.value] = k.text;\n          return r;\n        }, {}));\n      }\n      items = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.map(items, item => {\n        let o = {};\n        if (this.tree.map) {\n          item = this.tree.map(item.data !== undefined ? item.data : item, this.level + 1, item.data !== undefined ? item : {});\n        }\n        _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(bbnTreeCp.NODE_PROPERTIES, p => {\n          o[p] = p === 'text' ? item[this.tree.sourceText] : item[p];\n        });\n        if (!!item.data && !!item.data[this.tree.children]) {\n          o.numChildren = item.data[this.tree.children].length;\n        }\n        if (!!item[this.tree.children]) {\n          o.numChildren = item[this.tree.children].length;\n        }\n        if (o.data === undefined) {\n          o.data = item;\n        }\n        return o;\n      });\n      return items;\n    },\n    onNodeClick(node, ev) {\n      this.$emit('nodeclick', node, ev);\n    },\n    /**\r\n     * Resets the tree to the original configuration.\r\n     * @method reset\r\n     * @fires updateData\r\n     */\n    reset() {\n      this.isLoaded = false;\n      //this.$set(this, 'currentData', []);\n      //this.$forceUpdate();\n      //this.$nextTick(() => {\n      this.updateData();\n      //})\n    },\n    /**\r\n     * Resizes the root scroller.\r\n     * @method resize\r\n     */\n    resize() {\n      let scroll = this.tree.getRef('scroll');\n      if (scroll && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(scroll.onResize)) {\n        scroll.onResize();\n      }\n    },\n    /**\r\n     * Resizes the root tree and emit an open event\r\n     * @method onOpen\r\n     * @fires resize\r\n     * @emits open\r\n     */\n    onOpen() {\n      this.resize();\n      this.$emit('open');\n      this.tree.$emit('open', this);\n    },\n    /**\r\n     * Resizes the root tree and emit a close event.\r\n     * @method onClose\r\n     * @fires resize\r\n     * @emits close\r\n     */\n    onClose() {\n      this.resize();\n      this.$emit('close');\n      this.tree.$emit('close', this);\n    },\n    /**\r\n     * Finds a node based on its props.\r\n     * @method findNode\r\n     * @param {Object} props\r\n     * @param {Object} node\r\n     * @return {Object}\r\n     */\n    findNode(props, expand) {\n      let ret = false;\n      if (this.isRoot || this.node.numChildren && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isObject(props)) {\n        if (expand && !this.isRoot && !this.node.isExpanded) {\n          this.node.isExpanded = true;\n        }\n        let lst = this.getRef('list');\n        if (lst && lst.querySelectorAll) {\n          const eles = lst.querySelectorAll('li[is=bbn-tree-node]');\n          if (eles.length) {\n            const data = [];\n            eles.forEach(a => {\n              data.push(a.bbn.data);\n            });\n            let idx = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.search(data, props);\n            if (idx > -1) {\n              ret = eles[idx].bbn;\n            } else {\n              _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(eles, node => {\n                let tree = node.bbn.getRef('tree');\n                if (tree) {\n                  ret = tree.findNode(props, expand);\n                  if (ret) {\n                    return false;\n                  }\n                }\n              });\n            }\n          }\n        }\n      }\n      return ret;\n    },\n    /**\r\n     * Returns the node corresponding to the given idx.\r\n     * @method getNodeByIdx\r\n     * @param {Number} idx\r\n     * @return {bbnCp|Boolean}\r\n     */\n    getNodeByIdx(idx) {\n      if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isNumber(idx) && this.nodes.length) {\n        return _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(this.nodes, {\n          idx: parseInt(idx)\n        });\n      }\n      return false;\n    },\n    /**\r\n     * Adds a node to the tree.\r\n     * @param {Object} obj The item to add.\r\n     * Returns {Boolean|Object}\r\n     */\n    addNode(obj) {\n      if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isObject(obj)) {\n        obj = this._map([obj])[0];\n        obj._bbn = true;\n        obj.index = this.currentData.length;\n        this.currentData.push(obj);\n        return obj;\n      }\n      return false;\n    },\n    /**\r\n     * Returns the menu of the given node.\r\n     * @method getMenu\r\n     * @param {Object} node\r\n     * @fires reload\r\n     * @fires menu\r\n     * @return {Array}\r\n     */\n    getMenu(node) {\n      let menu = [],\n        tree = node.getRef('tree');\n      if (node.numChildren) {\n        menu.push({\n          text: node.isExpanded ? _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Close\") : _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Open\"),\n          icon: node.isExpanded ? 'nf nf-fa-arrow_circle_up' : 'nf nf-fa-arrow_circle_down',\n          action: () => {\n            node.isExpanded = !node.isExpanded;\n          }\n        });\n      }\n      if (this.isAjax && node.numChildren && tree && tree.isLoaded) {\n        menu.push({\n          text: _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Refresh\"),\n          icon: 'nf nf-fa-refresh',\n          action: () => {\n            this.reload(node);\n          }\n        });\n      }\n      if (this.menu) {\n        let m2 = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(this.menu) ? this.menu(node, node.idx) : this.menu;\n        if (m2.length) {\n          _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(m2, function (a, i) {\n            menu.push({\n              text: a.text,\n              icon: a.icon ? a.icon : '',\n              action: a.action\n            });\n          });\n        }\n      }\n      return menu;\n    },\n    /**\r\n     * Returns an object with the data to send for a given node.\r\n     * If UID has been given obj will only have this prop other the whole data object.\r\n     * @method getPostData\r\n     * @fires data\r\n     * @return {Object}\r\n     */\n    getPostData() {\n      // The final object to send\n      let r = {},\n        uid = this.uid || this.tree.uid;\n      // If the uid field is defined\n      if (uid) {\n        // If an item has been given we send the corresponding data, or otherwise an empty string\n        if (this.node) {\n          r[uid] = this.node.data && this.node.data[uid] ? this.node.data[uid] : '';\n        } else if (this.isRoot) {\n          r[uid] = this.root ? this.root : '';\n        }\n      } else if (this.node) {\n        r = this.node.data;\n      }\n      if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(this.tree.data)) {\n        r = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.extend(true, {}, this.tree.data(this.node ? this.node.data : {}), r);\n      } else {\n        r = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.extend(true, {}, this.tree.data, r);\n      }\n      return r;\n    },\n    /**\r\n     * Manages the key navigation inside the tree.\r\n     * @method keyNav\r\n     * @param {Event} e The event\r\n     */\n    keyNav(e) {\n      this.tree.$emit('keynav', e.key);\n      if (this.tree.activeNode) {\n        let parent = this.tree.activeNode.parent;\n        let data = parent.filteredData.filter(d => !!d.visible);\n        let min = 0;\n        let max = data.length - 1;\n        let idx = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.search(data, {\n          index: this.tree.activeNode.idx\n        });\n        let subtree = this.tree.activeNode.getRef('tree');\n        switch (e.key) {\n          case 'Enter':\n          case ' ':\n            if (this.tree.activeNode.selectable) {\n              this.tree.activeNode.isSelected = !this.tree.activeNode.isSelected;\n            } else {\n              let ev = new Event('nodeclick', {\n                cancelable: true\n              });\n              this.tree.$emit('nodeclick', this.tree.activeNode, ev);\n            }\n            break;\n          case 'PageDown':\n          case 'End':\n            if (data.length) {\n              _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(parent.nodes, {\n                idx: data[data.length - 1].index\n              }).isActive = true;\n              this.scrollToActive();\n            }\n            break;\n          case 'PageUp':\n          case 'Home':\n            if (data.length) {\n              _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(parent.nodes, {\n                idx: data[0].index\n              }).isActive = true;\n              this.scrollToActive();\n            }\n            break;\n          case 'ArrowLeft':\n            if (this.tree.activeNode.numChildren && this.tree.activeNode.isExpanded) {\n              this.tree.activeNode.isExpanded = false;\n            } else if (!this.tree.activeNode.parent.isRoot) {\n              this.tree.activeNode.parent.node.isActive = true;\n              this.scrollToActive();\n            }\n            break;\n          case 'ArrowRight':\n            if (this.tree.activeNode.numChildren) {\n              if (!this.tree.activeNode.isExpanded) {\n                this.tree.activeNode.isExpanded = true;\n              } else if (subtree && subtree.nodes.length) {\n                _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(subtree.nodes, {\n                  idx: subtree.filteredData[0].index\n                }).isActive = true;\n                this.scrollToActive();\n              }\n            }\n            break;\n          case 'ArrowDown':\n            if (idx + 1 <= max) {\n              _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(parent.nodes, {\n                idx: data[idx + 1].index\n              }).isActive = true;\n              this.scrollToActive();\n            } else if (parent.node && parent.node.parent) {\n              data = parent.node.parent.filteredData.filter(d => !!d.visible);\n              idx = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.search(data, {\n                index: parent.node.idx\n              });\n              if (idx > -1 && data[idx + 1]) {\n                _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(parent.node.parent.nodes, {\n                  idx: data[idx + 1].index\n                }).isActive = true;\n                this.scrollToActive();\n              }\n            }\n            break;\n          case 'ArrowUp':\n            if (idx - 1 >= min) {\n              _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(parent.nodes, {\n                idx: data[idx - 1].index\n              }).isActive = true;\n              this.scrollToActive();\n            } else if (!parent.isRoot && parent.node) {\n              parent.node.isActive = true;\n              this.scrollToActive();\n            }\n            break;\n        }\n      } else if (this.tree.selectedNode) {\n        this.tree.activeNode = this.tree.selectedNode;\n        this.scrollToActive();\n      } else if (this.tree.filteredData.length) {\n        _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getRow(this.tree.nodes, {\n          idx: this.tree.filteredData[0].index\n        }).isActive = true;\n        this.scrollToActive();\n      }\n    },\n    /**\r\n     * Reloads a node already loaded.\r\n     * @method reload\r\n     * @param {bbnCp} node\r\n     * @fires updateData\r\n     */\n    reload(node) {\n      //if ( this.isAjax ){\n      if (this.isRoot && !node) {\n        this.isLoaded = false;\n        return this.init();\n      } else {\n        node = !node ? this.node : node;\n        let tree = node.getRef('tree');\n        if (tree) {\n          tree.isLoaded = false;\n          return tree.updateData();\n        }\n      }\n      //}\n    },\n    /**\r\n     * Loads a node.\r\n     * @method load\r\n     * @fires updateData\r\n     */\n    load() {\n      this.updateData();\n    },\n    getNodeByUid(uid) {\n      let res = false;\n      if (this.uid) {\n        _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(this.findAll('bbn-tree-node'), e => {\n          if (e.source && e.source.data && e.source.data[this.uid] === uid) {\n            res = e;\n            return false;\n          }\n        });\n      }\n      return res;\n    },\n    /**\r\n     * Returns the node's path.\r\n     * @method getNodePath\r\n     * @param {Object} node\r\n     * @param {String} field\r\n     */\n    getNodePath(node, field) {\n      let f = field || this.uid || false,\n        obj = Object.keys(node.data).length ? _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.extend(true, {}, node.data) : false,\n        fromObj = !f || node.data[f] === undefined;\n      if (!fromObj || obj) {\n        let r = [fromObj ? obj : node.data[f]],\n          tree = node.parent;\n        while (tree && tree !== this) {\n          node = tree.node;\n          r.unshift(fromObj ? _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.extend(true, {}, node.data) : node.data[f]);\n          tree = node.parent;\n        }\n        return r;\n      }\n      return false;\n    },\n    /**\r\n     * Unselects the currently selected node.\r\n     * @method unselect\r\n     */\n    unselect() {\n      if (this.tree.selectedNode) {\n        this.tree.selectedNode.isSelected = false;\n        if (!this.multiple) {\n          this.$emit('unselect', this);\n        }\n      }\n    },\n    /**\r\n     * Deactivate the active nodes.\r\n     * @method deactivateAll\r\n     */\n    deactivateAll() {\n      if (this.tree.activeNode) {\n        this.tree.activeNode.isActive = true;\n      }\n    },\n    /**\r\n     * Returns true if the first argument node descends from the second.\r\n     * @method isNodeOf\r\n     * @param {Object} childNode\r\n     * @param {Object} parentNode\r\n     * @return {Boolean}\r\n     */\n    isNodeOf(childNode, parentNode) {\n      childNode = childNode.closest('bbn-tree-node');\n      while (childNode) {\n        if (childNode === parentNode) {\n          return true;\n        }\n        childNode = childNode.closest('bbn-tree-node');\n      }\n      return false;\n    },\n    /**\r\n     *  Moves a node to or inside a tree.\r\n     * @method move\r\n     * @param {Object} node\r\n     * @param {Object} target\r\n     * @param {Boolean} [false] force\r\n     */\n    move(node, target, force = false) {\n      // initializing and sending an event cancelable if force is false\n      let ev = new Event(\"move\", {\n        cancelable: !force\n      });\n      this.tree.$emit('move', node, target, ev);\n      // if the action has not been prevented\n      if (!ev.defaultPrevented) {\n        // getting the parent of the source node\n        let parent = node.parent;\n        // getting the position of the source node\n        let idx = !!node.parent ? _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.search(parent.currentData, {\n          index: node.idx\n        }) : -1;\n        // getting all the nodes at a lower level than the source node\n        let nodes = node.findAll('bbn-tree-node');\n        // filtered by those who are expanded\n        let expanded = nodes.filter(n => !!n.isExpanded);\n        // and by those who are selected\n        let selected = nodes.filter(n => !!n.isSelected);\n        // verification if the node had parent et his index is greater than or equel to 0\n        if (idx >= 0 && parent) {\n          // if there is no children then we set the number of children to 1\n          if (!target.source.numChildren) {\n            target.$set(target.source, 'numChildren', 1);\n          }\n          // otherwhise we increase the number of children by one\n          else {\n            target.source.numChildren++;\n          }\n          // updating the DOM of VUE\n          this.$nextTick(() => {\n            // get the ref and put it in the targetTree\n            let targetTree = target.getRef('tree');\n            if (node.isExpanded) {\n              // if the node is expanded we're adding it to the expanded\n              expanded.unshift(node);\n            }\n            // if the node is selected we're adding it to the selected\n            if (node.isSelected) {\n              selected.unshift(node);\n            }\n            // If the source node is inside a parent node and is moved then we lower the number of children by one\n            if (parent.node) {\n              parent.node.numChildren--;\n            }\n            // adding the node and push it to the tree\n            if (this.tree.isAjax) {\n              let nodeSource = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.extend(true, {}, parent.currentData[idx]);\n              if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(this.transferData)) {\n                nodeSource = this.transferData(nodeSource);\n              }\n              let children = target.source.data[this.tree.children];\n              if (!children) {\n                target.source.data[this.tree.children] = [];\n                children = target.source.data[this.tree.children];\n              }\n              if (!target.isExpanded) {\n                targetTree.$once('dataloaded', () => {\n                  // adding in the node source the length of the target tree if there is no length then we set it at 1\n                  nodeSource.num = targetTree.currentData.length || 1;\n                  // we're adding the index also\n                  nodeSource.index = nodeSource.num - 1;\n                  // and then we push node source in the targetTree\n                  children.push(nodeSource);\n                });\n              } else {\n                // adding in the node source the length of the target tree if there is no length then we set it at 1\n                nodeSource.num = targetTree.currentData.length || 1;\n                // we're adding the index also\n                nodeSource.index = nodeSource.num - 1;\n                // and then we push node source in the targetTree\n                children.push(nodeSource);\n              }\n            } else {\n              let nodeSource = parent.source.splice(idx, 1)[0];\n              if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(this.transferData)) {\n                nodeSource = this.transferData(nodeSource);\n              }\n              // if the array is empty we set one\n              if (!_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isArray(target.source.data[this.tree.children])) {\n                target.$set(target.source.data, this.tree.children, []);\n              }\n              // otherwise we just push the data inside the array\n              target.source.data[this.tree.children].push(nodeSource);\n            }\n            // we remove the expanded node\n            _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(expanded, n => {\n              n.removeFromExpanded(false);\n            });\n            // we remove the selected node\n            _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(selected, n => {\n              n.removeFromSelected(false);\n            });\n            // remove the old node\n            parent.currentData.splice(idx, 1);\n            this.$nextTick(() => {\n              // if the target node isn't expanded we do it\n              if (!target.isExpanded) {\n                target.isExpanded = true;\n              }\n              // then we update the data\n              if (!this.tree.isAjax) {\n                let path = target.getPath();\n                targetTree.updateData().then(() => {\n                  targetTree.expandPath(path);\n                });\n              }\n            });\n          });\n        }\n      }\n    },\n    /**\r\n     * Returns an object with all the unknown properties of the node component.\r\n     * @param {Object} data\r\n     * @return {Object}\r\n     */\n    toData(data) {\n      let r = {};\n      for (let n in data) {\n        if (bbnTreeCp.NODE_PROPERTIES.indexOf(n) === -1) {\n          r[n] = data[n];\n        }\n      }\n      return r;\n    },\n    /**\r\n     * Returns the current configuration of the tree.\r\n     * @method getConfig\r\n     * @returns {Object}\r\n     */\n    getConfig() {\n      let cfg = {\n        expanded: [],\n        selected: [],\n        state: this.currentState\n      };\n      if (!this.uid) {\n        return cfg;\n      }\n      // Expanded\n      _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(this.currentExpanded, c => {\n        if (c.data && c.data[this.uid]) {\n          cfg.expanded.push(c.data[this.uid]);\n        }\n      });\n      // Selected\n      _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(this.currentSelected, c => {\n        if (c.data && c.data[this.uid] && (!!this.multiple || !cfg.selected.length)) {\n          cfg.selected.push(c.data[this.uid]);\n        }\n      });\n      return cfg;\n    },\n    /**\r\n     * Gets the local storage.\r\n     * @method getLocalStorage\r\n     */\n    getLocalStorage() {\n      if (this.isRoot && this.hasStorage) {\n        return this.getStorage(this.storageFullName || this.storageName, !!this.storageFullName);\n      }\n    },\n    /**\r\n     * Sets the local storage.\r\n     * @method setLocalStorage\r\n     */\n    setLocalStorage() {\n      let ev = new Event('setStorage', {\n          cancelable: true\n        }),\n        cfg = this.getConfig();\n      this.$emit('setStorage', cfg, this.storageFullName || this.storageName, ev);\n      if (!ev.defaultPrevented) {\n        this.setStorage(cfg, this.storageFullName || this.storageName, !!this.storageFullName);\n      }\n    },\n    /**\r\n     * Scrolls the tree to the selected node.\r\n     * @method scrollToSelected\r\n     */\n    scrollToSelected() {\n      if (this.tree && this.tree.selectedNode) {\n        let scroll = this.tree.getRef('scroll');\n        if (scroll) {\n          scroll.scrollTo(0, this.tree.selectedNode.$el);\n        }\n      }\n    },\n    /**\r\n     * Scrolls the tree to the active node.\r\n     * @method scrollToActive\r\n     */\n    scrollToActive() {\n      if (this.tree && this.tree.activeNode) {\n        let scroll = this.tree.getRef('scroll');\n        if (scroll) {\n          scroll.scrollTo(0, this.tree.activeNode.$el);\n        }\n      }\n    },\n    _setCurrentState(state) {\n      this.currentState = state;\n    },\n    initStorage() {\n      let state;\n      if (this.hasStorage && this.isRoot) {\n        let storage = this.getLocalStorage();\n        if (storage) {\n          state = storage.state || null;\n        }\n      } else if (this.state) {\n        state = this.state;\n      }\n      if (state) {\n        this._setCurrentState(state);\n      }\n    },\n    expandPath(path, field, select = false, time = 1) {\n      field = field || this.uid || false;\n      if (field && path && path.length) {\n        if (!_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isArray(path)) {\n          path = [path];\n        }\n        let currentPaths = path.slice(),\n          uid = currentPaths.shift(),\n          isLast = !currentPaths.length;\n        if (uid !== undefined) {\n          if (this.isLoading || !this.isLoaded) {\n            this.$once('dataloaded', () => {\n              this.$nextTick(() => {\n                this.expandPath(path, field, select);\n              });\n            });\n          } else if (this.isLoaded && !this.isLoading) {\n            this.$nextTick(() => {\n              let node = this.findNode({\n                [field]: uid\n              });\n              if (node) {\n                if (isLast && !!select) {\n                  node.isSelected = true;\n                } else if (!!node.numChildren) {\n                  let tree = node.getRef('tree');\n                  if (tree) {\n                    if (!node.isExpanded) {\n                      tree.$once('dataloaded', () => {\n                        this.$nextTick(() => {\n                          tree.expandPath(currentPaths, field, select);\n                        });\n                      });\n                      node.isExpanded = true;\n                    } else if (!isLast) {\n                      tree.expandPath(currentPaths, field, select);\n                    }\n                  }\n                }\n              } else if (time === 1) {\n                setTimeout(() => {\n                  this.expandPath(path, field, select, 2);\n                }, 100);\n              }\n            });\n          }\n        }\n      }\n    },\n    selectPath(path, field) {\n      this.expandPath(path, field, true);\n    },\n    initState() {\n      if ((this.node?.isExpanded || this.isRoot || _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.count(Object.values(this.currentState), {\n        expanded: true\n      }) || _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.count(Object.values(this.currentState), {\n        selected: true\n      })) && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.numProperties(this.currentState) && this.filteredData.length) {\n        setTimeout(() => {\n          let hasSelected = false;\n          _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.iterate(this.currentState, (o, uid) => {\n            let it = this.uid !== undefined ? this.findNode({\n              [this.uid]: uid\n            }) : false;\n            if (it) {\n              if (o.items && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.numProperties(o.items) || o.expanded) {\n                it.isExpanded = true;\n              }\n              if (o.selected) {\n                if (it.selectable && (this.multiple || !hasSelected)) {\n                  it.isSelected = true;\n                  hasSelected = true;\n                } else {\n                  o.selected = false;\n                }\n              }\n            } else {\n              delete this.currentState[uid];\n            }\n          });\n        }, 50);\n      }\n    },\n    /**\r\n     * @method init\r\n     * @fires updateData\r\n     * @fires initState\r\n     */\n    init() {\n      if (this.node.isExpanded || this.isRoot || _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.count(Object.values(this.currentState), {\n        expanded: true\n      }) || _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.count(Object.values(this.currentState), {\n        selected: true\n      })) {\n        return this.updateData().then(() => {\n          this.isInit = true;\n          this.initState();\n        });\n      } else {\n        this.isInit = true;\n      }\n    },\n    /**\r\n     * Keep to prevent the one from list to exexute\r\n     * @method listOnBeforeMount\r\n     */\n    listOnBeforeMount() {\n      return;\n    },\n    /**\r\n     * @method afterUpdate\r\n     * @event dataloaded\r\n     * @fires $nextTick\r\n     * @fires initState\r\n     */\n    afterUpdate() {\n      if (!this.isLoaded && this.ready && !this.tree.autobind) {\n        this.$once('dataloaded', () => {\n          this.$nextTick(this.initState);\n        });\n      }\n    },\n    clickMenuItem(node, item, ev) {\n      if (item.action) {\n        item.action.bind(this.tree.$origin)(node, ev);\n      }\n    }\n  },\n  /**\r\n   * Emits the event beforeLoad and load. And opens the nodes defined in the prop path.\r\n   * Definition of the root tree and parent node.\r\n   * @event beforeupdate\r\n   * @event startloading\r\n   * @event datareceived\r\n   * @emits tree,beforeLoad\r\n   * @emits load\r\n   * @fires closest\r\n   */\n  created() {\n    this.$on('beforeupdate', e => {\n      if (this.isAjax && (this.tree.isLoading || this.isLoading)) {\n        e.preventDefault();\n      }\n      if (!e.defaultPrevented) {\n        this.tree.$emit('beforeload', this.getPostData());\n      }\n    });\n    this.$on('startloading', () => {\n      this.loading = true;\n    });\n    this.$on('datareceived', d => {\n      this.loading = false;\n      this.tree.$emit('load', d);\n    });\n    this.$on('dataloaded', d => {\n      this.tree.$emit('afterload', d);\n    });\n    if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(this.source)) {\n      this.isFunction = true;\n    }\n    let cp = this.closest('bbn-tree');\n    if (!cp) {\n      this.isRoot = true;\n      this.node = false;\n      this.tree = this;\n    } else {\n      while (cp && cp.level) {\n        cp = cp.closest('bbn-tree');\n      }\n      if (cp && !cp.level) {\n        this.tree = cp;\n        this.isAjax = this.tree.isAjax && !this.tree.hybrid;\n      }\n      this.node = this.closest('bbn-tree-node');\n    }\n  },\n  /**\r\n   * Updates the data of the tree and sets the prop 'ready' to true.\r\n   * @event mounted\r\n   * @fires updateData\r\n   */\n  mounted() {\n    this.ready = true;\n    this.initStorage();\n    if (this.tree.autobind) {\n      this.$forceUpdate().then(() => {\n        this.init();\n      });\n    } else {\n      this.isInit = true;\n    }\n  },\n  watch: {\n    /**\r\n     *\r\n     * @param {Object} newVal\r\n     */\n    activeNode(newVal) {\n      if (newVal && this.isRoot) {\n        let scroll = this.getRef('scroll');\n        if (scroll) {\n          //scroll.scrollTo(0, newVal.$el);\n        }\n      }\n    },\n    selectedNode(newVal) {\n      if (newVal && this.isRoot) {\n        let scroll = this.getRef('scroll');\n        if (scroll) {\n          //scroll.scrollTo(0, newVal.$el);\n        }\n      }\n    },\n    /**\r\n     * Updates the ree overNode and overOrder when the prop 'dragging' changes.\r\n     * @param {Boolean} newVal\r\n     */\n    dragging(newVal) {\n      if (!newVal) {\n        this.overNode = false;\n        this.overOrder = false;\n      }\n    },\n    quickFilter(newVal) {\n      if (!this.isAjax && this.nodes.length) {\n        _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(this.nodes, n => {\n          n.isExpanded = !!newVal.length;\n        });\n      }\n    }\n  },\n  components: {\n    /**\r\n     * @component bbn-tree-node\r\n     */\n    node: {\n      tag: 'li',\n      props: {\n        /**\r\n         * @prop {String} filterString\r\n         * @memberof bbn-tree-node\r\n         */\n        filterString: {\n          type: String\n        },\n        /**\r\n         * @prop {Boolean} [false] excludedSectionFilter\r\n         * @memberof bbn-tree-node\r\n         */\n        excludedSectionFilter: {\n          type: Boolean,\n          default: false\n        },\n        /**\r\n         * True if the node is selectable\r\n         * @prop {Boolean} [true] selectable\r\n         * @memberof bbn-tree-node\r\n         */\n        selectable: {\n          type: Boolean,\n          default: false\n        },\n        multiple: {\n          type: Boolean,\n          default: false\n        },\n        /**\r\n         * True if the node is selection\r\n         * @prop {Boolean} [false] selection\r\n         * @memberof bbn-tree-node\r\n         */\n        selection: {\n          type: Boolean,\n          default: true\n        },\n        /**\r\n         * The opened path if there is one\r\n         * @prop {Array} [[]] path\r\n         * @memberof bbn-tree-node\r\n         */\n        path: {\n          type: Array,\n          default() {\n            return [];\n          }\n        },\n        /**\r\n         * A component for the node\r\n         * @prop {String|Function|bbnCp} component\r\n         * @memberof bbn-tree-node\r\n         */\n        component: {\n          type: [String, Function, bbnCp, Object]\n        },\n        /**\r\n         * The list of children from the node\r\n         * @prop {Array} [[]] source\r\n         * @memberof bbn-tree-node\r\n         */\n        source: {\n          type: Object,\n          default() {\n            return {};\n          }\n        },\n        /**\r\n         * Node's level (see tree)\r\n         * @prop {Number} [1] level\r\n         * @memberof bbn-tree-node\r\n         */\n        level: {\n          type: Number,\n          default: 1\n        },\n        /**\r\n         * @prop {Number} idx\r\n         * @memberof bbn-tree-node\r\n         */\n        idx: {\n          type: Number\n        },\n        quickFilter: {\n          type: String,\n          default: ''\n        },\n        sortable: {\n          type: Boolean,\n          default: true\n        },\n        uid: {\n          type: String\n        },\n        treeState: {\n          type: Object,\n          default() {\n            return {};\n          }\n        },\n        flat: {\n          type: Boolean,\n          default: false\n        }\n      },\n      data() {\n        return {\n          ready: false,\n          /**\r\n                     * @data {Boolean} [false] doubleClk\r\n                     * @memberof bbn-tree-node\r\n                     */\n          doubleClk: false,\n          /**\r\n          * The parent tree\r\n          * @data {Boolean} [false] parent\r\n          * @memberof bbn-tree-node\r\n          */\n          parent: false,\n          /**\r\n           * The root tree\r\n           * @data {Boolean} [false] tree\r\n           * @memberof bbn-tree-node\r\n           */\n          tree: false,\n          /**\r\n           * True if the node is active\r\n           * @data {Boolean} [false] isActive\r\n           * @memberof bbn-tree-node\r\n           */\n          isActive: false,\n          /**\r\n           * The animation of the node\r\n           * @data {Boolean} animation\r\n           * @memberof bbn-tree-node\r\n           */\n          animation: this.level > 0,\n          /**\r\n           * True if the component bbn-tree-node is mounted\r\n           * @data {Boolean} [false] isMounted\r\n           * @memberof bbn-tree-node\r\n           */\n          isMounted: false,\n          orderOver: false\n        };\n      },\n      computed: {\n        isOverOrderTop() {\n          return this.tree && this.tree.realDragging && this.tree.overOrder && this.tree.overOrder === this.getRef('orderTop');\n        },\n        isOverOrderBottom() {\n          return this.tree && this.tree.realDragging && this.tree.overOrder && this.tree.overOrder === this.getRef('orderBottom');\n        },\n        data() {\n          return this.source.data;\n        },\n        isVisible() {\n          let tree = this.getRef('tree');\n          return !this.quickFilter || this.source.text.toLowerCase().includes(this.quickFilter.toLowerCase()) && (!this.numChildren || !this.tree.excludedSectionFilter || tree && tree.nodes && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.filter(tree.nodes, n => !!n.isVisible).length) || tree && tree.nodes && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.filter(tree.nodes, n => !!n.isVisible).length;\n        },\n        isExpanded: {\n          get() {\n            return !!this.source.expanded;\n          },\n          set(v) {\n            this.source.expanded = v;\n          }\n        },\n        isSelected: {\n          get() {\n            return !!this.source.selected;\n          },\n          set(v) {\n            this.source.selected = v;\n          }\n        },\n        isFilterable() {\n          return this.source.filterable !== undefined ? !!this.source.filterable : !!this.tree.filterable;\n        },\n        hasFilters() {\n          let tree = this.getRef('tree');\n          return tree && tree.hasFilters;\n        },\n        numChildren: {\n          get() {\n            return this.source.numChildren;\n          },\n          set(v) {\n            this.source.numChildren = v;\n          }\n        },\n        /**\r\n         * The style of the item's icon\r\n         * @computed iconStyle\r\n         * @return {Object}s\r\n         * @memberof bbn-tree-node\r\n         */\n        iconStyle() {\n          let style = {};\n          if (this.tree.iconColor) {\n            style.color = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(this.tree.iconColor) ? this.tree.iconColor(this) : this.tree.iconColor;\n          }\n          return style;\n        },\n        /**\r\n         * @computed menu\r\n         * @return {Array}\r\n         * @memberof bbn-tree-node\r\n         */\n        menu() {\n          return this.getMenu();\n        },\n        textFromText() {\n          if (this.source.data.text) {\n            return _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.html2text(this.source.data.text);\n          }\n          return '';\n        }\n      },\n      methods: {\n        randomString: _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.randomString,\n        /**\r\n         * Return true if the node is checked\r\n         * @method isChecked\r\n         * @memberof bbn-tree-node\r\n         */\n        isChecked(uid) {\n          return this.tree.checked.includes(uid);\n        },\n        /**\r\n         * Return true if the node is disabled\r\n         * @method isDisabled\r\n         * @memberof bbn-tree-node\r\n         */\n        isDisabled() {\n          return this.tree.disabled.includes(this.data[this.tree.uid]);\n        },\n        /**\r\n         * Checks the node and emits the events check and uncheck\r\n         * @method checkNode\r\n         * @emits check\r\n         * @emits uncheck\r\n         * @memberof bbn-tree-node\r\n         */\n        checkNode(val) {\n          if (val && this.data[this.tree.uid] && !this.tree.checked.includes(this.data[this.tree.uid])) {\n            this.tree.checked.push(this.data[this.tree.uid]);\n            this.tree.$emit('check', this.data[this.tree.uid]);\n          } else if (!val) {\n            let tmp = this.tree.checked.indexOf(this.data[this.tree.uid]);\n            if (tmp > -1) {\n              this.tree.checked.splice(tmp, 1);\n              this.tree.$emit('uncheck', this.data[this.tree.uid]);\n            }\n          }\n        },\n        /**\r\n         * Activate the node\r\n         * @method activate\r\n         * @memberof bbn-tree-node\r\n         */\n        activate() {\n          this.isActive = true;\n        },\n        update(attr) {\n          for (let n in attr) {\n            this[n] = attr[n];\n          }\n        },\n        /**\r\n         * Resize the parent tree\r\n         * @method tree.resize\r\n         * @memberof bbn-tree-node\r\n         * @memberof bbn-tree-node\r\n         */\n        resize() {\n          this.tree.resize();\n        },\n        reload() {\n          this.tree.reload(this);\n        },\n        /**\r\n         * Gets the menu of the parent tree\r\n         * @method getMenu\r\n         * @memberof bbn-tree-node\r\n         * @fires tree.getMenu\r\n         */\n        getMenu() {\n          return this.tree.getMenu(this);\n        },\n        beforeEnter() {\n          if (this.animation) {\n            //alert(\"beforeEnter \" + $(this.$refs.container).height());\n          }\n        },\n        enter() {\n          if (this.animation) {\n            //alert(\"enter \" + $(this.$refs.container).height());\n          }\n        },\n        afterEnter() {\n          if (this.animation) {\n            //alert(\"afterEnter \" + $(this.$refs.container).height());\n          }\n        },\n        /**\r\n         * Handles the start of dragging of the tree\r\n         * @method startDrag\r\n         * @param {Event} e The event\r\n         * @emits tree.dragstart\r\n         * @memberof bbn-tree-node\r\n         */\n        startDrag(e) {\n          if ((this.tree.draggable || this.sortable) && !this.tree.realDragging) {\n            if (this.tree.selectedNode) {\n              //this.tree.selectedNode.isSelected = false;\n            }\n            this.tree.$emit(\"dragstart\", this, e);\n            if (!e.defaultPrevented) {\n              this.tree.dragging = this;\n              this.tree.realDragging = true;\n              if (this.tree.droppableTrees.length) {\n                _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(this.tree.droppableTrees, dt => {\n                  if (dt !== this.tree) {\n                    dt.dragging = this;\n                  }\n                });\n              }\n            }\n          } else {\n            e.preventDefault();\n          }\n        },\n        /**\r\n         * Handles the dragging of the node\r\n         * @method drag\r\n         * @param {Event} e The event\r\n         * @emits tree.dragstart\r\n         * @emits  dragover\r\n         * @memberof bbn-tree-node\r\n         */\n        drag(e) {\n          this.mouseOver();\n          // we prevent default from the event\n          if (this.sortable) {\n            if (e.target.classList.contains('bbn-tree-order')) {\n              if (this.tree.overOrder !== e.target) {\n                this.tree.overOrder = e.target;\n              }\n            } else {\n              this.tree.overOrder = false;\n            }\n          }\n          if (!!this.tree.dragging) {\n            let subTree = this.getRef('tree');\n            if (!!this.tree.overNode && this === this.tree.overNode && this !== this.tree.dragging && !this.tree.isNodeOf(this, this.tree.dragging) && (!subTree || subTree !== this.parent)) {\n              this.tree.$emit(\"dragover\", this, this.tree.dragging, e);\n              if (e.defaultPrevented) {\n                this.tree.overNode = false;\n              }\n            } else {\n              this.tree.overNode = false;\n            }\n          }\n        },\n        /**\r\n         * Handles the leave of dragging\r\n         * @method leaveDrag\r\n         * @param {Event} e The event\r\n         * @memberof bbn-tree-node\r\n         */\n        leaveDrag(e) {\n          this.tree.overNode = false;\n        },\n        /**\r\n         * Handles the drop of dragging\r\n         * @method drop\r\n         * @param {Event} e The event\r\n         * @emits dragend\r\n         * @memberof bbn-tree-node\r\n         */\n        drop(e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          if (this.tree.dragging && this.tree.overNode && this === this.tree.overNode) {\n            let ev = new CustomEvent('drop', {\n              cancelable: true,\n              bubbles: true,\n              detail: e.detail\n            });\n            let originalTree = this.tree.dragging.tree;\n            this.tree.$emit('drop', this.tree.dragging, this, ev);\n            if (!ev.defaultPrevented) {\n              if (this.tree.overOrder) {\n                let numBefore = this.tree.dragging.source.num,\n                  numAfter = this.tree.overOrder.classList.contains('bbn-tree-order-top') ? 1 : this.tree.overNode.source.num + (numBefore > this.tree.overNode.source.num ? 1 : 0);\n                if (numBefore !== numAfter && this.tree.dragging.parent === this.tree.overNode.parent) {\n                  this.reorder(this.tree.dragging.source.num, numAfter);\n                }\n              } else if (this.tree.draggable && this.tree.dragging.parent !== this.tree.overNode) {\n                originalTree.move(this.tree.dragging, this);\n              }\n            }\n          }\n          let ev = new CustomEvent('dragend', {\n            cancelable: true,\n            bubbles: true\n          });\n          this.tree.$emit('dragend', ev);\n        },\n        /**\r\n         * Handles the end of dragging\r\n         * @method endDrag\r\n         * @param {Event} e The event\r\n         * @emits tree.dragend\r\n         * @memberof bbn-tree-node\r\n         */\n        endDrag(e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          let ev = new CustomEvent('dragend', {\n            cancelable: true,\n            bubbles: true\n          });\n          this.tree.$emit('dragend', this.source, ev);\n          if (!ev.defaultPrevented) {\n            _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(this.tree.dragging.tree.droppableTrees, dt => {\n              dt.overNode = false;\n              dt.realDragging = false;\n              dt.dragging = false;\n            });\n            if (!!this.tree.dragging && !this.tree.dragging.tree.selfDrop) {\n              this.tree.dragging.tree.overNode = false;\n              this.tree.dragging.tree.realDragging = false;\n              this.tree.dragging.tree.dragging = false;\n            }\n          }\n        },\n        // the args are the old index the new index and if we force the reorder or not\n        reorder(oldNum, newNum, force) {\n          // checking if the indexes are the same to order or not the data\n          if (oldNum !== newNum) {\n            // arr became the filteredData i don't know what the slice is for\n            let arr = this.parent.filteredData.slice();\n            // remove the data at old index\n            let ele = arr.splice(oldNum - 1, 1);\n            // create a new event beforeOrder that is cancelable\n            let ev = new Event('beforeOrder', {\n              cancelable: true\n            });\n            // if there is datas in ele\n            if (ele.length) {\n              // and force is false\n              if (!force) {\n                // we call the event beforeOrfer\n                this.tree.$emit('beforeOrder', oldNum, newNum, this.tree.dragging, ev);\n              }\n              if (!!force || !ev.defaultPrevented) {\n                // remove the data at the index\n                arr.splice(newNum - 1, 0, ele[0]);\n                _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.each(arr, (e, i) => {\n                  // and add the data\n                  if (e.num !== i + 1) {\n                    let data = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.extend(true, {}, e.data);\n                    e.num = i + 1;\n                    if (e.data.num !== undefined) {\n                      //e.data.num = e.num;\n                    }\n                    // then it orders is\n                    this.tree.$emit('order', data, e.num);\n                  }\n                });\n                //this.parent.updateData();\n              }\n            }\n          }\n        },\n        /**\r\n         * Defines the parent tree overNode\r\n         * @method mouseOver\r\n         * @memberof bbn-tree-node\r\n         */\n        mouseOver() {\n          this.tree.overNode = this.tree.dragging && this !== this.tree.dragging && (this.tree.draggable || this.sortable) ? this : false;\n        },\n        /**\r\n         * @method checkPath\r\n         * @memberof bbn-tree-node\r\n         */\n        checkPath() {\n          return;\n          if (this.tree.path.length > this.level) {\n            let item = this.tree.path.slice(this.level, this.level + 1)[0],\n              type = typeof item,\n              match = false;\n            if (type === 'object' && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.search([this.data], item) === 0) {\n              match = true;\n            } else if (this.tree.uid && this.data[this.tree.uid] && this.data[this.tree.uid] === item) {\n              match = true;\n            } else if (type === 'number' && this.idx === item) {\n              match = true;\n            }\n            if (match) {\n              if (this.tree.path.length > this.level + 1) {\n                this.isExpanded = true;\n              } else {\n                if (this.numChildren) {\n                  this.isExpanded = true;\n                }\n                this.isSelected = true;\n                this.tree.$refs.scroll.scrollTo(0, this.$el);\n              }\n            }\n          }\n        },\n        // this function get the fullPath where you path the separtor as arguments\n        getFullPath(separator, field) {\n          let f = field || this.uid || false;\n          if (f) {\n            let st = '';\n            let p = this;\n            while (p && p.$is('bbn-tree-node')) {\n              if (p.data[f]) {\n                if (p !== this) {\n                  st = separator + st;\n                }\n                st = p.data[f] + st;\n                p = p.parent.$parent;\n              } else {\n                return false;\n              }\n            }\n            return st;\n          }\n          return false;\n        },\n        getPath(field) {\n          return this.tree.getNodePath(this, field);\n        },\n        addToSelected(emit = true, storage = true) {\n          // if the current node isn't already selected\n          if (!this.tree.currentSelected.includes(this)) {\n            let sameParent = this.tree.selectedNode && this.tree.selectedNode.parent === this.parent;\n            if (this.tree.selectedNode && !this.tree.multiple || sameParent && !this.parent.multiple) {\n              this.tree.selectedNode.isSelected = false;\n            }\n            // initializing and calling the event beforeSelect\n            let ev = new Event('beforeSelect', {\n              cancelable: true\n            });\n            if (emit) {\n              this.tree.$emit('beforeSelect', this, ev);\n            }\n            if (!ev.defaultPrevented) {\n              // adding the node to selected\n              this.tree.currentSelected.push(this);\n              // call the event select\n              if (emit) {\n                this.tree.$emit('select', this);\n              }\n              // adding the node selected\n              if (this.tree !== this.parent) {\n                this.parent.currentSelected.push(this);\n                if (emit) {\n                  // call the event select\n                  this.parent.$emit('select', this);\n                }\n              }\n              if (!!this.uid) {\n                // getting all the nodes from root until this\n                let path = this.tree.getNodePath(this);\n                // Set the 'selected' property to true for this node on currentState\n                path.reduce((o, uid) => {\n                  if (!uid || !o) {\n                    return undefined;\n                  }\n                  if (o[uid] === undefined) {\n                    o[uid] = {\n                      expanded: false,\n                      items: {},\n                      selected: false\n                    };\n                  }\n                  if (uid === this.data[this.uid] && !o[uid].selected) {\n                    o[uid].selected = true;\n                  }\n                  return o[uid].items;\n                }, this.tree.currentState);\n              }\n              if (storage) {\n                this.$nextTick(() => {\n                  // and put it in the local storage\n                  this.tree.setLocalStorage();\n                });\n              }\n            }\n          }\n        },\n        removeFromSelected(emit = true, storage = true) {\n          // getting index of the currentTree select dans its parent\n          let idx = this.tree.currentSelected.indexOf(this);\n          let idx2 = this.parent.currentSelected.indexOf(this);\n          // initializing and sending an event cancelable if emit is false\n          let ev = new Event('beforeUnselect', {\n            cancelable: true\n          });\n          if (emit) {\n            // if emit is here we call the event beforeUnselect\n            this.tree.$emit('beforeUnselect', this, ev);\n          }\n          if (!ev.defaultPrevented) {\n            let path = [];\n            if (!!this.uid) {\n              // getting all the nodes from root until this\n              path = this.tree.getNodePath(this);\n            }\n            // if the tree is selected\n            if (idx > -1) {\n              // we remove it\n              this.tree.currentSelected.splice(idx, 1);\n              if (emit && (this.multiple || !this.tree.currentSelected.length)) {\n                this.tree.$emit('unselect', this);\n              }\n            }\n            // if the tree is selected and different from his parent\n            if (idx2 > -1 && this.tree !== this.parent) {\n              // we remove it and call the event unselect\n              this.parent.currentSelected.splice(idx, 1);\n              if (emit && (this.multiple || !this.tree.currentSelected.length)) {\n                this.parent.$emit('unselect', this);\n              }\n            }\n            if (!!this.uid) {\n              // uid of the last node\n              let last = path[path.length - 1];\n              // Set the 'selected' property to false for this node on currentState\n              path.reduce((o, uid) => {\n                if (!uid || !o) {\n                  return undefined;\n                }\n                if (o[uid]) {\n                  if (uid === last) {\n                    o[uid].selected = false;\n                    if (!_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.numProperties(o[uid].items) && !o[uid].expanded) {\n                      delete o[uid];\n                    }\n                  }\n                }\n                return !!o[uid] ? o[uid].items : false;\n              }, this.tree.currentState);\n            }\n            if (storage) {\n              // if storage exists we call setLocalStorage\n              this.$nextTick(() => {\n                this.tree.setLocalStorage();\n              });\n            }\n          }\n        },\n        addToExpanded(emit = true, storage = true) {\n          if (!this.tree.currentExpanded.includes(this)) {\n            // initializing and sending a cancelable event if emit is true\n            let ev;\n            if (emit) {\n              ev = new Event('beforeUnfold', {\n                cancelable: true\n              });\n              this.tree.$emit('beforeUnfold', this, ev);\n            }\n            if (!emit || !ev.defaultPrevented) {\n              // adding to the list of nodes that are currently expanded\n              this.tree.currentExpanded.push(this);\n              // if storage is true we update its content\n              // if emit is true we call unfold event\n              if (emit) {\n                this.tree.$emit('unfold', this);\n              }\n              // Starting from the parent\n              let parent = this.parent;\n              // going up until there is no parent anymore\n              while (parent && parent !== this.tree) {\n                // adding itself to the currentExpanded\n                parent.currentExpanded.push(this);\n                // parent becomes the next parent tree if it exists otherwise it's null\n                parent = parent.node ? parent.node.parent : null;\n              }\n              if (!!this.uid) {\n                // getting all the nodes from root until this\n                let path = this.tree.getNodePath(this);\n                // Adds for each of them the expanded property and sets to true\n                path.reduce((o, uid) => {\n                  if (!uid || !o) {\n                    return undefined;\n                  }\n                  if (o[uid] === undefined) {\n                    o[uid] = {\n                      expanded: true,\n                      items: {},\n                      selected: false\n                    };\n                  } else if (!o[uid].expanded) {\n                    o[uid].expanded = true;\n                  }\n                  return o[uid].items;\n                }, this.tree.currentState);\n              }\n              if (storage) {\n                this.$nextTick(() => {\n                  this.tree.setLocalStorage();\n                });\n              }\n              return true;\n            }\n          }\n          return false;\n        },\n        removeFromExpanded(emit = true, storage = true) {\n          // Getting the index of the tree which is expanded\n          let idx = this.tree.currentExpanded.indexOf(this);\n          // If the function indexOf works and return a good index\n          if (idx > -1) {\n            let ev;\n            if (emit) {\n              ev = new Event('beforeFold', {\n                cancelable: true\n              });\n              this.tree.$emit('beforeFold', this, ev);\n            }\n            // Initializing and sending an event cancelable if emit is true\n            // if the action has not been prevented\n            if (!emit || !ev.defaultPrevented) {\n              let path = [];\n              if (!!this.uid) {\n                // Getting all the nodes from root until this\n                path = this.tree.getNodePath(this);\n              }\n              // Starting from the parent\n              let parent = this.parent;\n              // Going up until there is no parent anymore\n              while (parent && parent !== this.tree) {\n                // Getting the index of the first parent after tree\n                let idx2 = parent.currentExpanded.indexOf(this);\n                if (idx2 > -1) {\n                  // If the return of the function allows it we remove it from the currentExpanded\n                  parent.currentExpanded.splice(idx2, 1);\n                }\n                // Parent becomes the next parent tree if it exists otherwise it's null\n                parent = parent.node ? parent.node.parent : null;\n              }\n\n              // And suppress the root currentExpanded\n              this.tree.currentExpanded.splice(idx, 1);\n              if (!!this.uid) {\n                // uid of the last node\n                let last = path[path.length - 1];\n                // for each nodes which has the expanded property setted to true it's setted to false\n                path.reduce((o, uid) => {\n                  if (!uid || !o) {\n                    return undefined;\n                  }\n                  if (o[uid]) {\n                    if (uid === last) {\n                      o[uid].expanded = false;\n                      if (!o[uid].selected) {\n                        delete o[uid];\n                      }\n                    }\n                  }\n                  return !!o[uid] ? o[uid].items : false;\n                }, this.tree.currentState);\n              }\n              if (storage) {\n                this.$nextTick(() => {\n                  // Set the localStorage with the data we get\n                  this.tree.setLocalStorage();\n                });\n              }\n              if (emit) {\n                // Call the fold event\n                this.tree.$emit('fold', this);\n              }\n            }\n            return true;\n          }\n          return false;\n        },\n        /**\r\n         * Single click on the node\r\n         * @method clickOnNode\r\n         * @emits nodeclick\r\n         * @memberof bbn-tree-node\r\n         */\n        clickOnNode(ev) {\n          this.$emit('nodeclick', this, ev);\n        },\n        /**\r\n         * Double click on the node\r\n         * @method dblClickOnNode\r\n         * @emits nodedoubleclick\r\n         * @memberof bbn-tree-node\r\n         */\n        dblClickOnNode(ev) {\n          this.tree.$emit('nodedoubleclick', this, ev);\n        },\n        getIcon() {\n          return this.source.icon || (!!this.numChildren ? this.isExpanded ? 'nf nf-fa-folder_open' : 'nf nf-fa-folder' : 'nf nf-fa-file');\n        },\n        remove() {\n          if (!this.parent.isAjax) {\n            this.parent.currentData.splice(this.idx, 1);\n          }\n        },\n        getCls(source, tree) {\n          return source.cls !== undefined ? source.cls : _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(tree.cls) ? tree.cls(source, this.tree, this.parent) : tree.cls || '';\n        },\n        onMouseUp(e) {\n          if (!this.tree.realDragging && this.tree.selectable) {\n            this.isSelected = !this.isSelected;\n          }\n        },\n        clickMenuItem(item, idx, dataIdx, ev) {\n          this.$emit('selectmenu', this, item, ev);\n          ev.preventDefault();\n        }\n      },\n      /**\r\n       * Defines the props tree and parent of the node\r\n       * @event created\r\n       * @memberof bbn-tree-node\r\n       */\n      created() {\n        // Looking for the parent\n        this.parent = this.closest('bbn-tree');\n        // tree take the value of the parent tree or the parent\n        this.tree = this.parent.tree || this.parent;\n        // If we click a node we're calling the addToSelect function\n        if (this.source.selected) {\n          this.addToSelected();\n        }\n        if (!this.parent.nodes.includes(this)) {\n          this.parent.nodes.push(this);\n        }\n        // If the tree is opened we're calling the addToExpanded function\n        if (this.tree.opened || this.level < this.tree.minExpandLevel) {\n          this.$set(this.source, 'expanded', true);\n          this.addToExpanded();\n        }\n      },\n      /**\r\n       * @event mounted\r\n       * @fires checkPath\r\n       * @fires resize\r\n       */\n      mounted() {\n        this.$nextTick(() => {\n          if (!this.animation) {\n            setTimeout(() => {\n              this.animation = true;\n            }, 500);\n          }\n          this.$set(this.source, 'visible', this.isVisible);\n          this.isMounted = true;\n          this.$nextTick(() => {\n            if (this.isExpanded && this.numChildren) {\n              let tree = this.getRef('tree');\n              if (tree && !tree.isLoaded && !tree.isLoading) {\n                tree.updateData();\n              }\n            }\n            setTimeout(() => {\n              this.ready = true;\n            }, 50);\n          });\n          this.resize();\n        });\n      },\n      beforeDestroy() {\n        if (this.isSelected) {\n          this.removeFromSelected(true, false);\n        }\n        if (this.isExpanded) {\n          this.removeFromExpanded(true, false);\n        }\n        if (this.isActive && this.tree.activeNode === this) {\n          this.tree.activeNode = false;\n        }\n        if (this.parent.nodes.includes(this)) {\n          this.parent.nodes.splice(this.parent.nodes.indexOf(this), 1);\n        }\n      },\n      watch: {\n        /**\r\n         * @watch doubleClk\r\n         * @param {Boolean} newVal\r\n         * @memberof bbn-tree-node\r\n         */\n        doubleClk(newVal) {\n          if (newVal) {\n            setTimeout(() => {\n              this.doubleClk = false;\n            }, 500);\n          }\n        },\n        /**\r\n         * Beware it's a computed, use tree.currentData[idx].expanded to change it.\r\n         *\r\n         * @watch isExpanded\r\n         * @fires tree.updateData\r\n         * @fires getRef\r\n         * @fires resize\r\n         * @fires addToExpanded\r\n         * @fires removeFromExpanded\r\n         * @fires tree.isNodeOf\r\n         * @memberof bbn-tree-node\r\n         */\n        isExpanded(newVal) {\n          if (newVal) {\n            if (this.addToExpanded()) {\n              let tree = this.getRef('tree');\n              if (this.numChildren && tree && !tree.isLoaded) {\n                tree.updateData();\n              } else {\n                this.resize();\n              }\n            }\n          } else {\n            if (this.removeFromExpanded()) {\n              if (this.tree.selectedNode && this.tree.isNodeOf(this.tree.selectedNode, this)) {\n                this.isActive = true;\n              }\n              this.resize();\n            }\n          }\n        },\n        /**\r\n         * @watch isSelected\r\n         * @param {Boolean} newVal\r\n         * @fires addToSelected\r\n         * @fires removeFromSelected\r\n         * @memberof bbn-tree-node\r\n         */\n        isSelected(newVal) {\n          if (newVal) {\n            this.addToSelected();\n          } else {\n            this.removeFromSelected();\n          }\n        },\n        /**\r\n         * @watch isActive\r\n         * @param {Boolean} newVal\r\n         * @emits tree.activate\r\n         * @emits tree.deactivate\r\n         * @memberof bbn-tree-node\r\n         */\n        isActive(newVal) {\n          if (newVal) {\n            if (this.tree.activeNode && this.tree.activeNode !== this) {\n              this.tree.activeNode.isActive = false;\n            }\n            this.tree.activeNode = this;\n          } else if (this.tree.activeNode === this) {\n            this.tree.activeNode = false;\n          }\n          this.tree.$emit(newVal ? 'activate' : 'deactivate', this);\n        },\n        isVisible(newVal) {\n          this.$set(this.source, 'visible', !!newVal);\n        }\n      }\n    }\n  }\n};\n\n\n\nlet cpLang = {};\nif (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].env.lang) {\n  try {\n    const lang = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].env.lang || 'en';\n    cpLang = await __webpack_require__(\"./src/components/tree/_i18n lazy recursive ^\\\\.\\\\/tree\\\\..*\\\\.lang$\")(`./tree.${lang}.lang`);\n    if (cpLang.default) {\n      cpLang = cpLang.default;\n    }\n  } catch (err) {}\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'bbn-tree',\n  definition: cpDef,\n  template: _tree_html__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  style: _tree_less__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  lang: cpLang\n});\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/tree/tree.js?");

/***/ })

}]);