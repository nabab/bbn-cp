function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import bbnHTML from "./Html.js";
import bbnAnonCp from "./AnonCp.js";
import "../cp.js";
const tmp = bbn.cp.stringToTemplate('<slot/>', true);
export default class bbnAnon extends bbnHTML {
  constructor() {
    super();
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  static get bbnCls() {
    return bbnAnonCp;
  }
}
_defineProperty(bbnAnon, "bbnFn", bbnAnonCp);
_defineProperty(bbnAnon, "bbnCls", 'bbnAnon');
_defineProperty(bbnAnon, "bbnTpl", tmp.res);
_defineProperty(bbnAnon, "bbnMap", tmp.map);
_defineProperty(bbnAnon, "bbnCfg", bbn.cp.normalizeComponent({
  mixins: [bbn.cp.mixins.basic],
  props: {
    is: {
      type: [String, Object],
      default: 'div'
    },
    source: bbn.fn.createObject()
  }
}, 'bbnAnon'));
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import bbnCp from "./Cp.js";
import "../cp.js";
export default class bbnAnonCp extends bbnCp {
  constructor(ele) {
    super(ele);
    _defineProperty(this, "$options", bbn.fn.createObject({
      name: 'bbn-anon'
    }));
    Object.defineProperty(this, '$options', {
      value: {
        name: ele.tagName.toLowerCase(),
        _componentTag: ele.tagName.toLowerCase(),
        components: bbn.fn.createObject(),
        get propsData() {
          if (this.$el) {
            var _this$$el$bbnSchema;
            return ((_this$$el$bbnSchema = this.$el.bbnSchema) === null || _this$$el$bbnSchema === void 0 ? void 0 : _this$$el$bbnSchema.props) || {};
          }
          return {};
        }
      },
      writable: false,
      configurable: false
    });
    this.$init();
  }
  async $connectedCallback() {
    //bbn.fn.log("ANON!!! ",this.$el.bbnSchema.props?.is);
    if (!this.$el.bbnTpl) {
      this.$el.bbnTpl = bbnAnon.bbnTpl;
      const tpl = this.$el.innerHTML.trim();
      if (tpl) {
        this.$el.bbnTpl.slots = tpl;
      }
    }
    const cfg = this.$cfg;
    /*
    if (cfg.components) {
      for (let n in cfg.components) {
        //bbn.fn.log("DEFINING COMPONENT", n, cfg.components[n], cfg.components[n].template);
        bbn.cp.define(cfg.componentNames[n], cfg.components[n], cfg.components[n].template);
      }
    }
    */

    if (cfg && cfg.computed) {
      bbn.fn.iterate(cfg.computed, (computed, name) => {
        if (name.substr(0, 1) === '$') {
          throw new Error(bbn._("Properties starting with the dollar sign are reserved"));
        }
        bbn.cp.setComputed(this, name, computed.get, computed.set);
      });
    }
    if (cfg && cfg.methods) {
      bbn.fn.iterate(cfg.methods, (fn, name) => {
        if (name.substr(0, 1) === '$') {
          throw new Error(bbn._("Properties starting with the dollar sign are reserved"));
        }
        if (this[name] === undefined) {
          Object.defineProperty(this, name, {
            writable: false,
            configurable: false,
            value: fn
          });
        }
      });
    }

    //bbn.fn.log("CONNCTRED CALLED IN ANON", this.$el);
    await bbnCp.prototype.$connectedCallback.apply(this);
  }
  get source() {
    return this.$props["source"];
  }
  $setUpProps() {
    if (!this.$cfg.props.source) {
      this.$cfg.props.source = bbn.fn.createObject({
        type: [String, Object, Array]
      });
    }
    bbn.fn.each(this.$cfg.props, (prop, name) => {
      this.$setUpProp(name, prop);
      Object.defineProperty(this, name, {
        get() {
          return this.$props[name];
        }
      });
    });
  }
}
_defineProperty(bbnAnonCp, "$acceptedAttributes", ['bbn-cfg', 'bbn-tpl', 'bbn-map', 'bbn-cls', 'bbn-fn', 'is', 'source', 'ref', 'key', 'index', 'slot']);
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnButtonHTML extends HTMLButtonElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnCellHTML extends HTMLTableCellElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
import { bbn } from "@bbn/bbn";
import "../cp.js";
export default class bbnCp {
  constructor(el) {
    // Setting up basic props
    Object.defineProperty(this, '$el', {
      value: el,
      writable: false,
      configurable: false
    });
  }

  /**
   * Adds or updates the given element to the $elements object property
   * 
   * @param {Symbol} id The ID of the element, based on the template
   * @param {HTMLElement, Text} ele The HTML element to be added
   * @param {String} hash The loop hash if any
   * @param {Number} index The loop index if any
   * @returns {undefined}
   */
  $addToElements(ele) {
    bbn.fn.checkType(ele, [HTMLElement, Text, Comment, SVGElement], "Elements should be HTML elements or text nodes");
    bbn.fn.checkType(ele.bbnId, ['string', 'symbol'], "In addToElements the ID should be a symbol");
    const id = ele.bbnId;
    const hash = ele.bbnHash;
    const origin = ele.bbnComponentId;
    let cp = this;
    if (origin !== this.$cid) {
      cp = bbn.cp.getComponent(origin).bbn;
    }
    if (hash) {
      if (!cp.$elements[id]) {
        cp.$elements[id] = bbn.fn.createObject();
      }
      if (cp.$elements[id][hash] && cp.$elements[id][hash] !== ele) {
        cp.$removeDOM(cp.$elements[id][hash]);
        cp.$elements[id][hash] = ele;
      } else if (cp.$elements[id][hash] !== ele) {
        cp.$elements[id][hash] = ele;
      }
    } else {
      if (cp.$elements[id] && cp.$elements[id] !== ele) {
        //bbn.fn.log("HHHH", this, "OLD", cp.$elements[id], "NEW", ele);
        cp.$removeDOM(cp.$elements[id]);
        cp.$elements[id] = ele;
      } else if (cp.$elements[id] !== ele) {
        cp.$elements[id] = ele;
      }
    }
  }

  /**
   * Reacts to change of attributes by emitting an update event
   * 
   * @todo The event updated shouldn't be here but during DOM creation process
   * @param {String} name The attribute's name
   * @param {String} oldValue The attribute's old value
   * @param {String} newValue The attribute's new value
   * @returns {undefined}
   */
  $attributeChange(name, oldValue, newValue) {
    /*
    const realName = name.indexOf(':') === 0 ? name.substr(1) : name;
     bbn.fn.log("ATTR------------>")
    if (this.$acceptedAttributes.includes(realName)) {
      this.bbn.$attr[name] = newValue;
      this.bbn.$setProp(name, newValue);
      if (this.bbn.$isMounted) {
        this.bbn.$tick();
        const updated = new Event('updated');
        this.bbn.$onUpdated();
        this.dispatchEvent(updated);
      }
    }
    */
  }

  /**
   * Starts everything up when the component enters the DOM
   * - Adds itself tyo the global static 'components'
   * - Sets up the props
   * - Triggers beforecreate
   * - Sets $parent
   * - Launches $addToElements in order to add the element to the $elements property
   * - Sets $root
   * - Adds namespaces for computed and methods
   * - Sets up the properties based on attributes
   * - Sets up the data
   * - Triggers created
   * - Creates the DOM
   * - Triggers beforemount
   * - Sets $isInit to true
   * - Triggers mounted
   * - Sets $isMOunted to true
   * - Starts tick interval
   * 
   * @returns {undefined}
   */
  async $connectedCallback() {
    var _this$$parent;
    // Check we are in the DOm
    //bbn.fn.warning("CALLBACK ON " + this.$options.name + " / " + this.$el.bbnSchema.id + " INIT: " + this.$isInit + " MOUNTED: " + this.$isMounted);
    if (!this.$el.isConnected || bbn.cp.getComponent(this.$el.bbnCid)) {
      bbn.fn.log("CONNECTED CALLBACK: not connected or already initialized", this.$el.isConnected, bbn.cp.getComponent(this.$el.bbnCid));
      return;
    }
    if (this.$isInit) {
      bbn.fn.log("WTF " + this.constructor.name);
      throw new Error("WTF " + this.constructor.name);
    }
    this.$init();
    // Adding itself to the global static #components
    bbn.cp.addComponent(this.$el);

    // Setting up $parent prop
    const parentNode = this.$el.parentNode;
    // host is for shadow DOM (not used)
    const parent = parentNode.host ? parentNode.host.closest(".bbn-component") : parentNode.closest(".bbn-component");
    /*
    const cpSource = bbn.cp.getComponent(this.$el.bbnComponentId);
    if (cpSource?.bbn && !cpSource.bbn.$retrieveElement(this.$el.bbnId)) {
      cpSource.$addToElements(this.$el);
    }
    */

    // $parent will always remain the same, it should only be null for root
    Object.defineProperty(this, '$parent', {
      value: parent ? parent.bbn : null,
      writable: false,
      configurable: false
    });
    /**
     * The highest component in the document's hierarchy
     */
    Object.defineProperty(this, '$root', {
      value: ((_this$$parent = this.$parent) === null || _this$$parent === void 0 ? void 0 : _this$$parent.$root) || this,
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$queue', {
      value: this.$root === this ? [] : this.$root.$queue,
      writable: false,
      configurable: false
    });
    /*
    Object.defineProperty(this, '$queue', {
      value: [],
      writable: false,
      configurable: false
    });
    */

    if (this === this.$root) {
      this.$fetchTimeout = null;
      Object.defineProperty(this, '$unknownComponents', {
        value: [],
        writable: false,
        configurable: false
      });
    }
    Object.defineProperty(this, '$fetchComponents', {
      value: async function () {
        if (this.$root.$unknownComponents.length) {
          let unknown = this.$root.$unknownComponents.splice(0, this.$root.$unknownComponents.length);
          const res = await bbn.cp.fetchComponents(unknown);
          return res;
        }
        return false;
      },
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$addUnknownComponent', {
      value: function (name) {
        if (name.indexOf('-') > 0 && !bbn.cp.known.includes(name) && !this.$root.$unknownComponents.includes(name)) {
          this.$root.$unknownComponents.push(name);
          return true;
        }
        return false;
      },
      writable: false,
      configurable: false
    });
    /**
     * The highest component in the doocument's hierarchy
     */
    Object.defineProperty(this, '$attrMap', {
      value: bbn.fn.clone(this.$el.bbnMap || this.$el.constructor.bbnMap),
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$currentMap', {
      configurable: true,
      writable: true,
      value: bbn.fn.clone(this.$el.bbnMap || this.$cls.bbnMap)
    });
    Object.defineProperty(this, '$currentResult', {
      configurable: false,
      writable: false,
      value: bbn.fn.createObject({
        _num: 0
      })
    });
    Object.defineProperty(this, '$schema', {
      configurable: false,
      writable: false,
      value: []
    });
    /**
     * The latest timestamp of the last update launch
     */
    Object.defineProperty(this, '$lastLaunch', {
      value: 0,
      writable: true
    });

    // An anon component won't have props nor this method
    /** @todo check if the above assertion is true (source?) */
    this.$setUpProps();

    // Sending beforeCreate event
    const beforeCreate = new Event('hook:beforecreate');
    this.$onBeforeCreate();
    this.$el.dispatchEvent(beforeCreate);

    // Setting up the config
    const cfg = this.$cfg;
    // Setting up the namespace for the methods
    if (cfg.methods) {
      bbn.fn.each(Object.keys(cfg.methods), n => this.$addNamespace(n, 'method'));
    }
    // Setting up the namespace for the computed
    if (cfg.computed) {
      bbn.fn.each(Object.keys(cfg.computed), n => this.$addNamespace(n, 'computed'));
    }

    // Setting up data
    if (this.$cfg.data) {
      // Proper to the specific private class: sets all the datasource
      Object.defineProperty(this, '$dataSource', {
        writable: false,
        configurable: false,
        value: this.$cfg.data
      });
      // Setting up all the data properties
      this.$updateData();
    }

    // Generates the evaluator function, will happen only once
    if (!this.$el.bbnEval && !this.$el.constructor.bbnEval) {
      // The template is not a one-shot (it is defined in the constructor)
      if (!this.$el.bbnTpl) {
        // The function has never been generated for this component
        if (!this.$el.constructor.bbnEval) {
          // Generating
          const stFn = bbn.cp.templateToFunction(this, this.$el.constructor.bbnTpl);
          if (!stFn) {
            throw new Error(bbn._("Impossible to create the template evaluator"));
          }
          // Setting in component's constructor
          this.$el.constructor.prototype.bbnEval = stFn;
        }
      }
      // The template is a one-shot, bbnAnon
      else {
        // Generating
        const stFn = bbn.cp.templateToFunction(this, this.$el.bbnTpl);
        if (!stFn) {
          throw new Error(bbn._("Impossible to create the template evaluator"));
        }
        // Setting in component's property
        Object.defineProperty(this.$el, 'bbnEval', {
          value: eval(stFn),
          writable: false,
          configurable: false
        });
      }
    }

    // Setting $eval with the retrived/generated function
    Object.defineProperty(this, '$eval', {
      value: this.$el.bbnEval || this.$el.constructor.bbnEval,
      writable: false,
      configurable: false
    });

    // Sending created event
    if (!this.$isCreated) {
      const created = new Event('hook:created');
      this.$onCreated();
      this.$el.dispatchEvent(created);
      Object.defineProperty(this, '$isCreated', {
        value: true,
        writable: false,
        configurable: false
      });
    }

    // Sets the current template schema and creates the DOM
    await this.$updateComponent().then(() => {
      // Not going on if the element disappeared
      if (!this.$el.isConnected) {
        return;
      }

      // registering current object to parent and setting root
      if (this.$parent) {
        this.$parent.$registerChild(this);
      }

      // Sending beforeMount event
      const beforeMount = new Event('hook:beforemount');
      this.$onBeforeMount();
      this.$el.dispatchEvent(beforeMount);

      // $isInit, defined in constructor  is made writable before being set to true
      Object.defineProperty(this, '$isInit', {
        value: true,
        writable: false,
        configurable: true
      });
      if (!this.$isMounted) {
        // Sending mounted event
        const mounted = new Event('hook:mounted');
        this.$onMounted();
        this.$el.dispatchEvent(mounted);
        Object.defineProperty(this, '$isMounted', {
          value: true,
          writable: false,
          configurable: false
        });
      }
      this.$start();
    });
  }
  $start() {
    return;
    if (this !== this.$root) {
      return;
    }
    if (this.$interval) {
      throw new Error(bbn._("The component %s is already started", this.$options.name));
    }
    Object.defineProperty(this, '$interval', {
      value: setInterval(() => this.$launchQueue(), bbn.cp.tickDelay),
      writable: false,
      configurable: true
    });
  }
  $stop() {
    if (this !== this.$root) {
      return;
    }
    if (!this.$interval) {
      throw new Error(bbn._("The component %s is not started", this.$options.name));
    }
    clearInterval(this.$interval);
    Object.defineProperty(this, '$interval', {
      value: null,
      writable: false,
      configurable: true
    });
  }

  /**
   * Creates an element in the given target
   * @param {HTMLElement} d 
   * @param {HTMLElement} target 
   * @returns 
   */
  async $createElement(node, target, before, loopInfo) {
    var _bbn$cp$getComponent;
    const d = node;
    // Components have an hyphen
    let isComponent = this.$isComponent(d);
    /** @constant {Array} todo A list of function to apply once the element will ne created */
    const todo = [];
    /** @constant {bbnComponentFunction} cpSource */
    const cpSource = d.componentId ? (_bbn$cp$getComponent = bbn.cp.getComponent(d.componentId)) === null || _bbn$cp$getComponent === void 0 ? void 0 : _bbn$cp$getComponent.bbn : this;
    const oldEle = cpSource.$retrieveElement(d.id, d.loopHash);
    let replace = false;
    let ele;
    if (oldEle) {
      const isComment = bbn.fn.isComment(oldEle);
      if (oldEle !== this.$el && (!!d.comment !== isComment || !isComment && d.tag && !bbn.cp.isTag(d.tag, oldEle))) {
        //bbn.fn.log("REPLACING " + d.id, isComment, d, oldEle);
        replace = true;
      } else {
        ele = oldEle;
      }
    }

    /** @todo check todo */
    let tag = d.tag;
    let originalTag = d.tag;
    if (tag && this.$cfg.componentNames[tag]) {
      tag = this.$cfg.componentNames[tag];
      isComponent = true;
    }
    /** 
     * @todo Add the possibility to change the tag using Customized built-in elements 
     * See createElement
     */
    if (isComponent) {
      var _bbn$cp$statics$tag;
      if (this.$addUnknownComponent(tag)) {
        await this.$fetchComponents(tag);
      }
      if ((_bbn$cp$statics$tag = bbn.cp.statics[tag]) !== null && _bbn$cp$statics$tag !== void 0 && _bbn$cp$statics$tag.tag) {
        originalTag = tag;
        tag = bbn.cp.statics[originalTag].tag;
      }
    }
    if (d.model) {
      for (let n in d.model) {
        if (n === '_default_') {
          if (isComponent) {
            var _bbn$cp$statics$tag2;
            let modelProp = ((_bbn$cp$statics$tag2 = bbn.cp.statics[tag]) === null || _bbn$cp$statics$tag2 === void 0 || (_bbn$cp$statics$tag2 = _bbn$cp$statics$tag2.cfg) === null || _bbn$cp$statics$tag2 === void 0 || (_bbn$cp$statics$tag2 = _bbn$cp$statics$tag2.model) === null || _bbn$cp$statics$tag2 === void 0 ? void 0 : _bbn$cp$statics$tag2.prop) || 'value';
            d.props[modelProp] = d.props._default_;
            delete d.props._default_;
            d.model[modelProp] = d.model._default_;
            //delete d.model._default_;
          } else {
            d.model.value = d.model._default_;
            //delete d.model._default_;
            d.props.value = d.props._default_;
            delete d.props._default_;
          }
        }
      }
    }
    if (!oldEle || replace) {
      if (d.comment) {
        ele = document.createComment(" ***_BBN_*** ");
      } else if (tag === 'svg') {
        ele = document.createElementNS("http://www.w3.org/2000/svg", tag);
        ele.innerHTML = d.content;
      } else {
        /** 
         * @todo Add the possibility to change the tag using Customized built-in elements 
         * See createElement
         */
        if (isComponent) {
          if (replace && oldEle !== null && oldEle !== void 0 && oldEle.tagName && tag === oldEle.tagName.toLowerCase()) {
            replace = false;
          }
        }

        /** @constant {HTMLElement} ele */
        const constructorArgs = [tag];
        if (originalTag !== tag) {
          constructorArgs.push({
            is: originalTag
          });
        }
        ele = document.createElement(...constructorArgs);
        if (originalTag !== tag) {
          ele.setAttribute('is', originalTag);
        }
        if (tag === 'bbn-anon') {
          if (d.cfg) {
            if (d.cfg.mixins && d.cfg.mixins.indexOf(bbn.cp.mixins.basic) === -1) {
              d.cfg.mixins.push(bbn.cp.mixins.basic);
            }
            Object.defineProperty(ele, 'bbnCfg', {
              value: d.cfg,
              writable: false,
              configurable: false
            });
            if (d.cfg.template) {
              const tmp = bbn.cp.stringToTemplate(d.cfg.template, true);
              Object.defineProperty(ele, 'bbnTpl', {
                value: tmp.res,
                writable: false,
                configurable: false
              });
              Object.defineProperty(ele, 'bbnMap', {
                value: tmp.map,
                writable: false,
                configurable: false
              });
              Object.defineProperty(ele, 'bbnInlineTemplates', {
                value: tmp.inlineTemplates,
                writable: false,
                configurable: false
              });
            }
          }
        }
      }

      // Giving to all elements property bbnId
      Object.defineProperty(ele, 'bbnId', {
        value: d.id,
        writable: false,
        configurable: false
      });

      // Outer schema of the component, with the slots
      Object.defineProperty(ele, 'bbnSchema', {
        value: d,
        writable: true,
        configurable: true
      });
      Object.defineProperty(ele, 'bbnComponentId', {
        value: cpSource.$cid,
        writable: false,
        configurable: false
      });
      if (d.directives) {
        Object.defineProperty(ele, 'bbnDirectives', {
          value: bbn.fn.createObject(),
          writable: false,
          configurable: false
        });
      }
      if (loopInfo) {
        Object.defineProperty(ele, 'bbnLoopVars', {
          value: loopInfo,
          writable: false,
          configurable: false
        });
      }
      if (d.loopHash) {
        Object.defineProperty(ele, 'bbnHash', {
          value: d.loopHash,
          writable: false,
          configurable: false
        });
        Object.defineProperty(ele, 'bbnIndex', {
          value: d.loopIndex,
          writable: false,
          configurable: false
        });
      }
      if (isComponent) {
        let realSlots;
        if (tag === 'bbn-anon') {
          realSlots = bbn.cp.retrieveSlots(ele.bbnTpl || d.items);
        } else {
          realSlots = bbn.fn.clone(ele.constructor.bbnSlots);
        }
        if (!bbn.fn.numProperties(realSlots)) {
          realSlots = bbn.fn.createObject({
            default: []
          });
        }

        // Outer schema of the component, with the slots
        Object.defineProperty(ele, 'bbnRealSlots', {
          value: realSlots,
          writable: false,
          configurable: false
        });
        // Outer schema of the component, with the slots
        Object.defineProperty(ele, 'bbnSlots', {
          get() {
            return this.bbnRealSlots;
          }
        });
      }
    } else {
      ele = oldEle;
      if (!bbn.fn.isSame(ele.bbnSchema.props, d.props)) {
        ele.bbnSchema = d;
        if (isComponent && ele.bbn && ele.bbn.$isMounted) {
          ele.bbn.$forceUpdate();
        }
      }
    }
    if (!d.comment) {
      cpSource.$updateElementFromProps(d, ele);
      if (d.pre) {
        ele.innerHTML = d.pre;
      }
    }
    if (oldEle && !replace) {
      return oldEle;
    }
    if (target !== this.$el) {
      this.$insertElement(ele, target, before, oldEle);
    } else {
      this.$addToElements(ele);
    }
    if (!d.comment && d.directives) {
      bbn.cp.insertDirectives(d.directives, ele);
    }
    return ele;
  }

  /**
   * Creates an element in the given target
   * @param {HTMLElement} d 
   * @param {HTMLElement} target 
   * @returns 
   */
  $createText(d, target, loopInfo) {
    const ele = document.createTextNode(d.text);
    bbn.fn.checkType(d.id, String, "Boo");
    Object.defineProperty(ele, 'bbnId', {
      value: d.id,
      writable: false,
      configurable: false
    });
    Object.defineProperty(ele, 'bbnComponentId', {
      value: this.$cid,
      writable: false,
      configurable: false
    });
    if (loopInfo) {
      Object.defineProperty(ele, 'bbnLoopVars', {
        value: loopInfo,
        writable: false,
        configurable: false
      });
    }
    if (d.loopHash) {
      Object.defineProperty(ele, 'bbnHash', {
        value: d.loopHash,
        writable: false,
        configurable: false
      });
      Object.defineProperty(ele, 'bbnIndex', {
        value: d.loopIndex,
        writable: false,
        configurable: false
      });
    }
    this.$addToElements(ele);
    if (bbn.cp.isComponent(target)) {
      var _target$bbnSlots;
      if ((_target$bbnSlots = target.bbnSlots) !== null && _target$bbnSlots !== void 0 && (_target$bbnSlots = _target$bbnSlots.default) !== null && _target$bbnSlots !== void 0 && _target$bbnSlots.length || bbn.fn.removeExtraSpaces(ele.textContent)) {
        target.bbnSlots.default.push(ele);
      }
      if (target.bbn && target.bbn.$isMounted) {
        target.bbn.$tick();
      }
    } else if (target !== this.$el) {
      target.appendChild(ele);
    }
    return ele;
  }

  /**
   * Shuts everything down
   * @returns 
   */
  $disconnectedCallback() {
    //bbn.fn.log("Before disconnected callback from " + this.$el.tagName + ' / ' + this.$el.bbnSchema.id);
    if (!this.$el.isConnected) {
      //bbn.fn.log("Disconnected callback from " + this.$el.tagName);
      // Sending beforeDestroy event
      const beforeDestroy = new Event('beforedestroy');
      this.$onBeforeDestroy();
      this.$el.dispatchEvent(beforeDestroy);
      Object.defineProperty(this, '$isDestroyed', {
        value: true,
        writable: false,
        configurable: true
      });
      // Sending destroyed event through a timeout
      // Deleting from elements prop
      while (this.$values.length) {
        let id = this.$values[this.$values.length - 1];
        const data = bbn.cp.dataInventory.get(id);
        if (!data) {
          throw new Error(bbn._("Impossible to find a piece of data in %s", this.$options.name));
        } else {
          //bbn.fn.log('Removing data for ' + this.$cid + ' in ' + this.$options.name + ' / path: ' + data.path[0]);
          data.removeComponent(this);
        }
      }
      bbn.cp.removeComponent(this.$el.bbnCid);
      /*
      this.$el.childNodes.forEach(node => {
        this.$removeDOM(node);
      });
      this.$removeFromElements(this.$el.bbnId, this.$el.bbnHash);
      */
      // Setting back $isinit
      Object.defineProperty(this, '$isInit', {
        value: false,
        writable: false,
        configurable: true
      });
      const destroyed = new Event('destroyed');
      this.$onDestroyed();
      this.$el.dispatchEvent(destroyed);
    }
  }

  /**
   * Starts everything up
   * @returns 
   */
  $init(el) {
    var _bbn$cp$getComponent2;
    if (Object.hasOwn(this, '$isInit')) {
      return;
    }
    /**
     * Constructor of the BBNComponentObject
     * 
     * @param {[HTMLElement]} el Always attached to an HTML component
     * @param {Number} id Comes from the template
     */

    /**
     * A reference to the component Object (this)
     */
    Object.defineProperty(this, '_self', {
      confifurable: false,
      writable: false,
      value: this.$el.bbn
    });

    // This will hold all the reactive data
    Object.defineProperty(this, '$values', {
      value: [],
      writable: false,
      configurable: false
    });

    // This will become true after all is mounted
    Object.defineProperty(this, '$isInit', {
      value: false,
      writable: false,
      configurable: true
    });

    // This will become true after the data functions are launched and the data is set
    Object.defineProperty(this, '$isDataSet', {
      value: false,
      writable: false,
      configurable: true
    });

    // This will be true during the construction process (updateComponent)
    Object.defineProperty(this, '$isCreating', {
      value: false,
      writable: true,
      configurable: true
    });

    // This will be true during the construction process (updateComponent)
    Object.defineProperty(this, '$isUpdating', {
      value: null,
      writable: true,
      configurable: true
    });
    Object.defineProperty(this, '$isCreated', {
      value: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(this, '$isDestroyed', {
      value: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(this, '$isMounted', {
      value: false,
      writable: true,
      configurable: true
    });

    // This will be true during the construction process (updateComponent)
    Object.defineProperty(this, '$isUpdatingComputed', {
      value: false,
      writable: true,
      configurable: true
    });
    // This will be true during the construction process (updateComponent)
    Object.defineProperty(this, '$tagUsed', {
      value: [],
      writable: false,
      configurable: true
    });

    /**
     * Object of all the instance properties available directly in the HTML templates.
     * Indexed by name, the value being the type (data, prop, method, computed)
     * @return {Object}
     */
    Object.defineProperty(this, '$namespaces', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });

    /**
     * Component configuration object
     */
    Object.defineProperty(this, '$cfg', {
      value: this.$el.bbnCfg || this.$el.constructor.bbnCfg,
      writable: false,
      configurable: false
    });

    /**
     * Template array
    */
    Object.defineProperty(this, '$tpl', {
      value: this.$el.bbnTpl || this.$el.constructor.bbnTpl,
      writable: false,
      configurable: false
    });
    const _t = this;
    Object.defineProperty(this.$options, 'propsData', {
      get() {
        var _t$$el$bbnSchema;
        return ((_t$$el$bbnSchema = _t.$el.bbnSchema) === null || _t$$el$bbnSchema === void 0 ? void 0 : _t$$el$bbnSchema.props) || {};
      }
    });
    Object.defineProperty(this.$options, 'components', {
      get() {
        return _t.$cfg.components || {};
      }
    });
    Object.defineProperty(this, '$props', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });

    /**
     * Object of all available slots nodes in the template.
     * Indexed by name with id as value
     */
    Object.defineProperty(this, '$availableSlots', {
      get() {
        return this.$el.bbnSlots || bbnHTML.availableSlots;
      }
    });

    /**
     * Is true if is creating or updating
     */
    Object.defineProperty(this, '$isBusy', {
      get() {
        return this.$isCreating || this.$isUpdating;
      }
    });

    /**
     * Object of all available slots nodes in the template.
     * Indexed by name with id as value
     */
    Object.defineProperty(this, '$hash', {
      get() {
        var _this$$el;
        return ((_this$$el = this.$el) === null || _this$$el === void 0 ? void 0 : _this$$el.bbnHash) || '';
      }
    });

    /**
     * Object of all elements with bbn-model prop.
     * Indexed by element's id with bbn-model's value as value
     */
    Object.defineProperty(this, '$computed', {
      value: bbn.fn.createObject()
    });

    // Setting $eval with the retrived/generated function
    Object.defineProperty(this, '$oldValues', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$watcher', {
      value: bbn.fn.createObject(),
      writable: false
    });
    bbn.fn.iterate(this.$cfg.watch, (a, name) => {
      this.$watch(name, a);
    });

    /**
     * Object referencing all the content for each available slot.
     * Indexed by slot's name (default is default), it contains an array of nodes which are the content
     * @return {Object}
     */
    Object.defineProperty(this, '$slots', {
      get() {
        return this.$el.bbnSlots;
      }
    });

    /**
     * The ID of the component, corresponding ot its ID in the template.
     * Components inside a loop have all the same id
     */
    Object.defineProperty(this, '$id', {
      value: this.$el.bbnId,
      writable: false,
      configurable: false
    });

    /**
     * Unique ID for each component, used for global registration
     */
    Object.defineProperty(this, '$cid', {
      value: this.$el.bbnCid,
      writable: false,
      configurable: false
    });

    /**
     * Unique ID for each component, used for global registration
     */
    Object.defineProperty(this, '$origin', {
      value: this.$el.bbnComponentId && this.$el.bbnComponentId !== this.$cid ? ((_bbn$cp$getComponent2 = bbn.cp.getComponent(this.$el.bbnComponentId)) === null || _bbn$cp$getComponent2 === void 0 ? void 0 : _bbn$cp$getComponent2.bbn) || this : this,
      writable: false,
      configurable: false
    });

    /**
     * Unique ID for each component, used for global registration
     */
    Object.defineProperty(this, '$cls', {
      value: this.$el.constructor,
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$attr', {
      value: bbn.fn.getAttributes(this.$el),
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$events', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });

    /**
    * Array of bbnComponentObject instances direct descendants of the current one
    * @return {Array}
    */
    Object.defineProperty(this, '$children', {
      value: [],
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$elements', {
      value: bbn.fn.createObject({
        '-': this.$el
      }),
      writable: false,
      configurable: false
    });

    /** @var {Object} $dataValues The content of the data */
    Object.defineProperty(this, '$dataValues', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });
    Object.defineProperty(this, '$refsElements', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });

    /**
     * Counts the number of times the component has been repainted through the method updateComponent
     */
    Object.defineProperty(this, '$numBuild', {
      value: 0,
      writable: true,
      configurable: true
    });

    //Object.defineProperty
    //this.$event = null;
    //this.$cls = this.$el.constructor;
    /**
     * Object referencing all the elements with ref prop
     * Indexed by name, value being the bbnComponentObject if it's a component a HTMLElement otherwise
     * @return {Object}
     */
    Object.defineProperty(this, '$refs', {
      configurable: false,
      writable: false,
      value: new Proxy(this.$refsElements, {
        get(target, propName) {
          let tmp = target[propName];
          if (tmp) {
            if (bbn.fn.isArray(tmp)) {
              return tmp.filter(a => a.isConnected).map(a => a.bbn || a);
            }
            return tmp.isConnected ? tmp.bbn || tmp : null;
          }
        }
      })
    });

    // Setting up available props for HTML templates
    this.$addNamespace('$props', 'internal');
    this.$addNamespace('$el', 'internal');
    this.$addNamespace('$root', 'internal');
    this.$addNamespace('$attr', 'internal');
    this.$addNamespace('$event', 'internal');
    this.$addNamespace('$parent', 'internal');
    this.$addNamespace('$options', 'internal');
    this.$addNamespace('$namespaces', 'internal');
    this.$addNamespace('$children', 'internal');
    this.$addNamespace('$refs', 'internal');
    this.$addNamespace('$slots', 'internal');
    this.$addNamespace('$isCreated', 'internal');
    this.$addNamespace('$isMounted', 'internal');
    this.$addNamespace('_self', 'internal');
    this.$addNamespace('_', 'method');
    this.$addNamespace('$emit', 'method');
    this.$addNamespace('$is', 'method');
    this.$addNamespace('$isComponent', 'method');
    this.$addNamespace('$nextTick', 'method');
    this.$addNamespace('$off', 'method');
    this.$addNamespace('$on', 'method');
    this.$addNamespace('$once', 'method');
    this.$addNamespace('$retrieveComponent', 'method');
    this.$addNamespace('$retrieveElement', 'method');
    this.$addNamespace('ancestors', 'method');
    this.$addNamespace('closest', 'method');
    this.$addNamespace('extend', 'method');
    this.$addNamespace('find', 'method');
    this.$addNamespace('findAll', 'method');
    this.$addNamespace('findAllByKey', 'method');
    this.$addNamespace('findByKey', 'method');
    this.$addNamespace('getChildByKey', 'method');
    this.$addNamespace('getComponentName', 'method');
    this.$addNamespace('getComponents', 'method');
    this.$addNamespace('getRef', 'method');
    bbn.fn.iterate(bbnCp.prototype, (a, n) => {
      if (bbn.fn.isFunction(a)) {
        this.$addNamespace(n, 'method');
      }
    });
  }

  /**
   * Creates an element in the given target
   * @param {HTMLElement} d 
   * @param {HTMLElement} target 
   * @returns 
   */
  $insertElement(ele, target, before, oldEle) {
    bbn.fn.checkType(target, HTMLElement, "The $insert function should have an HTMLElement as target");
    const d = ele.bbnSchema;
    //bbn.fn.checkType(ele, HTMLElement);
    const isParentComponent = target !== this.$el && bbn.cp.isComponent(target);
    let replace = false;
    const isComment = bbn.fn.isComment(ele);
    if (oldEle) {
      const isOldComment = bbn.fn.isComment(oldEle);
      if (oldEle !== this.$el && (isOldComment !== isComment || !isOldComment && d.tag && !bbn.cp.isTag(d.tag, oldEle))) {
        replace = true;
      } else {
        ele = oldEle;
      }
    }
    if (replace) {
      var _ele$bbnSchema;
      //bbn.fn.log("REPLACE", ele);
      if (isParentComponent && !((_ele$bbnSchema = ele.bbnSchema) !== null && _ele$bbnSchema !== void 0 && _ele$bbnSchema.comment)) {
        var _target$bbnSlots2;
        //bbn.fn.log("IN CP " + target.tagName, ele);
        const slot = ele.getAttribute("slot") || 'default';
        if ((_target$bbnSlots2 = target.bbnSlots) !== null && _target$bbnSlots2 !== void 0 && _target$bbnSlots2[slot]) {
          let search = {
            bbnId: oldEle.bbnId
          };
          if (oldEle.bbnHash) {
            search.bbnHash = oldEle.bbnHash;
          }
          let idx = bbn.fn.search(target.bbnSlots[slot], search);
          if (idx > -1) {
            /*
            const mounted = !!target.bbnSlots[slot][idx].parentNode;
            if (mounted) {
              oldEle.parentNode.replaceChild(ele, oldEle);
            }
            */

            target.bbnSlots[slot].splice(idx, 1, ele);
            if (target.bbn && target.bbn.$isMounted) {
              target.bbn.$tick();
            }
          }
        }
      } else {
        if (oldEle.parentNode) {
          try {
            oldEle.parentNode.replaceChild(ele, oldEle);
          } catch (e) {
            bbn.fn.log("ERROR IN REPLACE", e, ele, oldEle);
          }
        } else {
          try {
            target.appendChild(ele);
          } catch (e) {
            bbn.fn.log("ERROR IN APPEND", e, ele, oldEle);
          }
        }
      }
      this.$addToElements(ele);
    } else if (oldEle !== ele) {
      //bbn.fn.log(["INSERT ", ele, oldEle]);
      if (isParentComponent) {
        var _ele$bbnSchema$props, _target$bbnSlots3;
        const slot = ((_ele$bbnSchema$props = ele.bbnSchema.props) === null || _ele$bbnSchema$props === void 0 ? void 0 : _ele$bbnSchema$props.slot) || 'default';
        if ((_target$bbnSlots3 = target.bbnSlots) !== null && _target$bbnSlots3 !== void 0 && _target$bbnSlots3[slot]) {
          if (!ele.bbnSchema && !bbn.fn.removeExtraSpaces(ele.textContent)) {
            return;
          }
          let search = {
            bbnId: ele.bbnId
          };
          if (ele.bbnHash) {
            search.bbnHash = ele.bbnHash;
          }
          let idx = bbn.fn.search(target.bbnSlots[slot], search);
          if (idx > -1) {
            const mounted = !!target.bbnSlots[slot][idx].parentNode;
            if (mounted) {
              target.bbnSlots[slot][idx].parentNode.replaceChild(ele, target.bbnSlots[slot][idx]);
            }
            target.bbnSlots[slot].splice(idx, 1, ele);
          } else {
            target.bbnSlots[slot].push(ele);
          }
          this.$addToElements(ele);
        }
      } else {
        if (before) {
          target.insertBefore(ele, before);
        } else {
          target.appendChild(ele);
        }
        this.$addToElements(ele);
      }
    }
  }
  $updateProps() {
    bbn.fn.each(this.$namespaces, (a, n) => {
      if (a === 'props') {
        this.$getProp(n);
      }
    });
  }

  /**
   * Remove an element from the DOM
   * @param {HTMLElement} ele
   */
  $removeDOM(ele) {
    var _bbn$cp$getComponent3;
    //bbn.fn.log(this, "REMOVING " + (ele.bbn ? ele.bbn.$options.name + ' ': '') + ele.bbnId);
    const id = ele.bbnId;
    const hash = ele.bbnHash;
    const cpSource = ele.bbnComponentId && ele.bbnComponentId !== this.$cid ? ((_bbn$cp$getComponent3 = bbn.cp.getComponent(ele.bbnComponentId)) === null || _bbn$cp$getComponent3 === void 0 ? void 0 : _bbn$cp$getComponent3.bbn) || this : this;
    // It won't have an ID if it's a bbn-text or bbn-html or creaated by an external component/widget
    if (id) {
      if (ele.bbnSlots) {
        for (let n in ele.bbnSlots) {
          let slot = ele.bbnSlots[n].splice(0, ele.bbnSlots[n].length);
          for (let i = 0; i < slot.length; i++) {
            var _bbn$cp$getComponent4;
            let o = slot[i];
            //bbn.fn.log("REMOVE FROM SLOT", o);
            let cp = o.bbnComponentId !== this.$cid ? ((_bbn$cp$getComponent4 = bbn.cp.getComponent(o.bbnComponentId)) === null || _bbn$cp$getComponent4 === void 0 ? void 0 : _bbn$cp$getComponent4.bbn) || this : this;
            cp.$removeDOM(o);
          }
        }
      }
      if (ele.childNodes && ele.bbnSchema && !Object.hasOwn(ele.bbnSchema.props || {}, 'bbn-text') && !Object.hasOwn(ele.bbnSchema.props || {}, 'bbn-html') && ele.bbnSchema.tag !== 'svg') {
        while (ele.childNodes.length) {
          var _bbn$cp$getComponent5;
          let node = ele.childNodes[0];
          let cp = ele.bbnComponentId !== this.$cid ? ((_bbn$cp$getComponent5 = bbn.cp.getComponent(ele.bbnComponentId)) === null || _bbn$cp$getComponent5 === void 0 ? void 0 : _bbn$cp$getComponent5.bbn) || this : this;
          cp.$removeDOM(node);
        }
      }
      cpSource.$removeFromElements(id, hash);
    }
    if (ele.parentNode) {
      ele.parentNode.removeChild(ele);
    }
  }

  /**
   * Adds or updates the given element to the $elements object property
   * 
   * @param {Symbol} id The ID of the element, based on the template
   * @param {HTMLElement, Text} ele The HTML element to be added
   * @param {String} hash The loop hash if any
   * @param {Number} index The loop index if any
   * @returns {undefined}
   */
  $removeFromElements(id, hash) {
    bbn.fn.checkType(id, ['string', 'symbol'], "In removeFromElements the ID should be a symbol");
    if (hash) {
      const row = this.$elements[id];
      if (row) {
        delete this.$elements[id][hash];
      } else {
        bbn.fn.log(["HASH BUT NO ROW IN " + this.$options.name, id, hash, this.$elements[id]]);
      }
    } else {
      delete this.$elements[id];
    }
  }
  $retrieveElement(id, hash) {
    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    let loopObj = arguments.length > 3 ? arguments[3] : undefined;
    let res = this.$elements[id] || null;
    if (res && hash) {
      return res[hash] || null;
    }
    return res;
  }

  /**
   * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not
   * - Updates the component element based on its own schema ($el.bbnSchema)
   * - Updates the schema
   * - Generates/update the DOM when needed
   * 
   * @param {Boolean} shadow The content will go to the shadow DOM if true
   * @returns {Promise}
   */
  async $updateComponent(shadow) {
    if (!this.$isCreated || !this.$el.isConnected) {
      return;
    }
    if (this.$isUpdating === null) {
      Object.defineProperty(this, '$isCreating', {
        writable: false,
        configurable: true,
        value: true
      });
    } else if (this.$isBusy) {
      return this.$forceUpdate();
    } else {
      this.$isUpdating = true;
    }

    // The HTML component's root in the DOM
    let root = this.$el;
    if (shadow) {
      root = this.$el.attachShadow({
        mode: "open"
      });
    }
    const t1 = new Date().getTime();
    this.$lastLaunch = t1;
    this.$updateProps();
    if (!this.$numBuild) {
      bbn.fn.iterate(this.$watcher, (a, n) => {
        this.$updateWatcher(n, bbn.fn.getProperty(this, n), true);
      });
    }

    //this.$updateAllComputed();
    //bbn.fn.log(["EVALUATING", this.$options.name, this.$cid]);
    if (this.$options.name === 'bbn-table') {
      //debugger;
    }
    const e = await this.$eval(this);
    const t2 = new Date().getTime();
    this.$numBuild++;
    this.$lastLaunch = t2;
    if (this.$isCreating) {
      Object.defineProperty(this, '$isCreating', {
        writable: false,
        configurable: false,
        value: false
      });
      this.$emit('domcreated');
    }
    this.$isUpdating = false;
  }
  $isComponent(node) {
    if (node.tag && this.$cfg.componentNames[node.tag]) {
      return true;
    }
    return bbn.cp.isComponent(node);
  }

  /**
   * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not
   * - Updates the component element based on its own schema ($el.bbnSchema)
   * - Updates the schema
   * - Generates/update the DOM when needed
   * 
   * @param {Boolean} shadow The content will go to the shadow DOM if true
   * @returns {Promise}
   */
  $updateElementFromProps(node, ele) {
    if (node.comment) {
      return;
    }

    /** @constant {Object} props */
    const props = node.props || bbn.fn.createObject();
    /** @constant {Boolean} isComponent */
    const isComponent = this.$isComponent(node);
    /** @constant {bbnComponentObject} cpSource */
    const cpSource = this; //node.componentId ? bbn.cp.getComponent(node.componentId)?.bbn : this;
    if (!cpSource) {
      bbn.fn.log(node, bbn.cp.getComponent(node.componentId));
      bbn.fn.warning("The component source is not defined");
      return;
    }
    /** @var {Object} attr The attributes of the element to be built */
    const attr = bbn.fn.createObject();
    let isChanged = false;
    // Other normal props are prioritarian
    for (let n in props) {
      switch (n) {
        case 'ref':
          bbn.fn.checkType(props.ref, 'string', bbn._("Refs must be strings in %s", this.$options.name));
          cpSource.$setRef(props.ref, ele);
          break;
        case 'class':
          if (!isComponent && ele !== this.$el) {
            if (ele.className !== props['class']) {
              ele.className = props['class'];
            }
          }
          break;
        case 'style':
          if (!isComponent && ele !== this.$el) {
            if (props.style !== ele.style.cssText) {
              ele.style.cssText = bbn.cp.convertStyles(props.style);
            }
          }
          break;
        default:
          if (n.indexOf('bbn-') !== 0) {
            attr[n] = props[n];
          }
      }
    }
    if (Object.hasOwn(props, 'bbn-show')) {
      if (props['bbn-show'] && ele.style.display === 'none') {
        ele.style.removeProperty('display');
      } else if (!props['bbn-show']) {
        ele.style.display = 'none';
      }
    }
    if (node.model) {
      for (let n in node.model) {
        var _node$model$n$value;
        if (n === '_default_') {
          continue;
        }
        let isC = false;
        if (isComponent) {
          var _ele$bbnSchema$props2;
          if (Object.hasOwn(ele.bbnSchema.props || {}, n) && ((_ele$bbnSchema$props2 = ele.bbnSchema.props) === null || _ele$bbnSchema$props2 === void 0 ? void 0 : _ele$bbnSchema$props2[n]) !== node.model[n].value) {
            ele.bbnSchema.props[n] = node.model[n].value;
            isChanged = true;
            isC = true;
          }
        } else if (ele[n] !== undefined && ele[n] !== (bbn.fn.isString(node.model[n].value) ? node.model[n].value : (_node$model$n$value = node.model[n].value) !== null && _node$model$n$value !== void 0 && _node$model$n$value.toString ? node.model[n].value.toString() : '')) {
          isChanged = true;
          isC = true;
          ele[n] = node.model[n].value;
        }
      }
    } else if (Object.hasOwn(props, 'bbn-html') && ele.innerHTML !== props['bbn-html']) {
      ele.innerHTML = props['bbn-html'];
      isChanged = true;
    } else if (Object.hasOwn(props, 'bbn-text') && ele.innerText !== props['bbn-text']) {
      ele.innerText = props['bbn-text'];
      isChanged = true;
    }

    // Setting up attributes
    bbn.fn.iterate(attr, (value, name) => {
      if (!isComponent) {
        if (bbn.fn.isPrimitive(value)) {
          let propName = name;
          if (bbn.cp.badCaseAttributes[name]) {
            propName = bbn.cp.badCaseAttributes[name];
          }
          const isAttr = ele[propName] !== undefined;
          if (isAttr) {
            const attr = ele[propName];
            if (attr !== value) {
              if (!value) {
                ele.removeAttribute(name);
                // for SVG
                if ({}.toString.apply(ele[propName]).substr(0, 7) !== '[object') {
                  ele[propName] = '';
                }
              } else {
                ele.setAttribute(name, value);
                // for SVG
                if ({}.toString.apply(ele[propName]).substr(0, 7) !== '[object') {
                  ele[propName] = value;
                }
              }
            }
          }
        }
      } else if (ele.bbnSchema.props[name] !== value) {
        var _ele$bbn;
        ele.bbnSchema.props[name] = value;
        if ((_ele$bbn = ele.bbn) !== null && _ele$bbn !== void 0 && _ele$bbn.$isInit) {
          ele.bbn.$setProp(name, value);
        }
        isChanged = true;
      }
    });
    if (isChanged) {
      var _ele$bbn2;
      if (isComponent && (_ele$bbn2 = ele.bbn) !== null && _ele$bbn2 !== void 0 && _ele$bbn2.$isMounted) {
        ele.bbn.$tick();
      }
    }
  }

  /**
   * Sets the props and attributes of the component element based on its combined schema
   * 
   * @returns {undefined}
   */
  $updateFromSchema(props) {
    if (this.$el.bbnSchema) {
      var _this$$el$bbnSchema$p, _this$$el$bbnSchema$p2;
      //bbn.fn.warning("updateFromSchema " + this.$options.name);
      // The classes on the component itself are only generated once 
      // Concatenating classes from the attributes and from componentClass
      const cls = ['bbn-component'];
      if (this.componentClass) {
        cls.push(this.componentClass);
      }
      if (props !== null && props !== void 0 && props.class) {
        cls.push(props.class);
      }
      if ((_this$$el$bbnSchema$p = this.$el.bbnSchema.props) !== null && _this$$el$bbnSchema$p !== void 0 && _this$$el$bbnSchema$p.class) {
        cls.push(this.$el.bbnSchema.props.class);
      }
      let textCls = bbn.cp.convertClasses(cls);
      if (this.$el.className !== textCls) {
        // Converting to string
        this.$el.className = textCls;
      }
      //bbn.fn.log("PUTTING CLASSES " + textCls);

      let stl = [((_this$$el$bbnSchema$p2 = this.$el.bbnSchema.props) === null || _this$$el$bbnSchema$p2 === void 0 ? void 0 : _this$$el$bbnSchema$p2.style) || ''];
      stl.push(this.$attr.style || '');
      if (props !== null && props !== void 0 && props.style) {
        stl.push(props.style);
      }
      if ((props === null || props === void 0 ? void 0 : props['bbn-show']) !== undefined) {
        stl.push({
          display: props['bbn-show'] ? 'block' : 'none'
        });
      }
      stl = bbn.cp.convertStyles(stl);
      if (stl) {
        this.$el.style.cssText = bbn.cp.convertStyles(stl);
      }
      for (let n in props) {
        if (!['class', 'style'].includes(n)) {
          let value = props[n];
          if (Object.hasOwn(this.$props, n)) {
            this.$setProp(n, value);
          }
          if (bbn.fn.isPrimitive(value)) {
            let propName = n;
            if (bbn.cp.badCaseAttributes[n]) {
              propName = bbn.cp.badCaseAttributes[n];
            }
            const isAttr = this.$el[propName] !== undefined;
            if (isAttr) {
              const attr = this.$el[propName];
              if (attr !== value) {
                if (!value) {
                  this.$el.removeAttribute(n);
                  // for SVG
                  if ({}.toString.apply(this.$el[propName]).substr(0, 7) !== '[object') {
                    this.$el[propName] = '';
                  }
                } else {
                  this.$el.setAttribute(n, value);
                  // for SVG
                  if ({}.toString.apply(this.$el[propName]).substr(0, 7) !== '[object') {
                    this.$el[n] = bbn.fn.isString(value) ? value : (value === null || value === void 0 ? void 0 : value.toString()) || '';
                  } else {
                    //bbn.fn.warning("SVG OBJ " +propName);
                    //bbn.fn.log(this.$el[propName]);
                  }
                }
              }
            }
          }
        }
      }
      /*
      for (let n in props) {
        if (!['class', 'style'].includes(n)) {
          if (Object.hasOwn(this.$props, n)) {
            this.$setProp(n, props[n]);
          }
          else if (this.$el[n] !== undefined) {
            this.$el[n] = bbn.fn.isString(props[n]) ? props[n] : props[n]?.toString() || '';
          }
        }
      }
      */
    }
  }

  /**
   * Set the watcher for the given property.
   * 
   * @param {Number} index The loop index if any
   * @returns {undefined}
   */
  $watch(name, a) {
    const cp = this;
    const val = bbn.fn.getProperty(cp, name);
    let tmp = bbn.fn.createObject({
      handler: (bbn.fn.isFunction(a) ? a : a.handler).bind(cp),
      immediate: a.immediate || false,
      deep: a.deep || false,
      value: val,
      hash: bbnData.hash(val),
      num: 0
    });
    //bbn.fn.log(["WATCHING " + name, val, tmp])

    cp.$watcher[name] = tmp;

    // Returns a function to cancel the watcher
    return () => {
      delete cp.$watcher[name];
    };
  }
  $setRef(ref, ele) {
    if (this.$refsElements[ref] && this.$refsElements[ref] !== ele) {
      if (!bbn.fn.isArray(this.$refsElements[ref])) {
        if (!this.$refsElements[ref].isConnected) {
          this.$refsElements[ref] = ele;
        } else {
          this.$refsElements[ref] = [this.$refsElements[ref]];
        }
      }
      if (bbn.fn.isArray(this.$refsElements[ref])) {
        this.$refsElements[ref].push(ele);
      }
    } else {
      this.$refsElements[ref] = ele;
    }
  }
  $makeReactive(obj) {
    return obj;
    //const cp = this;
    //return bbn.fn.makeReactive(obj, () => cp.$tick(), cp);
  }

  $setUpData(name, value) {
    if (!Object.hasOwn(this, name)) {
      // The data will remain the same if not simple Obj/Array
      this.$dataValues[name] = bbnData.treatValue(value, this, name);
      const def = {
        get() {
          return this.$dataValues[name];
        },
        set(v) {
          return this.$setData(name, v);
        }
      };
      Object.defineProperty(this, name, def);
      this.$addNamespace(name, 'data');
      if (this.$numBuild) {
        this.$updateWatcher(name, this.$dataValues[name], true);
      }
      if (this.$isMounted) {
        this.$tick();
      }
    }
  }
  $updateWatcher(name, v, init) {
    var _this$$watcher;
    if ((init || this.$isInit) && (_this$$watcher = this.$watcher) !== null && _this$$watcher !== void 0 && _this$$watcher[name]) {
      let lev = 0;
      const bits = name.split(".");
      for (let i = bits.length - 1; i > -1; i--) {
        var _this$$watcher$name;
        let name = bits.join('.');
        if ((_this$$watcher$name = this.$watcher[name]) !== null && _this$$watcher$name !== void 0 && _this$$watcher$name.handler) {
          if (!bbn.fn.isFunction(this.$watcher[name].handler)) {
            throw new Error(bbn._("Watchers must be function, wrnmg parameter for %s", name));
          }
          const hash = bbnData.hash(v);
          if ((!lev || this.$watcher[name].deep) && hash !== this.$watcher[name].hash) {
            let oldDataObj = bbnData.getObject(this.$watcher[name].value);
            let oldV = oldDataObj ? oldDataObj.value : this.$watcher[name].value;
            this.$watcher[name].value = lev ? bbn.fn.getProperty(this, name) : v;
            this.$watcher[name].hash = bbnData.hash(this.$watcher[name].value);
            this.$watcher[name].num++;
            if (!init) {
              this.$watcher[name].handler.apply(this, [this.$watcher[name].value, oldV]);
            }
          }
        }
        bits.pop();
        lev++;
      }
    }
  }

  /**
  * Set the data properties of the object
  */
  $setData(name, v) {
    //bbn.fn.log(["SET DATA", this, name, v]);
    // In the case the function is called litterally it creates 
    if (!Object.hasOwn(this, name)) {
      return this.$setUpData(name, v);
    }
    if (this.$dataValues[name] !== v) {
      let isMod = true;
      // Will remain the same if not simple Obj/Array
      const oldV = bbnData.getValue(this.$dataValues[name]);
      // Getting the bbnData object
      let oldDataObj = bbnData.getObject(oldV);
      if (oldDataObj) {
        if (oldDataObj.isSame(v)) {
          isMod = false;
        } else {
          //bbn.fn.log(["REMOVING COMPONENT FROM DATA", this, oldV, v]);
          oldDataObj.removeComponent(this, name);
        }
      }
      if (isMod) {
        const newVal = bbnData.treatValue(v, this, name);
        this.$dataValues[name] = newVal;
        this.$updateWatcher(name, newVal);
        this.$tick();
      }
    }
  }
  $setUpProp(name, cfg) {
    if (!/[A-Z]/.test(name)) {
      name = bbn.fn.camelize(name);
    }
    if (Object.hasOwn(this.$cfg.props, name)) {
      if (!Object.hasOwn(this.$props, name)) {
        Object.defineProperty(this.$props, name, {
          value: undefined,
          writable: false,
          enumerable: true,
          configurable: true
        });
      }
      this.$addNamespace(name, 'props');
    }
    const value = this.$checkPropValue(name, cfg);
    const isDefined = value !== undefined;
    if (isDefined) {
      this.$realSetProp(name, value);
    }
  }
  $getProp(name) {
    if (Object.hasOwn(this.$el.bbnSchema.props || {}, name) && this.$el.bbnSchema.props[name] !== this.$props[name]) {
      this.$setProp(name, this.$el.bbnSchema.props[name]);
    }
    let v = bbnData.getValue(this.$props[name]);
    /*
    if (!bbn.fn.isPrimitive(v) && (typeof v === 'object') && [Array, Object, undefined].includes(v.constructor)) {
      const hash = bbn.fn.hash(v);
      if (this.$oldValues[name] !== hash) {
        if (this.$isInit) {
          if (this.$watcher?.[name]?.handler) {
            if (!bbn.fn.isFunction(this.$watcher[name].handler)) {
              throw new Error(bbn._("Watchers must be function, wrnmg parameter for %s", name));
            }
            const oldV = this.$watcher[name].value;
            this.$watcher[name].value = v;
            this.$watcher[name].handler.apply(this, [v, oldV]);
          }
           this.$oldValues[name] = hash;
          this.$tick();
        }
      }
    }
    */

    return v;
  }

  /**
   * Set properties of the initial component to the new web-component
   */
  $setProp(name, value) {
    if (!/[A-Z]/.test(name)) {
      name = bbn.fn.camelize(name);
    }
    const cfg = this.$cfg.props[name];
    /*
    if (bbn.cp.possibleAttributes.includes(name)) {
      return;
    }
    */

    if (!this.$el.constructor.bbnFn.$acceptedAttributes.includes(name) && name.indexOf('bbn') !== 0) {
      bbn.fn.warning(bbn._("The attribute %s in %s is not a property", name, this.$options.name));
      return;
    }
    if (!Object.hasOwn(this.$props, name)) {
      //bbn.fn.warning(bbn._("The attribute %s in %s is not defined", name, this.$options.name));
      return;
    }
    let v = this.$checkPropValue(name, cfg, value);
    if (v === this[name]) {
      return;
    }
    this.$realSetProp(name, v);
  }
  $realSetProp(name, value) {
    if (!/[A-Z]/.test(name)) {
      name = bbn.fn.camelize(name);
    }
    const original = this.$props[name];
    if (!bbn.fn.isSame(value, original)) {
      const oldObj = bbnData.getObject(original);
      if (oldObj) {
        oldObj.unset();
      }
    } else {
      return;
    }
    const newValue = bbnData.treatValue(value, this, name);
    const dataObj = bbnData.getObject(newValue);
    Object.defineProperty(this.$props, name, {
      value: newValue,
      writable: false,
      configurable: true
    });
    this.$updateWatcher(name, newValue);
    if (this.$isMounted) {
      this.$emit('propchange', name, newValue, original);
      //bbn.fn.log(["EMITTING PROPCHANGE", this.$options.name, this.$cid, name, newValue, original, hash, oldHash, JSON.stringify(value)]);
    }
  }

  $checkPropValue(name, cfg, value) {
    if (!cfg) {
      throw new Error(bbn._("The property %s is not defined in component %s", name, this.$options.name));
    }
    let isDefined = Object.hasOwn(this.$options.propsData, name) && this.$options.propsData[name] !== undefined;
    let v = undefined;
    if (value !== undefined) {
      v = value;
      isDefined = true;
    } else if (isDefined) {
      v = this.$options.propsData[name];
    }
    if (!this.$numBuild && !isDefined && cfg.default !== undefined) {
      if (bbn.fn.isObject(cfg.default) || bbn.fn.isArray(cfg.default)) {
        throw new Error(bbn._("A function must be used to return object default values in %s", name));
      }
      v = bbn.fn.isFunction(cfg.default) ? cfg.default() : cfg.default;
      isDefined = true;
    }
    if (cfg.required && (!isDefined || [null, undefined, ''].includes(v))) {
      throw new Error(bbn._("The property %s is required in component %s", name, this.$options.name));
    }
    if (cfg.type && isDefined && ![null, undefined, ''].includes(v)) {
      bbn.fn.checkType(v, cfg.type, bbn._("Wrong type for %s in component %s", name, this.$options.name));
    }
    if (isDefined && bbn.fn.isFunction(cfg.validator) && !cfg.validator(v)) {
      throw new Error(bbn._("The property %s is invalid", name));
    }
    return v;
  }

  /**
   * Update the data property with the dataSource Array
   */
  $updateData() {
    if (this.$isDataSet) {
      return;
    }
    if (this.$dataSource.length) {
      let tmp = bbn.fn.createObject(bbn.fn.extend(bbn.fn.createObject(), ...this.$dataSource.map(a => a.apply(this))));
      bbn.fn.each(tmp, (v, n) => {
        this.$setUpData(n, v);
      });
    }
    Object.defineProperty(this, '$isDataSet', {
      value: true,
      writable: false,
      configurable: false
    });
  }
  $updateComputed(name, val) {
    if (!this.$computed[name]) {
      throw new Error(bbn._("The computed %s is not defined in %s", name, this.$options.name));
    }
    const hash = bbnData.hash(val);
    if (!bbn.fn.isSame(this.$computed[name].hash, hash)) {
      const oldValue = this.$computed[name].val;
      //bbn.fn.log(["UPDATING COMPUTED " + name + " IN " + this.$options.name, val, oldValue]);
      this.$computed[name].old = oldValue;
      this.$computed[name].hash = hash;
      this.$computed[name].num = this.$computed[name].num < this.$numBuild ? this.$numBuild + 1 : this.$computed[name].num + 1;
      val = bbnData.treatValue(val, this, name);
      this.$computed[name].val = val;
      this.$updateWatcher(name, val);
      this.$tick();
      return true;
    }
    return false;
  }
  $updateAllComputed() {
    this.$isUpdatingComputed = true;
    bbn.fn.iterate(this.$computed, (a, name) => {
      a.update.bind(this)();
    });
    this.$isUpdatingComputed = false;
  }
  $retrieveComponent(id, hash) {
    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    let loopObj = arguments.length > 3 ? arguments[3] : undefined;
    const ele = this.$retrieveElement(...arguments);
    return (ele === null || ele === void 0 ? void 0 : ele.bbn) || null;
  }
  $retrieveLoopObject(id, hash) {
    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    return retrieve(id, hash, index, true);
  }

  /**
   * Register the given child of the component into the $children array
   */
  $registerChild(child) {
    bbn.fn.checkType(child, Object, "The child must be an object");
    this.$children.push(child);
    if (this.onRegisterChild) {
      this.onRegisterChild(child);
    }
  }

  /**
   * Unregister the given child of the component from the $children array
   */
  $unregisterChild(child) {
    let idx = this.$children.indexOf(child);
    if (idx > -1) {
      this.$children.splice(idx, 1);
    }
  }
  $_setInternalResult(_r, _name, _res, _hash) {
    if (!_r[_name]) {
      _r[_name] = bbn.fn.createObject();
    }
    if (!_hash) {
      _hash = '_root';
    }
    // If not set it's new
    if (!_r[_name][_hash]) {
      _r[_name][_hash] = bbn.fn.createObject({
        state: 'NEW',
        value: _res,
        elements: []
      });
      _r[_name][_hash].old = bbnData.hash(_r[_name][_hash].value);
    } else if (_r[_name][_hash].state === 'DEL') {
      _r[_name][_hash].value = _res;
      _r[_name][_hash].state = 'NEW';
    }
    // If it's a temporary value, we set it
    else if (_r[_name][_hash].state === 'TMP') {
      _r[_name][_hash].value = _res;
      const _o = bbnData.hash(_r[_name][_hash].value);
      if (!bbn.fn.isSame(_r[_name][_hash].old, _o)) {
        _r[_name][_hash].state = 'MOD';
      } else {
        _r[_name][_hash].state = 'OK';
      }
      _r[_name][_hash].old = _o;
    }
    return _r[_name][_hash].value;
  }
  $_getInternalState(_r, _name, _hash) {
    var _r$_name;
    if (!_hash) {
      _hash = '_root';
    }
    if (!((_r$_name = _r[_name]) !== null && _r$_name !== void 0 && _r$_name[_hash])) {
      bbn.fn.log("STATE", _r);
      throw new Error(_name + '  ---  ' + _hash + ' are not defined in ' + this.$options.name);
    }
    return _r[_name][_hash].state;
  }
  $_getInternalValue(_r, _name, _hash) {
    var _r$_name2;
    if (!_hash) {
      _hash = '_root';
    }
    if (!((_r$_name2 = _r[_name]) !== null && _r$_name2 !== void 0 && _r$_name2[_hash])) {
      bbn.fn.log("VALUE", _r);
      throw new Error(_name + '  --- ' + _hash + ' are not defined in ' + this.$options.name);
    }
    return _r[_name][_hash].value;
  }

  /**
   * beforeCreate hooks execution
   */
  $onBeforeCreate() {
    if (this.$cfg.beforeCreate) {
      bbn.fn.each(this.$cfg.beforeCreate, fn => {
        fn.bind(this)();
      });
    }
  }

  /**
   * created hooks execution
   */
  $onCreated() {
    if (this.$cfg.created) {
      bbn.fn.each(this.$cfg.created, fn => fn.apply(this));
    }
  }

  /**
   * beforeMount hooks execution
   */
  $onBeforeMount() {
    if (this.$cfg.beforeMount) {
      bbn.fn.each(this.$cfg.beforeMount, fn => fn.apply(this));
    }
  }

  /**
   * mounted hooks execution
   */
  $onMounted() {
    if (this.$cfg.mounted) {
      bbn.fn.each(this.$cfg.mounted, fn => fn.apply(this));
    }
  }

  /**
   * updated hooks execution
   */
  $onUpdated() {
    if (this.$cfg.updated) {
      bbn.fn.each(this.$cfg.updated, fn => fn.apply(this));
    }
  }

  /**
   * beforeDestroy hooks execution
   */
  $onBeforeDestroy() {
    if (this.$cfg.beforeDestroy) {
      bbn.fn.each(this.$cfg.beforeDestroy, fn => fn.apply(this));
    }
  }

  /**
   * destroyed hooks execution
   */
  $onDestroyed() {
    if (this.$cfg.destroyed) {
      bbn.fn.each(this.$cfg.destroyed, fn => fn.apply(this));
    }
  }

  /**
   * Add delay before another function call
   */
  $tick() {
    let row = bbn.fn.getRow(bbn.cp.queue, {
      cp: this
    });
    if (!row) {
      row = {
        cp: this,
        fns: []
      };
      bbn.cp.queue.push(row);
    }
    //bbn.fn.log("TICK");
    //console.trace();
    //bbn.fn.log(this, '--------------------')
  }

  /**
   * Check if there is no conflict between attributes/methods and
   * add list all the public methods and attributes that can be used by the component
   * @param name
   * @param type
   */
  $addNamespace(name, type) {
    if (!type) {
      throw new Error(bbn._("Type must be defined for %s", name));
    }
    if (bbn.var.reserved.includes(name)) {
      throw new Error(bbn._("The name %s is reserved", name));
    }
    if (this.$namespaces[name] && this.$namespaces[name] !== type) {
      bbn.fn.log(["The namespace already exists", "Component name: " + this.$options.name, "Prop name: " + name, this.$namespaces, name]);
      throw new Error(bbn._("The name %s in %s is already used by %s in %s", name, type, this.$namespaces[name], this.$options.name));
    }
    this.$namespaces[name] = type;
  }
  $isComponent(node) {
    var _this$$options$compon;
    if (node.tag && (_this$$options$compon = this.$options.components) !== null && _this$$options$compon !== void 0 && _this$$options$compon[node.tag]) {
      return true;
    }
    return bbn.cp.isComponent(node);
  }

  /**
   * Sets the given property on the given object using static method
   * @param {Object} obj 
   * @param {String} prop 
   * @param {*} value 
   * @param {Boolean} writable 
   * @param {Boolean} configurable 
   * @returns 
   */
  $set(obj, prop, value) {
    let writable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    let configurable = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    // Case where it's the prop or data of a component
    if (bbn.cp.isComponent(obj)) {
      //  It already exists
      if (obj.$namespaces[prop]) {
        // New treated value
        const dataObj = bbnData.treatValue(value, obj, prop);
        // The value is different
        if (!bbn.fn.isSame(dataObj, obj[prop])) {
          // It's a prop
          if (obj.$namespaces[prop] === 'props') {
            obj.$setProp(prop, value);
          }
          // It's a data
          else {
            obj[prop] = value;
          }
        }
      }
      // Creating a new data
      else {
        obj.$setUpData(prop, value);
      }
    } else {
      // Creating or updating if possible a property to the given object
      Object.defineProperty(obj, prop, {
        value,
        writable,
        configurable
      });
    }
    return this;
  }

  /**
   * Gets the given property from the given object using static method
   * @param {*} obj 
   * @param {*} prop 
   * @returns 
   */
  $get(obj, prop) {
    return obj[prop];
  }

  /**
   * Deletes the given property from the given object using static method
   * @param {*} obj 
   * @param {*} prop 
   * @returns 
   */
  $delete(obj, prop) {
    return delete obj[prop];
  }
  async $nextTick(fn) {
    const cp = this;
    return new Promise(resolve => {
      setTimeout(() => {
        if (fn) {
          fn.bind(cp)();
        }
        resolve();
      }, bbn.cp.tickDelay);
    });
  }
  /*
  $nextTick(fn) {
    return new Promise((resolve) => {
      if (!this.$queue.length) {
        this.$queue.push([]);
      }
       this.$queue[0].push(fn || resolve);
    });
  }
  */

  /**
   * Emits a new event with variable arguments
   */
  $emit(eventName) {
    bbn.fn.checkType(eventName, String);
    if (bbn.env.loggingLevel > 5) {
      bbn.fn.log(bbn._("Event %s emitted by %s", eventName, this.$options.name));
    }
    /*
    if ((args.length === 1) && (args[0] instanceof Event) && (args[0].type === eventName)) {
      
      this.$el.dispatchEvent(args[0]);
      return;
    }
    */

    let ok = true;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    bbn.fn.each(args, a => {
      if (!bbn.fn.isPrimitive(a)) {
        if (a instanceof CustomEvent && a.detail && a.detail.__bbnEvent) {
          ok = false;
          return false;
        }
      }
    });
    if (!ok) {
      return;
    }
    const option = bbn.fn.createObject({
      detail: {
        __bbnEvent: true,
        args: args
      }
    });
    const ev = new CustomEvent(eventName, option);
    this.$el.dispatchEvent(ev);
  }

  /**
   * Sets an event listener for the given event with the given handler on the component's element
   * @param {String} event 
   * @param {Function} handler 
   */
  $on(event, handler, remove, bound) {
    if (!bound) {
      bound = this;
    }
    bbn.fn.checkType(event, String, bbn._("Events must be strings for \$on in %s", this.$options.name));
    bbn.fn.checkType(handler, Function, bbn._("Events handlers must be functions for \$on in %s", this.$options.name));
    const fn = bbn.fn.analyzeFunction(handler);
    const hash = bbn.fn.md5((bound || this).$cid + '-' + fn.hash);
    if (!this.$events[event]) {
      this.$events[event] = bbn.fn.createObject();
    }
    if (!remove && this.$events[event][hash]) {
      //throw new Error(bbn._("The event %s is already set in %s", event, this.$options.name));
    }
    this.$events[event][hash] = ev => {
      var _ev$detail;
      const args = [];
      if ((_ev$detail = ev.detail) !== null && _ev$detail !== void 0 && _ev$detail.args) {
        args.push(...ev.detail.args);
      }
      /*
      else {
        args.push(ev);
      }
      */

      handler.bind(bound)(...args);
    };
    const opt = {};
    if (remove) {
      opt.once = true;
    }
    this.$el.addEventListener(event, this.$events[event][hash], opt);
  }

  /**
   * Removes an event listener on the element set with $on
   * @param {String} event 
   * @param {Function} handler 
   */
  $off(event, handler, bound) {
    var _this$$events$event;
    bbn.fn.checkType(event, String, bbn._("Events must be strings for \$off / %s in %s", event, this.$options.name));
    bbn.fn.checkType(handler, Function, bbn._("Events handlers must be functions for \$off / %s in %s", event, this.$options.name));
    const fn = bbn.fn.analyzeFunction(handler);
    const hash = bbn.fn.md5((bound || this).$cid + '-' + event + '-' + handler.toString());
    if ((_this$$events$event = this.$events[event]) !== null && _this$$events$event !== void 0 && _this$$events$event[hash]) {
      this.$el.removeEventListener(event, this.$events[event][hash]);
      delete this.$events[event][hash];
    }
  }

  /**
   * Sets an event listener for the given event with the given handler on the component's element
   * @param {String} event 
   * @param {Function} handler 
   */
  $once(event, handler) {
    this.$off(event, handler);
    this.$on(event, handler, true);
  }

  /**
   * Forcing executing tick (updateComponent) function by setting this.$tickLast to 0
   */
  async $forceUpdate(fn) {
    if (!this.$isBusy) {
      const prom = this.$updateComponent();
      if (fn) {
        return prom.then(() => fn);
      }
      return prom;
    } else {
      return new Promise(resolve => {
        let row = bbn.fn.getRow(bbn.cp.queue, {
          cp: this
        });
        if (!row) {
          row = {
            cp: this,
            fns: [resolve],
            force: true
          };
          bbn.cp.queue.push(row);
        }
        row.fns.push(resolve);
        if (fn && bbn.fn.isFunction(fn)) {
          row.fns.push(fn);
        }
        if (!row.force) {
          row.force = true;
        }
      });
    }
  }

  /**
   * @todo!
   */
  $destroy() {
    this.$root.$removeDOM(this.$el);
  }

  /**
   * Return the function bbn._ for the strings' translation.
   * @method _
   * @return {Function}
   */
  _() {
    return bbn._(...arguments);
  }

  /**
  * Returns the given ref (will return $refs[name] or $refs[name][0])
  * @method getRef
  * @param {String} name
  * @fires bbn.cp.getRef
  * @return {Function}
  */
  getRef(name) {
    return bbn.fn.isArray(this.$refs[name]) ? this.$refs[name][0] : this.$refs[name];
  }

  /**
  * Checks if the component corresponds to the selector
  * @method is
  * @fires bbn.cp.is
  * @param {String} selector 
  * @return {Function}
  */
  $is(selector) {
    return this.$el.matches(selector);
  }

  /*
  getPopup() {
    let popup = this.currentPopup;
    if (!popup) {
      let vm = this.$parent;
      while (vm && !popup) {
        if (vm.currentPopup) {
          popup = vm.currentPopup;
        }
        else {
          vm = vm.$parent;
        }
      }
    }
     if (arguments.length && popup) {
      let cfg = arguments[0];
      let args = [];
      if (bbn.fn.isObject(cfg)) {
        cfg.opener = this;
      }
       args.push(cfg);
      for (let i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
       return popup.open.apply(popup, args);
    }
     return popup;
  }
  */

  /**
  * Returns the closest component matching the given selector
  * @method closest
  * @param {String} selector
  * @param {Boolean} checkEle
  * @return {Function}
  */
  closest(selector, checkEle) {
    let ele = checkEle ? this.$el : this.$el.parentNode;
    let letters = selector.split('');
    if (!['.', '#', '[', ':'].filter(c => letters.includes(c)).length) {
      selector += ',*[is=' + selector + ']';
    }
    while (ele instanceof HTMLElement) {
      if (ele.matches(selector)) {
        return ele.bbn || ele;
      }
      ele = ele.bbnPortal || ele.parentNode || null;
    }
  }

  /**
  * Returns an array of parent components until $root
  * @method ancestors
  * @param {String} selector
  * @param {Boolean} checkEle
  * @return {Function}
  */
  ancestors(selector, checkEle) {
    let res = [];
    let ele = this.closest(selector, checkEle);
    while (ele) {
      res.push(ele);
      ele = ele.closest(selector);
    }
    return res;
  }

  /**
  * Fires the function bbn.cp.getChildByKey.
  * @method getChildByKey
  * @param {String} key
  * @param {String} selector
  * @return {Function}
  */
  getChildByKey(key, selector) {
    //to do?
  }

  /**
  * Fires the function bbn.cp.findByKey.
  * @method findByKey
  * @param {String} key
  * @param {String} selector
  * @param {Array} ar
  * @return {Function}
  */
  findByKey(key, selector, ar) {
    // to do?
  }

  /**
  * Fires the function bbn.cp.findAllByKey.
  * @method findAllByKey
  * @param {String} key
  * @param {String} selector
  * @return {Function}
  */
  findAllByKey(key, selector) {
    // to do?,
  }

  /**
  * Fires the function bbn.cp.find.
  * @method find
  * @param {String} selector
  * @param {Number} index
  * @return {Function}
  */
  find(selector, index) {
    var _this$$el$querySelect;
    const letters = selector.split('');
    if (!['.', '#', '[', ':'].filter(c => letters.includes(c)).length) {
      selector += ',*[is=' + selector + ']';
    }
    if (index) {
      selector += ':nth-of-type(' + index + ')';
    }
    return (_this$$el$querySelect = this.$el.querySelector(selector)) === null || _this$$el$querySelect === void 0 ? void 0 : _this$$el$querySelect.bbn;
  }

  /**
  * Fires the function bbn.cp.findAll.
  * @method findAll
  * @param {String} selector 
  * @param {Boolean} only_children 
  * @return {Function}
  */
  findAll(selector, only_children) {
    const letters = selector.split('');
    if (!['.', '#', '[', ':'].filter(c => letters.includes(c)).length) {
      selector += ',*[is=' + selector + ']';
    }
    if (only_children) {
      let res = [];
      Array.from(this.childNodes).forEach(a => {
        if (a.tagName && a.matches(selector)) {
          res.push(a.bbn);
        }
      });
      return res;
    }
    return Array.from(this.$el.querySelectorAll(selector)).map(a => a.bbn);
  }

  /**
  * @method extend
  * @param {Boolean} selector
  * @param {Object} source The object to be extended
  * @param {Object} obj1
  * @return {Object}
  */
  extend(deep, src, obj1) {
    // to do?
  }

  /**
  * Fires the function bbn.cp.getComponents.
  * @method getComponents
  * @param {Array} ar 
  * @param {Boolean} only_children 
  * @return {Function}
  */
  getComponents(ar, only_children) {
    if (only_children) {
      return Array.from(this.childNodes).filter(a => !!a._bbn);
    } else {
      return this.querySelectAll('*').filter(a => !!a._bbn);
    }
  }

  /**
   * Returns a component name based on the name of the given component and a path.
   * @method getComponentName
   * @memberof bbn.cp
   */
  getComponentName() {
    return this.$options.name;
  }
}
import { bbn } from "@bbn/bbn";

/**
 * Takes care of the data reactivity for non primitive values.
 */
export default class bbnData {
  /**
   * Returns a unique identifier from any type of value (hashes only simple objects and arrays)
   * 
   * @param {*} v Value to hash
   * @returns {String} The hash
   */
  static hash(v) {
    let hash = bbn.fn.hash(v);
    return hash;
  }

  /**
   * Add a special property to an object in order to prevent it from being reactive
   * @param {Object} value The value to immunize
   * @returns {Object} The immunized value
   */
  static immunizeValue(value, deep) {
    if (value && typeof value === 'object' && [undefined, Object, Array].includes(value.constructor)) {
      if (value.__bbnData) {
        const dataObj = bbnData.getObject(value);
        if (dataObj) {
          dataObj.unset();
        }
      }
      Object.defineProperty(value, '__bbnNoData', {
        value: true,
        enumerable: false,
        configurable: false,
        writable: false
      });
    }
    if (deep) {
      bbn.fn.iterate(value, (v, i) => {
        try {
          value[i] = bbnData.immunizeValue(v, true);
        } catch (e) {}
      });
    }
    return value;
  }

  /**
   * Gets the value stored in the bbnData object
   * @param {bbnData} obj 
   * @param {Boolean} original 
   * @returns {Object} The reactive value or the original value
   */
  static getValue(obj, original) {
    if (obj && typeof obj === 'object' && obj instanceof bbnData) {
      return obj[original ? 'data' : 'value'];
    }
    return obj;
  }

  /**
   * Returns the bbnData object from a value
   * @param {Object} value 
   * @returns {bbnData|null}
   */
  static getObject(value) {
    if (value && typeof value === 'object' && value.__bbnData) {
      return bbn.cp.dataInventory.get(value.__bbnData);
    }
    return null;
  }

  /**
   * Creates a new bbnData object if the given value is not primitive or already reactive, returns the value
   * @param {*} value 
   * @param {*} component 
   * @param {*} path 
   * @param {*} parent 
   * @returns {*} The original value or the reactive value
   */
  static treatValue(value, component, path, parent) {
    if (component.$isDestroyed) {
      return value;
    }
    if (value && typeof value === 'object' && [undefined, Object, Array].includes(value.constructor) && !value.__bbnNoData) {
      if (value.__bbnData) {
        if (!bbn.cp.dataInventory.has(value.__bbnData)) {
          //throw new Error(bbn._("The data inventory does not contain the data object"));
          bbn.fn.log(value);
          bbn.fn.warning(bbn._("The data inventory does not contain the data object"));
          return value;
        }
        const dataObj = bbn.cp.dataInventory.get(value.__bbnData);
        if (!parent) {
          dataObj.addComponent(component, path);
        }
        return dataObj.value;
      }
      if (value._bbnComponent) {
        throw new Error(bbn._("The data object is a component definition"));
      }
      const dataObj = new bbnData(value, component, path, parent);
      return dataObj.value;
    }
    return value;
  }

  /**
   * Pops the last element of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxyPop(target) {
    return () => {
      // The bbnData object of the target array
      const targetObj = bbnData.getObject(target);
      const len = target.length;
      if (len) {
        const subObj = bbnData.getObject(target[len - 1]);
        if (subObj) {
          subObj.unset();
        }
      }
      const res = target.pop();
      if (targetObj) {
        //bbn.fn.log("POP");
        targetObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in pop", target]);
      }
      return res;
    };
  }

  /**
   * Shifts the first element of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxyShift(target) {
    return () => {
      // The bbnData object of the target array
      const targetObj = bbnData.getObject(target);
      if (target.length) {
        const subObj = bbnData.getObject(target[0]);
        if (subObj) {
          subObj.unset();
        }
      }
      const res = target.shift();
      if (targetObj) {
        //bbn.fn.log("SHIFT");
        targetObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in shift", target]);
      }
      return res;
    };
  }

  /**
   * Pushes one or more elements to the end of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxyPush(target, component, path) {
    return function () {
      // The bbnData object of the target array
      const targetObj = bbnData.getObject(target);
      let newArgs = [];
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      bbn.fn.each(args, (a, i) => {
        const idx = target.length + i;
        const newVal = bbnData.treatValue(a, component, idx, targetObj);
        newArgs.push(newVal);
      });
      const res = target.push(...newArgs);
      if (targetObj) {
        //bbn.fn.log("PUSH");
        targetObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in push", target]);
      }
      return res;
    };
  }

  /**
   * Unshifts one or more elements to the beginning of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxyUnshift(target, component, path) {
    return function () {
      // The bbnData object of the target array
      const targetObj = bbnData.getObject(target);
      let newArgs = [];
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      bbn.fn.each(args, (a, i) => {
        const idx = target.length + i;
        const newVal = bbnData.treatValue(a, component, idx, targetObj);
        newArgs.push(newVal);
      });
      const res = target.unshift(...newArgs);
      const dataObj = bbn.cp.dataInventory.get(target.__bbnData);
      if (dataObj) {
        //bbn.fn.log([dataObj.path, path]);
        //bbn.fn.warning("UNSHIFT");
        dataObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in unshift", target]);
      }
      return res;
    };
  }

  /**
   * Reverses the order of the elements of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxyReverse(target) {
    return function () {
      const res = target.reverse(...arguments);
      const dataObj = bbn.cp.dataInventory.get(target.__bbnData);
      if (dataObj) {
        dataObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in reverse", target]);
      }
      return res;
    };
  }

  /**
   * Sorts the elements of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxySort(target) {
    return function () {
      const res = target.sort(...arguments);
      const dataObj = bbn.cp.dataInventory.get(target.__bbnData);
      if (dataObj) {
        bbn.fn.warning("SORT");
        dataObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in sort", target]);
      }
      return res;
    };
  }

  /**
   * Splices the elements of an array and updates the data object
   * @param {Array} target 
   * @param {*} component 
   * @param {*} path 
   * @returns 
   */
  static proxySplice(target, component, path) {
    return function (index, numDelete) {
      const dataObj = bbn.cp.dataInventory.get(target.__bbnData);
      let newArgs = [];
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }
      bbn.fn.each(args, (a, i) => {
        const idx = target.length + i;
        const newVal = bbnData.treatValue(a, component, idx, dataObj);
        newArgs.push(newVal);
      });
      for (let i = index; i < index + numDelete; i++) {
        let subObj = bbnData.getObject(target[i]);
        if (subObj) {
          subObj.unset();
        }
      }
      const res = target.splice(index, numDelete, ...newArgs);
      if (dataObj) {
        //bbn.fn.log("SPLICE");
        dataObj.update();
      } else {
        bbn.fn.log(["Impossible to find the data object in splice", target]);
      }
      return res;
    };
  }

  /**
   * Returns a set of functions to be used by the proxy of bbnData objects
   * @param {*} component 
   * @param {*} path 
   * @param {*} targetObj 
   * @returns 
   */
  static getProxyHandler(component, path, targetObj) {
    if (path === 'computed') {
      bbn.fn.log([component, path, targetObj]);
      throw new Error("Proxy cannot be initialized with a computed property");
    }
    return {
      get(target, key) {
        const realValue = target[key];
        if (key === '__bbnData') {
          return realValue;
        }
        if (key === '__bbnProxy') {
          return true;
        }
        if (bbn.fn.isFunction(realValue)) {
          if (targetObj && targetObj.isArray && bbn.fn.isString(key)) {
            const fnName = bbn.fn.camelize('proxy-' + key);
            if (bbn.fn.isFunction(bbnData[fnName])) {
              return bbnData[fnName](target, component, path);
            }
            return target[key];
          }
        } else if (realValue) {
          const val = bbnData.treatValue(realValue, component, key, targetObj);
          return val;
        }
        return realValue;
      },
      set(target, key, value) {
        const oldValue = target[key];
        const oldObj = bbnData.getObject(oldValue);
        let mod = false;
        if (oldObj && !oldObj.isSame(value)) {
          const newObj = bbnData.getObject(value);
          //bbn.fn.log(["UNSET", key, oldValue, value, oldObj.path, newObj?.path, oldObj.parent?.value?.length, newObj?.parent?.value?.length]);
          oldObj.unset();
          mod = true;
        } else if (!oldObj && !bbn.fn.isSame(oldValue, value)) {
          mod = true;
        }
        if (mod) {
          const newVal = bbnData.treatValue(value, component, key, targetObj);
          target[key] = newVal;
          const dataObj = bbnData.getObject(newVal);
          /*
          if (key === 'loading') {
            bbn.fn.log(["SET LOADING", value, mod, target, targetObj]);
          }
           bbn.fn.log(["SET", targetObj, key, newVal, oldValue, target, '------']);
          */
          targetObj.update(false, key);
          if (dataObj) {
            dataObj.update();
          }
        }
        return true;
      },
      defineProperty(target, key, description) {
        const oldValue = target[key];
        const oldObj = bbnData.getObject(oldValue);
        if (oldObj) {
          oldObj.unset();
        }
        if (description.value) {
          description.value = bbnData.treatValue(description.value, component, key, targetObj);
        }
        Object.defineProperty(target, key, description);
        if (targetObj) {
          targetObj.update(false, key);
        } else {
          bbn.fn.log(target, key, description);
          bbn.fn.warning("Impossible to get the target object");
        }
        return true;
      },
      deleteProperty(target, key) {
        const dataObj = bbnData.getObject(target[key]);
        if (dataObj) {
          dataObj.unset();
        }
        delete target[key];
        targetObj.update();
        return true;
      }
    };
  }

  /**
   * Constructor
   * @param {Object} data A regular object or array i.e. it mustn't be a class instance
   * @param {bbnCp} component The bbn component that contains the data
   * @param {String} path The path of the data in the component
   * @param {bbnData} parent If the data is a sub-object of another bbnData object, the parent object
   */
  constructor(data, component, path, parent) {
    /*
    if (path === 'computed') {
      bbn.fn.log([component, path, parent, data]);
      throw new Error("bbnData cannot be initialized with a computed property");
    }
    */

    if (data instanceof bbnData) {
      throw new Error("bbnData cannot be initialized with a bbnData");
    }
    if (!(component instanceof bbnCp)) {
      throw new Error("bbnData must be initialized with a bbn component");
    }
    if (!data || typeof data !== 'object' || ![undefined, Object, Array].includes(data.constructor)) {
      bbn.fn.log(data);
      throw new Error("The object given is not compatible with bbnData");
    }
    if (data !== null && data !== void 0 && data.__bbnData) {
      throw new Error("bbnData cannot be initialized with a bbnData");
    }
    if (parent && !(parent instanceof bbnData)) {
      throw new Error("parent must be a bbnData");
    }

    /**
     * @var {Symbol} id The unique id of the bbnData object
     */
    const id = Symbol();
    Object.defineProperty(this, 'id', {
      writable: false,
      configurable: false,
      value: id
    });

    /**
     * @var {String} path The path of the data in the component
     */
    Object.defineProperty(this, 'path', {
      writable: false,
      configurable: false,
      value: path
    });

    /**
     * @var {bbnCp} root The root component of the bbnData object, ie the original component for which the bbnData is created
     */
    Object.defineProperty(this, 'root', {
      writable: false,
      configurable: false,
      value: (parent === null || parent === void 0 ? void 0 : parent.root) || component
    });

    /**
     * @var {bbnData} parent The parent bbnData object if any
     */
    Object.defineProperty(this, 'parent', {
      value: parent || null,
      writable: true,
      configurable: true
    });

    /**
     * @var {Array} children The children bbnData objects (which have this object as parent)
     */
    Object.defineProperty(this, 'children', {
      value: [],
      writable: false,
      configurable: false
    });

    /**
     * @var {Symbol} __bbnData The special property added to the data object to identify it as being part of a bbnData object
     */
    Object.defineProperty(data, '__bbnData', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: this.id
    });

    /**
     * @var {Object|Array} data The original data object
     */
    Object.defineProperty(this, 'data', {
      value: data,
      writable: false,
      configurable: true
    });

    /**
     * @var {Proxy} value The proxy of the data object
     */
    Object.defineProperty(this, 'value', {
      value: new Proxy(this.data, bbnData.getProxyHandler(component, path, this)),
      writable: false,
      configurable: false
    });

    /**
     * @var {Boolean} isArray If the data is an array
     */
    Object.defineProperty(this, 'isArray', {
      value: data instanceof Array,
      writable: false,
      configurable: true
    });

    /**
     * @var {String} old The hash of the data object
     */
    Object.defineProperty(this, 'old', {
      value: bbn.fn.hash(data),
      writable: true,
      configurable: true
    });

    /**
     * @var {Object} components The components that use this data object, indexed by their unique id (cid)
     */
    Object.defineProperty(this, 'components', {
      value: bbn.fn.createObject(),
      writable: false,
      configurable: false
    });
    if (!this.parent || !this.parent.hasComponent(component)) {
      this.components[component.$cid] = {
        component,
        path: [path]
      };
      component.$values.push(this.id);
    }

    // If the object has a parent, the current object is added to the parent's children
    if (this.parent) {
      this.parent.children.push(this);
    }

    // The object is added to the data inventory
    bbn.cp.dataInventory.set(id, this);

    /*
    bbn.fn.each(this.value, (v, i) => {
      bbnData.treatValue(v, component, i, this);
    })
    */
  }

  // Returns the full path of a data object in a component
  fullPath(component) {
    if (!(component instanceof bbnCp)) {
      throw new Error("bbnData must be initialized with a bbn component");
    }
    let dataObj = this;
    const paths = [];
    if (!this.parent && this.root === component) {
      return this.path;
    }
    while (dataObj) {
      if (dataObj.components[component.$cid]) {
        paths.unshift(dataObj.components[component.$cid].path[0]);
        break;
      } else {
        paths.unshift(dataObj.path);
      }
      dataObj = dataObj.parent;
    }
    return paths.join('.');
  }

  /**
   * Returns the highest parent of the current object
   * @returns {bbnData} The root bbnData object
   */
  rootData() {
    let obj = this;
    while (obj.parent) {
      obj = obj.parent;
    }
    return obj;
  }
  isSame(obj) {
    if (obj !== null && obj !== void 0 && obj.__bbnProxy) {
      return bbn.fn.isSame(obj, this.value);
    } else if (obj !== null && obj !== void 0 && obj.__bbnData) {
      return bbn.fn.isSame(obj, this.data);
    }
    return false;
  }

  /**
   * Deletes all references to the data object and its children
   */
  unset(noParent) {
    const id = this.id;
    // Unsetting the children
    bbn.fn.each(this.children, subObj => {
      subObj.unset(true);
    });
    // Unsetting the data in each component but the root
    bbn.fn.iterate(this.components, (it, cid) => {
      const cp = it.component;
      if (cp) {
        // Root will be taken care of later
        if (!this.parent && cp === this.root) {
          return;
        }
        let idx = cp.$values.indexOf(id);
        if (idx > -1) {
          cp.$values.splice(idx, 1);
        } else if (cp.$isInit) {
          bbn.fn.log(this, it);
          throw new Error(bbn._("Impossible to find the data object in the values of the component %s with CID %s", cp.$options.name, cid));
        }

        //cp.$tick();
      } else {
        throw new Error(bbn._("Impossible to find the component %s", cid));
      }
    });

    // Unsetting the data in the root component
    if (!this.parent && this.root) {
      let idx = this.root.$values.indexOf(id);
      if (idx > -1) {
        this.root.$values.splice(idx, 1);
      } else {
        bbn.fn.log(this);
        throw new Error(bbn._("Impossible to find the data object in the values of the component %s", dataObj.root.$options.name));
      }
      //bbn.fn.log(["TICK ON UNSET", this]);
      this.root.$tick();
    }
    if (this.parent) {
      let idx = this.parent.children.indexOf(this);
      if (idx > -1) {
        this.parent.children.splice(idx, 1);
      }
    }
    // Ticking the parent components (only for the original unset call)
    if (!noParent && this.parent) {
      let dataObj = this;
      while (dataObj.parent) {
        dataObj = dataObj.parent;
        bbn.fn.iterate(dataObj.components, it => {
          //it.component.$tick();
        });
      }
    }
    delete this.data.__bbnData;
    bbn.cp.dataInventory.delete(id);
  }

  /**
   * Adds a component to the original bbnData object linked to it
   * @param {bbnCp} component 
   * @param {String} path 
   * @returns {Boolean}
   */
  addComponent(component, path) {
    if (!(component instanceof bbnCp)) {
      throw new Error(bbn._("bbnData hasComponent must be called with a bbn component"));
    }
    if (!this.hasComponent(component)) {
      this.components[component.$cid] = {
        component,
        path: [path]
      };
      if (!component.$values.includes(this.id)) {
        component.$values.push(this.id);
        return true;
      }
    } else if (!this.components[component.$cid]) {
      this.components[component.$cid] = {
        component,
        path: [this.path, path]
      };
      return true;
    } else if (!this.components[component.$cid].path.includes(path)) {
      this.components[component.$cid].path.push(path);
      return true;
    }
    return false;
  }

  /**
   * 
   * @param {bbnCp} component 
   * @returns 
   */
  hasComponent(component) {
    if (!(component instanceof bbnCp)) {
      throw new Error("bbnData hasComponent must be called with a bbn component");
    }
    if (this.components[component.$cid] !== undefined) {
      return true;
    }
    let obj = this;
    while (obj.parent) {
      if (obj.parent.components[component.$cid] !== undefined) {
        return true;
      }
      obj = obj.parent;
    }
    return false;
  }

  /**
   * Removes a component from the data object
   * @param {bbnCp} component 
   */
  removeComponent(component, path) {
    if (!(component instanceof bbnCp)) {
      throw new Error("bbnData hasComponent must be called with a bbn component");
    }
    if (!this.components[component.$cid]) {
      throw new Error("The component is not in the list of components");
    }
    if (component === this.root && (!path || path === this.path)) {
      this.unset();
    } else {
      if (path) {
        let pathIdx = this.components[component.$cid].path.indexOf(path);
        if (pathIdx === -1) {
          throw new Error("The path is not in the list of paths");
        }
        this.components[component.$cid].path.splice(pathIdx, 1);
      }
      if (!path || !this.components[component.$cid].path.length) {
        let idx = component.$values.indexOf(this.id);
        if (idx > -1) {
          component.$values.splice(idx, 1);
        }
        delete this.components[component.$cid];
      }
    }
  }

  /**
   * Update all the components linked to the data object
   * @param {Boolean} deep 
   */
  update(noParent, key) {
    //bbn.fn.log(["UPDATE", this, this.path + '/' + (key || "no key"), this.value]);
    let data = this;
    let lev = 0;
    /*
    if (data.root) {
      bbn.fn.log(["UPDATEBBNDATA", data.root, data]);
    }
    */
    while (data) {
      bbn.fn.iterate(data.components, (it, cid) => {
        if (!(it !== null && it !== void 0 && it.component)) {
          throw new Error(bbn._("Impossible to find the component %s", cid));
        }
        if (it.component.$isInit) {
          let name = this.fullPath(it.component);
          if (!lev && key) {
            name += '.' + key;
          }
          let bits = name.split('.');
          /*
          if (!noParent) {
            bbn.fn.log(['ON UPDATE', this, name, it.path, lev]);
          }
          */

          while (bits.length) {
            var _it$component$$watche;
            if ((_it$component$$watche = it.component.$watcher) !== null && _it$component$$watche !== void 0 && _it$component$$watche[name]) {
              if (bits.length > 1) {
                bits.shift();
                it.component.$updateWatcher(name, bbn.fn.getProperty(data.value, bits.join(".")));
              } else {
                it.component.$updateWatcher(name, data.value);
              }
            }
            bits.pop();
            name = bits.join('.');
          }

          //bbn.fn.log(["TICK on UPDATE", this]);
          it.component.$tick();
        }
      });
      if (data.root) {
        //bbn.fn.log(["root", data.root]);
        data.root.$tick();
      }
      if (!lev) {
        this.updateChildren();
        if (noParent) {
          return;
        }
      }
      data = data.parent;
      lev++;
    }
  }
  updateChildren() {
    if (this.children.length) {
      bbn.fn.each(this.children, obj => {
        obj.update(true);
      });
    }
  }
}
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnElementHTML extends HTMLLIElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnFormHTML extends HTMLFormElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnHTML extends HTMLElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnListHTML extends HTMLUListElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import "../cp.js";

/**
 * Create the bbn component class which extends the HTMLElement class
 */
export default class bbnRowHTML extends HTMLTableRowElement {
  constructor() {
    super();
    _defineProperty(this, "bbnCid", void 0);
    Object.defineProperty(this, 'bbnCid', {
      value: bbn.cp.createCid(),
      writable: false,
      configurable: false
    });
  }
  connectedCallback() {
    return bbn.cp.connectedCallback(this);
  }
  disconnectedCallback() {
    return bbn.cp.disconnectedCallback(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);
  }
  bbnUpdate(newSchema) {
    return bbn.cp.bbnUpdate(this, newSchema);
  }
}
/**
 * @file appui component
 * @description The autocomplete allows to select a single value from a list of items by proposeing suggestions based on the typed characters.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @ignore
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.observer
   * @mixin bbn.cp.mixins.serviceWorker
   * @mixin bbn.cp.mixins.browserNotification
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.localStorage, bbn.cp.mixins.observer, bbn.cp.mixins.serviceWorker, bbn.cp.mixins.browserNotification],
  statics() {
    return {
      registeredComponents: bbn.fn.createObject()
    };
  },
  props: {
    root: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} ['bbn.env.path'] url
     */
    url: {
      type: String,
      default: bbn.env.path
    },
    popup: {
      type: bbnCp
    },
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} def
     */
    def: {
      type: String
    },
    /**
     * @prop {Boolean} [true] autoload
     */
    autoload: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Object} [{}] options
     */
    options: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * @prop {Array} [[]] shortcuts
     */
    shortcuts: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {Object} [{}] plugins
     */
    plugins: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * @prop {Object} [{'span'}] cfg
     */
    cfg: {
      type: Object,
      default() {
        return {
          tag: 'span'
        };
      }
    },
    /**
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default() {
        return [/*{
                url: (this.plugins && this.plugins['appui-core'] ? this.plugins['appui-core'] : 'core') + '/home',
                title: bbn._("Dashboard"),
                load: true,
                fixed: true,
                icon: 'nf nf-fa-tachometer_alt'
                }*/];
      }
    },
    /**
     * @prop {(Object|Boolean)} [{}] searchBar
     */
    searchBar: {
      type: [Object, Boolean],
      default() {
        return {};
      }
    },
    /**
     * @prop {Boolean} [false] single
     */
    single: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] single
     */
    urlNavigation: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} ['bbn.env.siteTitle || bbn._("App-UI")'] title
     */
    title: {
      type: String,
      default: bbn.env.siteTitle || bbn._('App-UI')
    },
    /**
     * If this is set, along with componentSource and componentUrl a single container with this component will be created.
     * @prop {(String|Object)} component
     */
    component: {
      type: [String, Object]
    },
    /**
     * The source for the component.
     * @prop {Object} componentSource
     */
    componentSource: {
      type: Object
    },
    /**
     * The property to get from the componentSource to use for setting the URL.
     * @prop {String} componentUrl
     */
    componentUrl: {
      type: String
    },
    /**
     * Will be passed to router in order to ignore the dirty parameter.
     * @prop {Boolean} [false] ignoreDirty
     */
    ignoreDirty: {
      type: Boolean,
      default: false
    },
    /**
     * Will be passed to router in order to ignore the dirty parameter.
     * @prop {Boolean} [false] ignoreDirty
     */
    loadbar: {
      type: Boolean,
      default: true
    },
    /**
     * Will be passed to the top router in order to make it splittable.
     * @prop {Boolean} [false] splittable
     */
    splittable: {
      type: Boolean,
      default: false
    },
    /**
     * Sets if the router and the ocntainers inside it should be themselves scrollable or part of the global scroll.
     * @prop {Boolean} [false] scrollContent
     */
    scrollContent: {
      type: Boolean,
      default: true
    },
    prefix: {
      type: String
    },
    componentsPath: {
      type: String,
      default: 'components/'
    },
    componentsMixin: {
      type: Object
    },
    header: {},
    nav: {},
    status: {}
  },
  data() {
    let isMobile = bbn.fn.isMobile();
    let isTablet = bbn.fn.isTabletDevice();
    let d = {
      isFocused: false,
      intervalBugChrome: null,
      mode: bbn.env.mode,
      opacity: 0,
      pollerObject: {
        token: bbn.env.token || null
      },
      /* For the server query (checking or not) */
      chatOnline: true,
      /* No chat component if chat is not visible */
      chatVisible: false,
      /* Chat dialog windows */
      chatWindows: [],
      usersOnline: [],
      usersOnlineHash: false,
      width: 0,
      height: 0,
      popups: [],
      // Polling
      polling: false,
      pollingTimeout: 0,
      prePollingTimeout: 0,
      pollingErrors: 0,
      loaders: bbn.env.loadersHistory,
      notifications: [],
      poller: false,
      debug: false,
      isOverDebug: false,
      app: {
        user: {
          isAdmin: true
        }
      },
      cool: false,
      searchString: '',
      observerTimeout: false,
      colorEnvVisible: true,
      currentTitle: this.title,
      searchIsActive: false,
      bigMessage: false,
      hasBigMessage: false,
      searchOn: false,
      pressedKey: false,
      pressedTimeout: false,
      longPressed: false,
      isMobile: isMobile,
      isTablet: isTablet,
      isTouch: isMobile || isTablet,
      isDesktop: !isTablet && !isMobile,
      showBookmarks: false,
      bookmarksLoaded: false,
      isLoading: false,
      loadingText: bbn._('Loading')
    };
    return d;
  },
  computed: {
    isDev() {
      return bbn.env.isDev;
    },
    appComponent() {
      return 'span';
      return bbn.fn.extend({
        render(createElement) {
          return createElement();
        }
      }, this.cfg);
    },
    headerComponent() {
      return this.header && bbn.fn.isObject(this.header) ? this.header : false;
    },
    footerComponent() {
      return this.footer && bbn.fn.isObject(this.footer) ? this.footer : false;
    },
    appMode() {
      if (this.mode === 'dev') {
        return bbn._("Application in development mode");
      }
      if (this.mode === 'prod') {
        return bbn._("Application in production mode");
      }
      if (this.mode === 'test') {
        return bbn._("Application in testing mode");
      }
    }
  },
  methods: {
    fdate: bbn.fn.fdate,
    onCopy() {
      let cpb = this.getRef('clipboardButton');
      //bbn.fn.log("AWATCH", cpb);
      if (cpb) {
        cpb.style.color = 'green';
        setTimeout(() => {
          cpb.style.color = null;
        }, 250);
      }
    },
    setBigMessage(msg) {
      let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;
      this.bigMessage = msg;
      setTimeout(() => {
        this.hasBigMessage = true;
        setTimeout(() => {
          this.closeBigMessage();
        }, timeout < 100 ? timeout * 1000 : timeout);
      }, 50);
    },
    closeBigMessage() {
      this.hasBigMessage = false;
      setTimeout(() => {
        this.bigMessage = false;
      }, 250);
    },
    tabMenu(tab, router) {
      let res = [];
      if (bbn.env.isDev) {
        let plugin;
        bbn.fn.iterate(this.plugins, (a, n) => {
          if (tab.url.indexOf(a + '/') === 0) {
            plugin = n;
            return false;
          }
        });
        let url = this.plugins['appui-project'] + '/router/' + bbn.env.appName + '/ide/editor/file/';
        if (plugin) {
          url += 'lib/' + plugin + '/mvc' + bbn.fn.substr(tab.url, this.plugins[plugin].length);
        } else {
          url += 'app/main/mvc/' + tab.url;
        }
        url += '/_end_/';
        if (tab.url.indexOf('test/') === 0) {
          url += 'private';
        } else {
          url += 'php';
        }
        res.push({
          text: bbn._('Dev tools'),
          icon: 'nf nf-fa-code',
          items: [{
            text: bbn._('Open in editor'),
            icon: 'nf nf-fa-edit',
            action() {
              bbn.fn.link(url);
            }
          }, {
            text: bbn._('Log the container'),
            icon: 'nf nf-mdi-sign_text',
            action() {
              let idx = router.search(tab.url);
              //bbn.fn.log("Container with URL " + tab.url, router.urls[router.views[idx].url]);
            }
          }]
        });
      }

      return res;
    },
    onBeforeRoute(ev, path) {
      this.$emit('beforeroute', ev, path);
    },
    onRoute(path) {
      this.$emit('route', path);
    },
    route(url, force) {
      this.getRef('router').route(url, force);
    },
    register(name, cp) {
      if (bbnAppuiCp.registeredComponents[name]) {
        throw new Error(bbn._("%s is already registered", name));
      }
      if (cp) {
        bbnAppuiCp.registeredComponents[name] = cp;
      } else {
        throw new Error(bbn._("The component that should be registered as %s does not exist", name));
      }
    },
    unregister(name, ignore) {
      if (bbnAppuiCp.registeredComponents[name]) {
        delete bbnAppuiCp.registeredComponents[name];
      } else if (!ignore) {
        throw new Error(bbn._("The component") + ' ' + name + ' ' + bbn._("is not registered"));
      }
    },
    getRegistered(name, ignore) {
      if (bbnAppuiCp.registeredComponents[name]) {
        return bbnAppuiCp.registeredComponents[name];
      }
      if (name === undefined) {
        return bbnAppuiCp.registeredComponents;
      }
      if (!ignore) {
        throw new Error(bbn._("The component") + ' ' + name + ' ' + bbn._("cannot be found"));
      }
    },
    getField: bbn.fn.getField,
    toggleDebug() {
      let debug = this.getRef('debug');
      if (debug) {
        debug.toggle();
      }
    },
    getPopup() {
      let popup = this.popup || this.getRef('popup');
      if (arguments.length) {
        return popup.open(...arguments);
      }
      return popup;
    },
    loadPopup(obj) {
      return this.getPopup().load.apply(this, arguments);
    },
    userName(d) {
      return bbn.fn.getField(this.users, "text", "value", bbn.fn.isObject(d) && d.id ? d.id : d);
    },
    userGroup(d) {
      return bbn.fn.getField(this.users, "id_group", "value", bbn.fn.isObject(d) && d.id ? d.id : d);
    },
    notify(obj, type, timeout) {
      let notification = this.getRef('notification');
      if (notification) {
        return notification.show(obj, type, timeout);
      }
      bbn.fn.log("NOTIFICATION: " + type, obj);
    },
    error(obj, timeout) {
      return this.notify(obj, "error", timeout);
    },
    warning(obj, timeout) {
      return this.notify(obj, "warning", timeout);
    },
    success(obj, timeout) {
      return this.notify(obj, "success", timeout || 5);
    },
    info(obj, timeout) {
      return this.notify(obj, "info", timeout || 30);
    },
    confirm() {
      let p = appui.getPopup();
      return p.confirm.apply(p, arguments);
    },
    alert() {
      let p = appui.getPopup();
      return p.alert.apply(p, arguments);
    },
    measure() {
      /*
      let w = $(this.$el).width(),
          h = $(this.$el).height();
      if ( w && h && ((w !== this.width) || (h !== this.height)) ){
        this.width = w;
        this.height = h;
        this.$emit("resize", {width: this.width, height: this.height});
      }
      */
    },
    /*
    userName(d, force){
      let type = (typeof(d)).toLowerCase();
      if ( type === 'object' ){
        if ( d.full_name ){
          return d.full_name;
        }
        if ( d.login ){
          return d.login;
        }
        return bbn.lng.unknown + (d.id ? " (" + d.id + ")" : "");
      }
      else {
        if ( bbn.users !== undefined ){
          return bbn.fn.getField(bbn.users, "text", "value", d);
        }
      }
      if ( force ){
        return bbn._('Unknown');
      }
      return false;
    },
      userGroup(d){
      let type = (typeof(d)).toLowerCase();
      if ( type === 'object' ){
        d = d.id_group;
        type = (typeof(d)).toLowerCase();
      }
      if ( (type === 'number') ){
        if ( bbn.usergroups !== undefined ){
          return bbn.fn.getField(bbn.usergroups, "text", "value", id);
        }
        return bbn.lng.unknown + " (" + d + ")";
      }
      return bbn.lng.unknown;
    },
    */

    /**
     * Get messages from service worker
     * @param {Object} message
     */
    receive(message) {
      //bbn.fn.log("RECEIVING", message, message.type);
      if (message.type !== undefined) {
        switch (message.type) {
          case 'message':
            if (!bbn.fn.numProperties(message.data)) {
              return;
            }
            if (message.data && message.data.disconnected) {
              //document.location.reload();
              bbn.fn.log("DISCONNECTED", message.data);
            } else if (message.data && message.data.data) {}
            if (message.data && message.data.plugins && Object.keys(message.data.plugins).length) {
              bbn.fn.iterate(message.data.plugins, (d, i) => {
                if ('serviceWorkers' in d) {
                  this.$set(this.pollerObject, i, bbn.fn.extend(true, this.pollerObject[i], d.serviceWorkers));
                  delete d.serviceWorkers;
                }
                this.$emit(i, message.type, d);
              });
            }
            break;
          case 'log':
            this.$emit('swlog', message.data);
            break;
          case 'messageFromChannel':
            bbn.fn.log("messageFromChannel", message);
            this.$emit(message.channel, message.type, message.data);
            break;
          case 'notificationClick':
            bbn.fn.log("notificationClick", message.data);
            this.browserNotificationClick(message.data);
        }
      }
    },
    poll(data) {
      if (this.pollable && this.pollerPath) {
        if (!data) {
          data = {
            'appui-core': {
              observers: this.observers
            }
          };
        }
        if (this._postMessage(bbn.fn.extendOut({}, data, this.pollerObject))) {
          this.observersCopy = bbn.fn.clone(this.observers);
        }
      }
    },
    onChatMounted() {
      var _this$app;
      this.pollerObject['appui-chat'].online = (_this$app = this.app) === null || _this$app === void 0 || (_this$app = _this$app.user) === null || _this$app === void 0 ? void 0 : _this$app.chat;
      if (this.ready) {
        this.poll();
      }
    },
    getCurrentContainer() {
      let router = this.getRef('router'),
        container = !!router ? router.searchContainer(bbn.env.path, true) : false;
      return container || this;
    },
    searchBarBlur() {
      setTimeout(() => {
        this.searchIsActive = false;
      }, 500);
    },
    keydown(e) {
      if (this.longPressed) {
        e.preventDefault();
      }
      if (this.pressedKey) {
        this.pressedKey = false;
      }
      if (!e.metaKey && !e.ctrlKey && !e.shiftKey && !e.altKey && !this.isTouch) {
        let tag = e.target.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'DIV' && e.target.isContentEditable) {
          return;
        }
        this.pressedKey = e.key;
      }
    },
    removePressListener() {
      this.longPressed = false;
      document.removeEventListener('keyup', this.removePressListener);
    },
    longPress(key) {
      this.longPressed = true;
      document.addEventListener('keyup', this.removePressListener);
      if (bbn.fn.isNumber(key)) {
        let router = this.getRef('router');
        if (key === '0') {
          if (router.isVisual) {
            router.visualShowAll = !router.visualShowAll;
          }
          return;
        }
        let idx = parseInt(key);
        if (router.isVisual) {
          if (router.visualList[idx]) {
            idx = router.visualList[idx].view.idx;
            this.getRef('router').activateIndex(idx);
          }
        } else {
          idx--;
          if (router.isValidIndex(idx)) {
            this.getRef('router').activateIndex(idx);
          }
        }
        return;
      }
      switch (key) {
        case 'f':
          this.searchOn = true;
          break;
        case 'b':
          this.showBookmarks = true;
          break;
        case 'g':
          let loadbar = this.getRef('loading');
          if (loadbar) {
            loadbar.show();
          }
          break;
        case 'c':
          let clipboard = this.getRef('clipboard');
          if (clipboard) {
            clipboard.show();
          }
          break;
        case 'm':
          let menu = this.getRef('slider');
          if (menu) {
            menu.show();
          }
          break;
        case 'ArrowLeft':
          history.back();
          break;
        case 'ArrowRight':
          history.forward();
          break;
      }
    },
    onLoad() {
      this.$emit('load', ...arguments);
    },
    startLoading(text) {
      this.loadingText = text === false ? '' : text || bbn._('Loading');
      this.isLoading = true;
    },
    stopLoading() {
      this.isLoading = false;
    }
  },
  beforeCreate() {
    bbn.fn.defaultAjaxErrorFunction = (jqXHR, textStatus, errorThrown) => {
      var _window$appui;
      /** @todo */
      if ((_window$appui = window.appui) !== null && _window$appui !== void 0 && _window$appui.status) {
        this.$nextTick(() => {
          const loadBar = this.getRef('loading');
          if (bbn.fn.isCp(loadBar)) {
            loadBar.$forceUpdate();
          }
        });
      }
      appui.error({
        title: textStatus,
        content: errorThrown
      }, 4);
      return false;
    };
    bbn.fn.defaultPreLinkFunction = url => {
      let router = appui.getRef('router');
      if (router) {
        if (bbn.fn.isFunction(router.route) && !router.disabled) {
          router.route(url);
        }
        return false;
      }
      return true;
    };
    bbn.fn.defaultAlertFunction = ele => {
      /** @todo */
      let c = appui.getCurrentContainer();
      c.alert.apply(c, arguments);
    };
    bbn.fn.defaultStartLoadingFunction = () => {
      var _window$appui2;
      if ((_window$appui2 = window.appui) !== null && _window$appui2 !== void 0 && _window$appui2.status) {
        this.$nextTick(() => {
          const loadBar = this.getRef('loading');
          if (bbn.fn.isCp(loadBar)) {
            loadBar.$updateAllComputed();
          }
        });
      }
    };
    bbn.fn.defaultEndLoadingFunction = (url, timestamp, data, res) => {
      var _window$appui3;
      if (res && res.data && bbn.fn.numProperties(res.data) === 1 && res.data.disconnected) {
        window.location.reload();
        return;
      }
      if ((_window$appui3 = window.appui) !== null && _window$appui3 !== void 0 && _window$appui3.status) {
        this.$nextTick(() => {
          const loadBar = this.getRef('loading');
          if (bbn.fn.isCp(loadBar)) {
            loadBar.$updateAllComputed();
          }
        });
      }
    };
  },
  created() {
    if (window.appui) {
      throw new Error("Impossible to have 2 bbn-appui components on a same page. bbn-appui is meant to hold a whole web app");
    } else {
      window.appui = this;
      this.componentClass.push('bbn-resize-emitter', 'bbn-observer');
      this.cool = true;

      /*
      bbn.fn.each(this.plugins, (path, name) => {
        bbn.cp.addPrefix(
          name,
          (tag, resolve, reject) => bbn.cp.queueComponent(
            tag,
            path + '/' + this.componentsPath + bbn.fn.replaceAll('-', '/', tag).substr(name.length + 1), null, resolve, reject
          )
        );
      });
          if (this.prefix) {
        bbn.cp.addPrefix(
          this.prefix,
          (tag, resolve, reject, mixins) => bbn.cp.queueComponent(
            tag,
            this.componentsPath + bbn.fn.replaceAll('-', '/', tag).substr((this.prefix + '-').length),
            mixins,
            resolve,
            reject
          ),
          bbn.fn.extend(
            true,
            {},
            {
              methods: {
                getTab(){
                  return this.closest('bbn-container');
                },
                popup(){
                  return this.getTab().popup.apply(this, arguments);
                }
              }
            },
            this.componentsMixin
          )
        );
      }
      */

      let preloaded = ['container', 'router', 'scrollbar', 'scroll', 'floater', 'popup'];
      if (!this.single) {
        preloaded.push('pane', 'splitter', 'tabs', 'context', 'loadicon');
      }
      if (this.header) {
        preloaded.push('pane', 'splitter', 'search', 'fisheye');
      }
      if (this.plugins && this.plugins['appui-menu']) {
        preloaded.push('slider', 'tree', 'treemenu', 'menu', 'input', 'list', 'dropdown', 'checkbox', 'button');
      }
      if (this.plugins && this.plugins['appui-notification']) {
        preloaded.push('notification');
      }
      if (this.status) {
        preloaded.push('splitter', 'input', 'loadbar', 'checkbox', 'button');
        if (this.chat) {
          preloaded.push('chat');
        }
      }
      if (this.clipboard) {
        preloaded.push('slider', 'clipboard');
      }
      bbn.cp.fetchComponents(preloaded.map(c => 'bbn-' + c));
      this.$on('focusin', () => this.isFocused = true);
      this.$on('focusout', () => this.isFocused = false);
      document.addEventListener('keydown', this.keydown);
      document.addEventListener('keyup', () => {
        this.pressedKey = false;
      });
      this.$on('messageToChannel', data => {
        this.messageChannel(this.primaryChannel, data);
      });

      // Emissions from poller
      //appui
      this.$on('appui', (type, data) => {
        switch (type) {
          case 'messageFromChannel':
            this.messageFromChannel(data);
        }
      });
      // appui-chat
      this.$on('appui-chat', (type, data) => {
        let chat = this.getRef('chat');
        switch (type) {
          case 'message':
            if (bbn.cp.isComponent(chat) && bbn.fn.numProperties(data)) {
              chat.receive(data);
            }
            break;
          case 'messageFromChannel':
            if (bbn.cp.isComponent(chat)) {
              chat.messageFromChannel(data);
            }
            break;
        }
      });
      // appui-core
      this.$on('appui-core', (type, data) => {
        if (type === 'message' && data.observers) {
          bbn.fn.each(data.observers, obs => bbn.fn.each(bbn.fn.filter(this.observers, {
            id: obs.id
          }), o => this.observerEmit(obs.result, o)));
        }
      });
      // appui-notification
      this.$on('appui-notification', (type, data) => {
        if (this.plugins['appui-notification']) {
          if (type === 'message') {
            let tray = this.getRegistered('appui-notification-tray');
            if (bbn.cp.isComponent(tray) && bbn.fn.isFunction(tray.receive)) {
              tray.receive(data);
            }
            if ('browser' in data) {
              bbn.fn.each(data.browser, n => this.browserNotify(n.title, {
                body: bbn.fn.html2text(n.content),
                tag: n.id,
                timestamp: n.browser,
                requireInteraction: true
              }));
            }
          }
        }
      });
      // appui-cron
      this.$on('appui-cron', (type, data) => {
        if (type === 'message') {
          let cron = appui.getRegistered('appui-cron');
          if (bbn.cp.isComponent(cron) && bbn.fn.isFunction(cron.receive)) {
            cron.receive(data);
          }
        }
      });

      // Set plugins pollerObject
      if (!this.pollerObject.token) {
        this.pollerObject.token = bbn.env.token;
      }
      if (this.plugins['appui-chat']) {
        this.$set(this.pollerObject, 'appui-chat', {
          online: null,
          usersHash: false,
          chatsHash: false
        });
      }
      if (this.plugins['appui-notification']) {
        this.$set(this.pollerObject, 'appui-notification', {
          unreadHash: false
        });
      }
    }
  },
  beforeMount() {
    this.componentClass.push('bbn-background', this.scrollable ? 'bbn-overlay' : 'bbn-w-100');
    if (this.isMobile) {
      this.componentClass.push('bbn-desktop');
    }
  },
  mounted() {
    if (this.cool) {
      var _this$app2;
      if (this.$refs.app) {
        this.app = this.$refs.app;
      }
      this.onResize();
      this.ready = true;
      this.opacity = 1;
      this._postMessage({
        type: 'initCompleted'
      });
      if (!this.single) {
        this.registerChannel('appui', true);
        if (this.plugins['appui-chat']) {
          this.registerChannel('appui-chat');
        }
        if (this.plugins['appui-notification']) {
          this.registerChannel('appui-notification');
          this.browserNotificationURL = this.plugins['appui-notification'];
          this.browserNotificationSW = true;
        }
        this.poll();
      }
      this.onResize();
      setTimeout(() => {
        this.ready = true;
        this.opacity = 1;
        setTimeout(() => {
          this._postMessage({
            type: 'initCompleted'
          });
          this.registerChannel('appui', true);
          if (this.plugins['appui-chat']) {
            this.registerChannel('appui-chat');
          }
          if (this.plugins['appui-notification']) {
            this.registerChannel('appui-notification');
            this.browserNotificationURL = this.plugins['appui-notification'];
            this.browserNotificationSW = true;
          }
          this.poll();
        }, 5000);
      }, (_this$app2 = this.app) !== null && _this$app2 !== void 0 && _this$app2.header ? 1000 : 10);
    }
  },
  beforeDestroy() {
    this.$off('appui-chat');
    this.$off('appui-core');
    this.$off('appui-notification');
  },
  watch: {
    pressedKey(v) {
      clearTimeout(this.pressedTimeout);
      if (v) {
        this.pressedTimeout = setTimeout(() => {
          this.longPress(v);
          this.pressedKey = false;
        }, 500);
      }
    },
    observers: {
      deep: true,
      handler() {
        if (this.observerTimeout) {
          clearTimeout(this.observerTimeout);
        }
        this.observerTimeout = setTimeout(() => {
          this.poll();
        }, 1000);
      }
    },
    isLoading(newVal) {
      if (!newVal) {
        this.loadingText = bbn._('Loading');
      }
    }
  }
};
import cpHtml from './appui.html';
import cpStyle from './appui.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./appui.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-appui',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-audio component
 * @description bbn-audio allows the execution of audio files.
 * @copyright BBN Solutions
 * @author Mirko Argentino
 * @created 11/08/2020.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * The aduio's URL
     * @prop {String} [true] source
     */
    source: {
      type: String,
      required: true
    },
    /**
     * The audio's title
     * @prop {String} [''] title
     */
    title: {
      type: String,
      default: ''
    },
    /**
     * The title's position(top or bottom)
     * @prop {String} ['top'] titlePosition
     */
    titlePosition: {
      type: String,
      default: 'top',
      validator: p => ['top', 'bottom'].includes(p)
    },
    /**
     * The title's background
     * @prop {String} titleBackground
     */
    titleBackground: {
      type: String
    },
    /**
     * The title's color
     * @prop {String} titleColor
     */
    titleColor: {
      type: String
    },
    /**
     * Additional classes for the title
     * @prop {String} titleCls
     */
    titleCls: {
      type: String
    },
    /**
     * The player's width
     * @prop {String|Number} width
     */
    width: {
      type: [String, Number]
    },
    /**
     * The player's height
     * @prop {String|Number} height
     */
    height: {
      type: [String, Number]
    },
    /**
     * Specifies that the audio will start playing as soon as it is ready
     * @prop {Boolean} [false] autoplay
     */
    autoplay: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies that audio controls should be displayed
     * @prop {Boolean} [true] controls
     */
    controls: {
      type: Boolean,
      default: true
    },
    /**
     * Specifies that the audio will start over again, every time it is finished
     * @prop {Boolean} [false] loop
     */
    loop: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies that the audio output should be muted
     * @prop {Boolean} [false] muted
     */
    muted: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if yuo want to use a skinned player
     * @prop {Boolean} [false] skin
     */
    skin: {
      type: Boolean,
      default: false
    },
    /**
     * A custom background for the player
     * @prop {String} background
     */
    background: {
      type: String
    },
    /**
     * Additional classes for the player
     * @prop {String} cls
     */
    cls: {
      type: String
    }
  },
  data() {
    return {
      /**
       * This text will only be displayed in browsers that do not support the <video> element.
       * @data {String} ['Your browser does not support the audio tag.'] browserMessage
       */
      browserMessage: bbn._('Your browser does not support the audio tag.'),
      /**
       * The native audio element
       * @data {HTMLElement} widget
       */
      widget: null
    };
  },
  computed: {
    /**
     * The current formatted width
     * @computed currentWidth,
     * @return {String}
     */
    currentWidth() {
      return bbn.fn.isNumber(this.width) ? this.width + 'px' : this.width;
    },
    /**
     * The current formatted height
     * @computed currentHeight,
     * @return {String}
     */
    currentHeight() {
      return bbn.fn.isNumber(this.height) ? this.height + 'px' : this.height;
    },
    /**
     * Returns the correct media type
     * @computed type
     * @return {String|Boolean}
     */
    type() {
      if (this.source) {
        switch (bbn.fn.substr(this.source, this.source.lastIndexOf('.') + 1).toLowerCase()) {
          case 'mp3':
            return 'audio/mpeg';
          case 'wav':
            return 'video/wav';
          case 'ogg':
            return 'audio/ogg';
          default:
            return '';
        }
      }
      return false;
    }
  },
  methods: {
    /**
     * @method play
     */
    play() {
      this.widget.play();
    },
    /**
     * @method pause
     */
    pause() {
      this.widget.pause();
    },
    /**
     * @method onPay
     * @emits play
     */
    onPlay(ev) {
      this.$emit('play', ev, this);
    },
    /**
     * @method onPause
     * @emits pause
     */
    onPause(ev) {
      this.$emit('pause', ev, this);
    }
  },
  /**
   * @event mounted
   * @fires getRef
   */
  mounted() {
    this.widget = this.getRef('audio');
    if (this.muted) {
      this.widget.muted = true;
    }
  },
  watch: {
    /**
     * @watch muted
     */
    muted(newVal) {
      this.widget.muted = !!newVal;
    },
    /**
     * @watch loop
     */
    loop(newVal) {
      this.widget.loop = !!newVal;
    }
  }
};
import cpHtml from './audio.html';
import cpStyle from './audio.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./audio.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-audio',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-autocomplete component
 * @description The autocomplete allows to select a single value from a list of items by proposeing suggestions based on the typed characters.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
   * @mixin bbn.cp.mixins.dropdown
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input, bbn.cp.mixins.resizer, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.url, bbn.cp.mixins.dropdown],
  props: {
    /**
     * For to apply the filters or not.
     *
     * @prop {Boolean} filterable
     */
    filterable: {
      type: Boolean,
      default: true
    },
    /**
     * To define the length of the string to start the filter.
     *
     * @prop {Number} [0] minLength
     */
    minLength: {
      type: Number,
      default: 2
    },
    /**
     * Specifies the time of delay.
     *
     * @prop {Number} [250] delay
     */
    delay: {
      type: Number,
      default: 250
    },
    /**
     * Specifies the mode of the filter.
     *
     * @prop {String} ['startswith'] filterMode
     */
    filterMode: {
      type: String,
      default: 'startswith'
    },
    /**
     * Autobind defaults at false.
     *
     * @prop {Boolean} [false] autobind
     */
    autobind: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * Indicates if the filter input is visible
       * @data {Boolean} [false] inputIsVisible
       */
      inputIsVisible: false
    };
  },
  methods: {
    /**
     * Shows the filter input
     * @method _setInputVisible
     */
    _setInputVisible() {
      this.filterString = this.currentText;
      this.inputIsVisible = true;
      this.$nextTick(() => {
        this.getRef('input').focus();
      });
    },
    onChange() {
      if (!this.ready) {
        this.ready = true;
      }
    },
    /**
     * Puts the focus on the element.
     *
     * @method click
     * @fires getRef
     */
    click() {
      if (!this.isDisabled) {
        this.getRef('input').focus();
        if (this.filteredData.length) {
          this.isOpened = !this.isOpened;
        }
      }
    },
    /**
     * Remove the filter and close the list if it is notabove it.
     *
     * @method leave
     * @fires getRef
     */
    leave() {
      if (this.isOpened && !this.getRef('list').isOver) {
        this.isOpened = false;
      }
      this.inputIsVisible = false;
      this.filterString = '';
    },
    /**
     * Emits the event 'select'.
     *
     * @method select
     * @param {Object} item
     * @fires emitInput
     * @fires getRef
     * @emit change
     */
    select(item) {
      if (item) {
        let v = item;
        if (this.sourceValue && item[this.sourceValue] !== undefined) {
          v = item[this.sourceValue];
        }
        this.emitInput(v);
        this.$emit('change', v);
        this.currentText = item[this.sourceText];
        this.filterString = item[this.sourceText];
        this.$nextTick(() => {
          this.getRef('input').focus();
        });
      }
      this.isOpened = false;
    },
    /**
     * Function to do the reset and if the component is open it closes it.
     *
     * @method resetDropdown
     * @fires unfilter
     */
    resetDropdown() {
      this.currentText = this.currentTextValue;
      this.filterString = this.currentTextValue;
      this.unfilter();
      if (this.isOpened) {
        this.isOpened = false;
      }
    },
    /**
     * Function that performs different actions based on what is being pressed.
     *
     * @method keydown
     * @param {Event} e
     * @fires resetDropdown
     * @fires commonKeydown
     * @fires keynav
     */
    keydown(e) {
      if (this.commonKeydown(e)) {
        return;
      } else if (this.isOpened && e.key === 'Escape') {
        e.stopPropagation();
        e.preventDefault();
        this.resetDropdown();
        return;
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      }
      this.$emit('keydown', e);
    }
  },
  /**
   * @event created
   * @fires emitInput
   */
  created() {
    this.$on('dataloaded', () => {
      if (this.value !== undefined) {
        let row = bbn.fn.getRow(this.currentData, a => {
          return a.data[this.sourceValue] === this.value;
        });
        if (row) {
          this.currentText = row.data[this.sourceText];
        }
      }
      if (!this.currentText && !this.isNullable && this.filteredData.length) {
        this.emitInput(this.filteredData[0][this.sourceValue]);
      }
    });
  },
  watch: {
    /**
     * @watch filterString
     * @fires onResize
     * @fires unfilter
     * @param {String} v
     */
    filterString(v) {
      if (!this.ready) {
        this.ready = true;
      }
      clearTimeout(this.filterTimeout);
      if (!v && this.nullable && this.inputIsVisible) {
        this.unfilter();
        this.emitInput(null);
        this.currentText = '';
        if (this.currentData.length) {
          this.currentData.splice(0, this.currentData.length);
        }
      } else if (v) {
        if (v.length < this.minLength) {
          if (this.currentData.length) {
            this.currentData.splice(0, this.currentData.length);
          }
        } else if (v !== this.currentText) {
          this.isOpened = false;
          this.filterTimeout = setTimeout(() => {
            // this.filterTimeout = false;
            // We don't relaunch the source if the component has been left
            if (this.isActive) {
              this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
                field: this.sourceText,
                operator: this.filterMode,
                value: v
              });
              this.updateData().then(() => {
                this.isOpened = true;
              });
            }
          }, this.delay);
        }
      } else if (!v) {
        this.unfilter();
      }
    }
  }
};
import cpHtml from './autocomplete.html';
import cpStyle from './autocomplete.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./autocomplete.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-autocomplete',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-big-search component
 *
 * @description The easy-to-implement bbn-dropdown component allows you to choose a single value from a user-supplied list.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
   * @mixin bbn.cp.mixins.dropdown
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input, bbn.cp.mixins.resizer, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.url, bbn.cp.mixins.dropdown],
  props: {
    /**
     * @prop {Boolean} [false] filterselection 
     */
    filterselection: {
      default: false
    },
    /**
     * Defines if the search is filterable.
     * @prop {Boolean} [true] filterable 
     */
    filterable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true will automatically update the data before mount.
     * @prop {Boolean} [false] autobind 
     */
    autobind: {
      default: true
    },
    /**
     * Defines if the search can have a null value.
     * @prop {Boolean} [false] nullable
     */
    nullable: {
      default: false
    },
    /**
     * Defines the min length of the filter string. 
     * @prop {Number}[1] minLength
     * 
     */
    minLength: {
      type: Number,
      default: 1
    },
    /**
     * Defines the left icon of the search.
     * @prop {Boolean|String} [false] leftIcon 
     */
    leftIcon: {
      default: false
    },
    /**
     * Defines the right icon of the search.
     * @prop {Boolean|String} ['nf nf-fa-search'] rightIcon 
     */
    rightIcon: {
      default: 'nf nf-fa-search'
    },
    /**
     * Defines the min width of the input.
     * @prop {String} ['4,2rem'] minWidth
     */
    minWidth: {
      default: '4.2rem'
    },
    /**
     * Defines the max width of the input.
     * @prop {String} ['100%'] maxWidth
     */
    maxWidth: {
      default: '100%'
    },
    /**
     * Defines the delay before the component starts to search.
     * @prop {Number} [500] delay
     */
    delay: {
      type: Number,
      default: 20
    },
    /** 
     * @prop {String} ['?'] shortPlaceholder
     */
    shortPlaceholder: {
      type: String,
      default: '?'
    },
    /**
     * Delay to auto-hide the results when mouse out (or false to not auto-hide).
     * @prop {Boolean|Number} [1500] autohide
     */
    autohide: {
      type: [Boolean, Number],
      default: 1500
    },
    /**
     * The name of the property to be used as action to execute when selected.
     * @prop {String} sourceAction
     */
    sourceAction: {
      type: [String, Function],
      default: 'action'
    },
    /**
     * The name of the property to be used as URL to go to when selected.
     * @prop {String} sourceUrl
     */
    sourceUrl: {
      type: [String, Function],
      default: 'url'
    },
    /**
     * The URL where to send the selected result.
     * @prop {String} selectUrl
     */
    selectUrl: {
      type: String
    },
    /**
     * An array of javascript search functions
     * @prop {Array} searchFunctions
     */
    searchFunctions: {
      type: Array,
      default() {
        return [];
      },
      validator(a) {
        let ok = true;
        bbn.fn.each(a, f => {
          if (!bbn.fn.isFunction(f)) {
            ok = false;
            return false;
          }
        });
        return ok;
      }
    }
  },
  data() {
    return {
      isOpened: true,
      /**
       * The current min width.
       * @data {String} ['4.2rem'] specialWidth
       */
      specialWidth: this.minWidth,
      /**
       * The placeholder.
       * @data {String} ['?'] currentPlaceholder
       */
      currentPlaceholder: this.shortPlaceholder,
      /**
       * The timeout.
       * @data {Number|null} [null] timeout
       */
      timeout: null,
      /**
       * @data {Number|null} [null] mouseTimeout
       */
      mouseTimeout: null,
      /**
       * @data {Array} [null] registeredFunctions
       */
      registeredFunctions: this.searchFunctions.slice()
    };
  },
  computed: {
    isNullable() {
      return this.nullable && this.isActive;
    },
    /**
     * Returns the component object. 
     * @computed realComponent
     * @memberof listComponent
     */
    searchComponent() {
      let cp = bbn.fn.isString(this.component) || bbn.fn.isObject(this.component) && Object.keys(this.component).length ? this.component : null;
      if (!cp) {
        cp = {
          props: ['source'],
          data() {
            return this.source;
          },
          template: `<component :is="myCp" :source="source"></component>`,
          computed: {
            myCp() {
              return this.source.component || 'div';
            }
          }
        };
      }

      //bbn.fn.log(["BIG SEARCH", cp, this.source]);
      return cp;
    }
  },
  methods: {
    /**
     * Register a new search function
     * @method registerFunction
     * @param {Function} fn 
     */
    registerFunction(fn) {
      if (!bbn.fn.isFunction(fn)) {
        throw new Error(bbn._("%s takes a function as argument", "registerFunction"));
      }
      let signature = bbn.fn.md5(fn.toString());
      if (!bbn.fn.getRow(this.registeredFunctions, {
        signature: signature
      })) {
        this.registeredFunctions.push({
          signature: signature,
          fn: fn
        });
      }
    },
    /**
     * Unregister a search function
     * @method registerFunction
     * @param {Function} fn 
     */
    unregisterFunction(fn) {
      let idx = this.registeredFunctions.indexOf(fn);
      if (idx > -1) {
        this.registeredFunctions.splice(idx, 1);
      }
    },
    /**
     * Emits the event 'select' 
     * @method select
     * @param {Object} item 
     * @param {Number} idx
     * @param {Number} dataIndex
     * @emit change
     */
    select(item, idx, dataIndex) {
      if (!this.isDisabled) {
        let ev = new Event('select', {
          cancelable: true
        });
        this.$emit('select', ev, item, idx, dataIndex);
        if (!ev.defaultPrevented) {
          if (this.sourceAction && item[this.sourceAction]) {
            if (typeof item[this.sourceAction] === 'string') {
              if (bbn.fn.isFunction(this[item[this.sourceAction]])) {
                this[item[this.sourceAction]]();
              }
            } else if (bbn.fn.isFunction(item[this.sourceAction])) {
              if (this.actionArguments) {
                item[this.sourceAction](...this.actionArguments);
              } else {
                item[this.sourceAction](idx, item.data);
              }
            }
          } else if (this.sourceUrl && item[this.sourceUrl]) {
            let url = bbn.fn.isFunction(this.sourceUrl) ? this.sourceUrl(item, idx, dataIndex) : item[this.sourceUrl];
            if (url) {
              bbn.fn.link(url);
            }
          }
          if (this.selectUrl) {
            bbn.fn.post(this.selectUrl, {
              data: item,
              id: this.searchId
            }, d => {
              bbn.fn.log("RESULT OF SELECT URL", d);
            });
          }
          this.isOpened = false;
          this.filterString = '';
        }
      }
    },
    /**
     * States the role of the enter key on the dropdown menu.
     *
     * @method _pressEnter
     * @fires resetDropdown
     * @fires keynav
     *
     */
    keydown(e) {
      if (e.key === 'Enter') {
        let list = this.getRef('list');
        if (list && bbn.fn.isNumber(list.overIdx)) {
          list.select(list.overIdx);
        }
      }
      if (e.key === ' ' || this.commonKeydown(e)) {
        return;
      }
      if (e.key === 'Escape') {
        this.isOpened = false;
        this.filterString = '';
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      }
    },
    async updateData() {
      if (this.beforeUpdate() !== false) {
        this._dataPromise = new Promise(resolve => {
          let loadingRequestID;
          if (this.loadingRequestID) {
            bbn.fn.abort(this.loadingRequestID);
            setTimeout(() => {
              this.loadingRequestID = false;
              this.updateData().then(() => {
                resolve();
              });
            }, 50);
            return;
          }
          this.isLoading = true;
          this.$emit('startloading');
          let data = this.getData();
          loadingRequestID = bbn.fn.getRequestId(this.source, data);
          this.loadingRequestID = loadingRequestID;
          this.post(this.source, data).then(d => {
            if (!this.loadingRequestID || this.loadingRequestID !== loadingRequestID) {
              this.isLoading = false;
              this.loadingRequestID = false;
              throw new Error("No loading request");
            }
            this.isLoading = false;
            this.loadingRequestID = false;
            if (!d) {
              return;
            }
            if (d.status !== 200) {
              d.data = undefined;
            } else {
              d = d.data;
            }
            this.$emit('datareceived', d);
            if (bbn.fn.isArray(d.data)) {
              this.appendData(d.data);
            }
            this.afterUpdate();
            resolve(this.currentData);
            if (!this.isLoaded) {
              this.isLoaded = true;
            }
            this.$emit('dataloaded', d);
            if (this.isAjax && d && d.next_step) {
              if (d.id && d.data !== undefined) {
                this.searchId = d.id;
              }
              this.getMoreData(d.next_step);
            }
          });
        }).catch(e => {
          this.isLoading = false;
          this.loadingRequestID = false;
          bbn.fn.log("ERROR", e);
        });
        return this._dataPromise;
      }
    },
    appendData(data) {
      bbn.fn.each(this.treatData(data), a => {
        let todo = true;
        if (a.data.hash) {
          let row = bbn.fn.filter(this.currentData, r => r.data.hash === a.data.hash);
          if (row.length && row[0].data.score && a.data.score) {
            todo = false;
            row[0].data.score += a.data.score;
          }
        }
        if (todo) {
          this.currentData.push(a);
        }
      });
      bbn.fn.order(this.currentData, 'data.score', 'desc');
      this.updateIndexes();
    },
    getMoreData() {
      let step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (this.isAjax) {
        this.isLoading = true;
        this.$emit('startloading');
        let data = this.getData();
        data.step = step;
        this.loadingRequestID = bbn.fn.getRequestId(this.source, data);
        this.isLoading = true;
        this.post(this.source, data, d => {
          this.isLoading = false;
          this.loadingRequestID = false;
          if (d && d.data) {
            if (d.data.length) {
              this.appendData(d.data);
            }
            if (d.next_step) {
              if (this.isOpened !== undefined) {
                if (this.isOpened) {
                  //bbn.fn.log("APPEING DATA")
                  this.getMoreData(d.next_step);
                }
              } else {
                this.getMoreData(d.next_step);
              }
            }
          }
        });
      }
    },
    launchRegisteredFunctions(search) {
      bbn.fn.each(this.registeredFunctions, o => {
        let res = o.fn(search);
        if (bbn.fn.isArray(res) && res.length) {
          bbn.fn.each(res, r => {
            let d = bbn.fn.extend({}, r);
            delete d.score;
            if (!r.hash) {
              r.hash = bbn.fn.md5(JSON.stringify(d));
            }
            r.signature = o.signature;
          });
          this.appendData(res);
        }
      });
    }
  },
  watch: {
    isOpened(v) {
      bbn.fn.log("isOpened", this.isOpened);
      if (!v) {
        this.$emit('close');
      }
    },
    /**
     * @watch filterString
     * @param {String} v 
     */
    filterString(v) {
      if (!this.ready) {
        this.ready = true;
      }
      clearTimeout(this.filterTimeout);
      if (v !== this.currentText) {
        this.emitInput(v);
        this.$emit('change', v);
        if (this.currentData.length) {
          this.currentData.splice(0);
        }
        this.launchRegisteredFunctions(v);
        this.$nextTick(() => {
          this.filterTimeout = setTimeout(() => {
            this.filterTimeout = false;
            // We don't relaunch the source if the component has been left
            if (v && v.length >= this.minLength) {
              this.$once('dataloaded', () => {
                this.$nextTick(() => {
                  let list = this.find('bbn-scroll');
                  if (list) {
                    list.onResize();
                  }
                });
              });
              this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
                field: this.sourceText,
                operator: 'startswith',
                value: v
              });
            } else {
              this.unfilter();
            }
          }, this.delay);
        });
      }
    }
  },
  mounted() {
    this.ready = true;
  }
};
import cpHtml from './big-search.html';
import cpStyle from './big-search.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./big-search.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-big-search',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-combo component
 * @description The easy-to-implement bbn-combo component allows you to choose a single value from a user-supplied list or to write new.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.componentInside
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.componentInside],
  props: {
    /**
     * Max Image Width
     *
     * @prop {Number} [''] imgWidth
     */
    imgWidth: {
      type: Number,
      default: 420
    },
    /**
     * The max columns number
     * @prop {Number} maxColumns
     */
    maxColumns: {
      type: Number
    }
  },
  data() {
    return {
      windowWidth: window.innerWidth
    };
  },
  computed: {
    /**
     * @computed rowCount
     * @returns {Number}
     */
    rowCount() {
      let res = Math.ceil(this.windowWidth / this.imgWidth);
      if (!!this.maxColumns && this.maxColumns < res) {
        res = this.maxColumns;
      }
      return res;
    }
  },
  mounted() {
    this.ready = true;
    this.$nextTick(() => {
      window.addEventListener('resize', this.onResize);
    });
  },
  watch: {
    currentPage() {
      let sc = this.closest('bbn-scroll');
      while (sc && !sc.scrollable) {
        sc = sc.closest('bbn-scroll');
      }
      if (sc) {
        sc.scrollTo(0, this.$el.offsetTop, true);
      } else {
        let p = this.$el;
        while (p) {
          if (p.scrollHeight && p.clientHeight && p.scrollTop) {
            let pos = this.$el.offsetTop;
            p.scrollTop = pos;
            break;
          } else {
            p = p.parentNode;
          }
        }
      }
    }
  },
  methods: {
    onResize() {
      this.windowWidth = window.innerWidth;
    }
  }
};
import cpHtml from './block-list.html';
import cpStyle from './block-list.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./block-list.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-block-list',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
  * @file bbn-breadcrumb component
  * @description bbn-breadcrumb
  * @copyright BBN Solutions
  * @author Mirko Argentino mirko@bbn.solutions
  * @created 10/03/2020
  * @ignore
  */
const cpDef = {
  mixins: [
  /**
   * @mixin bbn.cp.mixins.basic
   */
  bbn.cp.mixins.basic,
  /**
   * @mixin bbn.cp.mixins.resizer
   */
  bbn.cp.mixins.resizer,
  /**
   * @mixin bbn.cp.mixins.localStorage
   */
  bbn.cp.mixins.localStorage,
  /**
   * @mixin bbn.cp.mixins.close
   */
  bbn.cp.mixins.close,
  /**
   * @mixin bbn.cp.mixins.observer
   */
  bbn.cp.mixins.observer],
  props: {
    /**
     * @prop {Array} [true] source
     */
    source: {
      type: Array,
      reuired: true
    },
    /**
     * @prop value
     */
    value: {},
    /**
     * @prop {Boolean} [true] content
     */
    content: {
      type: Boolean,
      default: true
    },
    /**
     * Sets if the tabs' titles will be scrollable in case they have a greater width than the page (true), or if they will be shown multilines (false, default).
     * @prop {Boolean} [false] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * The max length for a title
     * @prop {Number} maxTitleLength
     */
    maxTitleLength: {
      type: Number,
      default: 20
    },
    /**
     * @prop {Function} menu
     */
    menu: {
      type: Function
    },
    /**
     * Set it to true if you want to set this breadcrumb as a master.
     * @prop {Boolean} [false] master
     */
    master: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * The current selected view's index.
       * @data {Number|Boolean} [false] selected
       */
      selected: false,
      /**
       * @data {Boolean} [false] iconsReady
       */
      iconsReady: false,
      /**
       * The parents breadcrumbs list.
       * @data {Array} [[]] parents
       */
      parents: [],
      /**
       * The sub-breadcrumbs list indexed by the view's url
       * @data {Object} {{}} subBreadcrumbs
       */
      subBreadcrumbs: {},
      /**
       * A list of all sub-breadcrumbs
       * @data {Array} [[]] allSubBreadcrumbs
       */
      allSubBreadcrumbs: [],
      parent: false
    };
  },
  computed: {
    /**
     * Returns the scroll configuration
     * @computed scrollCfg
     * @return {Object}
     */
    scrollCfg() {
      return this.scrollable ? {
        axis: 'x',
        container: true,
        hidden: true
      } : {};
    },
    /**
     * The master bbn-router of this breadcrumb.
     * @computed itsMaster
     * @return {bbnCp}
     */
    router() {
      if (this.$parent && this.$parent.$options.name === 'bbn-router') {
        return this.$parent;
      }
      return false;
    },
    /**
     * Returns the master bbn-breadcrumb of this one
     * @computed itsMaster
     * @return {bbnCp}
     */
    itsMaster() {
      if (this.master) {
        return this;
      } else if (this.router && this.router.itsMaster && this.router.itsMaster.itsMasterBreadcrumb) {
        return this.router.itsMaster.itsMasterBreadcrumb;
      }
      return bbn.fn.getRow(this.parents, {
        master: true
      });
    },
    /**
     * The list of the sub-breadcrumbs used for the render.
     * @computed currents
     * @return {Array}
     */
    currents() {
      let ret = [],
        // a way to force this computed to update itself
        sbcs = this.allSubBreadcrumbs;
      /* if ( this.router && bbn.fn.isNumber(this.router.selected) ){
        let url = this.router.views[this.router.selected].url;
        if ( this.router.urls[url] && this.subBreadcrumbs[url] ){
          ret.push(this.subBreadcrumbs[url]);
          if ( this.subBreadcrumbs[url].currents.length ){
            ret.push(...this.subBreadcrumbs[url].currents);
          }
        }
      }
      return ret; */
      return this.getCurrents(this.router.selected);
    },
    /**
     * Returns the background color used for the main bar.
     * @computed backgroundColor
     * @return {String}
     */
    backgroundColor() {
      return this.isNumber(this.selected) && this.source[this.selected] && this.source[this.selected].bcolor ? this.source[this.selected].bcolor : '';
    },
    /**
     * Returns the font color used for the main bar.
     * @computed fontcolor
     * @return {String}
     */
    fontColor() {
      return this.isNumber(this.selected) && this.source[this.selected] && this.source[this.selected].fcolor ? this.source[this.selected].fcolor : '';
    }
  },
  methods: {
    /**
     * Alias of bbn.fn.isNumber
     * @method isNumber
     * @return {Boolean}
     */
    isNumber: bbn.fn.isNumber,
    /**
     * @method register
     * @param {bbnCp} bc
     * @param {String} url
     */
    register(bc, url) {
      this.subBreadcrumbs[url] = bc;
      this.allSubBreadcrumbs.push(bc);
      if (this.itsMaster) {
        this.itsMaster.allSubBreadcrumbs.push(bc);
      }
    },
    /**
     * @method unregister
     * @param {bbnCp} bc
     * @param {String} url
     */
    unregister(bc, url) {
      if (this.subBreadcrumbs[url]) {
        delete this.subBreadcrumbs[url];
      }
      let idx = bbn.fn.search(this.allSubBreadcrumbs, {
        _uid: bc._uid
      });
      if (idx !== -1) {
        this.allSubBreadcrumbs.splice(idx, 1);
      }
      if (this.itsMaster) {
        let idx2 = bbn.fn.search(this.itsMaster.allSubBreadcrumbs, {
          _uid: bc._uid
        });
        if (idx2 !== -1) {
          this.itsMaster.allSubBreadcrumbs.splice(idx2, 1);
        }
      }
    },
    getCurrents(idx) {
      let ret = [];
      if (this.router && bbn.fn.isNumber(idx) && this.router.views[idx]) {
        let url = this.router.views[idx].url;
        if (this.router.urls[url] && this.subBreadcrumbs[url]) {
          ret.push(this.subBreadcrumbs[url]);
          if (this.subBreadcrumbs[url].currents.length) {
            ret.push(...this.subBreadcrumbs[url].currents);
          }
        }
      }
      return ret;
    },
    /**
     * @method getMenuFn
     * @param {Number} idx
     * @return {Array}
     */
    getMenuFn(idx) {
      return this.menu ? this.menu(idx) : [];
    },
    /**
     * @method close
     * @param {Number} idx
     * @param {Boolean} force
     * @fires isValidIndex
     * @emit beforeclose
     * @emit close
     */
    close(idx, force) {
      if (this.isValidIndex(idx)) {
        let ev = new CustomEvent('beforeClose', {
          cancelable: true
        });
        this.$emit('beforeClose', idx, force, ev);
        if (!ev.defaultPrevented) {
          this.source.splice(idx, 1);
          if (this.selected > idx) {
            this.selected--;
          } else if (this.selected === idx) {
            this.selected = false;
          }
          this.$emit('close', idx, force);
        }
      }
    },
    /**
     * @method closeAll
     * @fires close
     */
    closeAll() {
      for (let i = this.source.length - 1; i >= 0; i--) {
        if (!this.source[i].fixed && !this.source[i].pinned) {
          this.close(i);
        }
      }
    },
    /**
     * @method closeAllBut
     * @fires close
     */
    closeAllBut(idx) {
      for (let i = this.source.length - 1; i >= 0; i--) {
        if (!this.source[i].fixed && !this.source[i].pinned && i !== idx) {
          this.close(i);
        }
      }
    },
    /**
     * @method isvalidIndex
     * @return {Boolean}
     */
    isValidIndex(idx) {
      return bbn.fn.isNumber(idx) && this.source[idx] !== undefined;
    },
    /**
     * Returns the breadcrumb's source list.
     * @method getList
     * @param {bbnCp} bc
     * @fires close
     * @return {Array}
     */
    getList(bc) {
      if (!bc) {
        bc = this;
      }
      let list = [],
        parents = bc.itsMaster && bc !== bc.itsMaster ? bc.getParents() : [];
      bbn.fn.each(bc.source, (t, i) => {
        if (!t.hidden && i !== bc.selected) {
          list.push({
            text: t.title,
            icon: t.icon,
            key: t.url,
            bcolor: t.bcolor,
            fcolor: t.fcolor,
            fixed: t.fixed,
            parents: parents,
            children: bc.getCurrents(i),
            action: () => {
              bc.selected = t.idx;
            },
            closeAction: () => {
              bc.close(t.idx);
            }
          });
        }
      });
      return list;
    },
    /**
     * @method getParents
     * @return {Array}
     */
    getParents() {
      return this.parent ? [...this.parent.getParents(), this.parent] : [];
    },
    /**
     * @method openMenu
     * @param {Event} ev
     */
    openMenu(ev) {
      let ele = ev.target.parentElement.parentElement,
        e = new MouseEvent("contextmenu", {
          bubbles: true,
          cancelable: true,
          view: window
        });
      ele.dispatchEvent(e);
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    if (!this.master) {
      bbn.fn.each(this.ancestors('bbn-breadcrumb'), b => {
        this.parents.push(b);
        if (b.master) {
          return false;
        }
      });
    }
    if (bbn.fn.isNumber(this.value)) {
      this.selected = this.value;
    }
    this.$nextTick(() => {
      if (!this.master && this.router) {
        this.parent = this.router.parent.itsBreadcrumb;
        this.router.parent.itsBreadcrumb.register(this, bbn.fn.substr(this.router.baseURL, 0, this.router.baseURL.length - 1));
      }
    });
    this.ready = true;
    setTimeout(() => {
      // bugfix for rendering some nf-mdi icons
      this.iconsReady = true;
    }, 1000);
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    if (!this.master && this.router && this.router.parent && this.router.parent.itsBreadcrumb) {
      this.router.parent.itsBreadcrumb.unregister(this, bbn.fn.substr(this.router.baseURL, 0, this.router.baseURL.length - 1));
    }
  },
  watch: {
    /**
     * @watch selected
     * @emit select
     */
    selected(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.$emit('select', newVal);
      }
    },
    /**
     * @watch value
     */
    value(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.selected = newVal;
      }
    }
  },
  components: {
    /**
     * @component listItem
     */
    listItem: {
      template: `
<span class="bbn-w-100 bbn-vxspadded bbn-hspadded">
<span class="bbn-flex-width bbn-vmiddle">
  <span class="text bbn-flex-fill">
    <template v-for="p in source.parents">
      <span :style="{
              backgroundColor: p.source[p.selected].bcolor || false,
              color: p.source[p.selected].fcolor || false
            }"
            class="bbn-hxspadded">
        <i v-if="p.source[p.selected].icon"
            :class="p.source[p.selected].icon"/>
        <span v-html="p.source[p.selected].title || '` + bbn._('Untitled') + `'"/>
      </span>
      <i class="nf nf-fa-angle_right bbn-hsmargin bbn-large bbn-breadcrumb-arrow"/>
    </template>
    <span :style="{
            backgroundColor: source.bcolor || false,
            color: source.fcolor || false
          }"
          class="bbn-hxspadded">
      <i v-if="source.icon"
          class="source.icon"/>
      <span v-html="source.text || '` + bbn._('Untitled') + `'"/>
    </span>
    <template v-for="(c, i) in source.children">
      <i class="nf nf-fa-angle_right bbn-hsmargin bbn-large bbn-breadcrumb-arrow"/>
      <span :style="{
              backgroundColor: c.source[c.selected].bcolor || false,
              color: c.source[c.selected].fcolor || false
            }"
            :class="['bbn-hxspadded', {'bbn-b': !!source.children[i+1]}]">
        <i v-if="c.source[c.selected].icon"
            class="c.source[c.selected].icon"/>
        <span v-html="c.source[c.selected].title || '` + bbn._('Untitled') + `'"></span>
      </span>
    </template>
  </span>
  <span v-if="!source.fixed"
        class="space"
        style="text-align: right"
        @click.prevent.stop="close">
    <i class="nf nf-fa-times"/>
  </span>
</span>
</span>
      `,
      props: {
        /**
         * @prop {Object} source
         * @memberof listItem
         */
        source: {
          type: Object,
          required: true
        }
      },
      methods: {
        /**
         * @method close
         * @memberof listItem
         */
        close() {
          this.source.closeAction();
          this.closest('bbn-context').showFloater = false;
        }
      }
    }
  }
};
import cpHtml from './breadcrumb.html';
import cpStyle from './breadcrumb.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./breadcrumb.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-breadcrumb',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-browser component
 * @description bbn-browser
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @ignore
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
    * The object source of component bbn-browser.
    * @prop {Object} Source
    */
    source: {}
  },
  data() {
    return {
      /**
      * @prop {Array} [[]] tabs
      */
      tabs: []
    };
  },
  computed: {
    /**
     * Return if the button is disabled.
     *
     * @computed isDisabled
     * @return {Boolean}
     */
    isDisabled() {
      return typeof this.disabled === 'function' ? this.disabled() : this.disabled;
    }
  },
  methods: {
    /**
     * The role of the button when clicked.
     *
     * @method click
     * @emit click
     */
    click(e) {
      if (this.url) {
        bbn.fn.link(this.url);
      } else {
        this.$emit('click', e);
      }
    }
  },
  components: {
    /**
    * @component tab
    */
    tab: {
      template: `
<div class="bbn-overlay">
<div class="bbn-flex-height">
  <div class="bbn-w-100">
    <div class="bbn-flex-width">
      <div class="bbn-block">
        <span v-if="ssl" class="bbn-green">
          <i class="nf nf-fa-lock"></i>
        </span>
        <span v-else class="bbn-red">
          <i class="nf nf-fa-unlock"></i>
        </span>
      </div>
      <div class="bbn-flex-fill">
        <bbn-input v-model="url" class="bbn-w-100" @keydown="keydown"></bbn-input>
      </div>
    </div>
  </div>
  <div class="bbn-flex-fill">
    <iframe v-if="realURL" class="bbn-overlay" src="rawURL"></iframe>
    <div v-else class="bbn-overlay">

    </div>
  </div>
</div>
</div>
      `,
      data() {
        return {
          /**
           * @data {Boolean} [false] ssl
           */
          ssl: false,
          /**
           * @data {String} ['home'] url
           */
          url: 'home',
          /**
           * @data {String} [null] rawURL
           */
          rawURL: null,
          /**
           * @data {String} [null] realURL
           */
          realURL: null
        };
      },
      methods: {
        /**
         * @method keydown
         * @param e
         */
        keydown(e) {
          bbn.fn.log(e);
        }
      }
    }
  }
};
import cpHtml from './browser.html';
import cpStyle from './browser.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./browser.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-browser',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-button component
 *
 * @description bbn-button is a component represents the button with the possibility of extensive customizations.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
import basic from '../../cp/mixins/basic.js';
import events from '../../cp/mixins/events.js';
const cpDef = {
  tag: 'button',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   */
  mixins: [basic, events],
  props: {
    /**
     * The title of the button.
     *
     * @prop {String} [''] title
     */
    title: {
      type: String,
      default: ''
    },
    /**
    * The button's text.
    *
    * @prop {String} text
    */
    text: {
      type: String
    },
    /**
    * Set to false for no text on the button.
    *
    * @prop {Boolean} [false] notext
    */
    notext: {
      type: Boolean,
      default: false
    },
    /**
     * The button links to a designated url.
     *
     * @prop {String} url
     */
    url: {
      type: String
    },
    /**
     * The icon shown on the button.
     *
     *  @prop {String} icon
     */
    icon: {
      type: String
    },
    /**
     * The icon(s) position (left or right).
     *
     * @prop {String} ['left'] iconPosition
     */
    iconPosition: {
      type: String,
      default: 'left',
      validator: p => ['left', 'right'].includes(p)
    },
    /**
     * A second icon to display on the button above the main icon.
     *
     * @prop {String} secondary
     */
    secondary: {
      type: String
    },
    /**
     * If defined the prop secondary, defines the color of the second icon of the button.
     *
     * @prop {String} [null] secondaryColor
     */
    secondaryColor: {
      type: String,
      default: null
    },
    /**
     * Specifies the type of button.
     *
     * @prop {String} ['button'] type
     */
    type: {
      type: String,
      default: 'button'
    },
    /**
     * Set to true to disable the button.
     *
     * @prop {(Boolean|Function)} [false] disabled
     */
    disabled: {
      type: [Boolean, Function, String],
      default: false
    },
    /**
     * Set to true for the button to glow.
     *
     * @prop {(String|Boolean)} [false] glowing
     */
    glowing: {
      type: [String, Boolean],
      default: false
    },
    /**
     * State the button's glowing colour.
     *
     * @prop {String} ['#c4a300'] glowingColor
     */
    glowingColor: {
      type: String,
      default: '#c4a300'
    },
    /**
     * The action that has to be performed at the event click.
     *
     * @prop {(Function|String)} action
     */
    action: {
      type: [Function, String]
    },
    /**
     * Adds the ellipsis
     * @prop {Boolean} [false] ellipsis
     */
    ellipsis: {
      type: Boolean,
      default: false
    },
    /**
     * If true the button will be focused when inserted in the DOM
     * @prop {Boolean} [false] focused
     */
    focused: {
      type: Boolean,
      default: false
    },
    /**
     * If true the button will have the bbn-active class
     * @prop {Boolean} [false] active
     */
    active: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      glowingID: bbn.fn.randomString()
    };
  },
  computed: {
    /**
     * Returns a combination of the properties 'text' and 'title' if the property 'noText' is set to true, else returns the property 'title'.
     *
     * @computed titleString
     * @return {String}
     */
    titleString() {
      if (this.title) {
        return this.title;
      }
      let st = '';
      if (this.notext && this.text) {
        st += this.text;
      }
      return st;
    },
    /**
     * Return if the button is disabled.
     *
     * @computed isDisabled
     * @fires disabled
     * @return {Boolean}
     */
    isDisabled() {
      return typeof this.disabled === 'function' ? this.disabled() : this.disabled;
    },
    /**
     * Returns the style of the button
     * @computed currentStyle
     * @return {Object}
     */
    currentStyle() {
      let obj = this.glowing && this.glowingColor ? {
        animation: `bbn-button-glowing-${this.glowingID} 3s infinite`
      } : {};
      if (this.ellipsis) {
        obj['text-overflow'] = 'ellipsis';
      }
      return obj;
    }
  },
  methods: {
    /**
     * The role of the button when clicked.
     *
     * @method click
     * @param {Event} e
     * @fires action
     * @emit click
     */
    click(e) {
      var _this$$el$bbnSchema$e;
      //bbn.fn.log("ONCLICK", e, this);
      if (this.url) {
        bbn.fn.link(this.url);
        e.preventDefault();
        e.stopPropagation();
      } else if (!((_this$$el$bbnSchema$e = this.$el.bbnSchema.events) !== null && _this$$el$bbnSchema$e !== void 0 && _this$$el$bbnSchema$e.click) && this.action && bbn.fn.isFunction(this.action)) {
        this.action.bind(this.$origin)(e, this);
        //bbn.fn.log(["CLICK BUTTON EVENT", this.$origin, this.action])
        e.preventDefault();
        e.stopPropagation();
      }
    }
  },
  beforeMount() {
    if (this.glowing && this.glowingColor) {
      let lc = bbn.fn.lightenDarkenHex(this.glowingColor, 40),
        styleTag = document.createElement('style');
      styleTag.textContent = bbn.fn.isString(this.glowing) ? this.glowing : `
@-webkit-keyframes bbn-button-glowing-${this.glowingID} {
0% { background-color: ${this.glowingColor}; -webkit-box-shadow: 0 0 3px ${this.glowingColor}; }
50% { background-color: ${lc}; -webkit-box-shadow: 0 0 40px ${lc}; }
100% { background-color: ${this.glowingColor}; -webkit-box-shadow: 0 0 3px ${this.glowingColor}; }
}
@-moz-keyframes bbn-button-glowing-${this.glowingID} {
0% { background-color: ${this.glowingColor}; -moz-box-shadow: 0 0 3px ${this.glowingColor}; }
50% { background-color: ${lc}; -moz-box-shadow: 0 0 40px ${lc}; }
100% { background-color: ${this.glowingColor}; -moz-box-shadow: 0 0 3px ${this.glowingColor}; }
}
@-o-keyframes bbn-button-glowing-${this.glowingID} {
0% { background-color: ${this.glowingColor}; box-shadow: 0 0 3px ${this.glowingColor}; }
50% { background-color: ${lc}; box-shadow: 0 0 40px ${lc}; }
100% { background-color: ${this.glowingColor}; box-shadow: 0 0 3px ${this.glowingColor}; }
}
@keyframes bbn-button-glowing-${this.glowingID} {
0% { background-color: ${this.glowingColor}; box-shadow: 0 0 3px ${this.glowingColor}; }
50% { background-color: ${lc}; box-shadow: 0 0 40px ${lc}; }
100% { background-color: ${this.glowingColor}; box-shadow: 0 0 3px ${this.glowingColor}; }
}
      `;
      document.body.appendChild(styleTag);
    }
  }
};
import cpHtml from './button.html';
import cpStyle from './button.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./button.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-button',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-calendar component
 *
 * @description The bbn-calendar component is a calendar that allows you to interact with dates by providing details, inserting reminders and creating events.
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.resizer
  */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.resizer],
  props: {
    /**
     * Auto-loads the data at mount of the component if it's set as "true".
     * @prop {Boolean} [false] autobind
    */
    autobind: {
      type: Boolean,
      default: false
    },
    /**
     * The array of events for each day.
     * When a string is set, an ajax call will be made to the corresponding url.
     *
     * @prop {(String|Array)} [[]] source
    */
    source: {
      type: [String, Array],
      default() {
        return [];
      }
    },
    /**
     * The visualization mode.
     * Allowed values: days, weeks, months and years.
     *
     * @prop {String} ['days'] type
    */
    type: {
      type: String,
      default: 'days',
      validator: m => ['days', 'weeks', 'months', 'years'].includes(m)
    },
    /**
     * Set to true to autoselect the date property value.
     *
     * @prop {Boolean} [false] autoSelect
     */
    autoSelection: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to select multiple values.
     *
     * @prop {Boolean} [false] multiSelection
    */
    multiSelection: {
      type: Boolean,
      default: false
    },
    /**
     * The value.
     *
     * @prop {String} [''] value
    */
    value: {
      type: String,
      default: ''
    },
    /**
     * Shows the arrows on the header.
     *
     * @prop {Boolean} [true] arrows
     */
    arrows: {
      type: Boolean,
      default: true
    },
    /**
     * Shows the arrows as buttons (only icons also).
     *
     * @prop {Boolean} [true] arrowsButtons
    */
    arrowsButtons: {
      type: Boolean,
      default: true
    },
    /**
     * The icon displayed before the title.
     *
     * @prop {String|Boolean} ['nf nf-oct-calendar'] titleIcon
    */
    titleIcon: {
      type: [String, Boolean],
      default: 'nf nf-oct-calendar'
    },
    /**
     * The function called on click on the title.
     * 
     * @prop {Function} titleAction
     */
    titleAction: {
      type: Function
    },
    /**
     * The initial date.
     *
     * @prop {String} date
    */
    date: {
      type: String
    },
    /**
     * Shows/hides the dates of the next and previous period in the current visualization.
     *
     * @prop {Boolean} [false] extraItems
    */
    extraItems: {
      type: Boolean,
      default: false
    },
    /**
     * Array of items to insert into a range.
     *
     * @prop {Array} [[]] itemsRange
     */
    itemsRange: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Shows only dates with events.
     *
     * @prop {Boolean} [false] onlyEvents
     */
    onlyEvents: {
      type: Boolean,
      default: false
    },
    /**
     * Disables the dates without events.
     *
     * @prop {Boolean} [false] disableNoEvents
     */
    disableNoEvents: {
      type: Boolean,
      default: false
    },
    /**
     * Shows/hides the date's details.
     *
     * @prop {Boolean} [false] itemDetails
    */
    itemDetails: {
      type: Boolean,
      default: false
    },
    /**
     * The icon used to indicate the presence of events in the item.
     * If set to false, nothing will be shown.
     *
     * @prop {String|Boolean} ['nf nf-fa-user'] eventIcon
    */
    eventIcon: {
      type: [String, Boolean],
      default: 'nf nf-fa-calendar'
    },
    /**
     * Shows/hides the padding of the item's cell.
     *
     * @prop {Boolean} [false] itemPadding
    */
    itemPadding: {
      type: Boolean,
      default: false
    },
    /**
     * The component used for the items.
     *
     * @prop {bbnCp} itemComponent
    */
    itemComponent: {
      type: [bbnCp, Object, String]
    },
    /**
     * The title for the item's details.
     *
     * @prop {Function|String} [''] itemTitle
    */
    itemTitle: {
      type: [Function, String],
      default: ''
    },
    /**
     * The component used for the header.
     *
     * @prop {bbnCp|Object|String} headerComponent
    */
    headerComponent: {
      type: [bbnCp, Object, String]
    },
    /**
     * The labels type.
     * Types: auto, letter, abbr, full, false.
     *
     * @prop {String|Boolean} ['auto'] labels
    */
    labels: {
      type: [String, Boolean],
      default: 'auto',
      validator: s => ['auto', 'letter', 'abbr', 'full', false].includes(s)
    },
    /**
     * The field used for the event's start.
     *
     * @prop {String} ['start'] startField
     */
    startField: {
      type: String,
      default: 'start'
    },
    /**
     * The field used for the event's end.
     *
     * @prop {String} ['end'] endField
    */
    endField: {
      type: String,
      default: 'end'
    },
    /**
     * The format used for the event's start.
     *
     * @prop {String} ['YYYY-MM-DD 00:00:00'] startFormat
     */
    startFormat: {
      type: String,
      default: 'YYYY-MM-DD 00:00:00'
    },
    /**
     * The format used for the event's end.
     *
     * @prop {String} ['YYYY-MM-DD 23:59:59'] endFormat
     */
    endFormat: {
      type: String,
      default: 'YYYY-MM-DD 23:59:59'
    },
    /**
     * The maximum allowed date.
     *
     * @prop {String} max
     */
    max: {
      type: String
    },
    /**
     * The minimum allowed date.
     *
     * @prop {String} min
     */
    min: {
      type: String
    },
    /**
     * The disabled dates.
     *
     * @prop {Array|Function} disableDates
     */
    disableDates: {
      type: [Array, Function],
      default() {
        return [];
      }
    },
    /**
     * Shows the "loading" text when it's loading.
     * @prop {Boolean} showLoading
     */
    showLoading: {
      type: Boolean,
      default: false
    }
  },
  data() {
    let mom = dayjs();
    if (this.date) {
      let m = dayjs(this.date, this.getCfg().valueFormat);
      mom = m.isValid() ? m : mom;
    } else if (this.max) {
      let m = dayjs(this.max, this.getCfg().valueFormat);
      mom = m.isValid() ? m : mom;
    }
    return {
      /**
       * Today as 'YYYY-MM-DD' format.
       *
       * @data {String} [today] today
      */
      today: dayjs().format('YYYY-MM-DD'),
      /**
       * The current calendar title.
       *
       * @data {String} [''] title
      */
      title: '',
      /**
       * The labels (text).
       *
       * @data {Array} [[]] currentLabels
      */
      currentLabels: [],
      /**
       * The Moment objects of the labels.
       *
       * @data {Array} [[]] currentLabelsDates
      */
      currentLabelsDates: [],
      /**
       * The current date as a Moment object.
       *
       * @data {Moment} currentDate
       */
      currentDate: mom,
      /**
       * The items' structures.
       *
       * @data {Array} [[]] items
      */
      items: [],
      /**
       * The component is ready.
       *
       * @data {Boolean} [false] ready
       */
      ready: false,
      /**
       * CSS style for the grid.
       *
       * @data {String} [''] gridStyle
      */
      gridStyle: '',
      /**
       * The current value.
       *
       * @data {String} [''] currentValue
       */
      currentValue: '',
      /**
       * The events.
       *
       * @data {Object} [{}] events
       */
      events: {}
    };
  },
  computed: {
    /**
     * The current configuration.
     *
     * @computed currentCfg
     * @fires getCfg
     * @return {Object}
    */
    currentCfg() {
      if (this.type) {
        return this.getCfg();
      }
      return {};
    }
  },
  methods: {
    /**
     * Makes a calendar item's structure.
     *
     * @method _makeItem
     * @param {String} txt The item's text
     * @param {String} val The item's value
     * @param {Boolean} hid If the item is hidden or not
     * @param {Boolean} col If the item is colored or not
     * @param {Boolean} dis If the item is disabled or not
     * @param {Boolean} ext If the item is extra or not
     * @return {Object}
    */
    _makeItem(txt, val, hid, col, dis, ext) {
      //let events = this.filterEvents(val),
      let events = this.events[val],
        obj = {
          text: txt,
          value: val,
          isCurrent: val === dayjs(this.today, this.currentCfg.valueFormat).format(this.currentCfg.valueFormat),
          hidden: !!hid,
          colored: !!col,
          over: false,
          events: events,
          inRange: this.itemsRange.includes(val),
          disabled: !!dis,
          extra: !!ext
        };
      if (this.onlyEvents && (!events || !events.length) || this.min && obj.value < dayjs(this.min, this.currentCfg.valueFormat).format(this.currentCfg.valueFormat) || this.max && obj.value > dayjs(this.max, this.currentCfg.valueFormat).format(this.currentCfg.valueFormat)) {
        obj.hidden = true;
      }
      if (this.disableDates) {
        obj.disabled = bbn.fn.isFunction(this.disableDates) ? this.disableDates(obj.value) : this.disableDates.includes(obj.value);
      }
      if (this.disableNoEvents && !obj.disabled) {
        obj.disabled = !events || !events.length;
      }
      return obj;
    },
    /**
     * Makes the items' structure in "days" mode.
     *
     * @method _makeDays
     * @fires _makeItem
     * @return {Object}
    */
    _makeDays() {
      let items = [],
        c = dayjs(this.currentDate.format('YYYY-MM-01')),
        currentMonth = this.currentDate.month(),
        sunday = dayjs(c).day('Sunday').weekday();
      for (let i = 1; i <= 6; i++) {
        if (i > 1) {
          c = c.add(1, 'w');
        }
        items = items.concat(Array.from({
          length: 7
        }, (v, k) => {
          let w = dayjs(c).weekday(k),
            val = w.format(this.currentCfg.valueFormat),
            otherMonth = dayjs(w).month() !== currentMonth,
            isHidden = !this.extraItems && !!otherMonth ? true : false;
          return this._makeItem(w.get('date'), val, isHidden, k === sunday, false, this.extraItems && !!otherMonth);
        }));
      }
      this.gridStyle = 'grid-template-columns: repeat(7, 1fr); grid-template-rows: max-content repeat(6, 1fr);';
      this.currentLabelsDates = Array.from({
        length: 7
      }, (v, i) => dayjs(this.currentDate).weekday(i));
      this.$set(this, 'items', items);
    },
    /**
     * Makes the items' structure of "weeks" mode.
     *
     * @method _makeWeeks
     * @fires _makeItem
     * @return {Object}
    */
    _makeWeeks() {
      let c = dayjs(this.currentDate),
        sunday = dayjs(c).day('Sunday').weekday(),
        items = Array.from({
          length: 7
        }, (v, k) => {
          let w = c.weekday(k);
          return this._makeItem(w.get('date'), w.format(this.currentCfg.valueFormat), false, k === sunday, false, false);
        });
      this.gridStyle = 'grid-template-columns: repeat(7, 1fr); grid-template-rows: max-content auto';
      this.currentLabelsDates = Array.from({
        length: 7
      }, (v, i) => dayjs(this.currentDate).weekday(i));
      this.$set(this, 'items', items);
    },
    /**
     * Makes the items' structure of "months" mode.
     *
     * @method _makeMonths
     * @fires _makeItem
     * @return {Object}
    */
    _makeMonths() {
      let c = dayjs(this.currentDate.format('YYYY-01-01')),
        items = Array.from({
          length: 12
        }, (v, k) => {
          let w = c.month(k);
          return this._makeItem(w.format('MMM'), w.format(this.currentCfg.valueFormat), !this.extraItems && w.get('year') !== this.currentDate.get('year'), false, false, this.extraItems && w.get('year') !== this.currentDate.get('year'));
        });
      this.gridStyle = 'grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr);';
      this.currentLabelsDates = [];
      this.$set(this, 'items', items);
    },
    /**
     * Makes the items' structure in "years" mode.
     *
     * @method _makeYears
     * @fires _makeItem
     * @return {Object}
    */
    _makeYears() {
      let c = dayjs(this.currentDate.format('YYYY-01-01')),
        year = c.format('YYYY'),
        items = Array.from({
          length: 12
        }, (v, k) => {
          let w = c.year(year - 6 + k);
          return this._makeItem(w.format('YYYY'), w.format(this.currentCfg.valueFormat), false, false, k === 0 || k === 11, false);
        });
      this.gridStyle = 'grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr);';
      this.currentLabelsDates = [];
      this.$set(this, 'items', items);
    },
    /**
     * Returns the correct configuration based on the calendar type.
     *
     * @method getCfg
     * @return {Object}
     */
    getCfg(type) {
      let m = type || this.type,
        cfg = {};
      switch (m) {
        case 'days':
          bbn.fn.extend(cfg, {
            make: this._makeDays,
            step: [1, 'M'],
            stepSkip: [1, 'y'],
            stepEvent: [1, 'd'],
            stepText: bbn._('month'),
            stepSkipText: bbn._('year'),
            titleFormat: 'MMM YYYY',
            valueFormat: 'YYYY-MM-DD',
            labelsFormatDefault: 'ddd',
            labelsFormatLetter: 'dd',
            labelsFormatAbbr: 'ddd',
            labelsFormatFull: 'dddd',
            startFormat: 'YYYY-MM-01',
            endFormat: () => {
              return 'YYYY-MM-' + this.currentDate.daysInMonth();
            },
            startExtra: [7, 'd'],
            endExtra: [15, 'd']
          });
          break;
        case 'weeks':
          bbn.fn.extend(cfg, {
            make: this._makeWeeks,
            step: [1, 'w'],
            stepEvent: [1, 'w'],
            stepText: bbn._('week'),
            titleFormat: 'MMM YYYY',
            valueFormat: 'YYYY-MM-DD',
            labelsFormatDefault: 'ddd',
            labelsFormatLetter: 'dd',
            labelsFormatAbbr: 'ddd',
            labelsFormatFull: 'dddd',
            startFormat: () => {
              return dayjs(this.currentDate).weekday(0).format('YYYY-MM-DD');
            },
            endFormat: () => {
              return dayjs(this.currentDate).weekday(6).format('YYYY-MM-DD');
            }
          });
          break;
        case 'months':
          bbn.fn.extend(cfg, {
            make: this._makeMonths,
            step: [1, 'y'],
            stepEvent: [1, 'M'],
            stepText: bbn._('year'),
            titleFormat: 'YYYY',
            valueFormat: 'YYYY-MM',
            startFormat: 'YYYY-01-01',
            endFormat: 'YYYY-12-31'
          });
          break;
        case 'years':
          bbn.fn.extend(cfg, {
            make: this._makeYears,
            step: [10, 'y'],
            stepEvent: [1, 'y'],
            stepText: bbn._('decade'),
            titleFormat: () => {
              let from = this.currentDate.format('YYYY') - 5,
                to = from + 9;
              return from + '-' + to;
            },
            valueFormat: 'YYYY',
            startFormat: () => {
              return this.currentDate.format('YYYY') - 5 + '-01-01';
            },
            endFormat: () => {
              return this.currentDate.format('YYYY') + 4 + '-12-31';
            }
          });
          break;
      }
      return cfg;
    },
    /**
     * Returns the correct labels' format.
     *
     * @method getLabelsFormat
     * @return {String|false}
     */
    getLabelsFormat() {
      if (this.labels) {
        switch (this.labels) {
          case 'letter':
            return this.currentCfg.labelsFormatLetter;
          case 'abbr':
            return this.currentCfg.labelsFormatAbbr;
          case 'full':
            return this.currentCfg.labelsFormatFull;
          default:
            if (this.$refs.label && this.$refs.label[0]) {
              let w = this.$refs.label[0].offsetWidth;
              if (w < 40) {
                return this.currentCfg.labelsFormatLetter;
              } else if (w < 100) {
                return this.currentCfg.labelsFormatAbbr;
              } else {
                return this.currentCfg.labelsFormatFull;
              }
            }
            return this.currentCfg.labelsFormatDefault;
        }
      }
      return false;
    },
    /**
     * Called to the component mounted setting currentDate at max or min.
     *
     * @method create
     * @fires init
     * @fires setTitle
     * @fires updateData
     */
    create() {
      if (!this.ready) {
        this.$once('dataloaded', () => {
          this.init();
          this.$nextTick(() => {
            if (!this.date && (this.max || this.min)) {
              if (this.max && !this.min && this.max < this.currentDate.format(this.currentCfg.valueFormat)) {
                this.currentDate = dayjs(this.max, this.currentCfg.valueFormat);
              }
              if (this.min && !this.max && this.min > this.currentDate.format(this.currentCfg.valueFormat)) {
                this.currentDate = dayjs(this.min, this.currentCfg.valueFormat);
              }
              this.currentCfg.make();
              this.setTitle();
            }
            this.ready = true;
          });
        });
        this.updateData();
      }
    },
    /**
     * Defines and inserts events.
     *
     * @method makeEvents
     */
    makeEvents() {
      this.$set(this, 'events', {});
      bbn.fn.each(this.currentData, d => {
        let tmpStart = dayjs(d.data[this.startField], this.startFormat).format(this.currentCfg.valueFormat),
          tmpEnd = dayjs(d.data[this.endField], this.endFormat).format(this.currentCfg.valueFormat);
        if (this.events[tmpStart] === undefined) {
          this.events[tmpStart] = [];
        }
        this.events[tmpStart].push(d.data);
        if (tmpStart !== tmpEnd) {
          let mom = dayjs(tmpStart, this.currentCfg.valueFormat).add(...this.currentCfg.stepEvent),
            tmp = mom.format(this.currentCfg.valueFormat);
          while (tmp <= tmpEnd) {
            if (this.events[tmp] === undefined) {
              this.events[tmp] = [];
            }
            this.events[tmp].push(d.data);
            mom.add(...this.currentCfg.stepEvent);
            tmp = mom.format(this.currentCfg.valueFormat);
          }
        }
      });
    },
    /**
     * Initializes the calendar.
     *
     * @method init
     * @fires currentCfg.make
     * @fires makeEvents
     * @fires setTitle
     * @fires setLabels
     * @emits input
     */
    init() {
      if (this.currentCfg && bbn.fn.isFunction(this.currentCfg.make)) {
        if (this.selection && this.autoSelection && this.currentCfg.valueFormat) {
          this.currentValue = this.value ? dayjs(this.value, this.currentCfg.valueFormat).format(this.currentCfg.valueFormat) : '';
          this.$emit('input', this.currentValue);
        }
        this.makeEvents();
        this.setTitle();
        this.currentCfg.make();
        this.$nextTick(() => {
          this.setLabels(this.currentLabelsDates);
          this.$emit('init', true);
        });
      }
    },
    /**
     * Filters the events.
     *
     * @method filterEvents
     * @param {String} v
     * @return {Array}
    */
    filterEvents(v) {
      return [];
      if (this.startField && this.endField) {
        return this.currentData && bbn.fn.isArray(this.currentData) ? bbn.fn.map(bbn.fn.filter(this.currentData, ev => {
          if (ev.data[this.startField] && ev.data[this.endField]) {
            let start = dayjs(ev.data[this.startField], this.startFormat).format(this.currentCfg.valueFormat),
              end = dayjs(ev.data[this.endField], this.endFormat).format(this.currentCfg.valueFormat);
            return start <= v && end >= v;
          }
          return false;
        }), ev => {
          return ev.data;
        }) : [];
      }
      return [];
    },
    /**
     * Sets the calendar's title.
     *
     * @method setTitle
     * @fires currentCfg.titleFormat
    */
    setTitle() {
      if (this.currentCfg && this.currentCfg.titleFormat) {
        this.$set(this, 'title', bbn.fn.isFunction(this.currentCfg.titleFormat) ? this.currentCfg.titleFormat() : this.currentDate.format(this.currentCfg.titleFormat));
      }
    },
    /**
     * Refreshes the data
     *
     * @method refresh
     * @param {Boolean} force
     * @fires updateData
     * @fires init
     * @emits dataLoad
     * @emits dataLoaded
    */
    refresh(force) {
      if (!force) {
        let ev = new Event('dataLoad', {
          cancelable: true
        });
        this.$emit('dataLoad', ev, this);
        if (ev.defaultPrevented) {
          return false;
        }
      }
      this.$once('dataloaded', () => {
        this.init();
      });
      this.updateData();
    },
    /**
     * Changes the current calendar view to the next period.
     *
     * @method next
     * @param {Boolean} skip
     * @fires refresh
     * @emits next
    */
    next(skip) {
      skip = typeof skip === 'boolean' ? skip : false;
      if (this.currentCfg && this.currentCfg.step && bbn.fn.isFunction(this.currentCfg.make)) {
        let check = dayjs(this.currentDate).add(...this.currentCfg[skip && this.currentCfg.stepSkip ? 'stepSkip' : 'step']).format(this.currentCfg.valueFormat);
        if (this.max && check > this.max) {
          this.currentDate = dayjs(this.max, this.currentCfg.valueFormat);
        } else {
          this.currentDate = dayjs(check, this.currentCfg.valueFormat);
        }
        let ev = new Event('next', {
          cancelable: true
        });
        this.$emit('next', ev, this);
        if (ev.defaultPrevented) {
          return false;
        }
        this.refresh();
      }
    },
    /**
     * Changes the current calendar view to the previous period.
     *
     * @method prev
     * @param {Boolean} skip
     * @fires refresh
     * @emits prev
    */
    prev(skip) {
      skip = typeof skip === 'boolean' ? skip : false;
      if (this.currentCfg && this.currentCfg.step && bbn.fn.isFunction(this.currentCfg.make)) {
        let check = dayjs(this.currentDate).subtract(...this.currentCfg[skip && this.currentCfg.stepSkip ? 'stepSkip' : 'step']).format(this.currentCfg.valueFormat);
        if (this.min && check < this.min) {
          this.currentDate = dayjs(this.min, this.currentCfg.valueFormat);
        } else {
          this.currentDate = dayjs(check, this.currentCfg.valueFormat);
        }
        let ev = new Event('prev');
        this.$emit('prev', ev, this);
        if (ev.defaultPrevented) {
          return false;
        }
        this.refresh();
      }
    },
    /**
     * Changes the current value after a selection.
     *
     * @method select
     * @param {String} val The selected day
     * @param {Boolean} [undefined] notEmit If true, the 'selected' emit will not be performed
     * @emits input
     * @emits selected
    */
    select(val, notEmit) {
      if (this.selection && val) {
        val = val === this.currentValue ? '' : val;
        this.currentValue = val;
        this.$emit('input', val);
        if (!notEmit) {
          this.$emit('selected', val, this, this.currentCfg.valueFormat);
        }
      }
    },
    /**
     * Additionals data to sent with the ajax call.
     *
     * @method getPostData
     * @return {Object}
    */
    getPostData() {
      let start = dayjs(this.currentDate.format(bbn.fn.isFunction(this.currentCfg.startFormat) ? this.currentCfg.startFormat() : this.currentCfg.startFormat)),
        end = dayjs(this.currentDate.format(bbn.fn.isFunction(this.currentCfg.endFormat) ? this.currentCfg.endFormat() : this.currentCfg.endFormat)),
        data = {};
      if (this.extraItems) {
        if (this.currentCfg.startExtra) {
          start.subtract(...this.currentCfg.startExtra);
        }
        if (this.currentCfg.endExtra) {
          end.add(...this.currentCfg.endExtra);
        }
      }
      data[this.startField] = start.format(this.startFormat);
      data[this.endField] = end.format(this.endFormat);
      if (this.data) {
        bbn.fn.extend(data, bbn.fn.isFunction(this.data) ? this.data() : this.data);
      }
      return data;
    },
    /**
     * Sets the labels.
     *
     * @method setLabels
     * @param {Array} d
     * @fires getLabelsFormat
    */
    setLabels(d) {
      if (bbn.fn.isArray(d) && d.length) {
        this.currentLabels = d.map(l => {
          return l.format(this.getLabelsFormat());
        });
      } else {
        this.currentLabels = [];
      }
    },
    /**
     * Handles the resize.
     *
     * @method onResize
     * @fires setLabels
    */
    onResize() {
      return new Promise((resolve, reject) => {
        this.setLabels(this.currentLabelsDates);
        resolve();
      });
    }
  },
  /**
   * @event beforeCreate
   */
  beforeCreate() {
    if (bbn.env && bbn.env.lang && bbn.env.lang !== dayjs.locale()) {
      dayjs.locale(bbn.env.lang);
    }
  },
  /**
   * @event mounted
   * @fires create
  */
  mounted() {
    this.create();
  },
  watch: {
    /**
     * @watch type
     * @fires create
    */
    type(newVal) {
      this.ready = false;
      this.create();
    },
    /**
     * @watch currentLabelsDates
     * @fires setLabels
    */
    currentLabelsDates(newVal) {
      this.setLabels(newVal);
    },
    /**
     * @watch value
     */
    value(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.currentValue = newVal;
      }
    },
    /**
     * @watch currentData
     * @fires init
    */
    currentData() {
      this.init();
    }
  }
};
import cpHtml from './calendar.html';
import cpStyle from './calendar.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./calendar.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-calendar',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-chart component
 *
 * @description  The bbn-chart component is a graphical representation of data.
 * It allows large amounts of information to be condensed into an easily understandable visual format where complex data can be displayed, interpreted and analyzed with detailed customization using one of these graphs: "line", "area", "bar", "pie", "donut" and "radial".
 *
 * @author Mirko Argentino
 *
 * @copyright BBN Solutions
 *
 * @created 10/02/2020
 */
import ApexCharts from 'apexcharts';
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],
  props: {
    /**
     * The component's data.
     * @prop {Object} source
     */
    source: {
      type: Object
    },
    /**
     * The type of chart.
     * @prop {String} ['line'] type
     */
    type: {
      type: String,
      required: true,
      default: 'line',
      validator: t => ['line', 'bar', 'pie', 'donut', 'area', 'radial'].includes(t)
    },
    /**
    * The width of the chart.
    * @prop {String} ['100%'] width
    */
    width: {
      type: String,
      default: '100%'
    },
    /**
     * The height of the chart.
     * @prop {String} ['100%'] height
     */
    height: {
      type: String,
      default: '100%'
    },
    /**
     * The theme of chart.
     *
     * @prop {String} ['light'] theme
     */
    theme: {
      type: String,
      default() {
        if (appui && appui.theme && appui.themes) {
          let isDark = bbn.fn.getField(appui.themes, 'isDark', {
            value: appui.theme
          });
          return !!isDark ? 'dark' : 'light';
        }
        return 'light';
      },
      validator: t => ['light', 'dark'].includes(t)
    },
    /**
     * The title of the chart.
     * @prop {String} title
     */
    title: {
      type: String
    },
    /**
     * The x-axis title.
     * @prop {String} xTitle
     */
    xTitle: {
      type: String
    },
    /**
     * The y-axis title.
     * @prop {String} yTitle
     */
    yTitle: {
      type: String
    },
    /**
     * Set it to false to hide the value points on the line chart, or specific the point' size.
     * @prop {Boolean|Number} [6] points
     */
    points: {
      type: [Boolean, Number],
      default: 6
    },
    /**
     * Set it to false if you want to hide the labels on the points.
     * @prop {Boolean} [true] pointsLabels
     */
    pointsLabels: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true to show a smooth line on the line chart.
     * @prop {Boolean} [false] smooth
     */
    smooth: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true to see a square line on the line and area charts.
     * @prop {Boolean} [false] step
     */
    step: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to create a donut pie chart. Integers can be given to determine the donut width.
     * @prop {Boolean|Number} [false] donut
     */
    donut: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * The series' background style ('gradient' or 'solid').
     * @prop {String} ['solid'] fill
     */
    fill: {
      type: String,
      default: 'solid',
      validator: f => ['gradient', 'solid'].includes(f)
    },
    /**
     * Opacity adjustment.
     * From 0.1 to 1
     * @prop {Number|String} opacity
    */
    opacity: {
      type: [Number, String]
    },
    /**
     * X-axis configuration object.
     * @prop {Object} [{}] xAxis
     */
    xAxis: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Y-axis configuration object.
     * @prop {Object} [{}] yAxis
     */
    yAxis: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Set it to false to hide the grid line on the chart.
     * @prop {Boolean} [true] grid
     */
    grid: {
      type: Boolean,
      default: true
    },
    /**
     * Set it to false if you want to hide the grid for the x-axis on the chart.
     * @prop {Boolean} [true] xGrid
     */
    xGrid: {
      type: Boolean,
      default: true
    },
    /**
    * Set it to false if you want to hide the grid for the y-axis on the chart.
    * @prop {Boolean} [true] yGrid
    */
    yGrid: {
      type: Boolean,
      default: true
    },
    /**
     * The grid's color.
     * @prop {String} gridColor
     */
    gridColor: {
      type: String
    },
    /**
     * The grid's background.
     * @prop {String} gridColor
     */
    gridBackground: {
      type: String
    },
    /**
     * Set it to false if you want to disable the animations.
     * If you give a number it will be used as the time (ms) for the animations.
     *
     * @prop {Boolean|Number} [800] animation
     */
    animation: {
      type: [Boolean, Number],
      default: 800
    },
    /**
     * Set it to true if you want the stacked bars.
     * @prop {Boolean} [false] stacked
     */
    stacked: {
      type: Boolean,
      default: false
    },
    /**
     * The distance between the bars on the bar chart.
     * @prop {Number} barsDistance
     */
    barsDistance: {
      type: Number
    },
    /**
     * Set it to true if you want to see horizontal bars on the bar chart.
     * @prop {Boolean} [false] horizontalBars
     */
    horizontal: {
      type: Boolean,
      default: false
    },
    /**
     * A colors list for personalization.
     * @prop {String|Array} color
     */
    color: {
      type: [String, Array],
      default() {
        return [bbn.var.colors.webblue, bbn.var.colors.turquoise, bbn.var.colors.orange, bbn.var.colors.red, bbn.var.colors.purple, bbn.var.colors.yellow, bbn.var.colors.pink, bbn.var.colors.brown, bbn.var.colors.grey, bbn.var.colors.navy, bbn.var.colors.olive, bbn.var.colors.pastelorange, bbn.var.colors.cyan, bbn.var.colors.green, bbn.var.colors.black, bbn.var.colors.white];
      }
    },
    /**
     * Set it to false if you want to hide the labels on the chart.
     * @prop {Boolean} [true] labels
     */
    labels: {
      type: Boolean,
      default: true
    },
    /**
     * Set it to false if you want to hide the x-axis labels on the chart.
     * @prop {Boolean} [true] xLabels
     */
    xLabels: {
      type: Boolean,
      default: true
    },
    /**
     * Set it to false if you want to hide the y-axis labels on the chart.
     * @prop {Boolean} [true] xLabels
     */
    yLabels: {
      type: Boolean,
      default: true
    },
    /**
     * The labela color.
     * @prop {String} labelsColor
     */
    labelsColor: {
      type: String
    },
    /**
     * The x-axis labels color.
     * @prop {String} xLabelsColor
     */
    xLabelsColor: {
      type: String
    },
    /**
     * The y-axis labels color.
     * @prop {String} yLabelsColor
     */
    yLabelsColor: {
      type: String
    },
    /**
     * Set a rotation angle for the x-axis.
     * @prop {Number} xLabelsRotate
     */
    xLabelsRotate: {
      type: Number
    },
    /**
     * Set a rotation angle for the y-axis.
     * @prop {Number} yLabelsRotate
     */
    yLabelsRotate: {
      type: Number
    },
    /**
     * A custom function for the labels value.
     * @prop {Function} labelsRender
     */
    labelsRender: {
      type: Function
    },
    /**
     * A custom function for the x-axis value.
     * @prop {Function} xLabelsRender
     */
    xLabelsRender: {
      type: Function
    },
    /**
     * A custom function for the y-axis value.
     * @prop {Function} yLabelsRender
     */
    yLabelsRender: {
      type: Function
    },
    /**
     * X offset of the pie chart's labels.
     * @prop {Number} [0] labelsOffsetX
     */
    labelsOffsetX: {
      type: Number,
      default: 0
    },
    /**
     * Y offset of the pie chart's labels.
     * @prop {Number} [0] labelsOffsetY
     */
    labelsOffsetY: {
      type: Number,
      default: 0
    },
    /**
     * X offset of the x-axis' labels.
     * @prop {Number} [0] xLabelsOffsetX
     */
    xLabelsOffsetX: {
      type: Number,
      default: 0
    },
    /**
     * Y offset of the x-axis' labels.
     * @prop {Number} [0] xLabelsOffsetY
     */
    xLabelsOffsetY: {
      type: Number,
      default: 0
    },
    /**
     * X offset of the y-axis' labels.
     * @prop {Number} [0] yLabelsOffsetX
     */
    yLabelsOffsetX: {
      type: Number,
      default: 0
    },
    /**
     * Y offset of the y-axis' labels.
     * @prop {Number} [0] yLabelsOffsetY
     */
    yLabelsOffsetY: {
      type: Number,
      default: 0
    },
    /**
     * The background color for personalization.
     * @prop {String} background
     */
    background: {
      type: String
    },
    /**
     * The max value limit.
     * @prop {Number} [undefined] max
     */
    max: {
      type: Number,
      default: undefined
    },
    /**
     * The min value limit.
     * @prop {Number} [undefined] min
     */
    min: {
      type: Number,
      default: undefined
    },
    /**
     * Set it to false if you want to hide the tooltip.
     * @prop {Boolean} [true] tooltip
     */
    tooltip: {
      type: Boolean,
      default: true
    },
    /**
     * Tooltip value customize.
     * @prop {Function} tooltipRender
     */
    tooltipRender: {
      type: Function
    },
    /**
     * Tooltip value customize.
     * @prop {Function} tooltipLegendRender
     */
    tooltipLegendRender: {
      type: Function
    },
    /**
     * X axis tooltip customize.
     * @prop {Function} xTooltipRender
     */
    xTooltipRender: {
      type: Function
    },
    /**
     * Y axis tooltip customize.
     * @prop {Function} yTooltipRender
     */
    yTooltipRender: {
      type: Function
    },
    /**
     * Z axis tooltip customize.
     * @prop {Function} zTooltipRender
     */
    zTooltipRender: {
      type: Function
    },
    /**
     * The legend list.
     * @prop {Boolean|Array} legend
     */
    legend: {
      type: [Boolean, Array]
    },
    /**
     * The legend position.
     * You can use 'top', 'bottom', 'left' or a 'right'.
     * @prop {String} ['bottom'] legendPosition
     */
    legendPosition: {
      type: String,
      default: 'bottom',
      validator: t => ['top', 'bottom', 'left', 'right'].includes(t)
    },
    /**
     * Legend customize.
     * @prop {Function} legendRender
     */
    legendRender: {
      type: Function
    },
    /**
     * Set it to true to see distributed series on the bar chart.
     * @prop {Boolean} [false] distributed
     */
    distributed: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if you want to transform the values to currencies.
     * @prop {Boolean} [false] currency
     */
    currency: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean|String} [false] xDate
     */
    xDate: {
      type: [Boolean, String],
      default: false
    },
    /**
     * The string used when the chart hasn't the data.
     * @prop {String} ['No Data'] nodata
     */
    nodata: {
      type: String,
      default: bbn._('No data')
    },
    /**
     * Set it to true if you want to see the odd values only.
     * @prop {Boolean} [false] odd
     */
    odd: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if you want to see the even values only.
     * @prop {Boolean} [false] even
     */
    even: {
      type: Boolean,
      default: false
    },
    /**
     * Shows only interger on the y-axis labels.
     * @prop {Boolean} [false] onlyInteger
     */
    onlyInteger: {
      type: Boolean,
      default: false
    },
    /**
     * The number of ticks on the y-axis.
     * @prop {String|Number} ticksNumber
     */
    ticksNumber: {
      type: [String, Number]
    },
    /**
     * Display or note the toolbar/menu in the top right corner.
     * @prop {Boolean} [true] toolbar
     */
    toolbar: {
      type: Boolean,
      default: true
    },
    /**
     * Show the download menu / hamburger icon in the toolbar.
     * If you want to display a custom icon instead of hamburger icon, you can provide HTML string in this property.
     * @prop {Boolean|String} [false] toolbarDownload
     */
    toolbarDownload: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Show the rectangle selection icon in the toolbar.
     * If you want to display a custom icon for selection, you can provide HTML string in this property.
     * @prop {Boolean|String} [true] toolbarSelection
     */
    toolbarSelection: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Show the zoom icon which is used for zooming by dragging selection on the chart area.
     * If you want to display a custom icon for zoom, you can provide HTML string in this property.
     * @prop {Boolean|String} [true] toolbarZoom
     */
    toolbarZoom: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Show the zoom-in icon which zooms in 50% from the visible chart area.
     * If you want to display a custom icon for zoom-in, you can provide HTML string in this property.
     * @prop {Boolean|String} [true] toolbarZoomin
     */
    toolbarZoomin: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Show the zoom-out icon which zooms out 50% from the visible chart area.
     * If you want to display a custom icon for zoom-out, you can provide HTML string in this property.
     * @prop {Boolean|String} [true] toolbarZoomout
     */
    toolbarZoomout: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Show the panning icon in the toolbar.
     * If you want to display a custom icon for span, you can provide HTML string in this property.
     * @prop {Boolean|String} [true] toolbarPan
     */
    toolbarPan: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Reset the chart data to its initial state after zommin/zoomout/panning.
     * If you want to display a custom icon for reset, you can provide HTML string in this property.
     * @prop {Boolean|String} [true] toolbarReset
     */
    toolbarReset: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Allows to add additional icon buttons in the toolbar.
     * In the below example, index should be used to place at a particular position in the toolbar.
     * [{
     *   icon: '<img src="/static/icons/chart-carpet.png" width="20">',
     *   index: 4,
     *   title: 'tooltip of the icon',
     *   class: 'custom-icon',
     *   click: function (chart, options, e) {
     *     console.log("clicked custom-icon")
     *   }
     * }]
     * @prop {Array} [[]] toolbarCustom
     */
    toolbarCustom: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Use this prop to give native widget's properties.
     * @prop {Object} [{}] cfg
     */
    cfg: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] container
       */
      container: false,
      /**
       * @data {Number} [0] containerHeight
       */
      containerHeight: 0,
      /**
       * @data {Number} [0] containerWidth
       */
      containerWidth: 0,
      /**
       * @data {Boolean} [false] ready
       */
      ready: false,
      /**
       * @data {Boolean} [false] isInit
       */
      isInit: false,
      /**
       * @data {Boolean} [false] widget
       */
      widget: false,
      /**
       * The random string
       * @data {String} ['random string'] id
       */
      id: bbn.fn.randomString()
    };
  },
  computed: {
    /**
     * This makes the widget's data from the source.
     * @computed data
     * @return {Array}
     */
    data() {
      let series = this.source.series,
        data = [];
      if (this.isLine || this.isBar || this.isArea) {
        if (bbn.fn.isArray(series) && series.length) {
          if (!bbn.fn.isArray(series[0])) {
            data.push({
              data: this.even || this.odd ? bbn.fn.filter(series, (v, k) => {
                k++;
                return this.even && k % 2 === 0 || this.odd && k % 2 > 0;
              }) : series
            });
          } else {
            bbn.fn.each(series, (s, i) => {
              if (bbn.fn.isObject(s)) {} else {
                data.push({
                  data: this.even || this.odd ? bbn.fn.filter(s, (v, k) => {
                    k++;
                    return this.even && k % 2 === 0 || this.odd && k % 2 > 0;
                  }) : s,
                  name: this.legend && this.legend.length ? this.legend[i] : false
                });
              }
            });
          }
        }
      } else if (this.isPie || this.isDonut || this.isRadial) {
        data = this.even || this.odd ? bbn.fn.filter(this.source.series, (v, k) => {
          k++;
          return this.even && k % 2 === 0 || this.odd && k % 2 > 0;
        }) : this.source.series;
      }
      return data;
    },
    /**
     * This checks the chart's type is 'line'.
     * @computed isLine
     * @return {Boolean}
     */
    isLine() {
      return this.type === 'line';
    },
    /**
     * This checks the chart's type is 'bar'.
     * @computed isBar
     * @return {Boolean}
     */
    isBar() {
      return this.type === 'bar';
    },
    /**
     * This checks the chart's type is 'pie'.
     * @computed isPie
     * @return {Boolean}
     */
    isPie() {
      return this.type === 'pie' && !this.donut;
    },
    /**
     * This checks the chart's type is 'donut'.
     * @computed isDonut
     * @return {Boolean}
     */
    isDonut() {
      return this.type === 'donut' || this.type === 'pie' && !!this.donut;
    },
    /**
     * This checks the chart's type is 'area'.
     * @computed isArea
     * @return {Boolean}
     */
    isArea() {
      return this.type === 'area';
    },
    /**
     * This checks the chart's type is 'radial'.
     * @computed isRadial
     * @return {Boolean}
     */
    isRadial() {
      return this.type === 'radial';
    },
    /**
     * Sets the color property to the correct form.
     * @computed colors
     * @return {Array}
     */
    colors() {
      let colors = [];
      if (typeof this.color === 'string') {
        colors = [this.color];
      }
      if (Array.isArray(this.color)) {
        colors = this.color;
      }
      return bbn.fn.map(colors, c => {
        if (c.indexOf('#') !== 0 || c.toLowerCase().indexOf('rgb') !== 0) {
          return bbn.fn.colorToHex(c);
        }
        return c;
      });
    },
    /**
     * Makes the base configuration object for the 'line' chart.
     * @computed lineCfg
     * @return {Object}
     */
    lineCfg() {
      let cfg = {};
      return this.isLine ? bbn.fn.extend(true, cfg, this.lineBarAreaCommon, this.lineAreaCommon) : {};
    },
    /**
     * Makes the base configuration object for the 'bar' chart.
     * @computed barCfg
     * @return {Object}
     */
    barCfg() {
      let cfg = {
        chart: {
          stacked: !!this.stacked
        },
        plotOptions: {
          bar: {
            horizontal: !!this.horizontal,
            distributed: this.distributed
          }
        }
      };
      if (this.barsDistance) {
        cfg.stroke = {
          show: true,
          width: this.barsDistance,
          colors: ['transparent']
        };
      }
      return this.isBar ? bbn.fn.extend(true, cfg, this.lineBarAreaCommon) : {};
    },
    /**
     * Makes the base configuration object for the 'area' chart.
     * @computed areaCfg
     * @return {Object}
     */
    areaCfg() {
      let cfg = {};
      return this.isArea ? bbn.fn.extend(true, cfg, this.lineAreaCommon) : {};
    },
    /**
     * Makes the base configuration object for the 'line' and 'area' chart.
     * @computed lineAreaCommon
     * @return {Object}
     */
    lineAreaCommon() {
      let cfg = {
        markers: {
          size: this.points || 0
        },
        stroke: {
          curve: !!this.smooth ? 'smooth' : !!this.step ? 'stepline' : 'straight'
        }
      };
      return this.isLine || this.isArea ? bbn.fn.extend(true, cfg, this.lineBarAreaCommon) : {};
    },
    /**
     * Makes a common configuration object for the 'line' and 'bar' charts.
     * @computed lineBarAreaCommon
     * @return {Object}
     */
    lineBarAreaCommon() {
      if (this.isLine || this.isBar || this.isArea) {
        let cfg = {
          xaxis: {
            labels: {
              show: !!this.labels && !!this.xLabels && this.data.length,
              style: {
                colors: this.xLabelsColor || this.labelsColor || [],
                cssClass: 'bbn-chart-xaxis-label'
              },
              offsetX: this.xLabelsOffsetX,
              offsetY: this.xLabelsOffsetY,
              showDuplicates: true
            },
            title: {
              text: this.xTitle,
              style: {
                cssClass: 'bbn-chart-xaxis-title'
              }
            }
          },
          yaxis: {
            labels: {
              show: !!this.labels && !!this.xLabels && this.data.length,
              style: {
                colors: this.yLabelsColor || this.labelsColor || [],
                cssClass: 'bbn-chart-yaxis-label'
              },
              offsetX: this.yLabelsOffsetX,
              offsetY: this.yLabelsOffsetY
            },
            title: {
              text: this.yTitle,
              style: {
                cssClass: 'bbn-chart-yaxis-title'
              }
            },
            min: this.min,
            max: this.max
          },
          grid: {
            show: !!this.grid && (!!this.xGrid || !!this.yGrid),
            xaxis: {
              lines: {
                show: !!this.xGrid
              }
            },
            yaxis: {
              lines: {
                show: !!this.yGrid
              }
            }
          }
        };
        if (this.xDate) {
          cfg.xaxis.type = 'datetime';
          if (bbn.fn.isString(this.xDate)) {
            cfg.xaxis.labels.formatter = (value, timestamp, index) => {
              return dayjs(timestamp).format(this.xDate);
            };
          }
        }
        if (this.onlyInteger) {
          cfg.yaxis.decimalsInFloat = 3;
        }
        if (this.ticksNumber) {
          cfg.yaxis.tickAmount = parseInt(this.ticksNumber);
        }
        if (this.gridColor) {
          cfg.grid.borderColor = this.gridColor;
        }
        if (this.gridBackground) {
          cfg.grid.row = {
            colors: [this.gridBackground]
          };
        }
        if (this.currency) {
          cfg.dataLabels = {
            formatter: (val, opts) => {
              return bbn.fn.money(val);
            }
          };
          if (this.tooltip) {
            cfg.tooltip = {
              y: {
                formatter: val => {
                  return bbn.fn.money(val);
                }
              }
            };
          }
        }
        if (this.xLabelsRotate) {
          cfg.xaxis.labels.rotate = this.xLabelsRotate;
          cfg.xaxis.labels.rotateAlways = true;
        }
        if (this.yLabelsRotate) {
          cfg.yaxis.labels.rotate = this.yLabelsRotate;
        }
        if (this.labelsRender || this.xLabelsRender) {
          cfg.xaxis.labels.formatter = this.xLabelsRender || this.labelsRender;
        }
        if (this.labelsRender || this.yLabelsRender) {
          cfg.yaxis.labels.formatter = this.yLabelsRender || this.labelsRender;
        }
        if (Object.keys(this.xAxis).length) {
          bbn.fn.extend(true, cfg.xaxis, this.xAxis);
        }
        if (Object.keys(this.yAxis).length) {
          bbn.fn.extend(true, cfg.yaxis, this.yAxis);
        }
        return cfg;
      }
      return {};
    },
    /**
     * Makes the base configuration object for the 'pie' chart.
     * @computed pieCfg
     * @return {Object}
     */
    pieCfg() {
      let cfg = {};
      return this.isPie ? bbn.fn.extend(true, cfg, this.pieDonutCommonCfg) : {};
    },
    /**
     * Makes the base configuration object for the 'donut' chart.
     * @computed donutCfg
     * @return {Object}
     */
    donutCfg() {
      let cfg = {
        chart: {
          type: 'donut'
        }
      };
      if (bbn.fn.isNumber(this.donut)) {
        cfg.plotOptions = {
          pie: {
            donut: {
              size: this.donut + '%'
            }
          }
        };
      }
      return this.isDonut ? bbn.fn.extend(true, cfg, this.pieDonutCommonCfg) : {};
    },
    /**
     * Makes a common configuration object for the 'pie' and 'donut' charts.
     * @computed pieDonutCommonCfg
     * @return {Object}
     */
    pieDonutCommonCfg() {
      if (this.container && (this.isPie || this.isDonut)) {
        let cfg = {
          legend: {
            show: !!this.legend
          },
          dataLabels: {
            enabled: !!this.labels && this.data.length
          }
        };
        if (this.labelsColor) {
          cfg.dataLabels.style = {
            colors: [this.labelsColor]
          };
        }
        if (this.currency) {
          cfg.dataLabels.formatter = (val, opts) => {
            return bbn.fn.money(opts.w.config.series[opts.seriesIndex]);
          };
          if (this.tooltip) {
            cfg.tooltip = {
              y: {
                formatter: val => {
                  return bbn.fn.money(val);
                }
              }
            };
          }
        }
        if (this.labelsRender) {
          cfg.dataLabels.formatter = this.labelsRender;
          /* if ( this.tooltip ){
            cfg.tooltip = {
              y: {
                formatter: this.labelsRender
              }
            };
          } */
        }

        if (this.labelsOffsetX) {
          cfg.dataLabels.offsetX = this.labelsOffsetX;
        }
        if (this.labelsOffsetY) {
          cfg.dataLabels.offsetY = this.labelsOffsetY;
        }
        if (this.containerHeight && this.containerWidth && this.width === '100%' && this.height === '100%') {
          cfg.chart = {};
          if (this.containerWidth < this.containerHeight) {
            cfg.chart.width = this.containerWidth;
            //cfg.chart.height ='100%';
            cfg.chart.height = this.containerWidth;
          } else {
            cfg.chart.width = '100%';
            //cfg.chart.width = this.containerHeight;
            cfg.chart.height = this.containerHeight;
          }
        }
        return cfg;
      }
      return {};
    },
    /**
     * Makes the base configuration object for the 'pie' chart.
     * @computed radialCfg
     * @fires isRadial
     * @return {Object}
     */
    radialCfg() {
      let cfg = {
        chart: {
          type: 'radialBar'
        },
        plotOptions: {
          radialBar: {
            dataLabels: {
              total: {
                show: true,
                label: bbn._('TOTAL')
              }
            }
          }
        }
      };
      return this.isRadial ? cfg : {};
    },
    /**
     * Makes the configuration object for the widget.
     * @computed widgetCfg
     * @fires getLabels
     * @return {Object}
     */
    widgetCfg() {
      let cfg = {
        chart: {
          id: this.id,
          type: this.type,
          height: this.height,
          width: this.width,
          animations: {
            enabled: !!this.animation,
            speed: bbn.fn.isNumber ? this.animation : 800,
            easing: 'easeinout',
            animateGradually: {
              enabled: true,
              delay: 250
            },
            dynamicAnimation: {
              enabled: true,
              speed: 350
            }
          },
          toolbar: {
            show: this.toolbar,
            tools: {
              download: this.toolbarDownload,
              selection: this.toolbarSelection,
              zoom: this.toolbarZoom,
              zoomin: this.toolbarZoomin,
              zoomout: this.toolbarZoomout,
              pan: this.toolbarPan,
              reset: this.toolbarReset,
              customIcons: this.toolbarCustom
            }
          },
          defaultLocale: 'en',
          locales: [{
            name: 'en',
            options: {
              months: [bbn._('January'), bbn._('February'), bbn._('March'), bbn._('April'), bbn._('May'), bbn._('June'), bbn._('July'), bbn._('August'), bbn._('September'), bbn._('October'), bbn._('November'), bbn._('December')],
              shortMonths: [bbn._('Jan'), bbn._('Feb'), bbn._('Mar'), bbn._('Apr'), bbn._('May'), bbn._('Jun'), bbn._('Jul'), bbn._('Aug'), bbn._('Sep'), bbn._('Oct'), bbn._('Nov'), bbn._('Dec')],
              days: [bbn._('Sunday'), bbn._('Monday'), bbn._('Tuesday'), bbn._('Wednesday'), bbn._('Thursday'), bbn._('Friday'), bbn._('Saturday')],
              shortDays: [bbn._('Sun'), bbn._('Mon'), bbn._('Tue'), bbn._('Wed'), bbn._('Thu'), bbn._('Fri'), bbn._('Sat')],
              toolbar: {
                download: bbn._('Download SVG'),
                selection: bbn._('Selection'),
                selectionZoom: bbn._('Selection Zoom'),
                zoomIn: bbn._('Zoom In'),
                zoomOut: bbn._('Zoom Out'),
                pan: bbn._('Panning'),
                reset: bbn._('Reset Zoom')
              }
            }
          }],
          events: {
            click: (event, chartContext, config) => {
              this.$emit('click', event, chartContext, config);
            }
          }
        },
        series: this.data,
        labels: this.getLabels(),
        legend: {
          show: this.legend && this.legend.length,
          position: this.legendPosition,
          itemMargin: {
            horizontal: 5,
            vertical: 5
          },
          formatter: this.legendRender || undefined
        },
        dataLabels: {
          enabled: !!this.pointsLabels
        },
        tooltip: {
          enabled: !!this.tooltip,
          x: {
            formatter: this.xTooltipRender || undefined
          },
          y: {
            formatter: this.yTooltipRender || this.tooltipRender || undefined,
            title: {
              formatter: this.tooltipLegendRender || undefined
            }
          },
          z: {
            formatter: this.zTooltipRender || undefined
          }
        },
        colors: this.colors.length ? this.colors : undefined,
        fill: {
          type: this.fill,
          opacity: this.opacity
        },
        theme: {
          mode: this.theme
        },
        noData: {
          text: this.nodata
        }
      };
      if (this.background) {
        cfg.chart.background = this.background;
      }
      if (this.opacity && this.fill === 'gradient') {
        cfg.fill.gradient = {
          shadeIntensity: 1,
          opacityFrom: this.opacity,
          opacityTo: 1
        };
      }
      if (this.legendPosition === 'bottom') {
        cfg.legend.offsetY = -5;
      }
      if (this.isLine) {
        bbn.fn.extend(true, cfg, this.lineCfg, this.cfg);
      } else if (this.isBar) {
        bbn.fn.extend(true, cfg, this.barCfg, this.cfg);
      } else if (this.isPie) {
        bbn.fn.extend(true, cfg, this.pieCfg, this.cfg);
      } else if (this.isDonut) {
        bbn.fn.extend(true, cfg, this.donutCfg, this.cfg);
      } else if (this.isRadial) {
        bbn.fn.extend(true, cfg, this.radialCfg, this.cfg);
      } else if (this.isArea) {
        bbn.fn.extend(true, cfg, this.areaCfg, this.cfg);
      }
      return cfg;
    }
  },
  methods: {
    /**
     * Destroys the current widget if it exists and fires the chart type constructor.
     * @method init
     * @param {Boolean} emptyData
     * @fires destroy
     * @fires setSize
     * @fires getRef
     */
    init(emptyData) {
      this.destroy();
      this.setSizes();
      this.$nextTick(() => {
        if (!this.widget) {
          let cfg = bbn.fn.extend(true, {}, this.widgetCfg);
          if (emptyData) {
            cfg.series = [];
            cfg.labels = [];
          }
          this.widget = new window.ApexCharts(this.getRef('chart'), cfg);
          this.widget.render();
          this.isInit = true;
        }
      });
    },
    /**
     * Destroys the component chart.
     *  
     * @method destroy
     */
    destroy() {
      if (this.widget && this.ready) {
        this.widget.destroy();
        this.widget = false;
      }
    },
    /**
     * Set the dimensions, in height and width.
     *
     * @method setSizes
     */
    setSizes() {
      this.containerHeight = this.container.offsetHeight;
      this.containerWidth = this.container.offsetWidth;
    },
    /**
     * Re-adjust the dimensions, in height and width.
     *
     * @method onResize
     * @fires setSizes
     */
    onResize() {
      if (this.ready) {
        this.$nextTick(() => {
          this.setSizes();
          if (this.widget) {
            //this.updateWidget();
          }
        });
      }
    },
    /**
     * Update chart.
     *
     * @method updateWidget
     * @param {Object} cfg
     */
    updateWidget(cfg) {
      if (this.widget && this.ready) {
        this.widget.updateOptions(bbn.fn.extend(true, {}, cfg || this.widgetCfg), !!this.isBar, !!this.animation);
      }
    },
    /**
     * Return list labels.
     *
     * @method getLabels
     * @return {Array}
     */
    getLabels() {
      return this.data && this.data.length ? this.source.labels ? this.even || this.odd ? bbn.fn.filter(this.source.labels, (v, k) => {
        k++;
        return this.even && k % 2 === 0 || this.odd && k % 2 > 0;
      }) : this.source.labels : [] : [];
    }
  },
  watch: {
    /**
     * @watch ready
     * @fires init
     */
    ready(newVal) {
      this.$nextTick(() => {
        if (newVal) {
          this.init();
        }
      });
    },
    /**
     * @watch widgetCfg
     * @fires init
     * @fires updateWidget
     */
    widgetCfg: {
      deep: true,
      handler(newVal, oldVal) {
        if (this.ready && this.isInit) {
          if (newVal.chart.type !== oldVal.chart.type) {
            this.isInit = false;
            this.init(true);
          } else {
            this.updateWidget();
          }
        }
      }
    }
  },
  /**
   * @event mounted
   * @fires init
   * @fires getRef
   */
  mounted() {
    this.container = this.getRef('container');
    this.$nextTick(() => {
      this.ready = true;
    });
  }
};
import cpHtml from './chart.html';
import cpStyle from './chart.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./chart.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
const def = {
  name: 'bbn-chart',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
export { ApexCharts, def as default };
/**
 * @file bbn-chat component
 * @description bbn-chat component allows the user to communicate in chat sessions with other users online.
 * @author Thomas Nabet, Mirko Argentino
 * @copyright BBN Solutions
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.serviceWorker
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage, bbn.cp.mixins.resizer, bbn.cp.mixins.serviceWorker],
  props: {
    /**
     * The id of the current user
     * @prop {String} userId
     */
    userId: {
      type: String
    },
    /**
     * The array of all users.
     * @prop {Array} [[]] users
     */
    users: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The array of groups.
     * @prop {Array} [[]] groups
     * @todo not used yet
     */
    groups: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The array of users currently online.
     * @prop {Array} [[]] onlineUsers
     */
    onlineUsers: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * True if the current user is online.
     * @prop {Boolean} [true] online
     */
    online: {
      type: Boolean,
      default: true
    },
    /**
     * The url used for the actions of the chat.
     * @prop {String} url
     */
    url: {
      type: String
    }
  },
  data() {
    let isDark = false;
    if (appui && appui.theme && appui.themes) {
      isDark = bbn.fn.getField(appui.themes, 'isDark', {
        value: appui.theme
      });
    }
    return {
      /**
       * True if the current user is online.
       * @data {Boolean} currentOnline
       */
      currentOnline: this.online,
      /**
       * True if the main window is visibile.
       * @data {Boolean} [false] mainWindowVisible
       */
      mainWindowVisible: false,
      /**
       * The last chat time.
       * @data {Number} [null] lastChat
       */
      lastChat: null,
      /**
       * The current chats.
       * @data {Array} [[]] currentChats
       */
      currentChats: [],
      /**
       * The current chats hash.
       * @data {String} [null] chatHash
       */
      chatsHash: null,
      /**
       * The current users hash.
       * @data {String} [null] onlineUsersHash
       */
      onlineUsersHash: null,
      /**
       * Indicates if we have received the first response with the users hash
       * @data {Boolean} [false] usersReceived
       */
      usersReceived: false,
      /**
       * Indicates if we have received the first response with the chats hash
       * @data {Boolean} [false] chatsReceived
       */
      chatsReceived: false,
      /**
       * The chat coordinates.
       * @data {String} [''] bottomCoord
       */
      bottomCoord: '',
      /**
       * Indicates if a dark theme is used
       * @data {Boolean} isDarkTheme
       */
      isDarkTheme: isDark
    };
  },
  computed: {
    /**
     * The array of online users excluding the current user.
     * @computed usersOnlineWithoutMe
     * @return {Array}
     */
    usersOnlineWithoutMe() {
      return this.onlineUsers.filter(a => {
        return a !== this.userId;
      }).map(a => {
        return bbn.fn.isObject(a) ? a : {
          value: a
        };
      });
    },
    /**
     * The array of visible windows
     * @computed visibleWindows
     * @return {Array}
     */
    visibleWindows() {
      return this.currentChats.filter(c => c.visible);
    },
    /**
     * The main menu
     * @computed mainMenu
     * @returns {Array}
     */
    mainMenu() {
      let res = [];
      if (this.currentOnline) {
        res.push({
          icon: 'nf nf-oct-organization',
          text: bbn._('New group chat'),
          action: () => {
            this.getPopup({
              title: bbn._('New group chat'),
              component: this.$options.components.newGroup,
              width: 300,
              height: 400
            });
          }
        });
      }
      res.push({
        icon: this.currentOnline ? 'nf nf-mdi-message_bulleted_off bbn-red' : 'nf nf-mdi-message bbn-green',
        text: this.currentOnline ? bbn._('Switch offline') : bbn._('Switch online'),
        action: this.currentOnline ? this.switchOffline : this.switchOnline
      });
      return res;
    },
    /**
     * The users list ordered by name
     * @computed allUSers
     * @returns {Array}
     */
    allUsers() {
      if (this.users && this.users.length) {
        return bbn.fn.order(this.users.filter(u => u.value !== this.userId), 'text', 'ASC');
      }
      return [];
    },
    /**
     * The list of the users without chats
     * @computed allUsersWithoutChats
     * @returns {Array}
     */
    allUsersWithoutChats() {
      let res = [];
      res = res.concat(this.allUsers.filter(u => this.onlineUsers.includes(u.value) && !Object.values(this.currentChats).filter(c => c.participants.length === 1 && c.participants.includes(u.value)).length));
      res = res.concat(this.allUsers.filter(u => !this.onlineUsers.includes(u.value) && !Object.values(this.currentChats).filter(c => c.participants.length === 1 && c.participants.includes(u.value)).length));
      return res;
    },
    /**
     * Indicates if the first response with the chats hash and the users hash
     * @computed isReady
     * @return {Boolean}
     */
    isReady() {
      return this.chatsReceived && this.usersReceived;
    }
  },
  methods: {
    /**
     * Alias of bbn.fn.getField
     * @method getField
     */
    getField: bbn.fn.getField,
    /**
     * Alias of bbn.fn.shorten
     * @method shorten
     */
    shorten: bbn.fn.shorten,
    /**
     * Returns the chat object basing on the given id property.
     * @method chatById
     * @param {String} idChat
     * @return {Boolean|Object}
     */
    chatById(idChat) {
      return bbn.fn.getRow(this.currentChats, {
        id: idChat
      });
    },
    /**
     * Returns the chat object basing on the given idx property.
     * @method chatByIdx
     * @param {Number} idx
     * @return {Boolean|Object}
     */
    chatByIdx(idx) {
      return bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
    },
    /**
     * Returns the chat object basing on the given idTemp property.
     * @method chatByIdTemp
     * @param {String} idTemp
     * @return {Boolean|Object}
     */
    chatByIdTemp(idTemp) {
      return bbn.fn.getRow(this.currentChats, {
        idTemp: idTemp
      });
    },
    /**
     * Returns the chat window component basing on the given idx property
     * @method chatWindowByIdx
     * @param {Number} idx
     * @fires findByKey
     * @return {bbnCp|Boolean}
     */
    chatWindowByIdx(idx) {
      return this.findByKey(idx, 'chat');
    },
    /**
     * Opens the chat window by the given user id
     * @method chatTo
     * @param {String} idUser
     * @fires maximaze
     * @fires addChat
     * @fires messageToChannel
     * @fires activate
     */
    chatTo(idUser) {
      let chat = this.currentChats.filter(c => c.participants.length === 1 && c.participants.includes(idUser));
      if (chat.length) {
        this.maximaze(chat[0].idx);
        return;
      }
      if (this.currentOnline) {
        let chatObj = {
          id: '',
          idTemp: bbn.fn.randomString(24, 24),
          info: {
            title: '',
            creator: this.userId
          },
          participants: [idUser],
          partecipantsActivity: {
            [idUser]: 0
          },
          admins: [this.userId],
          messages: [],
          visible: true,
          minimized: false,
          active: false,
          unread: 0
        };
        this.messageToChannel({
          function: 'addChat',
          params: [bbn.fn.extend(true, {}, chatObj, {
            visible: false
          })]
        });
        this.activate(this.addChat(chatObj));
      }
    },
    /**
     * @method addChat
     * @param {Object} chatObj
     * @returns {Number}
     */
    addChat(chatObj) {
      let idx = chatObj.idx !== undefined ? chatObj.idx : this.getNewIdx();
      chatObj.idx = idx;
      this.currentChats.push(chatObj);
      return idx;
    },
    /**
     * @method receive
     * @param {Object} data
     * @fires chatById
     * @fires chatWindowByIdx
     * @fires minimize
     * @fires getNewIdx
     * @fires addChat
     */
    receive(data) {
      //bbn.fn.log("RECEIVING THIS FOR CHAT", data);
      // Online status
      if ('online' in data) {
        if (data.online) {
          this.currentOnline = true;
        } else {
          bbn.fn.each(this.currentChats, c => {
            c.visible = false;
            c.minimized = false;
          });
          this.currentOnline = false;
        }
      }
      // Users
      if (data.users && data.users.hash) {
        if (this.onlineUsersHash !== data.users.hash) {
          this.onlineUsersHash = data.users.hash;
          this.onlineUsers.splice(0, this.onlineUsers.length);
          if (data.users.list) {
            this.onlineUsers.push(...data.users.list);
          }
        }
        this.usersReceived = true;
      }
      // Chats
      if (data.chats) {
        let isStarted = !!this.lastChat,
          chats = Object.values(data.chats.list),
          chatsIds = Object.keys(data.chats.list);
        this.chatsReceived = true;
        if ('hash' in data.chats) {
          this.chatsHash = data.chats.hash;
        }
        // All list
        if (!isStarted && !this.currentChats.length) {
          bbn.fn.each(chats, c => {
            let unread = c.messages ? c.messages.filter(m => m.unread).length : 0,
              current = bbn.fn.getRow(this.currentChats, {
                id: c.info.id
              });
            if (current) {
              c.minimized = !current.active && !!unread;
              c.unread = unread;
              c.participantsActivity = this._participantsActivity(c.participants);
              c.participants = bbn.fn.map(c.participants, p => p.id);
              bbn.fn.iterate(c, (v, p) => {
                this.$set(current, p, v);
              });
            } else {
              this.addChat(bbn.fn.extend(true, {}, c, {
                id: c.info.id,
                idx: this.getNewIdx(),
                visible: false,
                minimized: !!unread,
                active: false,
                unread: unread,
                participants: bbn.fn.map(c.participants, p => p.id),
                participantsActivity: this._participantsActivity(c.participants)
              }));
            }
          });
        }
        // Only new
        else {
          bbn.fn.each(this.currentChats, (c, i) => {
            if (!chatsIds.includes(c.id) && !c.idTemp) {
              this.currentChats.splice(i, 1);
            }
          });
          bbn.fn.iterate(data.chats.list, (c, idChat) => {
            let chat = this.chatById(idChat);
            if (chat) {
              if (c.info) {
                this.$set(chat, 'info', c.info);
              }
              if (c.messages) {
                if (chat.messages === undefined) {
                  this.$set(chat, 'messages', []);
                }
                if (c.messages.length) {
                  chat.messages.push(...c.messages);
                  chat.unread += c.messages ? c.messages.filter(m => m.unread).length : 0;
                  if (chat.visible) {
                    let cont = this.chatWindowByIdx(chat.idx);
                    if (cont) {
                      cont.scrollEnd();
                    }
                  } else if (this.currentOnline) {
                    this.minimize(chat.idx);
                  }
                }
              }
              if (c.participants) {
                let parts = bbn.fn.map(c.participants, p => p.id);
                if (!bbn.fn.isSame(parts, chat.participants)) {
                  chat.participants.splice(0);
                  chat.participants.push(...parts);
                }
                this.$set(chat, 'participantsActivity', this._participantsActivity(c.participants));
              }
              if (c.admins && !bbn.fn.isSame(c.admins, chat.admins)) {
                chat.admins.splice(0);
                chat.admins.push(...c.admins);
              }
            } else {
              let idx = this.getNewIdx(),
                visible = c.info.creator && this.userId === c.info.creator,
                mess = '';
              if (c.participants.length === 1) {
                bbn.fn.each(this.currentChats, (cc, ci) => {
                  if (cc.idTemp !== undefined && cc.idTemp !== '' && cc.participants.length === 1 && cc.participants.includes(c.participants[0].id)) {
                    let cw = this.chatWindowByIdx(cc.idx);
                    if (bbn.cp.isComponent(cw)) {
                      mess = cw.currentMessage;
                      visible = true;
                    }
                    this.currentChats.splice(ci, 1);
                    return;
                  }
                });
              }
              this.addChat(bbn.fn.extend(true, {}, c, {
                id: idChat,
                idx: idx,
                visible: visible,
                minimized: false,
                active: false,
                unread: c.messages ? c.messages.filter(m => m.unread).length : 0,
                participants: bbn.fn.map(c.participants, p => p.id),
                participantsActivity: this._participantsActivity(c.participants)
              }));
              if (this.currentOnline && !visible) {
                this.minimize(idx);
              }
              if (mess.length) {
                this.$nextTick(() => {
                  let cw = this.chatWindowByIdx(idx);
                  if (bbn.cp.isComponent(cw)) {
                    this.$set(cw, 'currentMessage', mess);
                  }
                });
              }
            }
          });
        }
      }
      // lastChat
      if ('last' in data) {
        this.lastChat = data.last;
      }
      // New messages
      if (data.messages) {
        bbn.fn.iterate(data.messages, (messages, idChat) => {
          let chat = this.chatById(idChat);
          if (chat) {
            if (chat.messages === undefined) {
              this.$set(chat, 'messages', []);
            }
            if (messages.length) {
              chat.messages.push(...messages);
              chat.unread += messages.filter(m => m.unread).length;
              if (chat.visible) {
                let cont = this.chatWindowByIdx(chat.idx);
                if (cont) {
                  cont.scrollEnd();
                }
                if (chat.active) {
                  this.activate(chat.idx);
                }
              } else if (this.currentOnline) {
                this.minimize(chat.idx);
              }
            }
          }
        });
      }
    },
    /**
     * @method getNewIdx
     * @returns {Number}
     */
    getNewIdx() {
      let max = -1;
      bbn.fn.each(this.currentChats, c => {
        if (c.idx > max) {
          max = c.idx;
        }
      });
      return max + 1;
    },
    /**
     * @method setIdByTemp
     * @param {String} idTemp
     * @param {String} id
     */
    setIdByTemp(idTemp, id) {
      let c = bbn.fn.getRow(this.currentChats, {
        idTemp: idTemp
      });
      if (c) {
        this.$set(c, 'id', id);
        this.$set(c, 'idTemp', '');
      }
    },
    /**
     * @method removeChatByTemp
     * @param {String} idTemp
     */
    removeChatByTemp(idTemp) {
      let idx = bbn.fn.search(this.currentChats, {
        idTemp: idTemp
      });
      if (idx > -1) {
        this.currentChats.splice(idx, 1);
      }
    },
    /**
     * Switch the current user online.
     * @method switchOnline
     * @fires post
     * @fires alert
     */
    switchOnline() {
      this.post(this.url + '/actions/user/online', d => {
        if (!d.success) {
          this.alert(bbn._('You are already online'));
        }
      });
    },
    /**
     * Switch the current user offline.
     * @method switchOffline
     * @fires post
     * @fires alert
     */
    switchOffline() {
      this.post(this.url + '/actions/user/offline', d => {
        if (!d.success) {
          this.alert(bbn._('You are already offline'));
        }
      });
    },
    /**
     * Checks if the given user is online.
     * @method isOnline
     * @param {String} idUser
     * @returns {Boolean}
     */
    isOnline(idUser) {
      return this.onlineUsers.includes(idUser);
    },
    /**
     * Gets the participants list (full object) from an array of ids
     * @method getParticipants
     * @param {Array} participants
     * @returns {Array}
     */
    getParticipants(participants) {
      if (bbn.fn.isArray(participants)) {
        return participants.filter(p => p !== this.userId).map(p => bbn.fn.getRow(this.allUsers, 'value', p));
      }
      return [];
    },
    /**
     * Gets the formatted list of participants
     * @method getParticipantsFormatted
     * @param {Array}
     * @param {String} [', '] separator
     * @returns {String}
     */
    getParticipantsFormatted(participants) {
      let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ', ';
      if (bbn.fn.isArray(participants) && participants.length) {
        if (bbn.fn.isObject(participants[0])) {
          return participants.map(p => p.text).join(separator);
        } else {
          return this.getParticipantsFormatted(this.getParticipants(participants), separator);
        }
      }
      return '';
    },
    /**
     * The method called on chat selection.
     * @method onSelectChat
     * @param {Object} data
     * @param {Number} idx
     * @param {Number} index
     * @param {Event} ev
     * @fires chatById
     * @fires maximaze
     */
    onSelectChat(data, idx, index, ev) {
      ev.preventDefault();
      let chat = this.chatById(data.id);
      if (chat && this.isReady) {
        this.maximaze(chat.idx);
      }
    },
    /**
     * The method called on user selection.
     * @method onSelectUser
     * @param {Object} data
     * @param {Number} idx
     * @param {Number} index
     * @param {Event} ev
     * @fires chatTo
     */
    onSelectUser(data, idx, index, ev) {
      ev.preventDefault();
      if (this.isReady) {
        this.chatTo(data.value);
      }
    },
    /**
     * Closes the given chat window.
     * @method close
     * @param {Number} idx
     */
    close(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        this.$set(chat, 'visible', false);
      }
    },
    /**
     * Minimizes the given chat window.
     * @method minimize
     * @param {Number} idx
     * @fires close
     */
    minimize(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        this.$set(chat, 'minimized', true);
        this.close(idx);
      }
    },
    /**
     * Maximazes the given chat window.
     * @method maximaze
     * @param {Number} idx
     */
    maximaze(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        this.$set(chat, 'minimized', false);
        this.$set(chat, 'visible', true);
      }
    },
    /**
     * Toggle minimized to the given chat window.
     * @method toggleMinimized
     * @fires minimize
     * @fires maximaze
     */
    toggleMinimized(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        if (chat.minimized) {
          this.maximaze(idx);
        } else {
          this.minimize(idx);
        }
      }
    },
    /**
     * Activates the given chat window
     * @method activate
     * @param {Number} idx
     * @fires setLastActivity
     * @fires removeUnread
     * @fires messageToChannel
     */
    activate(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        this.$set(chat, 'active', true);
        if (chat.id) {
          this.setLastActivity(chat.id, this.userId);
        }
        setTimeout(() => {
          this.removeUnread(idx);
        }, 2000);
        this.messageToChannel({
          function: 'removeUnread',
          params: [idx]
        });
      }
    },
    /**
     * Removes unread tag from messages and from chat
     * @method removeUnread
     * @param {Number} idx
     */
    removeUnread(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        if (chat.unread) {
          this.$set(chat, 'unread', 0);
        }
        if (!!chat.messages && chat.messages.length) {
          for (let i = chat.messages.length - 1; i > -1; i--) {
            if (chat.messages[i].user !== this.userId && chat.messages[i].unread !== undefined) {
              if (!chat.messages[i].unread) {
                break;
              }
              this.$set(chat.messages[i], 'unread', false);
            }
          }
        }
      }
    },
    /**
     * Deactivates the given chat window
     * @method deactivate
     * @param {Number} idx
     * @fires setLastActivity
     */
    deactivate(idx) {
      let chat = bbn.fn.getRow(this.currentChats, {
        idx: idx
      });
      if (chat) {
        this.$set(chat, 'active', false);
        if (chat.id) {
          this.setLastActivity(chat.id, this.userId);
        }
      }
    },
    /**
     * Sets the last activity of the given user on the given chat
     * @method setLastActivity
     * @param {String} idChat
     * @param {String} idUser
     * @fires post
     */
    setLastActivity(idChat, idUser) {
      if (idChat && idUser && this.currentOnline) {
        this.post(this.url + '/actions/chat/activity', {
          id_chat: idChat,
          id_user: idUser
        });
      }
    },
    /**
     * Trasforms the array of participants activity to an object "idParticipant: lastActivity"
     * @method _participantsActivity
     * @param {Array} list
     * @return {Object}
     */
    _participantsActivity(list) {
      let res = {};
      bbn.fn.each(list, l => res[l.id] = l.lastActivity);
      return res;
    },
    /**
     * Sets the bottom coordinates of the main window
     * @method _setCoord
     */
    _setCoord() {
      let coord = this.$el.offsetParent.getBoundingClientRect();
      this.bottomCoord = `${coord.bottom - coord.top}px`;
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    this.$nextTick(() => {
      this._setCoord();
      this.ready = true;
    });
  },
  watch: {
    /**
     * @watch mainWindowVisible
     * @fires _setCoord
     */
    mainWindowVisible: {
      immediate: true,
      handler(newVal) {
        if (newVal) {
          this._setCoord();
        }
      }
    }
  },
  components: {
    /**
     * The chat window.
     * @component chat
     */
    chat: {
      name: 'chat',
      /**
       * @mixin bbn.cp.mixins.basic
       * @memberof chat
       */
      mixins: [bbn.cp.mixins.basic],
      props: {
        /**
         * @prop {Number} idx
         * @memberof chat
         */
        idx: {
          type: Number
        },
        /**
         * The user id.
         * @prop {String} [''] userId
         * @memberof chat
         */
        userId: {
          type: String,
          default: ''
        },
        /**
         * The id of the current chat.
         * @prop {String} [''] chatId
         * @memberof chat
         */
        chatId: {
          type: String,
          default: ''
        },
        /**
         * The array of partecipants to the chat.
         * @prop {Array} [[]] partecipants
         * @memberof chat
         */
        participants: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * Partecipants activity details
         * @prop {Object} [{}] partecipantsActivity
         * @memberof chat
         */
        participantsActivity: {
          type: Object,
          default() {
            return {};
          }
        },
        /**
         * The array of the admins of the chat.
         * @prop {Array} [[]] admins
         * @memberof chat
         */
        admins: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * The array of all messages of the chat.
         * @prop {Array} [[]] messages
         * @memberof chat
         */
        messages: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * The array of all users (including offline ones).
         * @prop {Array} [[]] users
         * @memberof chat
         */
        users: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * The conversation's info
         * @prop {Object} [{title: ''}] info
         * @memberof chat
         */
        info: {
          type: Object,
          default() {
            return {
              title: ''
            };
          }
        },
        /**
         * A temporary id used for a new chat
         * @prop {String} [''] idTemp
         * @memberof chat
         */
        idTemp: {
          type: String,
          default: ''
        },
        /**
         * Indicates if the chat is active
         * @prop {Boolean} [false] active
         * @memberof chat
         */
        active: {
          type: Boolean,
          default: false
        },
        /**
         * The number of unread message
         * @prop {Number} [0] unread
         * @memberof chat
         */
        unread: {
          type: Number,
          default: 0
        }
      },
      data() {
        return {
          /**
           * The current message.
           * @data {String} [''] currentMessage
           * @memberof chat
           */
          currentMessage: '',
          /**
           * The main bbn-chat component
           * @data {bbnCp} chat
           * @memberof chat
           */
          cp: cp,
          /**
           * Indicates if a loading is in progress
           * @data {Boolean} [false] isLoading
           * @memberof chat
           */
          isLoading: false,
          /**
           * Indicates if to show or not the chat configuration panel
           * @data {Boolean} [false] showInfo
           * @memberof chat
           */
          showInfo: false,
          /**
           * Indicates whether a message is being sent
           * @data {Boolean} isSending
           * @memberof chat
           */
          isSending: false,
          /**
           * The background color used for the received messages
           * @data {String} [''] receivedBackground
           * @memberof chat
           */
          receivedBackground: ''
        };
      },
      computed: {
        /**
         * True if the chat is a group
         * @computed isGroup
         * @memberof chat
         * @return {Boolean}
         */
        isGroup() {
          return this.participants.length > 1 || this.info.title;
        },
        /**
         * The current chat title
         * @coputed currentTitle
         * @memberof chat
         * @fires cp.getParticipantsFormatted
         * @return {String}
         */
        currentTitle() {
          return this.info.title || this.cp.getParticipantsFormatted(this.participants);
        },
        /**
         * The list of the online participants
         * @computed online
         * @memberof chat
         * @fires cp.isOnline
         * @return {Array}
         */
        online() {
          return this.participants.filter(p => this.cp.isOnline(p));
        },
        /**
         * The formatted list of the online participants
         * @computed onlineFromatted
         * @memberof chat
         * @fires cp.getParticipantsFormatted
         * @return {String}
         */
        onlineFormatted() {
          return this.online.length ? bbn._('Online participants') + ':\n' + this.cp.getParticipantsFormatted(this.online, '\n') : '';
        }
      },
      methods: {
        /**
         * Alias of bbn.fn.getField method
         * @method getField
         * @memberof chat
         */
        getField: bbn.fn.getField,
        /**
         * Returns the source of the menu.
         * @method getMenuFn
         * @memberof chat
         * @fires confirm
         * @fires leave
         * @fires destroy
         * @return {Array}
         */
        getMenu() {
          let res = [];
          if (this.cp.currentOnline) {
            res.push({
              text: bbn._('Info'),
              icon: 'nf nf-fa-info',
              action: () => {
                this.showInfo = true;
              }
            });
            res.push({
              text: bbn._('Leave the chat'),
              icon: 'nf nf-mdi-comment_remove',
              action: () => {
                this.confirm(bbn._('Are you sure you want to leave this chat?'), () => {
                  this.leave();
                });
              }
            });
            if (this.info.creator === this.userId) {
              res.push({
                text: bbn._('Destroy the chat'),
                icon: 'nf nf-fa-trash',
                action: () => {
                  this.confirm(bbn._('Are you sure you want to destroy this chat?'), () => {
                    this.destroy();
                  });
                }
              });
            }
          }
          return res;
        },
        /**
         * Closes the chat window.
         * @method close
         * @memberof chat
         * @fires cp.close
         */
        close() {
          if (this.idTemp && !this.chatId && !this.messages.length) {
            return this.destroy();
          }
          this.cp.close(this.idx);
        },
        /**
         * Minimizes the chat window.
         * @method minimize
         * @memberof chat
         * @fires cp.minimize
         */
        minimize() {
          this.cp.minimize(this.idx);
        },
        /**
         * Leaves the chat.
         * @method leave
         * @memberof chat
         * @fires post
         * @fires alert
         */
        leave() {
          if (this.chatId) {
            this.post(this.cp.url + '/actions/chat/leave', {
              id_chat: this.chatId
            }, d => {
              if (!d.success) {
                this.alert(bbn._("Impossible to leave the chat!"));
              }
            });
          } else if (this.idTemp) {
            this.cp.currentChats.splice(bbn.fn.search(this.cp.currentChats, {
              idx: this.idx
            }), 1);
          }
        },
        /**
         * Destroys the chat.
         * @method destroy
         * @memberof chat
         * @fires post
         * @fires alert
         */
        destroy() {
          if (this.chatId) {
            this.post(this.cp.url + '/actions/chat/destroy', {
              id_chat: this.chatId
            }, d => {
              if (!d.success) {
                this.alert(bbn._("Impossible to destroy the chat!"));
              }
            });
          } else if (this.idTemp) {
            this.cp.currentChats.splice(bbn.fn.search(this.cp.currentChats, {
              idx: this.idx
            }), 1);
            this.cp.messageToChannel({
              function: 'removeChatByTemp',
              params: [this.idTemp]
            });
          }
        },
        /**
         * Sends the current message.
         * @method sendMessage
         * @memberof chat
         * @fires post
         */
        sendMessage() {
          if (this.currentMessage) {
            this.isSending = true;
            this.post(this.cp.url + '/actions/message/new', {
              id_chat: this.chatId || null,
              id_temp: this.idTemp || null,
              users: this.participants,
              text: this.currentMessage
            }, d => {
              if (d.success) {
                if (this.idTemp && d.id_chat) {
                  this.cp.setIdByTemp(this.idTemp, d.id_chat);
                  this.cp.messageToChannel({
                    function: 'setIdByTemp',
                    params: [this.idTemp, d.id_chat]
                  });
                  this.isSending = false;
                }
                this.cp.setLastActivity(this.chatId, this.userId);
              }
            });
            this.currentMessage = '';
          }
        },
        /**
         * Handles the resize of the scroll in the chat window.
         * @method scrollEnd
         * @fires getRef
         * @memberof chat
         */
        scrollEnd() {
          let sc = this.getRef('scroll');
          if (sc) {
            //sc.onResize(true).then(() => {
            sc.scrollEndY();
            //});
          }
        },

        /**
         * The render of the message.
         * @method renderMsg
         * @param {String} msg
         * @return {String}
         * @memberof chat
         */
        renderMsg(msg) {
          msg = bbn.fn.html2text(msg);
          let matches = msg.match(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g);
          if (matches) {
            bbn.fn.each(matches, v => {
              if (v.indexOf(bbn.env.host) === 0) {
                msg = msg.replace(v, '<a href="javascript:;" onclick="bbn.fn.link(\'' + bbn.fn.substr(v, bbn.env.host.length + 1) + '\')">' + bbn.fn.substr(v, bbn.env.host.length + 1) + '</a>');
              } else {
                msg = msg.replace(v, '<a href="' + v + '" target="_blank">' + v + '</a>');
              }
            });
          }
          return msg;
        },
        /**
         * Formats the given timestamp
         * @method getTime
         * @memberof chat
         * @param {String} t
         * @return {String}
         */
        getTime(t) {
          return dayjs.unix(t).format('HH:mm');
        },
        /**
         * Formats the given timestamp
         * @method getDate
         * @memberof chat
         * @param {String} d
         * @return {String}
         */
        getDate(d) {
          return dayjs.unix(d).format('DD MMMM YYYY');
        },
        /**
         * Checks if the given timestamp is equal at today
         * @method isToday
         * @memberof chat
         * @param {String} d
         * @return {Boolean}
         */
        isToday(d) {
          return dayjs().format('DD/MM/YYYY') === dayjs.unix(d).format('DD/MM/YYYY');
        },
        /**
         * Load more old messages
         * @method loadMoreMessages
         * @memberof chat
         * @fires post
         */
        loadMoreMessages() {
          if (this.messages.length) {
            this.isLoading = true;
            this.post(this.cp.url + '/actions/message/previous', {
              id_chat: this.chatId,
              time: this.messages[0].time
            }, d => {
              this.isLoading = false;
              if (d.messages && d.messages.length) {
                this.messages.unshift(...d.messages);
              }
            }, e => {
              this.isLoading = false;
            });
          }
        },
        /**
         * Checks if all participants read the given message
         * @method isMsgRead
         * @memberof chat
         * @param {Object} msg
         * @return {Boolean}
         */
        isMsgRead(msg) {
          if (msg.time) {
            return !this.participants.filter(p => !this.participantsActivity[p] || this.participantsActivity[p] < msg.time).length;
          }
          return false;
        },
        /**
         * Gets the style properties for the given message
         * @method getStyle
         * @memberof chat
         * @param {Object} msg
         * @param {Number} idx
         * @return {Object}
         */
        getStyle(msg, idx) {
          let sent = msg.user === this.userId,
            ret = {};
          if (this.$refs.message && !sent && !msg.unread) {
            if (this.receivedBackground) {
              ret.backgroundColor = this.receivedBackground + '!important';
              ret.borderColor = this.receivedBackground;
            }
          }
          return ret;
        },
        addEmoji(emoji) {
          this.currentMessage += (this.currentMessage.lenght ? ' ' : '') + String.fromCodePoint('0x' + emoji);
        }
      },
      created() {
        let el = document.createElement('div');
        el.classList.add('bbn-alt-background');
        document.body.append(el);
        this.receivedBackground = bbn.fn.lightenDarkenHex(bbn.fn.rgb2hex(getComputedStyle(el).backgroundColor), this.cp.isDarkTheme ? 30 : -30);
        el.remove();
      },
      /**
       * @event mounted
       * @fires getRef
       * @memberof chat
       */
      mounted() {
        if (this.cp.currentOnline) {
          this.getRef('input').focus();
        }
      }
    },
    /**
     * Represents the individual item in the users list.
     * @component user
     */
    user: {
      template: `
<div class="bbn-grid bbn-p bbn-vmiddle bbn-vxsmargin"
    style="grid-template-columns: max-content auto max-content"
>
<div class="bbn-middle" style="min-width: 1.5rem">
  <bbn-initial :user-name="source.text"
              :width="16"
              :height="16"
  ></bbn-initial>
</div>
<div class="bbn-ellipsis bbn-w-100"
      v-text="source.text"
></div>
<div class="bbn-middle" style="min-width: 1.5rem">
  <i :class="{
        'nf nf-fa-circle': cp.isOnline(source.value),
        'bbn-green': cp.isOnline(source.value)
      }"
  ></i>
</div>
</div>
      `,
      name: 'user',
      props: {
        /**
        * The source object
        * @prop {Object} source
        * @memberof user
        */
        source: {
          type: Object
        }
      },
      data() {
        return {
          /**
           * The main chat component
           * @data {bbnCp} cp
           * @memberof user
           */
          cp: cp
        };
      }
    },
    /**
     * Represents the individual item in the current chats list
     * @component active
     */
    active: {
      template: `
<div class="bbn-grid bbn-p bbn-vmiddle bbn-vxsmargin"
    style="grid-template-columns: max-content auto max-content max-content"
    :title="participantsFormatted"
>
<div class="bbn-middle" style="min-width: 1.5rem">
  <bbn-initial :user-name="participantsFormatted"
                :width="16"
                :height="16"
                v-if="!isGroup && !source.info.title"
  ></bbn-initial>
  <i v-else
      class="nf nf-oct-organization"></i>
</div>
<div class="bbn-ellipsis bbn-w-100"
      v-text="source.info.title || participantsFormatted"
></div>
<div class="bbn-middle">
  <span v-if="source.unread"
        class="bbn-xs bbn-badge bbn-primary"
        v-text="source.unread">
  </span>
</div>
<div class="bbn-middle" style="min-width: 1.5rem">
  <i v-if="cp.currentOnline && (online.length === participants.length)"
      class="nf nf-fa-circle bbn-green"
      :title="onlineFormatted"
  ></i>
  <i v-else-if="cp.currentOnline && isGroup && online.length"
      class="nf nf-fa-circle bbn-orange"
      :title="onlineFormatted"
  ></i>
</div>
</div>
      `,
      name: 'active',
      props: {
        /**
        * The source object
        * @prop {Object} source
        * @memberof active
        */
        source: {
          type: Object
        }
      },
      data() {
        return {
          /**
           * The main chat component
           * @data {bbnCp} cp
           * @memberof active
           */
          cp: cp
        };
      },
      computed: {
        /**
         * The participants list (full object)
         * @computed participants
         * @memberof active
         * @fires cp.getParticipants
         * @return {Array}
         */
        participants() {
          return this.cp.getParticipants(this.source.participants);
        },
        /**
         * The formatted paticipants list
         * @computed participantsFormatted
         * @memberof active
         * @fires cp.getParticipantsFormatted
         * @return {Array}
         */
        participantsFormatted() {
          if (this.participants) {
            return this.cp.getParticipantsFormatted(this.participants, '\n');
          }
          return '';
        },
        /**
         * True if this chat is a group
         * @computed isGroup
         * @memberof active
         * @return {Boolean}
         */
        isGroup() {
          return this.participants.length > 1;
        },
        /**
         * The list of the online participants
         * @computed online
         * @memberof active
         * @fires cp.isOnline
         * @return {Array}
         */
        online() {
          return this.participants.filter(p => this.cp.isOnline(p.value));
        },
        /**
         * The formatted list of the online participants
         * @computed onlineFormatted
         * @memberof active
         * @fires cp.getParticipantsFormatted
         * @return {String}
         */
        onlineFormatted() {
          return this.online.length && this.isGroup ? bbn._('Online participants') + ':\n' + this.cp.getParticipantsFormatted(this.online, '\n') : '';
        }
      }
    },
    /**
     * The interface where to see/change the chat's info
     * @component info
     */
    info: {
      template: `
<div class="bbn-spadded">
<div v-if="(participants.length > 1) || info.title || titleVisible"
      class="bbn-header bbn-c"
>` + bbn._('TITLE') + `</div>
<div v-if="(participants.length > 1) || info.title || titleVisible"
      class="bbn-flex-width bbn-vmiddle bbn-top-sspace"
>
  <bbn-input class="bbn-flex-fill bbn-right-sspace"
            v-model="currentTitle"
            :readonly="!isAdmin"
  ></bbn-input>
  <bbn-button icon="nf nf-fa-save"
              :notext="true"
              @click="saveTitle"
              v-if="isAdmin && chatId && currentTitle"
  ></bbn-button>
</div>
<div class="bbn-header bbn-top-sspace bbn-vmiddle">
  <div class="bbn-flex-fill bbn-c">` + bbn._('PARTICIPANTS') + `</div>
  <div class="bbn-hsmargin">
    <i v-if="isAdmin"
        class="bbn-p nf nf-fa-plus"
        @click="onAddUserClick"
    ></i>
  </div>
</div>
<div class="bbn-spadded bbn-bordered bbn-grid bbn-no-border-top"
    style="grid-template-columns: max-content auto max-content"
>
  <template v-for="p in currentParticipants">
    <div class="bbn-middle"
        style="min-width: 1.5rem"
    >
      <bbn-initial :user-name="p.text"
                  :width="16"
                  :height="16"
      ></bbn-initial>
    </div>
    <div class="bbn-ellipsis bbn-w-100"
        v-text="p.text"
    ></div>
    <div class="bbn-middle"
        style="min-width: 1.5rem"
    >
      <template v-if="isAdmin">
        <i v-if="!admins.includes(p.value) || isCreator"
          class="bbn-p nf nf-fa-trash bbn-red bbn-left-sspace"
          @click="removeUser(p.value)"
        ></i>
        <i v-if="isCreator"
          :class="['bbn-p', 'nf nf-fa-star', 'bbn-left-sspace', {
            'bbn-primary-text-alt': admins.includes(p.value)
          }]"
          @click="toggleAdmin(p.value)"
        ></i>
      </template>
    </div>
  </template>
</div>
</div>
      `,
      name: 'info',
      props: {
        /**
         * The chat's ID
         * @prop {String} [''] chatId
         * @memberof info
         */
        chatId: {
          type: String,
          default: ''
        },
        /**
         * The current user's ID
         * @prop {String} userId
         * @memberof info
         */
        userId: {
          type: String,
          required: true
        },
        /**
         * The chat's info
         * @prop {Object} info
         * @memberof info
         */
        info: {
          type: Object,
          required: true
        },
        /**
         * The chat's participants list
         * @prop {Array} [[]] participants
         * @memberof info
         */
        participants: {
          type: Array,
          defauult() {
            return [];
          }
        },
        /**
         * The chat's admins list
         * @prop {Array} [[]] admins
         * @memberof info
         */
        admins: {
          type: Array,
          defauult() {
            return [];
          }
        },
        /**
         * The array of all users (including offline ones).
         * @prop {Array} [[]] users
         * @memberof info
         */
        users: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * True if the chat title is to be shown
         * @prop {Boolean} [false] titleVisible
         * @memberof info
         */
        titleVisible: {
          type: Boolean,
          default: false
        }
      },
      data() {
        return {
          /**
           * The current title
           * @data {String} currentTitle
           * @memberof info
           */
          currentTitle: this.info.title || ''
        };
      },
      computed: {
        /**
         * @computed currentParticipants
         * @memberof info
         * @fires cp.getParticipants
         * @return {Array}
         */
        currentParticipants() {
          return cp.getParticipants(this.participants);
        },
        /**
         * True if the current user is the chat creator
         * @computed isCreator
         * @memberof info
         * @return {Boolean}
         */
        isCreator() {
          return this.userId === this.info.creator;
        },
        /**
         * True if the current user is a chat admin
         * @computed isAdmin
         * @memberof info
         * @return {Boolean}
         */
        isAdmin() {
          return this.admins.includes(this.userId);
        }
      },
      methods: {
        /**
         * Save the title
         * @method saveTitle
         * @memberof info
         * @fires post
         * @fires alert
         */
        saveTitle() {
          if (this.chatId) {
            this.post(cp.url + '/actions/chat/title', {
              id_chat: this.chatId,
              title: this.currentTitle
            }, d => {
              if (d.success) {
                this.$set(this.info, 'title', this.currentTitle);
              } else {
                this.alert(bbn._("Impossible to save the chat's title"));
              }
            });
          }
        },
        /**
         * Toggle the given user as chat admin
         * @method toggleAdmin
         * @memberof info
         * @param {String} idUser
         * @fires addAdmin
         * @fires removeAdmin
         */
        toggleAdmin(idUser) {
          let idx = this.admins.indexOf(idUser);
          if (idx === -1) {
            this.addAdmin(idUser);
          } else {
            this.removeAdmin(idUser);
          }
        },
        /**
         * The called method when an user is added from interface
         * @method onAddUserClick
         * @memberof info
         * @fires getPopup
         */
        onAddUserClick() {
          this.getPopup({
            title: bbn._('Select user'),
            component: this.$options.components.users,
            source: {
              participants: this.participants,
              creator: this.info.creator,
              onSelect: this.addUser
            },
            scrollable: false,
            width: 300
          });
        },
        /**
         * Add a user to the chat.
         * @method addUser
         * @param {String} idUser
         * @memberof info
         * @fires post
         * @fires alert
         */
        addUser(idUser) {
          if (!this.participants.includes(idUser) && this.admins.includes(this.userId)) {
            if (this.chatId) {
              this.post(cp.url + '/actions/user/add', {
                id_chat: this.chatId,
                id_user: idUser
              }, d => {
                if (!d.success) {
                  this.alert(bbn._("Impossible to add the user!"));
                }
              });
            } else {
              let title = cp.getParticipantsFormatted(this.participants);
              this.participants.push(idUser);
              if (this.info.title === title) {
                this.$set(this.info, 'title', cp.getParticipantsFormatted(this.participants));
              }
            }
          }
        },
        /**
         * Remove the given user from the chat
         * @method removeUser
         * @memberof info
         * @param {String} idUser
         * @fires confirm
         * @fires post
         * @fires alert
         */
        removeUser(idUser) {
          if (this.participants.includes(idUser) && (!this.admins.includes(idUser) || idUser !== this.info.creator && this.userId === this.info.creator)) {
            this.confirm(bbn._('Are you sure you want to remove this user from the chat?'), () => {
              let remove = () => {
                let title = cp.getParticipantsFormatted(this.participants),
                  changeTitle = this.info.title === title;
                this.participants.splice(this.participants.indexOf(idUser), 1);
                if (changeTitle) {
                  this.$set(this.info, 'title', cp.getParticipantsFormatted(this.participants));
                }
              };
              if (this.chatId) {
                this.post(cp.url + '/actions/user/remove', {
                  id_chat: this.chatId,
                  id_user: idUser
                }, d => {
                  if (d.success) {
                    remove();
                  } else {
                    this.alert(bbn._("Impossible to remove the user!"));
                  }
                });
              } else {
                remove();
              }
            });
          }
        },
        /**
         * Add admin to the chat
         * @method addAdmin
         * @memberof info
         * @param {String} idUser
         * @fires post
         * @fires alert
         */
        addAdmin(idUser) {
          if (this.userId === this.info.creator && idUser !== this.userId && !this.admins.includes(idUser)) {
            if (this.chatId) {
              this.post(cp.url + '/actions/admin/add', {
                id_chat: this.chatId,
                id_user: idUser
              }, d => {
                if (d.success) {
                  this.admins.push(idUser);
                } else {
                  this.alert(bbn._('Impossibile to set this user as admin!'));
                }
              });
            } else {
              this.admins.push(idUser);
            }
          }
        },
        /**
         * Remove admin
         * @method removeAdmin
         * @memberof info
         * @param {String} idUser
         * @fires post
         * @fires alert
         */
        removeAdmin(idUser) {
          if (this.userId === this.info.creator && idUser !== this.userId && this.admins.includes(idUser)) {
            if (this.chatId) {
              this.post(cp.url + '/actions/admin/remove', {
                id_chat: this.chatId,
                id_user: idUser
              }, d => {
                if (d.success) {
                  this.admins.splice(this.admins.indexOf(idUser), 1);
                } else {
                  this.alert(bbn._('Impossibile to set this user as admin!'));
                }
              });
            } else {
              this.admins.splice(this.admins.indexOf(idUser), 1);
            }
          }
        }
      },
      watch: {
        /**
         * @watch currentTitle
         * @memberof info
         * @param {String} newVal
         * @emit titleChanged
         */
        currentTitle(newVal) {
          this.$emit('titleChanged', newVal);
        },
        /**
         * @watch info.title
         * @memberof info
         * @param {String} newVal
         */
        'info.title'(newVal) {
          this.currentTitle = newVal;
        }
      },
      components: {
        /**
         * The users tree
         * @component users
         * @memberof info
         */
        users: {
          template: `
<div class="bbn-vpadded bbn-overlay">
<bbn-tree :source="users"></bbn-tree>
</div>
          `,
          name: 'users',
          props: {
            /**
             * The source object
             * @prop {Object} source
             * @memberof info
             */
            source: {
              type: Object
            }
          },
          data() {
            return {
              /**
               * The users list
               * @data {Array} users
               * @memberof info
               */
              users: bbn.fn.map(cp.users.filter(u => !this.source.participants.includes(u.value) && u.value !== this.source.creator), u => {
                return bbn.fn.extend(true, {
                  component: this.$options.components.user
                }, u);
              })
            };
          },
          components: {
            /**
             * The individual user component
             * @component user
             * @memberof users
             */
            user: {
              template: `
<span class="bbn-iblock bbn-p" @click="select">
<bbn-initial :user-name="source.text"
              :width="16"
              :height="16"
></bbn-initial>
<span class="bbn-left-sspace"
      v-text="source.text"
></span>
</span>
              `,
              name: 'user',
              props: {
                /**
                 * The source object
                 * @prop {Object} source
                 * @memberof user
                 */
                source: {
                  type: Object
                }
              },
              methods: {
                /**
                 * The called method on user selecting
                 * @method select
                 * @memberof user
                 * @fires closest
                 * @fires getPopup
                 */
                select() {
                  this.closest('bbn-tree').$parent.source.onSelect(this.source.value);
                  this.getPopup().close();
                }
              }
            }
          }
        }
      }
    },
    /**
     * The interface to create a new group
     * @component newGroup
     */
    newGroup: {
      template: `
<bbn-form :validation="validation"
        :source="chat"
        :action="cp.url + '/actions/chat/group'"
>
<component :is="cp.$options.components.info"
            :info="{
              title: '',
              creator: cp.userId
            }"
            :participants="chat.participants"
            :admins="chat.admins"
            :user-id="cp.userId"
            :users="cp.users"
            @titleChanged="title => chat.title = title"
            :titleVisible="true"
></component>
</bbn-form>
      `,
      name: 'newGroup',
      data() {
        return {
          /**
           * The main chat component
           * @data {bbnCp} cp
           * @memberof newGroup
           */
          cp: cp,
          /**
           * The chat info
           * @data {Object} chat
           */
          chat: {
            title: '',
            participants: [cp.userId],
            admins: [cp.userId]
          }
        };
      },
      methods: {
        /**
         * The called method on form validation
         * @method validation
         * @memberof newGroup
         * @param {Object} d
         * @fires alert
         * @return {Boolean}
         */
        validation(d) {
          if (d.participants.length < 3) {
            this.alert(bbn._('Two or more participants are required'));
            return false;
          }
          if (!d.title) {
            this.alert('The title is required');
            return false;
          }
          return true;
        }
      }
    }
  }
};
import cpHtml from './chat.html';
import cpStyle from './chat.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./chat.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-chat',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-checkbox component
 *
 * @description The bbn-checkbox component is a box that by clicking, it assigns a certain value and when we deselect it takes another.
 * The values that can be assumed in case of selection or not are  defined in the configuration of the component.
 * In addition, we can customize it by using the properties at disposal.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.componentInside
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events, bbn.cp.mixins.componentInside],
  props: {
    value: {
      /**
       * The value of the checkbox.
       *
       * @prop {Boolean} [true] value
       */
      default: true
    },
    /**
    * The value of the checkbox when unchecked.
    *
    * @prop {Boolean} [null] novalue
    */
    novalue: {
      default: null
    },
    /**
     * The name of the component checkbox.
     *
     * @prop {String} [null] name
     */
    name: {
      type: String,
      default: null
    },
    /**
     * The id of the checkbox.
     *
     * @prop {String} id
     */
    id: {
      type: String,
      default() {
        return bbn.fn.randomString(10, 25);
      }
    },
    /**
     * The property used for the component's value instead of the classic "value" property.
     *
     * @prop {String|Boolean|Number} [undefined] modelValue
     */
    modelValue: {
      type: [String, Boolean, Number],
      default: undefined
    },
    /**
     * Set to true to have required checkbox selection.
     *
     * @prop {Boolean} [false] required
     */
    required: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to disable the checkbox.
     *
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true for a readonly checkbox.
     *
     * @prop {Boolean} [false] readonly
     */
    readonly: {
      type: Boolean,
      default: false
    },
    /**
     * The accompanying label for the checkbox.
     *
     * @prop {String} label
     */
    label: {
      type: String
    },
    /**
     * Set to true for a checked checkbox.
     *
     * @prop {Boolean} [false] checked
     */
    checked: {
      type: Boolean,
      default: false
    },
    /**
     * If set to true, a comparison will also be made on the component value type.
     *
     * @prop {Boolean} [false] strict
     */
    strict: {
      type: Boolean,
      default: false
    }
  },
  model: {
    prop: 'modelValue',
    event: 'input'
  },
  computed: {
    /**
     * Returns the state of the checkbox.
     *
     * @computed state
     * @return {Boolean}
     */
    state() {
      if (this.checked && this.modelValue === undefined) {
        return true;
      }
      if (this.checked && (!this.strict && this.modelValue != this.value || this.strict && this.modelValue !== this.value)) {
        return false;
      }
      if (this.strict && this.modelValue === this.value || !this.strict && this.modelValue == this.value) {
        return true;
      }
      return this.checked;
    }
  },
  methods: {
    /**
     * Emits a change when the state of the checkbox changes.
     *
     * @method toggle
     * @emits input
     * @emits change
     */
    toggle() {
      if (!this.isDisabled && !this.readonly) {
        //bbn.fn.log("TOGGLE");
        let emitVal = !this.state ? this.value : this.novalue;
        this.$emit('input', emitVal);
        this.$emit('change', emitVal, this);
      }
    },
    /**
     * Prevents the event action if the component is disabled or readonly
     * @method onClick
     * @fires click
     */
    onClick(ev) {
      if (this.isDisabled || this.readonly) {
        ev.preventDefault();
      } else {
        this.$emit('beforechange', ev, this.state);
        if (!ev.defaultPrevented) {
          //bbn.fn.log("ONCLICK");
          this.click(ev);
        }
      }
    },
    /**
     * Prevents the event action if the component is disabled or readonly
     * @method onKeyDown
     * @fires keydown
     */
    onKeyDown(ev) {
      if ((this.isDisabled || this.readonly) && ev.keyCode === 32) {
        ev.preventDefault();
      } else {
        //bbn.fn.log("KEYDOWN");
        this.keydown(ev);
      }
    }
  },
  /**
   * @todo ask mirko about @emit
   *
   *
   * @event mounted
   * @fires toggle
   * @emits input
   */
  mounted() {
    if (this.checked && !this.state) {
      this.toggle();
    }
    if (!this.checked && !this.state) {
      //this.$emit('input', this.novalue);
    }
  },
  watch: {
    /**
     * @watch checked
     * @param {Boolean} newValue
     * @fires toggle
     */
    checked(newValue) {
      if (newValue !== this.state) {
        this.toggle();
      }
    }
  }
};
import cpHtml from './checkbox.html';
export default {
  name: 'bbn-checkbox',
  definition: cpDef,
  template: cpHtml
};
/**
 * @file bbn-clipboard component
 *
 * @description bbn-clipboard Classic input with normalized appearance.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 *
 * @created 15/08/2019.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  props: {
    /**
     * @prop {String} ['right'] orientation
     */
    orientation: {
      type: String,
      default: 'right'
    },
    /**
     * @prop {Array} [[]] source
     */
    source: {
      type: Array
    },
    /**
     * @prop {Array} [[]] max The maximum number of items kept in the clipboard
     */
    max: {
      type: Number,
      default: 20
    },
    /**
     * @prop {Array} [[]] max The maximum number of items kept in the clipboard
     */
    maxSize: {
      type: Number,
      default: 1000000
    }
  },
  data() {
    return {
      /**
       * @data {Number} [0] opacity
       */
      opacity: 0,
      /**
       * @data {Array} items
       */
      items: this.source ? this.source.slice() : [],
      /**
       * @data {String} [''] search
       */
      search: '',
      /**
       * @data {Boolean} [false] isSetting
       */
      isSetting: false,
      /**
       * @data {String} [null] uid
       */
      uid: null,
      /**
       * @data {Boolean} [false] isOpened
       */
      isOpened: false,
      /**
       * @data {Boolean} [false] isUpdatingClipboard
       */
      isUpdatingClipboard: false
    };
  },
  computed: {},
  methods: {
    /**
     * Emits a change when the state of the checkbox changes.
     *
     * @method unsearch
     */
    unsearch() {
      if (this.search.length) {
        this.search = '';
        this.items = this.source;
      }
    },
    /**
     * @todo empty function
     *
     * @method test
     */
    test(uid) {
      bbn.fn.log("TEST", uid);
    },
    /**
     *
     *
     * @method togle
     *
     */
    toggle() {
      return this.getRef('slider').toggle();
    },
    /**
     *
     * @fires getRef
     * @method show
     */
    show() {
      return this.getRef('slider').show();
    },
    /**
     *
     * @fires getRef
     * @method hide
     */
    hide() {
      return this.getRef('slider').hide();
    },
    /**
     *
     * @fires getItem
     * @method save
     */
    save(uid, title) {
      let item = this.getItem(uid);
      if (item) {
        let content = item.file || item.text;
        if (!title) {
          bbn.fn.log("NO TITLE", item);
          title = item.text;
          if (!item.file && title.length > 15) {
            title = bbn.fn.sanitize(bbn.fn.substr(title, 0, 50)).substr(15);
          }
        }
        bbn.fn.download(title, content, item.type);
      }
    },
    /**
     *
     * @fires getItem
     * @fires save
     * @method saveAs
     */
    saveAs(uid) {
      let item = this.getItem(uid);
      if (item) {
        let bits = item.text.split('.');
        let title = prompt(bbn._('Enter the file name'), bits.length > 1 ? '.' + bits.pop().toLowerCase() : item.text);
        if (title) {
          this.save(uid, title);
        }
      }
    },
    /**
     * @method add
     * @param data
     * @emits add
     * @fires setStorage
     * @fires unsetStorage
     */
    add(data) {
      let dt = bbn.fn.timestamp();
      let uid = dt;
      let ar = [{
        dt: dt,
        uid: uid,
        text: data.raw,
        type: 'text/plain',
        stype: 'text',
        size: data.raw.length,
        mdate: null,
        content: '',
        file: '',
        pinned: false
      }];
      if (data.files && data.files.length) {
        // No need for a list of files if there is only one
        if (data.files.length === 1) {
          ar = [];
        }
        bbn.fn.each(data.files, o => {
          uid++;
          let stype = 'text';
          if (o.type !== 'text/plain') {
            if (o.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
              stype = 'ms.word';
            } else if (o.type === 'application/vnd.oasis.opendocument.text') {
              stype = 'oo.text';
            } else if (o.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') {
              stype = 'oo.sheet';
            } else if (o.type.indexOf('image/') !== 0) {
              let bits = o.type.split('/');
              stype = bits[1] || bits[0];
            } else {
              stype = o.type.length > 15 ? bbn._('Other') : o.type;
            }
          }
          ar.push({
            dt: dt,
            uid: uid,
            text: o.name,
            type: o.type,
            stype: stype,
            size: o.size,
            mdate: o.mdate,
            content: '',
            file: o.data
          });
        });
      } else if (data.str && data.str.length) {
        bbn.fn.each(data.str, o => {
          if (o.type === 'text/plain') {
            ar[0].text = o.data;
          } else {
            ar[0].type = o.type;
            if (o.type.indexOf('image/') !== 0) {
              let bits = o.type.split('/');
              ar[0].stype = bits[1] || bits[0];
            } else {
              stype = o.type;
            }
            ar[0].content = o.data;
          }
        });
      }
      let added = [];
      bbn.fn.each(ar, a => {
        let idx = bbn.fn.search(this.items, {
          text: a.text,
          type: a.type
        });
        if (idx !== -1) {
          this.unsetStorage(this.items[idx].uid);
          this.items.splice(idx, 1);
        } else {
          added.unshift(a);
        }
        if (this.hasStorage) {
          this.setStorage(a, a.uid);
        }
        this.items.unshift(a);
      });
      if (added.length) {
        bbn.fn.each(added, o => {
          bbn.fn.upload('core/upload', {
            type: 'clipboard',
            file: o.data
          },
          // success
          res => bbn.fn.log("CLIPBOARD success", res),
          // failure
          res => bbn.fn.log("CLIPBOARD failure", res),
          // progress
          res => bbn.fn.log("CLIPBOARD progress", res));
        });
        this.$emit('add', added);
      }
      this.$forceUpdate();
    },
    /**
     *
     * @method remove
     * @emits remove
     * @fires unsetStorage
     */
    remove(src) {
      let idx = bbn.fn.search(this.items, {
        uid: src.uid
      });
      if (idx > -1) {
        let e = new Event('remove', {
          cancelable: true
        });
        this.$emit('remove', e, this.items[idx]);
        if (!e.defaultPrevented) {
          this.unsetStorage(src.uid);
          this.items.splice(idx, 1);
        }
      }
    },
    /**
     *
     *
     * @method getItem
     *
     */
    getItem(uid) {
      return bbn.fn.getRow(this.items, {
        uid: uid
      });
    },
    /**
     *
     * @fires getRef
     * @method updateSlider
     */
    updateSlider() {
      this.$nextTick(() => {
        this.getRef('slider').onResize();
      });
    },
    /**
     *
     * @fires remove
     * @method clear
     */
    clear() {
      this.confirm(bbn._('Are you sure you want to delete the whole content of the clipboard?'), () => {
        while (this.items.length) {
          this.remove(this.items[this.items.length - 1]);
        }
      });
    },
    /**
     *
     * @fires add
     * @fires updateSlider
     * @method copy
     * @return {Boolean}
     */
    copy(e) {
      let type = e.type;
      bbn.fn.getEventData(e).then(data => {
        this.add(data);
        this.updateSlider();
        bbn.fn.log("DATA FROM " + type, data);
      });
      return true;
    },
    /**
     *
     * @fires getRef
     * @fires getItem
     * @method setClipboard
     */
    setClipboard(uid, mode) {
      let item = this.getItem(uid);
      if (item) {
        let doIt = () => {
          this.uid = uid;
          this.mode = mode;
          this.isSetting = true;
          this.getRef('textarea').value = ' ';
          this.getRef('textarea').select();
          document.execCommand('copy');
        };
        if (item.file) {
          let reader = new FileReader();
          reader.onloadend = () => {
            this.file = reader.result;
            doIt();
          };
          reader.readAsBinaryString(item.file);
        } else {
          doIt();
        }
      }
    },
    /**
     * @fires getItem
     * @fires copy
     * @param {Object} e
     */
    onCopy(e) {
      if (e.clipboardData && this.isSetting && this.uid) {
        let item = this.getItem(this.uid);
        if (item) {
          e.clipboardData.setData('text/plain', this.mode === 'html' ? item.content : item.text);
          //bbn.fn.log("ITEM IS FOUND");
          let v;
          switch (this.mode) {
            case 'html':
              e.clipboardData.setData('text/html', item.content);
              break;
            case 'image':
              //bbn.fn.log("IMAGE!", item.type);
              if (item.file) {
                e.clipboardData.setData(item.type, item.file);
                e.clipboardData.setData('text/html', '<img src="data:' + item.type + ';base64, ' + btoa(item.file) + '" alt="' + item.text + '">');
              }
              break;
            case 'file':
              //bbn.fn.log(this.file);
              if (this.file) {
                e.clipboardData.setData(item.type, this.file);
              }
              break;
          }
          //bbn.fn.log("SETTING " + item.text);
          //bbn.fn.log(e.clipboardData.items, e.clipboardData.items[0], e.clipboardData.items.length);
          //e.preventDefault();
          /*
          bbn.fn.each(e.clipboardData.items, item => {
            bbn.fn.log("ITEM FROM THE CLIPBOARD OFFICIAL", item);
            navigator.clipboard.write(item).then(() => {
              bbn.fn.log("WRITE OPERATION ON CLIPBOARD OK");
            });
          });
          */
        }

        this.isSetting = false;
        this.uid = null;
        this.file = null;
      } else {
        this.copy(e);
      }
    },
    /**
     * @method addInput
     * @fires getRed
     * @fires add
     */
    addInput() {
      let input = this.getRef('paster');
      if (input && input.value) {
        this.add({
          raw: input.value
        });
        input.value = '';
      }
    }
  },
  /**
   * @method created
   * @fires getStorage
   * @fires unsetStorage
   */
  created() {
    if (!this.items && this.hasStorage) {
      let items = this.getStorage(this.getComponentName(), true);
      if (bbn.fn.isArray(items)) {
        let tmp = [];
        items.forEach(a => {
          let it = this.getStorage(a);
          if (it) {
            tmp.push(it);
          }
        });
        if (tmp.length) {
          this.items = tmp;
        }
      }
    }
    if (!this.items) {
      this.items = [];
    }
    if (this.hasStorage) {
      // Checking if there is no lost clipboard items
      let local = localStorage;
      let uid;
      let cp = this.getComponentName();
      for (let n in local) {
        if (!n.indexOf(cp + '-') && (uid = parseInt(bbn.fn.substr(n, cp.length + 1))) && !bbn.fn.getRow(this.items, {
          uid: uid
        })) {
          this.unsetStorage(uid);
        }
      }
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    document.addEventListener('copy', this.onCopy);
    this.ready = true;
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    document.removeEventListener('copy', this.onCopy);
  },
  watch: {
    /**
     * @watch items
     * @fires remove
     * @fires alert
     * @fires setStorage
     * @emits copy
     */
    items() {
      if (this.ready && !this.isUpdatingClipboard) {
        this.isUpdatingClipboard = true;
        if (this.items.length > this.max) {
          let i;
          for (i = this.items.length - 1; i >= 0; i--) {
            if (!this.items[i].pinned) {
              this.remove({
                uid: this.items[i].uid
              });
              if (this.items.length === this.max) {
                break;
              }
            }
          }
          if (!i && this.items.length > this.max) {
            this.remove({
              uid: this.items[0].uid
            });
            this.alert(bbn._("Limit reached, unpin elements to add new ones"));
            return;
          }
        }
        this.setStorage(this.items.map(a => a.uid), this.getComponentName(), true);
        this.$emit('copy');
        this.isUpdatingClipboard = false;
      }
    },
    /**
     * @watch search
     */
    search(val) {
      if (val.length >= 3) {
        let res = [];
        res = bbn.fn.filter(this.items, a => {
          if (a.text.toLowerCase().indexOf(this.search.toLowerCase()) >= 0) {
            return a;
          }
        });
        this.items = res;
      } else {
        this.items = this.source;
      }
    }
  }
};
import cpHtml from './clipboard.html';
import cpStyle from './clipboard.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./clipboard.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-clipboard',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-cms-block component
 * @description bbn-cms-block
 * @copyright BBN Solutions
 * @author Loredana Bruno
 * @created 09/11/2020.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  statics() {
    let titleTemplates = {
        h1: `<h1 v-text="source.content"></h1>`,
        h2: `<h2 v-text="source.content"></h2>`,
        h3: `<h3 v-text="source.content"></h3>`,
        h4: `<h4 v-text="source.content"></h4>`,
        h5: `<h5 v-text="source.content"></h5>`
      },
      htmlTemplates = {
        p: `<p v-html="source.content"></p>`,
        span: `<span v-html="source.content"></span>`
      },
      templates = {
        text: {
          view: `<div v-html="source.content || '&nbsp;'"/>`,
          edit: `<bbn-textarea class="bbn-w-100"
                              v-model="source.content"/>`
        },
        html: {
          view: `<div @click="$parent.editMode" @mouseover="$parent.mouseover" @mouseleave="$parent.mouseleave"
                    :class="['component-container', 'bbn-block-html', alignClass]"
                    v-html="source.content"
                    :style="style">
  
              </div>`,
          edit: `<div :class="['component-container', 'bbn-block-html', alignClass ]">
                <bbn-rte v-model="source.content">
                </bbn-rte>
              </div>`
        },
        title: {
          view: `<div @click="$parent.editMode" @mouseover="$parent.mouseover" @mouseleave="$parent.mouseleave"  :class="['component-container', 'bbn-block-title', {'has-hr': source.hr}, alignClass]":style="style">
                <hr v-if="source.hr">
                <bbn-anon :is="cpHTML(source.tag, 'title')" :source="source"></bbn-anon>
                <hr v-if="source.hr">
                </div>`,
          edit: `<div :class="['component-container','bbn-cms-block-edit' ,'bbn-block-title', 'bbn-flex-height', {'has-hr': source.hr}, alignClass]" :style="style">
                <div class="edit-title bbn-w-100">
                  <hr v-show="source.hr"><bbn-anon :is="cpHTML(source.tag,'title')" :source="source"></bbn-anon><hr v-if="source.hr">
                </div>
                <div class="bbn-grid-fields bbn-vspadded bbn-w-100">
                  <label v-text="_('Title tag')"></label>
                  <div>
                    <bbn-dropdown :source="tags" v-model="source.tag"></bbn-dropdown>
                  </div>
                  <label v-text="_('Title text')"></label>
                  <bbn-input v-model="source.content"></bbn-input>
                  <label>Title color</label>
                    <div>
                      <bbn-colorpicker @change="setColor"
                      ></bbn-colorpicker>
                    </div>
                  <label v-text="_('Title alignment')"></label>
                  <bbn-block-align-buttons></bbn-block-align-buttons>
                  <label v-text="_('Line')"></label>
                  <bbn-checkbox v-model="source.hr"></bbn-checkbox>
                </div>
              </div>`
        },
        image: {
          //taglia originale 100% width,width 50% 33% 25%
          view: `
        <div class="component-container bbn-block-image" :class="alignClass">
          <a v-if="source.href" target="_self" :href="$parent.linkURL + source.href" class="bbn-c">
            <img :src="$parent.path + source.src"
                  style="heigth:500px;width:100%"
                  :style="style"
                  :alt="source.alt ? source.alt : ''"
            >
          </a>
          <img v-else
                :src="$parent.path + source.src"
                :style="style"
                :alt="source.alt ? source.alt : ''"
          >
          <p class="image-caption bbn-l bbn-s bbn-vsmargin"
              v-if="source.caption"
              v-html="source.caption"
          ></p>
          <!--error when using decodeuricomponent on details of home image-->
          <a class="image-details-title bbn-l bbn-vsmargin bbn-w-100"
              v-if="source.details_title"
              v-html="(source.details_title)"
              :href="source.href"
              target="_blank"
          ></a>
          <p class="image-details bbn-l bbn-vsmargin"
              v-if="source.details"
              v-html="(source.details)"
          ></p>
        </div>`,
          edit: `
        <div class="component-container bbn-block-image" :class="alignClass">
          <div class="bbn-padded">
            <div class="bbn-grid-fields bbn-vspadded">
              <label v-text="_('Upload your image')"></label>
              <bbn-upload :save-url="'upload/save/' + ref"
                          remove-url="test/remove"
                          :json="true"
                          :paste="true"
                          :multiple="false"
                          v-model="image"
                          @success="imageSuccess"
              ></bbn-upload>
  
              <label v-text="_('Image size')"></label>
              <bbn-cursor v-model="source.style['width']"
                          unit="%"
                          :min="0"
                          :max="100"
                          :step="20"
              ></bbn-cursor>
  
              <label v-text="_('Image alignment')"></label>
              <bbn-block-align-buttons></bbn-block-align-buttons>
            </div>
          </div>
          <img :src="$parent.path + source.src" :style="style">
          <p class="image-caption bbn-l bbn-s bbn-vsmargin" v-if="source.caption" v-html="source.caption"></p>
        </div>
                  `
        },
        carousel: {
          view: `
        <div :class="['component-container', 'bbn-block-carousel', 'bbn-w-100',  alignClass]" :style="style" v-if="show">
          <div v-for="(group, idx) in carouselSource"
                v-if="idx === currentCarouselIdx"
          >
            <bbn-cms-carousel-control :source="idx"
                                      :key="idx"
                                      v-if="carouselSource.length > 3"
            ></bbn-cms-carousel-control>
            <div :class="['bbn-w-100',carouselCols]">
              <bbn-cms-block-gallery-item v-for="(image, imgIdx) in group" :source="image" :key="imgIdx" :index="imgIdx"></bbn-cms-block-gallery-item>
            </div>
          </div>
        </div>
        `,
          edit: `<div>edit</div>`
        },
        gallery: {
          view: `
        <div :class="['component-container', 'bbn-block-gallery', alignClass, galleryCols]" :style="style" v-if="show">
          <bbn-cms-block-gallery-item v-for="(image, idx) in source.source" :source="image" :key="idx" :index="idx"></bbn-cms-block-gallery-item>
        </div>
        `,
          edit: `
        <div>
          <div :class="['component-container', 'bbn-block-gallery', alignClass, galleryCols]" :style="style" v-if="show">
            <!-- GIVE HREF TO VIEW FULL IMAGE -->
            <bbn-cms-block-gallery-item v-for="(image, idx) in source.content" :source="image" :key="idx" :index="idx"></bbn-cms-block-gallery-item>
          </div>
          <div class="bbn-grid-fields bbn-padded">
            <label>Columns number</label>
            <div>
              <bbn-dropdown v-model="source.columns"
                            :source="tinyNumbers"
              ></bbn-dropdown>
            </div>
            <label v-text="_('Upload your images')"></label>
            <bbn-upload :save-url="'upload/save/' + ref"
                        remove-url="test/remove"
                        :data="{gallery: true}"
                        :paste="true"
                        :multiple="true"
                        v-model="source.content"
                        @success="imageSuccess"
            ></bbn-upload>
  
          </div>
        </div>
        `
        },
        video: {
          view: `
          <div :class="['component-container', 'bbn-cms-block-video', alignClass]">
            <!--ERROR ON HOME-->
            <!--bbn-video :width="source.width"
                        :style="style"
                        :height="source.height"
                        :autoplay="autoplay"
                        :muted="muted"
                        :youtube="youtube"
                        :source="source.src"
            ></bbn-video-->
            <iframe
                    :style="style"
  
                    :autoplay="false"
  
                    :src="source.src"
              ></iframe>
          </div>`,
          edit: `
        <div class="component-container" id="video-container">
          <div class="bbn-grid-fields bbn-padded">
            <label v-text="_('Video source')"></label>
            <bbn-input v-model="source.content"></bbn-input>
            <label>Muted</label>
            <div>
              <bbn-button :notext="true"
                          :title="_('Mute the video')"
                          @click="muted = !muted"
                          :icon="muted ? 'nf nf-oct-mute' : 'nf nf-oct-unmute'"
              >
              </bbn-button>
            </div>
            <label>Autoplay</label>
            <div>
              <bbn-button :notext="true"
                          :title="_('Autoplay')"
                          @click="autoplay = !autoplay"
                          :icon="autoplay ? 'nf nf-fa-pause' : 'nf nf-fa-play'"
              >
              </bbn-button>
            </div>
            <label>Video alignment</label>
            <bbn-block-align-buttons></bbn-block-align-buttons>
            <label>Video width</label>
            <div>
              <bbn-cursor v-model="source.style['width']"
                          :min="100"
                          :max="1000"
                          :step="10"
                          class="bbn-w-70"
              ></bbn-cursor>
            </div>
            <label>Video height</label>
            <div>
              <bbn-cursor v-model="source.style['height']"
                          :min="100"
                          :max="1000"
                          :step="10"
                          class="bbn-w-70"
              ></bbn-cursor>
            </div>
          </div>
          <div :class="alignClass">
            <bbn-video :width="source.style.width"
                      :style="style"
                      :height="source.style.height"
                      :autoplay="autoplay"
                      :muted="muted"
                      :youtube="youtube"
                      :source="source.content"
            ></bbn-video>
          </div>
        </div>
        `
        },
        line: {
          view: `<div class="component-container"><hr :style="style"></div>`,
          edit: `<div class="block-line-edit component-container">
                <hr :style="style">
                <div class="block-line-edit-command bbn-padded">
                  <div class="bbn-grid-fields bbn-vspadded">
                    <label>Line width</label>
                    <div>
                      <bbn-cursor v-model="source.style['width']"
                                  :min="0"
                                  :max="100"
                                  unit="%"
                      ></bbn-cursor>
                    </div>
                    <label>Line height</label>
                    <div>
                      <bbn-cursor v-model="source.style['border-width']"
                                  :min="1"
                                  :max="10"
                                  unit="px"
                      ></bbn-cursor>
                    </div>
                    <label>Line style</label>
                    <div>
                      <bbn-dropdown v-model="source.style['border-style']"
                                    :source="borderStyle"
                      ></bbn-dropdown>
                    </div>
  
                    <label>Line color</label>
                    <div>
                      <bbn-colorpicker v-model="source.style['border-color']"
                      ></bbn-colorpicker>
                    </div>
                    <label>Line alignment</label>
                    <bbn-block-align-buttons></bbn-block-align-buttons>
                  </div>
                </div>
                </div>`
        },
        space: {
          view: `<div class="component-container" :style="style">
                <div class="block-space-view"></div>
              </div>`,
          edit: `
            <div class="component-container" :style="style">
              <div :style="style" class="block-space-edit">
                <bbn-cursor v-model="source.style.height"
                            unit="px"
                            :min="0"
                            :step="50"
                ></bbn-cursor>
              </div>
            </div>`
        }
      };
    let borderStyle = [{
      "text": "hidden",
      "value": "hidden"
    }, {
      "text": "dotted",
      "value": "dotted"
    }, {
      "text": "dashed",
      "value": "dashed"
    }, {
      "text": "solid",
      "value": "solid"
    }, {
      "text": "double",
      "value": "double"
    }, {
      "text": "groove",
      "value": "groove"
    }, {
      "text": "ridge",
      "value": "ridge"
    }];
    return {
      borderStyle,
      titleTemplates,
      htmlTemplates,
      templates
    };
  },
  props: {
    /**
     * The aduio's URL
     * @prop {Object} [true] source
     */
    source: {
      type: Object,
      required: true
    },
    /**
     * The audio's title
     * @prop {String} [''] title
     */
    title: {
      type: String,
      default: ''
    },
    /**
     * @prop {Number} index
     */
    index: {
      type: Number
    },
    /**
     * The path for the index showing the images ('ex: image/').
     *
     * @prop {String} [''] path
     */
    path: {
      type: String,
      default: ''
    },
    /**
     * The path for the links (give a path to a controller to manage the links).
     *
     * @prop {String} [''] linkURL
     */
    linkURL: {
      type: String,
      default: ''
    }
    /*edit: {
      type: Boolean,
      default: false
    },*/
  },

  data() {
    return {
      /**
       * @data {Boolean} [false] over
       */
      over: false,
      /**
       * @data {Boolean} [false] edit
       */
      edit: false,
      /**
       * @data {Boolean} [true] isAdmin
       */
      isAdmin: true,
      /**
       * @data {Boolean} [true] editing
       */
      editing: true,
      /**
       * @data {String} ['100%'] width
       */
      width: '100%',
      /**
       * @data {String} ['100%'] height
       */
      height: '100%',
      //ready is important for the component template to be defined
      /**
       * Ready is important for the component template to be defined.
       *
       * @data {Boolean} [true] ready
       */
      ready: true,
      initialSource: {}
    };
  },
  computed: {
    /**
     * changed
     * @returns {boolean}
     */
    changed() {
      return !bbn.fn.isSame(this.initialSource, this.source);
    },
    /**
     * type
     * @returns {"all"|"sharedworker"|"window"|"worker"|string}
     */
    type() {
      return this.source.type || 'text';
    },
    /**
     * parent
     * @returns {*|null}
     */
    parent() {
      return this.ready ? this.closest('bbn-container').getComponent() : null;
    }
  },
  methods: {
    /**
     * @method onMyMouseEnter
     */
    onMyMouseEnter() {
      alert('enter');
    },
    /**
     * @method mouseleave
     */
    mouseleave() {
      this.over = false;
    },
    /**
     * @method mouseover
     */
    mouseover() {
      this.over = true;
      /*console.log('over: ' + this.over)
      if ( !e.target.closest(".component-container") ){
        e.preventDefault();
        e.stopImmediatePropagation();
        this.over = false;
      }
      else{
        this.over = true;
      }*/
    },

    /**
     * @method mouseenter
     */
    mouseenter() {
      alert('enter');
    },
    /**
     * @method selectImg
     * @param st
     */
    selectImg(st) {
      bbn.fn.link(st);
    },
    /**
     * @method alert
     */
    alert() {
      alert('test');
    },
    /**
     * adds the events listener when edit = true
     * @method _setEvents
     * @param {boolean} edit
     */
    _setEvents() {
      bbn.fn.log("setEvenbt");
      document.addEventListener('mousedown', this.checkMouseDown);
      document.addEventListener('touchstart', this.checkMouseDown);
      document.addEventListener('keydown', this.checkKeyCode);
      /*if ( edit ){
        document.addEventListener('mousedown', this.checkMouseDown);
        document.addEventListener('touchstart', this.checkMouseDown);
        document.addEventListener('keydown', this.checkKeyCode);
      }
      else{
        document.addEventListener('mouseover', this.mouseover);
        document.removeEventListener('mousedown', this.checkMouseDown);
        document.removeEventListener('touchstart', this.checkMouseDown);
      }*/
    },

    /**
     * @method checkKeyCode
     * @param e
     */
    checkKeyCode(e) {
      bbn.fn.log("checkKeyCode");
      if (e.keyCode === 27) {
        this.edit = false;
      }
    },
    /**
     * set edit to false
     * @param {event} e
     */
    checkMouseDown(e) {
      if (!e.target.closest(".bbn-cms-block-edit")) {
        /*e.preventDefault();
        e.stopImmediatePropagation();*/
        this.edit = false;
        alert(this.edit);
      } else {
        alert(this.edit);
        this.editMode();
      }
    },
    /**
     * @method editBlock
     */
    editBlock() {
      bbn.fn.log("editBlock");
      if (this.changed) {
        appui.success(bbn._('Block changed'));
        //add a confirm
        this.$nextTick(() => {
          this.edit = false;
        });
      } else {
        this.edit = false;
      }
    },
    /**
     * @method cancelEdit
     */
    cancelEdit() {
      bbn.fn.log("cancelEdit");
      bbn.fn.iterate(this.initialSource, (v, i) => {
        this.source[i] = v;
        this.edit = false;
      });
    },
    /**
     * @method editNode
     */
    editMode() {
      bbn.fn.log("editMode");
      let blocks = this.closest('bbn-container').getComponent().findAll('bbn-cms-block');
      bbn.fn.each(blocks, (v, i) => {
        v.edit = false;
        v.over = false;
      });
      this.edit = true;
    },
    /**
     * returns the object of the component basing on the given type
     *
     * @method component
     * @param {string} type
     */
    component(type) {
      return {
        props: {
          source: {}
        },
        template: this.edit ? bbnCmsBlockCp.templates[type]['edit'] : bbnCmsBlockCp.templates[type]['view'],
        data() {
          let tmp = Object.keys(bbnCmsBlockCp.titleTemplates).map(a => {
            return a = {
              text: a,
              value: a
            };
          });
          return {
            //cp video
            muted: true,
            autoplay: false,
            align: '',
            tags: tmp,
            image: [],
            tinyNumbers: [{
              text: '1',
              value: 1
            }, {
              text: '2',
              value: 2
            }, {
              text: '3',
              value: 3
            }, {
              text: '4',
              value: 4
            }],
            borderStyle: bbnCmsBlockCp.borderStyle,
            ref: new Date().getTime(),
            show: true,
            currentCarouselIdx: 0
          };
        },
        computed: {
          edit() {
            return this.$parent.edit;
          },
          path() {
            return this.$parent.path;
          },
          linkURL() {
            return this.$parent.linkURL;
          },
          carouselSource() {
            if (this.source.source && this.source.type === 'carousel') {
              let res = [];
              var i,
                j,
                temparray,
                chunk = 3;
              for (i = 0, j = this.source.source.length; i < j; i += chunk) {
                temparray = this.source.source.slice(i, i + chunk);
                res.push(temparray);
                // do whatever
              }

              return res;
            }
          },
          mobile() {
            if (bbn.env.width <= 640) {
              this.$parent.isMobile = true;
              return true;
            }
            return false;
          },
          galleryCols() {
            if (this.source.type === 'gallery' && !this.mobile) {
              if (this.source.columns === 1) {
                return 'cols-1';
              } else if (this.source.columns === 2) {
                return 'cols-2';
              } else if (this.source.columns === 4) {
                return 'cols-4';
              }
              return 'cols-3';
            } else if (this.mobile) {
              if (this.source.columns !== 2) {
                return 'cols-2';
              } else {
                return 'cols-1';
              }
            }
          },
          carouselCols() {
            if (this.source.type === 'carousel' && !this.mobile) {
              if (this.source.columns === 1) {
                return 'cols-1';
              } else if (this.source.columns === 2) {
                return 'cols-2';
              } else if (this.source.columns === 4) {
                return 'cols-4';
              }
              return 'cols-3';
            } else if (this.mobile) {
              return 'cols-2';
            }
          },
          youtube() {
            return this.source.src.indexOf('youtube') > -1;
          },
          alignClass() {
            let st = 'bbn-c';
            if (this.source.align === 'left') {
              st = 'bbn-l';
            }
            if (this.source.align === 'right') {
              st = 'bbn-r';
            }
            return st;
          },
          style() {
            let st = '';
            if (this.source.style) {
              if (this.source.style['color']) {
                st += 'color: ' + this.source.style['color'] + ';';
              }
              if (this.source.style['font-size']) {
                st += 'font-size:' + this.source.style['font-size'] + (bbn.fn.isNumber(this.source.style['font-size']) ? 'px;' : ';');
              }
              if (this.source.style['width']) {
                st += 'width:' + this.source.style['width'] + (bbn.fn.isNumber(this.source.style['width']) ? 'px;' : ';');
              }
              if (this.source.style['height']) {
                st += 'height:' + this.source.style['height'] + (bbn.fn.isNumber(this.source.style['height']) ? 'px;' : ';');
              }
              if (this.source.style['border-style']) {
                st += 'border-style:' + this.source.style['border-style'] + ';';
              }
              if (this.source.style['border-color']) {
                st += 'border-color:' + this.source.style['border-color'] + ';';
              }
              if (this.source.type === 'line') {
                if (bbn.fn.isEmpty(this.source.style) || !this.source.style['border-width']) {
                  this.source.style['border-width'] = '100%';
                  st += 'border-top-width:' + this.source.style['border-width'] + (bbn.fn.isNumber(this.source.style['border-width']) ? 'px;' : ';');
                  st += 'border-bottom:0';
                }
              } else {
                if (this.source.style['border-width']) {
                  st += 'border-width:' + this.source.style['border-width'] + (bbn.fn.isNumber(this.source.content['border-width']) ? 'px;' : ';');
                }
              }
            }
            if (this.source.align && (this.source.type === 'line' || this.source.type === 'video')) {
              let margin = '';
              switch (this.source.align) {
                case 'center':
                  margin = 'margin-left: auto;margin-right:auto';
                  break;
                case 'left':
                  this.source.type === 'video' ? margin = 'float: left' : margin = 'margin-left: 0';
                  break;
                case 'right':
                  this.source.type === 'video' ? margin = 'float: right' : margin = 'margin-right: 0';
                  break;
              }
              st += margin;
            }
            return st;
          }
        },
        methods: {
          decodeURIComponent(st) {
            //the regular expression to match the new line
            /*let reg = /\r?\n|\r/g;
            if(st.match(reg)){
              st = st.replace(reg, '');
            }*/
            //var st = bbn.fn.nl2br(st);
            return decodeURIComponent(this.escape(st));
          },
          escape(st) {
            return escape(st);
          },
          /**
           * calculate the height of the images in gallery basing on source.columns
           */
          makeSquareImg() {
            if (!this.source.noSquare) {
              //creates square container for the a
              var items = this.$el.querySelectorAll('a'),
                images = this.$el.querySelectorAll('img');
              this.show = false;
              if (this.source.columns === 1) {
                for (let i in items) {
                  if (images[i].tagName === 'IMG') {
                    this.$nextTick(() => {
                      images[i].style.height = 'auto';
                      images[i].style.width = '100%';
                    });
                  }
                }
              } else {
                for (let i in images) {
                  if (images[i].tagName === 'IMG') {
                    this.$nextTick(() => {
                      images[i].style.height = items[i].offsetWidth + 'px';
                    });
                  }
                }
              }
              this.show = true;
            }
          },
          setColor(a) {
            this.source.style.color = a;
            this.$parent.edit = false;
            //this.$forceUpdate()
          },

          //returns the component for the blocks of type title
          cpHTML(tag, type) {
            return {
              props: ['source'],
              template: type === 'title' ? bbnCmsBlockCp.titleTemplates[tag] : bbnCmsBlockCp.htmlTemplates[tag]
            };
          },
          /** @todo Seriously these arguments names??  */
          imageSuccess(a, b, c, d) {
            if (c.success && c.image.src.length) {
              if (this.source.type === 'gallery') {
                c.image.src = c.image.name;
                c.image.alt = '';
                setTimeout(() => {
                  this.show = false;
                  //this.source.content.push(c.image);//
                  this.makeSquareImg();
                }, 200);
              } else {
                this.source.content = c.image.name;
              }
              appui.success(bbn._('Image correctly uploaded'));
            } else {
              appui.error(bbn._('An error occurred while uploading the image'));
            }
          }
        },
        components: {
          'bbn-cms-block-gallery-item': {
            props: ['source', 'index'],
            //:src="'image/' + source.content"
            //the template below to take the image from index
            template: `
              <!--IMPORTANT CHANGE FROM CLICK TO HREF WHEN WILL BE POSSIBLE TO MAKE LINK-->
              <!--a  target="_self" :href="(source.href ? (linkURL + source.href) : source.src)"-->
              <a  target="_self" @click="selectImg">
                <!--TO TAKE IMAGE FROM THE INDEX-->
                <img :src="path + source.src" :alt="source.alt ? source.alt : ''" :style="$parent.source.style">
                <div v-if="source.caption || (source.title && (type === 'carousel'))"
                      :class="['bbn-block-gallery-caption',$parent.alignClass]"
                      v-html="(source.caption && (type === 'gallery')) ? source.caption : source.title"
                ></div>
                <div v-if="source.details_title"
                      :class="['image-details-title',$parent.alignClass]"
                      v-html="source.details_title"
                ></div>
                <div v-if="source.details"
                      :class="['image-details',$parent.alignClass]"
                      v-html="source.details"
                ></div>
                <div v-if="source.price"
                      :class="['image-price',$parent.alignClass]"
                      v-text="source.price"
                ></div>
                <time v-if="source.time"
                      v-text="source.time"
                      :class="$parent.alignClass"/>
              </a>
              `

            /*template: `
            <a :href="(source.src ? source.src : source.name)" target="_blank">
              <!--TO TAKE IMAGE FROM THE INDEX-->
              <!--img :src="'image/gallery/' + (source.src ? source.src : source.name)" :alt="source.alt ? source.alt : ''"-->
              <img :src="source.src" :alt="source.alt ? source.alt : ''">
            </a>
            `*/,
            methods: {
              //IMPORTANT TO RENDER CHINESE CHARACTERS
              decodeURIComponent(st) {
                return this.$parent.decodeURIComponent(st);
              },
              escape(st) {
                return this.$parent.escape(st);
              },
              selectImg() {
                //bbn.fn.log("SELECT IMG", this.closest('bbn-container'), this.closest('bbn-container').getComponent());
                return this.closest('bbn-cms-block').selectImg(this.source.href);
              }
            },
            computed: {
              path() {
                return this.$parent.path;
              },
              linkURL() {
                return this.$parent.linkURL;
              },
              type() {
                return this.$parent.source.type;
              }
            },
            mounted() {
              bbn.fn.happy(this.source.price);
            }
          },
          'bbn-cms-carousel-control': {
            template: `
            <div class="bbn-r control">
              <span>
                <i @click="prev" class="prev nf nf-oct-chevron_left"></i>
                <i @click="next" class="next nf nf-oct-chevron_right"></i>
              </span>
            </div>`,
            methods: {
              next() {
                if (this.$parent.currentCarouselIdx < this.$parent.carouselSource.length - 1) {
                  this.$parent.currentCarouselIdx++;
                }
              },
              prev() {
                if (this.$parent.currentCarouselIdx > 0) {
                  this.$parent.currentCarouselIdx--;
                }
              }
            }
          },
          //internal component for align buttons in edit of the block
          'bbn-block-align-buttons': {
            template: `
            <div>
              <bbn-button icon="nf nf-fa-align_left"
                          :title="_('Align left')"
                          :notext="true"
                          @click="align = 'left'"
                          :class="{'bbn-state-active': ($parent.source.align === 'left')}"
              ></bbn-button>
              <bbn-button icon="nf nf-fa-align_center" :title="_('Align left')"
                          :notext="true"
                          @click="align = 'center'"
                          :class="{'bbn-state-active': ($parent.source.align === 'center')}"
              ></bbn-button>
              <bbn-button icon="nf nf-fa-align_right"
                          :title="_('Align left')"
                          :notext="true"
                          @click="align = 'right'"
                          :class="{'bbn-state-active': ($parent.source.align === 'right')}"
              ></bbn-button>
            </div>`,
            data() {
              return {
                align: ''
              };
            },
            watch: {
              align(val) {
                this.$parent.source.align = val;
                this.$parent.$parent.$forceUpdate();
              }
            }
          }
        },
        watch: {
          'source.columns': {
            handler(val) {
              this.makeSquareImg();
            }
          }
        },
        beforeMount() {
          if (bbn.fn.isEmpty(this.source.style)) {
            this.source.style = {};
          }
          if (this.$parent.edit) {
            if (this.source.type === 'image' && this.source.content && this.source.content.length) {
              let extension = bbn.fn.substr(this.source.content, this.source.content.lastIndexOf('.'), this.source.content.length);
              //take the correct size
              this.image.push({
                "name": this.source.content,
                "size": 574906,
                "extension": extension
              });
            } else if (this.source.type === 'gallery' && this.source.content && this.source.content.length) {
              /*this.image = bbn.fn.map(this.source.content, a => {
                let extension = bbn.fn.substr(a.src, a.src.lastIndexOf('.'), a.src.length);
                a.name = a.src;
                a.size = 465464;
                a.extension = extension;
                return a
              })*/
            }
          }
        },
        mounted() {
          if (this.source.type === 'gallery' || this.source.type === 'carousel') {
            this.makeSquareImg();
          }
        }
      };
    }
  },
  mounted() {
    this.initialSource = bbn.fn.extend({}, this.source);
    this.ready = true;
    if (bbn.fn.isEmpty(this.source.style)) {
      bbn.fn.warning(this.source.type + "  HAS STYLE WHICH IS EMPTY?");
      this.source.style = {};
    }
    if (bbn.fn.isEmpty(this.source.style) || !this.source.style.color) {
      this.source.style.color = '';
    }
    if (!this.source.align) {
      this.source.align = 'left';
    }
    if (bbn.fn.isEmpty(this.source.style) || !this.source.style.width) {
      this.source.width = '100%';
    }
    //if alignment is already defined as style property
    if (this.source.style && this.source.style.align) {
      this.source.align = this.source.style.align;
    }
    bbn.fn.log("I AM THE BLOCK! ", this.source);
  },
  watch: {
    changed() {
      bbn.fn.log("changed");
    },
    type() {
      bbn.fn.log("type");
    },
    edit(val) {
      /*
      //if adding a new block
      throw new Error('watch')
      if ( ( val === false ) && ( this.newBlock === true ) ){
        this.parent.source.lines.push(this.source)
        this.parent.lines.push({
          content: {
            data:  '<div>[CONTENT]</div>'
          },
          type: ''
        });
        appui.success(bbn._('New block ' + this.source.type + ' added!'))
        this.newBlock = false;
      }
      //this._setEvents()
      */
    }
  }
};
import cpHtml from './cms-block.html';
import cpStyle from './cms-block.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./cms-block.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-cms-block',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/*jshint esversion: 6 */
import { js_beautify, css_beautify, html_beautify } from "js-beautify";
import tern from "tern";
import { LanguageSupport } from "@codemirror/language";
import * as autocomplete from "@codemirror/autocomplete";
import * as commands from "@codemirror/commands";
import * as collaboration from "@codemirror/collab";
import * as language from "@codemirror/language";
import * as lint from "@codemirror/lint";
import * as state from "@codemirror/state";
import * as search from "@codemirror/search";
import * as view from "@codemirror/view";
import * as html from "@codemirror/lang-html";
import * as vue from "@codemirror/lang-vue";
import * as javascript from "@codemirror/lang-javascript";
import * as php from "@codemirror/lang-php";
import * as css from "@codemirror/lang-css";
import * as json from "@codemirror/lang-json";
import * as markdown from "@codemirror/lang-markdown";
import * as xml from "@codemirror/lang-xml";
import * as theme from "thememirror";
import { abbreviationTracker } from '@emmetio/codemirror6-plugin';
const languageExtensions = {
  javascript: [new LanguageSupport(javascript.javascriptLanguage)],
  html: [new LanguageSupport(html.htmlLanguage)],
  css: [new LanguageSupport(css.cssLanguage)],
  php: [new LanguageSupport(php.phpLanguage)],
  json: [new LanguageSupport(json.jsonLanguage)],
  markdown: [new LanguageSupport(markdown.markdownLanguage)],
  xml: [new LanguageSupport(xml.xmlLanguage)],
  vue: [new LanguageSupport(vue.vueLanguage)]
};
const codemirror6 = {
  autocomplete,
  commands,
  collaboration,
  language,
  languageExtensions,
  lint,
  state,
  search,
  view,
  vue,
  html,
  javascript,
  php,
  css,
  json,
  markdown,
  xml,
  theme,
  elmet: abbreviationTracker(),
  getBasicExtensions(cm) {
    if (!cm.ext) {
      cm.ext = {
        lineNumbers: cm.view.lineNumbers(),
        lineWrapping: cm.view.EditorView.lineWrapping,
        highlightActiveLineGutter: cm.view.highlightActiveLineGutter(),
        highlightSpecialChars: cm.view.highlightSpecialChars(),
        history: cm.commands.history(),
        foldGutter: cm.language.foldGutter(),
        drawSelection: cm.view.drawSelection(),
        dropCursor: cm.view.dropCursor(),
        allowMultipleSelections: cm.state.EditorState.allowMultipleSelections.of(true),
        indentOnInput: cm.language.indentOnInput(),
        syntaxHighlighting: cm.language.syntaxHighlighting(cm.language.defaultHighlightStyle, {
          fallback: true
        }),
        bracketMatching: cm.language.bracketMatching(),
        closeBrackets: cm.autocomplete.closeBrackets(),
        autocompletion: cm.autocomplete.autocompletion(),
        rectangularSelection: cm.view.rectangularSelection(),
        crosshairCursor: cm.view.crosshairCursor(),
        highlightSelectionMatches: cm.search.highlightSelectionMatches(),
        keymap: cm.view.keymap.of([...cm.autocomplete.closeBracketsKeymap, ...cm.commands.defaultKeymap, ...cm.search.searchKeymap, ...cm.commands.historyKeymap, ...cm.language.foldKeymap, ...cm.autocomplete.completionKeymap, ...cm.lint.lintKeymap, cm.commands.indentWithTab])
      };
    }
    return cm.ext;
  }
};

/**
 * @file bbn-code component
 *
 * @description bbn-code is a text editor.
 * It specializes in editing the code of a supported language.
 * Various tools are provided to the users, which can be configured to their liking.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    mode: {
      type: String,
      default: 'php'
    },
    theme: {
      type: String,
      default: 'dracula'
    },
    extensions: {
      type: Array,
      default: null
    },
    wrap: {
      type: Boolean,
      default: true
    },
    tabSize: {
      type: Number,
      default: 2
    }
  },
  data() {
    return {
      state: null,
      widget: null,
      compartments: bbnData.immunizeValue(bbn.fn.createObject())
    };
  },
  methods: {
    updateDoc() {
      this.$emit('update', this.currentDoc);
    },
    getExtensions() {
      var _this$extensions;
      if ((_this$extensions = this.extensions) !== null && _this$extensions !== void 0 && _this$extensions.length) {
        return this.extensions;
      }
      const cm = codemirror6;
      if (!this.mode || !this.theme) {
        throw new Error("You earmust provide a language and a theme");
      }
      if (!cm.languageExtensions[this.mode] && !['js', 'less', 'purephp'].includes(this.mode)) {
        throw new Error("Unknown language");
      }
      if (!cm.theme[this.theme]) {
        throw new Error("Unknown theme");
      }
      const extensions = [];
      const state = cm.state;
      const cpt = state.Compartment;
      this.compartments.wrap = new cpt();
      extensions.push(this.compartments.wrap.of(cm.view.EditorView.lineWrapping));
      this.compartments.tabSize = new cpt();
      extensions.push(this.compartments.tabSize.of(state.EditorState.tabSize.of(this.tabSize)));

      // push current language extension and current theme extension
      this.compartments.language = new cpt();
      if (this.mode === "js") {
        extensions.push(this.compartments.language.of(cm.javascript.javascript()));
      } else if (this.mode === "less") {
        extensions.push(this.compartments.language.of(cm.css.css()));
      } else if (this.mode === "purephp") {
        extensions.push(this.compartments.language.of(cm.php.php({
          plain: true
        })));
      } else if (cm.languageExtensions[this.mode]) {
        extensions.push(this.compartments.language.of(cm.languageExtensions[this.mode]));
      } else {
        throw new Error("Language unrecognized!");
      }
      this.compartments.theme = new cpt();
      extensions.push(this.compartments.theme.of(cm.theme[this.theme]));
      this.compartments.readonly = new cpt();
      extensions.push(this.compartments.readonly.of(state.EditorState.readOnly.of(this.disabled || this.readonly)));
      return extensions;
    },
    onChange(tr) {
      this.widget.update([tr]);
      let value = this.widget.state.doc.toString();
      if (value !== this.value) {
        this.emitInput(value);
      }
    },
    initUntilExtensionsLoaded(max) {
      this.init();
    },
    init() {
      let cm = codemirror6;
      let extensions = this.getExtensions();
      //bbn.fn.log("extensions", extensions, this.extensions);
      let editorStateCfg = {
        doc: this.value,
        extensions,
        readOnly: cm.state.EditorState.readOnly.of(this.readonly)
      };
      this.state = cm.state.EditorState.create(editorStateCfg);
      this.widget = new cm.view.EditorView(bbnData.immunizeValue({
        state: this.state,
        parent: this.getRef('element'),
        dispatch: t => this.onChange(t),
        lineWrapping: this.wrap
      }));
    },
    onKeyDown(event) {
      this.lastKeyDown = event;
      if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'f') {
        let newValue = "";
        if (['javascript', 'js'].includes(this.mode) && window.beautifier.js) {
          const options = {
            indent_size: 2,
            space_in_empty_paren: true
          };
          newValue = window.beautifier.js(this.widget.state.doc.toString(), options);
        } else if (['css', 'less'].includes(this.mode) && window.beautifier.css) {
          const options = {
            indent_size: 2,
            space_in_empty_paren: true
          };
          newValue = window.beautifier.css(this.widget.state.doc.toString(), options);
        } else if (['html'].includes(this.mode) && window.beautifier.html) {
          const options = {
            indent_size: 2,
            space_in_empty_paren: true,
            wrap_attributes: 'force-aligned'
          };
          newValue = window.beautifier.html(this.widget.state.doc.toString(), options);
        } else if (['php', 'purephp'].includes(this.mode)) {
          const options = {
            indent_size: 2,
            space_in_empty_paren: true
          };
          if (this.mode === 'purephp') {
            options.plain = true;
          }
          newValue = window.beautifier.html(this.widget.state.doc.toString(), options);
        }
        this.widget.dispatch({
          changes: {
            from: 0,
            to: this.widget.state.doc.toString().length,
            insert: newValue
          }
        });
      }
      if (event.key === ".") {
        codemirror6.autocomplete.startCompletion(this.widget);
      }
      this.$emit('keydown', event);
    },
    scrollBottom() {
      let sc = this.find('div.cm-scroller');
      if (sc) {
        sc.scrollTop = sc.scrollHeight;
      }
    }
  },
  mounted() {
    this.initUntilExtensionsLoaded(100);
  },
  watch: {
    tabSize(v) {
      this.widget.dispatch({
        effects: this.compartments.tabSize.reconfigure(codemirror6.state.EditorState.tabSize.of(v))
      });
    },
    wrap(v) {
      this.widget.dispatch({
        effects: this.compartments.wrap.reconfigure(codemirror6.view.EditorView.lineWrapping.of(v))
      });
    },
    readonly(v) {
      this.widget.dispatch({
        effects: this.compartments.readonly.reconfigure(codemirror6.state.EditorState.readOnly.of(v))
      });
    },
    value(nv) {
      if (this.widget) {
        let value = this.widget.state.doc.toString();
        if (value !== nv) {
          this.widget.dispatch({
            changes: {
              from: 0,
              to: this.widget.state.doc.length,
              insert: nv
            }
          });
        }
      }
    }
  }
};
import cpHtml from './code.html';
import cpStyle from './code.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./code.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
const def = {
  name: 'bbn-code',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
export { def as default, codemirror6, js_beautify, css_beautify, html_beautify, tern };
/**
 * @file bbn-collapsable-columns component
 * @description The bbn-collapsable-columns.
 * @copyright BBN Solutions
 * @author Mirko Argentino
 * @created 11/10/2022
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list],
  props: {
    /**
     * The component to use for the toolbar
     * @prop {String|Object|bbnCp} toolbar
     */
    toolbar: {
      type: [String, Object, Vue]
    },
    /**
     * The name of the property used to specify the color to use as the background
     * @prop {String} ['backgroundColor'] sourceBackgroundColor
     */
    sourceBackgroundColor: {
      type: String,
      default: 'backgroundColor'
    },
    /**
     * The name of the property used to specify the color to use for the font
     * @prop {String} ['fontColor'] sourceFontColor
     */
    sourceFontColor: {
      type: String,
      default: 'fontColor'
    },
    /**
     * The name of the property used to specify the component for the toolbar
     * @prop {String} ['toolbar'] sourceToolbar
     */
    sourceToolbar: {
      type: String,
      default: 'toolbar'
    },
    /**
     * The name of the property used to specify the item component
     * @prop {String} ['component'] sourceComponent
     */
    sourceComponent: {
      type: String,
      default: 'component'
    },
    /**
     * Defines the behaviour of the columns about the scroll.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * The column's width
     * @prop {Number|String} ['40rem'] columnWidth
     */
    columnWidth: {
      type: [Number, String],
      default: '40rem'
    },
    /**
     * Set to true allows the columns children to be filtered.
     * @prop {Boolean} [false] childrenFilterable
     */
    childrenFilterable: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the filters of the columns' children.
     * @prop {Object} [{logic: 'AND',conditions: []}] filters
     */
    childrenFilters: {
      type: [Object, Function],
      default() {
        return {
          logic: 'AND',
          conditions: []
        };
      }
    },
    /**
     * Set to true allows columns' children to be sortable.
     * @prop {Boolean} [false] childrenSortable
     */
    childrenSortable: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the order of the columns' children.
     * @prop {Array|Object} [[]] ChildrenOrder
     */
    childrenOrder: {
      type: [Array, Object],
      default() {
        return [];
      }
    },
    /**
     * On first dataloaded event collapse empty columns
     * @prop {Boolean} [true] collapseEmpty
     */
    collapseEmpty: {
      type: Boolean,
      default: true
    },
    /**
     * The options for the component
     * @prop {Object} componentOptions
     */
    componentOptions: {
      type: Object
    },
    /**
     * The name of the property used to specify the component's options of the item
     * @prop {String} ['componentOptions'] sourceComponentOptions
     */
    sourceComponentOptions: {
      type: String,
      default: 'componentOptions'
    },
    /**
     * The limit of rows to be shown in a page of the list.
     * @prop {Number} [0] limit
     */
    limit: {
      type: Number,
      default: 0
    },
    /**
     * The limit of rows to be shown in a page of the children list.
     * @prop {Number} [10] limit
     */
    childrenLimit: {
      type: Number,
      default: 10
    }
  },
  data() {
    return {
      /**
       * @data {Array} [[]] columns
       */
      columns: []
    };
  },
  methods: {
    /**
     * Normalizes the data
     * @method _map
     * @param {Array} data
     * @return {Array}
     */
    _map(data) {
      if (bbn.fn.isArray(data)) {
        if (data.length && !bbn.fn.isObject(data[0]) && !bbn.fn.isArray(data[0]) && this.sourceValue && this.sourceText) {
          data = data.map(a => {
            return {
              [this.sourceValue]: a,
              [this.sourceText]: a
            };
          });
        }
        data = data.map(a => {
          a.opened = false;
          return a;
        });
        return (this.map ? data.map(this.map) : data).slice();
      }
      return [];
    },
    /**
     * Collapses all columns
     * @method collapseAll
     */
    collapseAll() {
      bbn.fn.each(this.columns, c => {
        c.collapse();
      });
    },
    /**
     * Expands all columns
     * @method expandAll
     */
    expandAll() {
      bbn.fn.each(this.columns, c => {
        c.expand();
      });
    },
    /**
     * Fires setCheckCollapse method on every columns
     * @method setAllCheckCollapse
     */
    setAllCheckCollapse() {
      bbn.fn.each(this.columns, c => c.setCheckCollapse(true));
    },
    /**
     * Removes a column form the columns list
     * @method removeColumn
     * @param {Object} column
     */
    removeColumn(column) {
      if (this.columns.length && column.bbnUid) {
        let idx = bbn.fn.search(this.columns, 'bbnUid', column.bbnUid);
        if (idx > -1) {
          this.columns.splice(idx, 1);
        }
      }
    }
  }
};
import cpHtml from './collapsable-columns.html';
import cpStyle from './collapsable-columns.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./collapsable-columns.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-collapsable-columns',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
//* This component allows you to create an intuitive interface for color manipulations

/**
 * @file bbn-colorpicker component
 *
 * @description The bbn-colorpicker component contains a field that shows the currently selected color.
 * Clicking on the input field it displays a color chart. The set of colors can be customized using the palette property.
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 *
 * @created 10/02/2020
 */
import iro from '@jaames/iro';
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events, bbn.cp.mixins.resizer],
  props: {
    /**
     * The colorpicker's value.
     * @prop {String} value
     */
    value: {
      type: String
    },
    /**
     * Shows the coolors wheel.
     * @prop {Boolean} [true] wheel
     */
    wheel: {
      type: Boolean,
      default: true
    },
    /**
     * Show a colors slider instead of the wheel.
     * @prop {Boolean} [false] slider
     */
    slider: {
      tyoe: Boolean,
      default: false
    },
    /**
     * Shows the brightness slier
     * @prop {Boolean}.[true] brightness
     */
    brightness: {
      type: Boolean,
      default: true
    },
    /**
     * Shows the saturation slider.
     * @prop {Boolean} [true] saturation
     */
    saturation: {
      type: Boolean,
      default: true
    },
    /**
     * Shows the colors palette only.
     * @prop {Boolean} [false] onlyPalette
     */
    onlyPalette: {
      type: Boolean,
      default: false
    },
    /**
     * The initial color.
     * @prop {String} ['#FDFDFD'] color
     */
    color: {
      type: String,
      default: '#FDFDFD'
    },
    /**
     * Set it to true to show an input containing the color code.
     * @prop {Boolean} [true] showCodes
     */
    showCodes: {
      type: Boolean,
      default: true
    },
    /**
     * An array containing the list of colors by hex, rgb, rgba, or hsl.
     * @prop {Array} palette
     */
    palette: {
      type: Array,
      default() {
        return bbn.var.colors ? Object.values(bbn.var.colors) : [];
      }
    },
    /**
     * Shows a button that empties the selection when clicked.
     * @prop {Boolean} [true] emptyButton
     */
    emptyButton: {
      type: Boolean,
      default: true
    },
    /**
     * Defines the color code.
     * Accepted values: 'hex', 'rgb', 'rgba', 'hsl'.
     * @prop {String} ['hex'] codeColor
     */
    codeColor: {
      type: String,
      default: "hex",
      validator: c => ['hex', 'rgb', 'rgba', 'hsl'].includes(c)
    },
    /**
     * Clicking a palette element will automatically select the color and close the widget.
     * @prop {Boolean} [false] autoSelect
     */
    autoSelect: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data widget
       */
      widget: false,
      /**
       * @data {Boolean} [false] showFloater
       */
      showFloater: false,
      /**
       * @data {Boolean} [false] showPalette
       */
      showPalette: this.onlyPalette || this.palette.length,
      /**
       * @data {String} currentValue
       */
      currentValue: this.value,
      /**
       * @data {String} [''] currentHex
       */
      currentHex: '',
      /**
       * @data {String} [''] currentRgb
       */
      currentRgb: '',
      /**
       * @data {String} [''] currentRgba
       */
      currentRgba: '',
      /**
       * @data {String} [''] currentHsl
       */
      currentHsl: '',
      /**
       * @data {Boolean|Number} [false] initTimeout
       */
      initTimeout: false
    };
  },
  computed: {
    /**
     * The widget configuration.
     * @computed currentCfg
     * @return {Object}
     */
    currentCfg() {
      let obj = {
        handleRadius: 6,
        color: this.value || this.color,
        layout: []
      };
      if (this.wheel && !this.slider && !this.onlyPalette) {
        obj.layout.push({
          component: iro.ui.Wheel
        });
      } else if (!this.onlyPalette) {
        obj.layout.push({
          component: iro.ui.Slider,
          options: {
            sliderType: 'hue'
          }
        });
      }
      if (this.brightness && !this.onlyPalette) {
        obj.layout.push({
          component: iro.ui.Slider
        });
      }
      if (this.saturation && !this.onlyPalette) {
        obj.layout.push({
          component: iro.ui.Slider,
          options: {
            sliderType: 'saturation'
          }
        });
      }
      return obj;
    }
  },
  methods: {
    /**
     * The method called at the window resize event.
     * @method onResize
     * @fires init
     */
    onResize() {
      this.$nextTick(() => {
        this.init();
      });
    },
    /**
     * Initializes the widget.
     * @method init
     * @fires destroy
     * @fires setEvents
     * @fires getRef
     */
    init() {
      if (this.widget) {
        this.destroy();
      }
      clearTimeout(this.initTimeout);
      this.initTimeout = setTimeout(() => {
        let el = this.getRef('picker');
        if (el) {
          let parent = el.offsetParent;
          let width;
          if (parent) {
            width = parent.getBoundingClientRect().width - 100;
          } else {
            width = 400;
          }
          this.widget = new iro.ColorPicker(el, bbn.fn.extend(true, {
            width: width
          }, this.currentCfg));
          this.setEvents();
        }
      }, 300);
    },
    /**
     * Sets the current values.
     * @method setCurrents
     */
    setCurrents(color) {
      if (bbn.fn.isObject(color)) {
        this.currentHex = color.hexString;
        this.currentRgb = color.rgbString;
        this.currentRgba = color.rgbaString;
        this.currentHsl = color.hslString;
        switch (this.codeColor) {
          case 'hex':
            this.currentValue = this.currentHex;
            break;
          case 'rgb':
            this.currentValue = this.currentRgb;
            break;
          case 'rgba':
            this.currentValue = this.currentRgba;
            break;
          case 'hsl':
            this.currentValue = this.currentHsl;
            break;
        }
      } else {
        this.currentHex = '';
        this.currentRgb = '';
        this.currentRgba = '';
        this.currentHsl = '';
        this.currentValue = '';
      }
    },
    /**
     * Sets the events to the widget.
     * @method setEvents
     * @fires setCurrents
     */
    setEvents() {
      this.widget.on('mount', cp => {
        if (this.value) {
          this.setCurrents(cp.color);
        }
        cp.on('color:change', color => {
          this.setCurrents(color);
        });
      });
    },
    /**
     * Unsets the widget's events.
     * @method unsetEvents
     */
    unsetEvents() {
      if (this.widget) {
        this.widget.off('color:change');
      }
    },
    /**
     * Destroys the widget.
     * @method destroy
     * @fires unsetEvents
     */
    destroy() {
      if (this.widget) {
        this.unsetEvents();
        this.widget.base.remove();
        this.widget = false;
      }
    },
    /**
     * Empties the current calue.
     * @method empty
     * @fires setCurrents
     */
    empty() {
      this.setCurrents();
    },
    /**
     * Sets the component value.
     * @method save
     * @emit input
     * @emit change
     */
    save() {
      if (this.value !== this.currentValue) {
        this.emitInput(this.currentValue || (this.nullable ? null : ''));
        this.$emit('change', this.currentValue);
      }
      this.showFloater = false;
    },
    /**
     * Sets the color to the widget.
     * @method setColor
     */
    setColor(color) {
      this.widget.color.set(color);
      if (this.autoSelect) {
        this.$nextTick(() => {
          this.save();
        });
      }
    },
    /**
     * Sets the color inserted from the inputs.
     * @method fromInput
     * @fires setColor
     */
    fromInput(event) {
      this.setColor(event.target.value);
    },
    /**
     * Opens/closes the floater.
     * @method openCloseFloater
     */
    openCloseFloater() {
      if (this.showFloater) {
        this.showFloater = false;
      } else if (!this.isDisabled && !this.readonly) {
        this.showFloater = true;
      }
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    if (!window.iro) {
      bbn.fn.error("IRO NEEDED!!");
    }
    this.ready = true;
  },
  /**
   * @event beforeDestroy
   * @fires destroy
   */
  beforeDestroy() {
    this.destroy();
  }
};
import cpHtml from './colorpicker.html';
import cpStyle from './colorpicker.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./colorpicker.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
const def = {
  name: 'bbn-colorpicker',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
export { def as default, iro };
"use strict";

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keepCool
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.keepCool, bbn.cp.mixins.resizer],
  props: {
    /**
     * @prop {Number} index
     */
    index: {
      type: Number
    },
    /**
     * @prop {Boolean} [false] collapsable
     */
    collapsable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] autoCollapse
     */
    autoCollapse: {
      type: Boolean,
      default: false
    },
    /**
     * The width
     * @prop {Number|String} ['100%'] width
     */
    width: {
      type: [Number, String],
      default: '100%'
    },
    /**
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} backgroundColor
     */
    backgroundColor: {
      type: String
    },
    /**
     * @prop {String} fontColor
     */
    fontColor: {
      type: String
    },
    /**
     * @prop {String} title
     */
    title: {
      type: String
    },
    /**
     * @prop {String|bbnCp|Object} toolbar
     */
    toolbar: {
      type: [String, Vue, Object]
    },
    /**
     * @prop {Object} toolbarSource
     */
    toolbarSource: {
      type: Object
    },
    /**
     * The options for the component
     * @prop {Object} componentOptions
     */
    componentOptions: {
      type: Object
    },
    /**
     * @prop {Boolean} [false] startHidden
     */
    startHidden: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} isVisible
       */
      isVisible: !this.startHidden,
      /**
       * @data {Boolean} [false] collapsed
       */
      collapsed: false
    };
  },
  computed: {
    /**
     * @computed items
     */
    items() {
      if (this.pageable && (!this.isAjax || !this.serverPaging)) {
        return this.filteredData.slice().splice(this.start, this.currentLimit);
      }
      return this.filteredData;
    },
    /**
     * @computed headerVisible
     */
    headerVisible() {
      return !!this.collapsable || this.title !== undefined || !!this.toolbar;
    }
  },
  methods: {
    /**
     * @method setCheckCollapse
     * @param {Boolean} force
     * @fires $once
     * @fires expand
     * @fires collapse
     */
    setCheckCollapse(force) {
      if (this.autoCollapse || force) {
        this.$once('dataloaded', () => {
          if (this.filteredData.length) {
            this.expand(force);
          } else {
            this.collapse(force);
          }
        });
      }
    },
    /**
     * @method expand
     * @param {Boolean} force
     * @emits expanded
     */
    expand(force) {
      if (this.collapsable || force) {
        this.collapsed = false;
        this.$emit('expanded', this);
      }
    },
    /**
     * @method collapse
     * @param {Boolean} force
     * @emits collapsed
     */
    collapse(force) {
      if (this.collapsable || force) {
        this.collapsed = true;
        this.$emit('collapsed', this);
      }
    },
    /**
     * @method expandAll
     * @fires findAll
     */
    expandAll() {
      if (!!this.component && this.currentData.length) {
        let items = this.findAll(this.component);
        bbn.fn.each(items, item => {
          item.$set(item, 'collapsed', false);
        });
      }
    },
    /**
     * @method collapsedAll
     * @fires findAll
     */
    collapseAll() {
      if (!!this.component && this.currentData.length) {
        let items = this.findAll(this.component);
        bbn.fn.each(items, item => {
          item.$set(item, 'collapsed', true);
        });
      }
    }
  },
  /**
   * @event beforeMount
   * @fires setCheckCollapse
   * @emits beforemount
   */
  beforeMount() {
    if (this.collapsable) {
      this.setCheckCollapse();
    }
    this.$emit('beforemount', this);
  },
  /**
   * @event mounted
   * @fires $nextTick
   */
  mounted() {
    this.$nextTick(() => {
      this.ready = true;
    });
  },
  /**
   * @event beforeDestroy
   * @emits beforedestroy
   */
  beforeDestroy() {
    this.$emit('beforedestroy', this);
  },
  watch: {
    /**
     * @watch data
     * @fires updateData
     */
    data: {
      deep: true,
      handler() {
        this.updateData();
      }
    },
    /**
     * @watch isLoaded
     * @fires $once
     */
    isLoaded: {
      immediate: true,
      handler(newVal) {
        if (this.startHidden) {
          this.$once('dataloaded', () => {
            this.isVisible = true;
          });
        }
      }
    },
    /**
     * @watch currentPage
     * @fires closest
     * @fires $once
     */
    currentPage(newVal) {
      if (!this.scrollable) {
        let externalScroll = this.closest('bbn-scroll');
        if (externalScroll && externalScroll.hasScrollY) {
          this.$once('dataloaded', () => {
            externalScroll.scrollTo(null, this.$el);
          });
        }
      }
    }
  }
};
import cpHtml from './column-list.html';
import cpStyle from './column-list.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./column-list.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-column-list',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-combo component
 * @description The easy-to-implement bbn-combo component allows you to choose a single value from a user-supplied list or to write new.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
   * @mixin bbn.cp.mixins.dropdown
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input, bbn.cp.mixins.resizer, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.url, bbn.cp.mixins.dropdown],
  props: {
    /**
     * Set to true allows the columns of the list to be filtered. A filter icon will appear at the top of each column.The property can be given to each column to define different behaviour.
     * @prop {Boolean} [true] filterable
     */
    filterable: {
      type: Boolean,
      default: true
    },
    /**
     * To define the length of the string to start the filter.
     *
     * @prop {Number} [0] minLength
     */
    minLength: {
      type: Number,
      default: 0
    },
    /**
     * Specifies the time of delay.
     *
     * @prop {Number} [10] delay
     */
    delay: {
      type: Number,
      default: 10
    }
  },
  methods: {
    /**
     * Puts the focus on the element.
     *
     * @method click
     * @fires getRef
     */
    click() {
      if (!this.isDisabled && !this.readnly) {
        this.getRef('input').focus();
        if (this.filteredData.length) {
          this.isOpened = !this.isOpened;
        }
      }
    },
    /**
     * Remove the filter and close the list if it is notabove it.
     *
     * @method leave
     * @fires getRef
     */
    leave() {
      if (this.isOpened && !this.getRef('list').isOver) {
        this.isOpened = false;
      }
    },
    /**
     * Emits the event 'select'
     * @method select
     * @param {Object} item
     * @fires emitInput
     * @fires getRef
     * @emit change
     */
    select(item) {
      if (item && item[this.sourceValue] !== undefined) {
        this.writing = false;
        this.emitInput(item[this.sourceValue]);
        this.$emit('change', item[this.sourceValue]);
        this.filterString = item[this.sourceText];
        this.$nextTick(() => {
          this.getRef('input').focus();
        });
      }
      this.isOpened = false;
    },
    /**
     * Select the string of text inside of the input.
     * @method selectText
     * @fires getRef
     */
    selectText() {
      this.getRef('input').selectText();
    },
    /**
     * Function to do the reset and if the component is open it closes it.
     *
     * @method resetDropdown
     * @fires unfilter
     */
    resetDropdown() {
      this.filterString = this.currentTextValue;
      this.unfilter();
      if (this.isOpened) {
        this.isOpened = false;
      }
    },
    /**
     * Function that performs different actions based on what is being pressed.
     *
     * @method keydown
     * @param {Event} e
     * @fires resetDropdown
     * @fires commonKeydown
     * @fires keynav
     */
    keydown(e) {
      if (e.key === 'Tab') {
        let list = this.getRef('list');
        list = list ? list.getRef('list') : {};
        if (list.overIdx > -1) {
          this.filterString = list.filteredData[list.overIdx].data[this.sourceValue];
          return;
        }
      }
      if (e.key === ' ' || this.commonKeydown(e)) {
        return;
      }
      if (e.key === 'Escape') {
        this.resetDropdown();
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      } else if (!this.isDisabled || !this.readonly) {
        this.writing = true;
      }
    }
  },
  /**
   * @event created
   * @fires emitInput
   */
  created() {
    this.$on('dataloaded', () => {
      if (this.value !== undefined) {
        let row = bbn.fn.getRow(this.currentData, a => {
          return a.data[this.sourceValue] === this.value;
        });
        if (row) {
          this.currentText = row.data[this.sourceText];
        }
      }
      if (!this.currentText && !this.isNullable && this.filteredData.length) {
        this.emitInput(this.filteredData[0][this.sourceValue]);
      }
    });
  },
  watch: {
    /**
     * @watch filterString
     * @param {String} v
     * @fires onResize
     * @fires unfilter
     * @fires emitInput
     */
    filterString(v) {
      if (!this.ready) {
        this.ready = true;
      }
      clearTimeout(this.filterTimeout);
      if (this.writing) {
        this.filterTimeout = setTimeout(() => {
          this.filterTimeout = false;
          if (this.isActive) {
            if (v && v.length >= this.minLength) {
              this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
                field: this.sourceText,
                operator: this.searchOperator,
                value: v
              });
            } else {
              this.unfilter();
              this.enptyData();
            }
          }
          this.emitInput(v);
        }, this.delay);
      }
    },
    filteredTotal() {
      let fl = this.getRef('list');
      if (this.isOpened && fl) {
        fl.fullResize();
      }
    }
  }
};
import cpHtml from './combo.html';
import cpStyle from './combo.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./combo.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-combo',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-container component
 *
 * @description bbn-container is a uniquely identified container component that can be used by bbn-tabnav.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 *
 * @created 15/02/2017
 */

/**
 * @component
 * @param {string} url - The URL on which the tabNav will be initialized.
 * @param {boolean} autoload - Defines if the tab will be automatically loaded based on URLs. False by default
 * except if it is true for the parent.
 * @param {string} orientation - The position of the tabs' titles: top (default) or bottom.
 * @param {string} root - The root URL of the tabNav, will be only taken into account for the top parents'
 * tabNav, will be automatically calculated for the children.
 * @param {boolean} scrollable - Sets if the tabs' titles will be scrollable in case they have a greater width
 * than the page (true), or if they will be shown multilines (false, default).
 * @param {array} source - The tabs shown at init.
 * @param {string} current - The URL to which the tabnav currently corresponds (its selected tab).
 * @param {string} baseURL - The parent TabNav's URL (if any) on top of which the tabNav has been built.
 * @param {array} parents - The tabs shown at init.
 * @param {array} tabs - The tabs configuration and state.
 * @param {boolean} parentTab - If the tabNav has a tabNav parent, the tab Vue object in which it stands, false
 * otherwise.
 * @param {boolean|number} selected - The index of the currently selected tab, and false otherwise.
 */

const cpDef = {
  name: 'bbn-container',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.observer
   */
  statics() {
    return {
      componentsList: []
    };
  },
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.observer],
  props: {
    /**
     * The index of the container
     * @prop {Number} idx
     */
    idx: {
      type: Number
    },
    /**
     * The timestamp of the last activation
     * @prop {Number} last
     */
    last: {
      type: Number
    },
    /**
     * A unique id for the container that will ben used as index by the router
     * @prop {String} uid
     */
    uid: {
      type: String,
      default() {
        return bbn.fn.randomString();
      }
    },
    /**
     * A unique id for the container that will ben used as index by the router
     * @prop {String} uid
     */
    visual: {
      type: Boolean,
      default: false
    },
    /**
     * Time between 2 automatic screenshot in visual mode, in milliseconds
     * @prop {Number} [43200000] screenshotDelay (12 hours)
     */
    screenshotDelay: {
      type: Number,
      default: 43200000
    },
    pane: {},
    error: {},
    component: {},
    /**
     * The source of the component.
     * @prop {Object|Function} source
     */
    source: {
      type: [Array, Object, String, Function]
    },
    /**
     * The title of the component.
     * @prop {String|Number} ['Untitled'] title
     */
    title: {
      type: [String, Number],
      default: bbn._("Untitled")
    },
    /**
     * The options object of the component.
     * @prop {Object} options
     */
    options: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Defines if the component has to be cached.
     * @prop {Boolean} [false] cached
     */
    cached: {
      type: Boolean,
      default: false
    },
    /**
     * Defines if the component has to be scrollable.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the component to use.
     * @prop component
     */
    component: {
      type: [String, Object, Function]
    },
    /**
     * Defines the icon.
     * @prop {String|Boolean} icon
     */
    icon: {
      type: [String, Boolean]
    },
    /**
     * Defines if the component can have a text.
     * @prop {Boolean} [false] notext
     */
    notext: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the component's content.
     * @prop {String} [''] content
     */
    content: {
      type: String,
      default: ""
    },
    /**
     * Defines the menu.
     * @prop {Array|Function} menu
     */
    menu: {
      type: [Array, Function, Boolean]
    },
    /**
     * Defines if the component is loaded.
     * @prop {Boolean} loaded
     */
    loaded: {
      type: Boolean,
      default: false
    },
    /**
     * Tells if the component is currently loading.
     * @prop {Boolean} loading
     */
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the component's fcolor.
     * @prop {String} fcolor
     */
    fcolor: {
      type: String
    },
    /**
     * Defines the component's bcolor.
     * @prop {String} bcolor
     */
    bcolor: {
      type: String
    },
    /**
     * @prop {Boolean} [false] load
     */
    load: {
      type: Boolean,
      default: false
    },
    /**
     * Defines if the component has to be selected.
     * @prop {Boolean|Number} [false] selected
     */
    selected: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Defines the css string for the component.
     * @prop {String} [''] css
     */
    css: {
      type: String,
      default: ""
    },
    /**
     * @prop {String|Object} advert
     */
    advert: {
      type: [String, Object]
    },
    /**
     * @prop {String} help
     */
    help: {
      type: String
    },
    /**
     * @prop {Array} imessages
     */
    imessages: {
      type: [Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop script
     */
    script: {},
    /**
     * Defines if the component has to be fixed.
     * @prop {Boolean|Number} [false] fixed
     */
    fixed: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Defines
     if the component has to be pinned.
      * @prop {Boolean|Number} [false] pinned
        */
    pinned: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Defines the url.
     * @prop {String|Number} url
     */
    url: {
      type: [String, Number]
    },
    /**
     * @prop current
     * @prop {String|Number} current
     */
    current: {
      type: [String, Number]
    },
    /**
     * @prop {Boolean} [true] real
     */
    real: {
      type: Boolean,
      default: true
    },
    /**
     * The object of configuration for the component
     * @prop {Object} cfg
     */
    cfg: {
      type: Object
    },
    /**
     * @prop {Object} events
     */
    events: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Defines if the component is disabled.
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: [Boolean, Function],
      default: false
    },
    /**
     * Defines if the component is hidden.
     * @prop {Boolean} [false] hidden
     */
    hidden: {
      type: [Boolean, Function],
      default: false
    },
    portal: {
      type: [String, HTMLElement, Boolean],
      default: false
    }
  },
  data() {
    return {
      /**
       * The router which the container belongs to if it exists.
       * @data [null] router
       */
      router: null,
      /**
       * True if the data changes and is unsaved.
       * @data {Boolan} [false] dirty
       */
      dirty: false,
      /**
       * True if the container is a componenent.
       * @data [null] isComponent
       */
      isComponent: null,
      /**
       * True if the container is fullscreen.
       * @data {Boolean} [false] fullScreen
       */
      fullScreen: false,
      /**
       * A random unique component name.
       * @data {String} [this.randomName()] componentName
       */
      componentName: this.randomName(),
      /**
       * The array containing popup objects.
       * @data {Array} [[]] popups
       */
      popups: [],
      /**
      * An object with each mounted children router.
      * @data {Object} [{}] routers
      */
      routers: {},
      /**
      * Time between 2 automatic screenshot in visual mode, in milliseconds
      * @data {Number} currentScreenshotDelay
      */
      currentScreenshotDelay: this.screenshotDelay,
      /**
       * @todo not used
       */
      isComponentActive: false,
      /**
       * True when the component finishes loading.
       * @data {Boolean} isLoaded
       */
      isLoaded: !this.load || this.loaded,
      /**
       * True if the container is pinned.
       * @data {Boolean} isPinned
       */
      isPinned: this.pinned,
      /**
       * True if the container is fixed.
       * @data {Boolean} isStatic
       */
      isFixed: this.fixed,
      /**
       * The current url.
       * @data {String} currentURL
       */
      currentURL: this.current || this.url,
      /**
       * Reacts to mouse movements.
       * @data {Boolean} isOver
       */
      isOver: false,
      /**
       * The closest bbn-container if any.
       * @data {Object|null} _bbn_container
       */
      _bbn_container: null,
      /**
       * The base 64 encoded thumbnail image.
       * @data {String} thumbnail
       */
      thumbnail: false,
      /**
       * A list of form components contained in this container
       * @data {Array} [[]] forms
       */
      forms: [],
      /**
       * The error status if loading goes bad.
       * @data {null|Object} errorStatus
       */
      errorStatus: null,
      componentDefinition: false,
      componentTemplate: false,
      componentCSS: false,
      currentIndex: this.idx || null
    };
  },
  computed: {
    /**
     * Defines the css string for the component.
     * @prop {String} [''] css
     */
    currentCss: {
      get() {
        var _this$currentView;
        return ((_this$currentView = this.currentView) === null || _this$currentView === void 0 ? void 0 : _this$currentView.css) || '';
      },
      set(v) {
        if (this.currentView) {
          this.currentView.css = v;
        }
      }
    },
    /**
     * The source of the component.
     * @prop {Object|Function} source
     */
    currentSource: {
      get() {
        var _this$currentView2;
        return ((_this$currentView2 = this.currentView) === null || _this$currentView2 === void 0 ? void 0 : _this$currentView2.source) || undefined;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.source = v;
        }
      }
    },
    /**
     * The title of the component.
     * @prop {String|Number} ['Untitled'] title
     */
    currentTitle: {
      get() {
        var _this$currentView3;
        return ((_this$currentView3 = this.currentView) === null || _this$currentView3 === void 0 ? void 0 : _this$currentView3.title) || bbn._('Untitled');
      },
      set(v) {
        if (this.currentView) {
          this.currentView.title = v;
        }
      }
    },
    /**
     * The options object of the component.
     * @prop {Object} options
     */
    currentOptions: {
      get() {
        var _this$currentView4;
        return ((_this$currentView4 = this.currentView) === null || _this$currentView4 === void 0 ? void 0 : _this$currentView4.options) || {};
      },
      set(v) {
        if (this.currentView) {
          this.currentView.options = v;
        }
      }
    },
    /**
     * Defines if the component has to be cached.
     * @prop {Boolean} [false] cached
     */
    currentCached: {
      get() {
        var _this$currentView5;
        return ((_this$currentView5 = this.currentView) === null || _this$currentView5 === void 0 ? void 0 : _this$currentView5.cached) || false;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.cached = v;
        }
      }
    },
    /**
     * Defines if the component has to be scrollable.
     * @prop {Boolean} [true] scrollable
     */
    currentScrollable: {
      get() {
        var _this$currentView6;
        return ((_this$currentView6 = this.currentView) === null || _this$currentView6 === void 0 ? void 0 : _this$currentView6.scrollable) || true;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.scrollable = v;
        }
      }
    },
    /**
     * Defines the component to use.
     * @prop component
     */
    currentComponent: {
      get() {
        var _this$currentView7;
        return ((_this$currentView7 = this.currentView) === null || _this$currentView7 === void 0 ? void 0 : _this$currentView7.component) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.component = v;
        }
      }
    },
    /**
     * Defines the icon.
     * @prop {String|Boolean} icon
     */
    currentIcon: {
      get() {
        var _this$currentView8;
        return ((_this$currentView8 = this.currentView) === null || _this$currentView8 === void 0 ? void 0 : _this$currentView8.icon) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.icon = v;
        }
      }
    },
    /**
     * Defines if the component can have a text.
     * @prop {Boolean} [false] notext
     */
    currentNotext: {
      get() {
        var _this$currentView9;
        return ((_this$currentView9 = this.currentView) === null || _this$currentView9 === void 0 ? void 0 : _this$currentView9.notext) || false;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.notext = v;
        }
      }
    },
    /**
     * Defines the component's content.
     * @prop {String} [''] content
     */
    currentContent: {
      get() {
        var _this$currentView10;
        return ((_this$currentView10 = this.currentView) === null || _this$currentView10 === void 0 ? void 0 : _this$currentView10.content) || '';
      },
      set(v) {
        if (this.currentView) {
          this.currentView.content = v;
        }
      }
    },
    /**
     * Defines the menu.
     * @prop {Array|Function} menu
     */
    currentMenu: {
      get() {
        var _this$currentView11;
        return ((_this$currentView11 = this.currentView) === null || _this$currentView11 === void 0 ? void 0 : _this$currentView11.menu) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.menu = v;
        }
      }
    },
    /**
     * Defines the component's fcolor.
     * @prop {String} fcolor
     */
    currentFcolor: {
      get() {
        var _this$currentView12;
        return ((_this$currentView12 = this.currentView) === null || _this$currentView12 === void 0 ? void 0 : _this$currentView12.fcolor) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.fcolor = v;
        }
      }
    },
    /**
     * Defines the component's bcolor.
     * @prop {String} bcolor
     */
    currentBcolor: {
      get() {
        var _this$currentView13;
        return ((_this$currentView13 = this.currentView) === null || _this$currentView13 === void 0 ? void 0 : _this$currentView13.bcolor) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.bcolor = v;
        }
      }
    },
    /**
     * @prop {String|Object} advert
     */
    currentAdvert: {
      get() {
        var _this$currentView14;
        return ((_this$currentView14 = this.currentView) === null || _this$currentView14 === void 0 ? void 0 : _this$currentView14.advert) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.advert = v;
        }
      }
    },
    /**
     * @prop {String} help
     */
    currentHelp: {
      get() {
        var _this$currentView15;
        return ((_this$currentView15 = this.currentView) === null || _this$currentView15 === void 0 ? void 0 : _this$currentView15.help) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.help = v;
        }
      }
    },
    /**
     * @prop {Array} imessages
     */
    currentImessages: {
      get() {
        var _this$currentView16;
        return ((_this$currentView16 = this.currentView) === null || _this$currentView16 === void 0 ? void 0 : _this$currentView16.imessages) || [];
      },
      set(v) {
        if (this.currentView) {
          this.currentView.imessages = v;
        }
      }
    },
    /**
     * @prop script
     */
    currentScript: {
      get() {
        var _this$currentView17;
        return ((_this$currentView17 = this.currentView) === null || _this$currentView17 === void 0 ? void 0 : _this$currentView17.script) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.script = v;
        }
      }
    },
    /**
     * @prop current
     * @prop {String|Number} current
     */
    currentCurrent: {
      get() {
        var _this$currentView18;
        return ((_this$currentView18 = this.currentView) === null || _this$currentView18 === void 0 ? void 0 : _this$currentView18.current) || null;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.current = v;
        }
      }
    },
    /**
     * The object of configuration for the component
     * @prop {Object} cfg
     */
    currentCfg: {
      get() {
        var _this$currentView19;
        return ((_this$currentView19 = this.currentView) === null || _this$currentView19 === void 0 ? void 0 : _this$currentView19.cfg) || {};
      },
      set(v) {
        if (this.currentView) {
          this.currentView.cfg = v;
        }
      }
    },
    /**
     * @prop {Object} events
     */
    currentEvents: {
      get() {
        var _this$currentView20;
        return ((_this$currentView20 = this.currentView) === null || _this$currentView20 === void 0 ? void 0 : _this$currentView20.events) || {};
      },
      set(v) {
        if (this.currentView) {
          this.currentView.events = v;
        }
      }
    },
    /**
     * Defines if the component is disabled.
     * @prop {Boolean} [false] disabled
     */
    currentDisabled: {
      get() {
        var _this$currentView21;
        return ((_this$currentView21 = this.currentView) === null || _this$currentView21 === void 0 ? void 0 : _this$currentView21.disabled) || false;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.disabled = v;
        }
      }
    },
    /**
     * Defines if the component is hidden.
     * @prop {Boolean} [false] hidden
     */
    currentHidden: {
      get() {
        var _this$currentView22;
        return ((_this$currentView22 = this.currentView) === null || _this$currentView22 === void 0 ? void 0 : _this$currentView22.hidden) || false;
      },
      set(v) {
        if (this.currentView) {
          this.currentView.hidden = v;
        }
      }
    },
    /**
     * True if the router configuration object has pane (ie is in a splitter pane).
     * @data {Boolean} [false] isVisible
     */
    isPane() {
      var _this$currentView23;
      return !!((_this$currentView23 = this.currentView) !== null && _this$currentView23 !== void 0 && _this$currentView23.pane);
    },
    currentView() {
      if (!this.router) {
        this.router = this.closest('bbn-router');
      }
      if (this.router) {
        return bbn.fn.getRow(this.router.views, {
          idx: this.currentIndex
        });
      }
      return null;
    },
    /**
     * True if the container is shown.
     * @data {Boolean} [false] isVisible
     */
    isVisible() {
      if (this.router) {
        if (this.isPane) {
          if (!this.router.routed) {
            return false;
          }
          if (this.isLoaded) {
            return true;
          }
          let pane = bbn.fn.getRow(this.router.currentPanes, {
            id: this.currentView.pane
          });
          if (pane) {
            let idx = bbn.fn.search(pane.tabs, {
              url: this.currentView.url
            });
            if (pane.tabs[idx]) {
              return idx === pane.selected;
            }
          }
          return this.router.routed && this.isPane || this.router.selected === this.currentIndex;
        } else {
          return this.router.selected === this.currentIndex;
        }
      }
      return false;
    },
    isVisualVisible() {
      var _this$router;
      if ((_this$router = this.router) !== null && _this$router !== void 0 && _this$router.isVisual) {
        let row = bbn.fn.getRow(this.router.visualList, 'view.idx', this.currentIndex);
        if (row) {
          return row.visible;
        }
      }
      return false;
    },
    visualStyle() {
      let r = this.router;
      if (r && r.isVisual) {
        if (r.numVisualReals > 0 && (!this.isVisible || r.visualShowAll) && (!this.ready || !this.isPane)) {
          return {
            zoom: 0.1,
            width: '100%',
            height: 'auto',
            overflow: 'hidden'
          };
        }
        let coord = [1, r.numVisualCols + 1, 1, r.numVisualRows + 1];
        if (r.numVisualReals > 0) {
          switch (r.visualOrientation) {
            case 'top':
              coord[2] = 2;
              break;
            case 'bottom':
              coord[3] = coord[3] - 1;
              break;
            case 'left':
              coord[0] = 2;
              break;
            case 'right':
              coord[1] = coord[1] - 1;
              break;
          }
        }
        return {
          gridColumnStart: coord[0],
          gridColumnEnd: coord[1],
          gridRowStart: coord[2],
          gridRowEnd: coord[3],
          zoom: 1
        };
      }
      return {};
    },
    anonComponent() {
      return this.$refs.component;
    }
  },
  methods: {
    /**
     * Returns the full current url.
     * 
     * @method getFullCurrentURL
     * @return {String}
     */
    getFullCurrentURL() {
      return this.router.getFullBaseURL() + this.currentURL;
    },
    /**
    * Returns the full url.
    * 
    * @method getFullURL
    * @return {String}
    */
    getFullURL() {
      return this.router.getFullBaseURL() + this.url;
    },
    /**
     * Sets the value of the property loaded to the given val.
     * 
     * @method setLoaded
     * @param {Boolean} val 
     */
    setLoaded(val) {
      this.isLoaded = !!val;
    },
    /**
     * Generates a random name used for the component.
     * 
     * @method randomName
     * @return {String}
     */
    randomName() {
      let n = bbn.fn.randomString(20, 15).toLowerCase();
      while (bbnContainerCp.componentsList.indexOf(n) > -1) {
        n = bbn.fn.randomString(20, 15).toLowerCase();
      }
      return n;
    },
    /**
     * Shows the container.
     * 
     * @method show
     */
    show() {
      if (!this.isPane) {
        this.router.selected = this.currentIndex;
        if (this.visual && this.router.visualShowAll) {
          this.router.visualShowAll = false;
        }
      }
    },
    close() {
      if (!this.isPane) {
        this.router.close(this.currentIndex);
      }
    },
    /**
     * Sets the current url.
     * 
     * @method setCurrent
     * @param {String} url 
     */
    setCurrent(url) {
      if (url.indexOf(this.url) === 0) {
        this.currentURL = url;
        return true;
      }
      return false;
    },
    /**
     * Sets the title of the container.
     * 
     * @method setTitle
     * @param {String} title 
     */
    setTitle(title) {
      if (this.router) {
        if (!this.real) {
          this.router.views[this.currentIndex].title = title;
        } else {
          this.currentTitle = title;
        }
      }
    },
    /**
     * Sets the icon of the container.
     * 
     * @method setIcon
     * @param {String} title 
     */
    setIcon(icon) {
      if (this.router) {
        if (!this.real) {
          this.router.views[this.currentIndex].icon = icon;
        } else {
          this.currentIcon = icon;
        }
      }
    },
    /**
     * Sets the color.
     * 
     * @method setColor
     * @param {String} bcolor 
     * @param {String} fcolor 
     */
    setColor(bcolor, fcolor) {
      if (this.router) {
        let view = this.router.getView(this.url);
        if (view) {
          if (bcolor) {
            this.router.$set(view, "bcolor", bcolor);
          }
          if (fcolor) {
            this.router.$set(view, "fcolor", fcolor);
          }
        }
      }
    },
    /**
     * Gets the popup object.
     *  
     * @method popup
     * @return {Object}
     */
    popup() {
      let popup = this.getPopup();
      return arguments.length ? popup.open.apply(popup, arguments) : popup;
    },
    /**
     * Gets the child component.
     * 
     * @method getComponent
     * @return {Object|Boolean}
     */
    getComponent() {
      return this.getRef('component');
    },
    /**
     * Fires the parent's method enter.
     * 
     * @method enter
     * @fires router.enter
     */
    enter() {
      this.router.enter(this);
    },
    pin() {
      this.router.pin(this.currentIndex);
    },
    unpin() {
      this.router.unpin(this.currentIndex);
    },
    /**
     * Fires the parent's method reload.
     * 
     * @method reload
     * @fires router.reload
     */
    reload() {
      this.popups.splice(0);
      this.$nextTick(() => {
        this.router.reload(this.currentIndex);
      });
    },
    /**
     * Handles the configuration of the container's menu.
     * 
     * @param {Object} obj 
     */
    addMenu(obj) {
      if (this.currentIndex > -1 && obj.text && this.router.views && this.router.views[this.currentIndex]) {
        if (this.router.views[this.currentIndex].menu === undefined) {
          this.router.views[this.currentIndex].menu = [];
        }
        let menu = this.router.views[this.currentIndex].menu || [],
          idx = bbn.fn.isFunction(menu) ? -1 : bbn.fn.search(menu || [], {
            text: obj.text
          });
        if (idx === -1) {
          if (bbn.fn.isFunction(menu)) {
            this.router.views[this.currentIndex].menu = () => {
              let items = menu() || [];
              if (bbn.fn.search(items, obj) === -1) {
                if (!obj.key) {
                  obj.key = bbn.fn.randomInt(99999, 99999999999);
                }
                items.push(obj);
              }
              return items;
            };
          } else {
            if (!obj.key) {
              obj.key = bbn.fn.randomInt(99999, 99999999999);
            }
            menu.push(obj);
          }
        } else {
          obj.key = menu[idx].key;
          menu.splice(idx, 1, obj);
        }
        this.router.views[this.currentIndex].menu = menu;
        return obj.key;
      }
      return false;
    },
    /**
     * Deletes the given key from the container's menu.
     * 
     * @method deleteMenu
     * @param {String} key 
     */
    deleteMenu(key) {
      if (this.currentIndex > -1 && this.router.views && this.router.views[this.currentIndex]) {
        let menu = this.router.views[this.currentIndex].menu || [];
        if (bbn.fn.isFunction(menu)) {
          menu = () => {
            let items = menu() || [];
            let idx = bbn.fn.search(items, "key", key);
            if (idx > -1) {
              items.splice(idx, 1);
              this.router.views[this.currentIndex].menu = items;
              //this.router.$forceUpdate();
              return true;
            }
          };
        } else {
          let idx = bbn.fn.search(menu, "key", key);
          if (idx > -1) {
            menu.splice(idx, 1);
            this.router.views[this.currentIndex].menu = menu;
            //this.router.$forceUpdate();
            return true;
          }
        }
      }
      return false;
    },
    onResize() {
      if (this.isVisible && this.ready) {
        return bbn.cp.mixins.resizer.methods.onResize.apply(this);
      }
    },
    /**
     * Initializes the component.
     * 
     * @method init
     */
    init() {
      if (this.isVisible && (this.real || this.isLoaded && !this.ready)) {
        //bbn.fn.log("INIT " + this.currentURL, this.real,this.currentScript, this.currentView )
        let res;
        if (this.currentScript) {
          res = typeof this.currentScript === 'string' ? eval(this.currentView.script) : this.currentView.script;
          //bbn.fn.log("************************************", res);
          // if evaluating the script property returns a function that will be onMount
          if (bbn.fn.isFunction(res)) {
            this.onMount = res;
            this.isComponent = false;
          }
          // Otherwise if it's an object we assume it is a component
          else if (res && typeof res === 'object') {
            if (!res.props) {
              res.props = bbn.fn.createObject();
            }
            if (!res.props.source) {
              res.props.source = {
                type: Object
              };
            }
            if (!res.mixins) {
              res.mixins = [];
            }
            if (!res.mixins.includes(bbn.cp.mixins.basic)) {
              res.mixins.push(bbn.cp.mixins.basic);
            }
            this.componentDefinition = bbn.cp.normalizeComponent(res, 'bbn-container-' + this.getFullURL());

            //bbn.fn.log("YUUUU", res, this.componentDefinition, this.currentContent)
            this.componentDefinition.template = this.currentContent;
            this.isComponent = true;
          }
        } else if (this.currentContent) {
          this.isComponent = false;
        }
        if (this.isComponent) {
          // We create a local component with a random name,
          // the content as template
          // and the object returned as component definition
          // Adding also a few funciton to interact with the tab
          let cont = this;
          const definition = bbn.fn.extend(true, res ? res : {}, {
            template: '<div class="' + (this.router.scrollContent ? '' : 'bbn-w-100') + '">' + this.currentView.content + '</div>',
            methods: {
              getContainer() {
                if (!this._bbn_container) {
                  this._bbn_container = this.closest('bbn-container');
                }
                return this._bbn_container;
              },
              getTab() {
                return this.getContainer();
              },
              addMenu() {
                return this.getContainer().addMenu.apply(this.router, arguments);
              },
              deleteMenu() {
                return this.getContainer().deleteMenu.apply(this.router, arguments);
              }
            },
            props: {
              source: {
                type: Object
              }
            }
          });
          if (!definition.props) {
            definition.props = bbn.fn.createObject();
          }
          if (!definition.props.source) {
            definition.props.source = {
              type: Object
            };
          }
          if (!definition.mixins) {
            definition.mixins = [];
          }
          if (!definition.mixins.includes(bbn.cp.mixins.basic)) {
            definition.mixins.push(bbn.cp.mixins.basic);
          }
          this.$el.bbnCfg = bbn.cp.normalizeComponent(definition, 'bbn-container-' + this.getFullURL());
          // The local anon component gets defined
          this.$options.components[this.componentName] = this.$el.bbnCfg;
        } else {
          this.isComponent = false;
        }
        if (bbn.env.url.indexOf('#')) {
          let scroll = this.getRef('scroll');
          /**
           * @todo  Does it mean the scroll manage the hash? Check it out
           */
          if (scroll && (scroll.currentY || scroll.currentX)) {
            return;
          }
          let hash = bbn.env.url.split('#')[1];
          if (hash) {
            hash = '#' + hash;
            location.hash = null;
            location.hash = hash;
          }
        }
        if (this.visual) {
          this.setScreenshot();
        }
        this.ready = true;
      }
    },
    showMenu() {
      return this.router.getMenuFn(this.currentIndex);
    },
    setScreenshot() {
      if (!this._screenshotInterval && this.router.isVisual && this.router.db && !this.isPane) {
        let url = this.getFullURL();
        this.router.db.selectOne('containers', 'time', {
          url: url
        }).then(time => {
          // Checking if we have a screenshot of less than an hour
          if (bbn.fn.timestamp() - (time || 0) >= this.currentScreenshotDelay) {
            this.saveScreenshot(0.1, 10000);
          }
        }).catch(() => {
          this.saveScreenshot(0.1, 10000);
        });
        this._screenshotInterval = setInterval(() => {
          this.saveScreenshot(0.1);
        }, this.currentScreenshotDelay);
      }
    },
    unsetScreenshot() {
      if (this._screenshotInterval) {
        clearInterval(this._screenshotInterval);
        this._screenshotInterval = false;
        if (this._screenshotTimeout) {
          clearTimeout(this._screenshotTimeout);
          this._screenshotTimeout = false;
        }
      }
    },
    async saveScreenshot() {
      let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.1;
      let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (this.router.db && this.currentView.idx === this.router.selected && !this.isPane) {
        let img = await this.takeScreenshot(scale, timeout, true);
        let num_tries = 0;
        while (!img && num_tries < 5) {
          num_tries++;
          img = await this.takeScreenshot(scale, 5000);
        }
        if (!img) {
          bbn.fn.log(bbn._("Impossible to take the screenshot of") + ' ' + this.getFullCurrentURL());
          return;
          //throw new Error(bbn._("Impossible to take the screenshot of " + this.getFullCurrentURL()));
        }

        this.thumbnail = img.src;
        // This is in fact an insert/update
        this.router.db.insert('containers', {
          url: this.getFullURL(),
          image: img.src,
          time: bbn.fn.timestamp()
        });
      }
    },
    takeScreenshot() {
      let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let image = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return new Promise(resolve => {
        if (this._screenshotTimeout) {
          if (force) {
            clearTimeout(this._screenshotTimeout);
          } else {
            resolve(false);
          }
        }
        this._screenshotTimeout = setTimeout(() => {
          let exit = () => {
            this._screenshotTimeout = false;
            resolve(false);
          };
          if (this.currentIndex === this.router.selected && this.isVisible && window.html2canvas && bbn.fn.isActiveInterface(600) && !this.router.visualShowAll) {
            let scroll = this.getRef('scroll');
            if (!scroll) {
              return exit();
            }
            if (scroll.$el) {
              scroll = scroll.$el;
            }
            let w = scroll.clientWidth;
            let h = scroll.clientHeight;
            let s = Math.min(w, h);
            let ct = this.getRef('canvasSource');
            if (!ct || !s) {
              return exit();
            }
            ct.style.width = s + 'px !important';
            ct.style.height = s + 'px !important';
            html2canvas(ct, {
              width: s,
              height: s,
              scale: scale
            }).then(canvas => {
              ct.style.width = null;
              ct.style.height = null;
              this._screenshotTimeout = false;
              if (!image) {
                resolve(canvas);
                return;
              }
              let img = bbn.fn.canvasToImage(canvas);
              let ctx = canvas.getContext('2d');
              let size = Math.min(canvas.width, canvas.height);
              let num = Math.min(this.router.numVisualCols, this.router.numVisualRows);
              let msize = Math.ceil(size / num);
              ctx.drawImage(img, 0, 0, size, size, 0, 0, msize, msize);
              resolve(img);
            });
          } else {
            exit();
          }
        }, timeout);
      });
    },
    updateScreenshot() {
      if (this.visual && this.router.db) {
        let url = this.getFullURL();
        this.router.db.selectOne('containers', 'image', {
          url: url
        }).then(res => {
          if (res) {
            this.thumbnail = res;
          }
        });
      }
    },
    /**
     * @method registerRouter
     * @param {Object} bc
     * @param {String} url
     */
    registerRouter(router) {
      this.routers[bbn.fn.substr(router.getBaseURL(), 0, -1)] = router;
      this.router.registerRouter(router);
    },
    /**
     * @method unregisterRouter
     * @param {Object} bc
     * @param {String} url
     */
    unregisterRouter(router) {
      delete this.routers[bbn.fn.substr(router.getBaseURL(), 0, -1)];
      this.router.unregisterRouter(router);
    }
  },
  /**
   * @event created 
   */
  created() {
    this.componentClass.push('bbn-resize-emitter');
    if (this.isComponent) {
      bbnContainerCp.componentsList.push(this.componentName);
    } else if (this.isComponent === null) {
      // The default onMount function is to do nothing.
      this.onMount = () => {
        return false;
      };
    }
  },
  beforeMount() {
    // The router is needed
    this.router = this.closest('bbn-router');
    //const cp = this.getRef('component');
  },

  /**
   * @event mounted
   * @fires router.register
   */
  mounted() {
    //bbn.fn.log("MOUNTED CONTAINER " + this.url);
    if (!this.router) {
      throw new Error(bbn._("bbn-container cannot be rendered without a bbn-router"));
    }
    this.updateScreenshot();
    this._screenshotInterval = false;
    if (!this.router.ready) {
      bbn.fn.warning("ROUTER NOT READY");
      this.router.$on('ready', () => {
        bbn.fn.warning("ROUTER INITING");
        this.init();
      });
    } else {
      //bbn.fn.warning("ROUTER REGISTERING");
      this.router.register(this);
      this.$nextTick(() => {
        this.init();
      });
    }
    this.$el.title = '';
    //
    // The container is registered
  },

  /**
   * @event beforeDestroy
   * @fires router.unregister
   */
  beforeDestroy() {
    if (this.router) {
      this.router.unregister(this);
    }
    if (this.isComponent) {
      let idx = bbnContainerCp.componentsList.indexOf(this.componentName);
      if (idx > -1) {
        bbnContainerCp.componentsList.splice(idx, 1);
      }
    }
  },
  watch: {
    currentView: {
      deep: true,
      handler(v, ov) {
        if (v || ov) {
          //bbn.fn.log("DEEP HANDLER ON VIEW", v, ov);
          this.$tick();
        }
      }
      /*
      bbn.fn.iterate(v, (a, n) => {
        let name = 'c' + bbn.fn.correctCase(n);
        if (Object.hasOwn(this, name) && !bbn.fn.isSame(this[name], a)) {
          this[name] = a;
          bbn.fn.log("***************** CHANGING " + name + " IN CURRENT VIEW FOR " + this.url + " *****************")
        }
      });
      */
    },

    /**
     * The source of the component.
     * @prop {Object|Function} source
     */
    source(v) {
      if (this.real) {
        this.currentView.source = v;
      }
    },
    /**
     * The options object of the component.
     * @prop {Object} options
     */
    options(v) {
      if (this.real) {
        this.currentView.options = v;
      }
    },
    /**
     * Defines if the component has to be cached.
     * @prop {Boolean} [false] cached
     */
    cached(v) {
      if (this.real) {
        this.currentView.cached = v;
      }
    },
    /**
     * Defines if the component has to be scrollable.
     * @prop {Boolean} [true] scrollable
     */
    scrollable(v) {
      if (this.real) {
        this.currentView.scrollable = v;
      }
    },
    /**
     * Defines the component to use.
     * @prop component
     */
    component(v) {
      if (this.real) {
        this.currentView.component = v;
      }
    },
    /**
     * Defines the icon.
     * @prop {String|Boolean} icon
     */
    icon(v) {
      if (this.real) {
        this.currentView.icon = v;
      }
    },
    /**
     * Defines if the component can have a text.
     * @prop {Boolean} [false] notext
     */
    notext(v) {
      if (this.real) {
        this.currentView.notext = v;
      }
    },
    /**
     * Defines the component's content.
     * @prop {String} [''] content
     */
    content(v) {
      if (this.real) {
        this.currentView.content = v;
      }
    },
    /**
     * Defines the menu.
     * @prop {Array|Function} menu
     */
    menu(v) {
      if (this.real) {
        this.currentView.menu = v;
      }
    },
    /**
     * Defines the component's fcolor.
     * @prop {String} fcolor
     */
    fcolor(v) {
      if (this.real) {
        this.currentView.fcolor = v;
      }
    },
    /**
     * Defines the component's bcolor.
     * @prop {String} bcolor
     */
    bcolor(v) {
      if (this.real) {
        this.currentView.bcolor = v;
      }
    },
    /**
     * Defines the css string for the component.
     * @prop {String} [''] css
     */
    css(v) {
      if (this.real) {
        this.currentView.css = v;
      }
    },
    /**
     * @prop {String|Object} advert
     */
    advert(v) {
      if (this.real) {
        this.currentView.advert = v;
      }
    },
    /**
     * @prop {String} help
     */
    help(v) {
      if (this.real) {
        this.currentView.help = v;
      }
    },
    /**
     * @prop {Array} imessages
     */
    imessages(v) {
      if (this.real) {
        this.currentView.imessages = v;
      }
    },
    /**
     * @prop script
     */
    script(v) {
      if (this.real) {
        this.currentView.script = v;
      }
    },
    /**
     * The object of configuration for the component
     * @prop {Object} cfg
     */
    cfg(v) {
      if (this.real) {
        this.currentView.cfg = v;
      }
    },
    /**
     * @prop {Object} events
     */
    events(v) {
      if (this.real) {
        this.currentView.events = v;
      }
    },
    /**
     * Defines if the component is disabled.
     * @prop {Boolean} [false] disabled
     */
    disabled(v) {
      if (this.real) {
        this.currentView.disabled = v;
      }
    },
    /**
     * Defines if the component is hidden.
     * @prop {Boolean} [false] hidden
     */
    hidden(v) {
      if (this.real) {
        this.currentView.hidden = v;
      }
    },
    title(v) {
      if (this.real) {
        this.currentView.title = v;
      }
    },
    loaded(v) {
      this.isLoaded = v;
    },
    loading(v) {
      this.isLoading = v;
    },
    current(newVal) {
      if (newVal.indexOf(this.url) === 0) {
        this.currentURL = newVal;
      }
      if (this.real) {
        this.currentView.current = v;
      }
    },
    /**
     * @watch currentUrl
     * @param {String} newVal 
     * @param {String} oldVal 
     */
    currentURL(newVal, oldVal) {
      // Auto cancelling if it does not correspond to the url
      if (!newVal || newVal.indexOf(this.url) !== 0) {
        this.currentURL = this.url;
      }
      // Routing if the router has different info
      else if (this.currentView && this.currentView.current !== newVal) {
        this.router.route(newVal);
      }
    },
    ready(v) {
      if (v) {
        if (this.onMount) {
          this.onMount(this.$el, this.source);
        }
      }
    },
    /**
     * @watch visible
     * @param {Boolean} nv 
     * @param {Boolean} ov 
     * @fires selfEmit
     */
    isVisible(nv) {
      var _this$router2;
      //bbn.fn.log("Changing isVisible for " + this.currentURL);
      let emit = true;
      if (!this.isPane && (_this$router2 = this.router) !== null && _this$router2 !== void 0 && _this$router2.isVisual) {
        if (nv) {
          this.setScreenshot();
        } else {
          this.unsetScreenshot();
        }
      }
      if (emit) {
        this.$emit(nv ? 'view' : 'unview', this);
      }
      if (nv && this.router) {
        if (!this.isLoaded && !this.isLoading) {
          this.router.load(this.currentURL, true);
        }
        if (!this.ready) {
          this.$nextTick(() => {
            this.onResize();
            this.init();
          });
        }
      }
    },
    /**
     * @watch content
     * @param {Boolean} newVal 
     * @param {Boolean} oldVal 
     */
    content(newVal, oldVal) {
      if (newVal) {
        this.currentView.content = newVal;
        bbn.fn.log("GT CONTENT");

        /*
        setTimeout(() => {
          this.onMount = () => {
            return false;
          };
          let res;
          if ( this.script ){
            res = typeof this.script === 'string' ? eval(this.script) : this.script;
            if (bbn.fn.isFunction(res) ){
              this.onMount = res;
              this.isComponent = false;
            }
            else if ( typeof(res) === 'object' ){
              this.isComponent = true;
            }
          }
          else if ( this.source && this.content ){
            bbn.fn.extend(res ? res : {}, {
              name: this.name,
              template: '<div class="bbn-overlay">' + this.content + '</div>',
              props: ['source']
            });
          }
          else{
            this.isComponent = false;
          }
          this.isComponentActive = true;
        }, oldVal ? 200 : 0)
        */
      }
    },

    /**
     * If true adds the event listener keydown, or else removes the event listener.
     * @watch fullScreen
     * @param {Boolean} newVal 
     * @fires selfEmit
     */
    fullScreen(newVal) {
      let fn = e => {
        if (e.keyCode === 27) {
          this.fullScreen = false;
        }
      };
      if (newVal) {
        document.body.addEventListener('keydown', fn);
      } else {
        document.body.removeEventListener('keydown', fn);
      }
      this.$nextTick(() => {
        this.selfEmit(true);
      });
    },
    dirty(v) {
      let view = this.router.getView(this.url);
      if (view) {
        view.dirty = v;
        this.router.retrieveDirtyContainers();
      }
    }
  }
};
import cpHtml from './container.html';
import cpStyle from './container.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./container.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-container',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-context component
 *
 * @description bbn-context is a menu that can be activated with a right click.
 * The source of the menu can have a tree structure.
 *
 * @copyright BBN Solutions
 *
 * @created 15/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.dimensions
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.dimensions, bbn.cp.mixins.events],
  props: {
    /**
     * @prop {Boolean} [false] autobind
     */
    autobind: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Will force the position.
     * @prop {String} [''] position
     */
    position: {
      type: String,
      default: ''
    },
    /**
     * The html tag used to render the property content.
     * @prop {String} ['span'] tag
     */
    tag: {
      type: String,
      default: 'span'
    },
    /**
     * If defined it will be show at the top of the list.
     * @prop {String} [false] floaterTitle
     */
    floaterTitle: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Set to true to show the floating element containing the menu.
     * @prop {Boolean} [false] context
     * 
     */
    context: {
      type: Boolean,
      default: false
    },
    /**
     * The content of the context menu.
     * @prop {String} content
     */
    content: {
      type: String
    },
    /**
     * Selection mode.
     * @prop {String} ['free'] mode
     */
    mode: {
      type: String,
      default: 'free'
    },
    /**
     *
     * @prop {String} ['items'] children
     */
    children: {
      type: String,
      default: 'items'
    },
    /**
     * The component used by list's items.
     * @prop {Object|String} itemComponent
     */
    itemComponent: {
      type: [Object, String]
    },
    /**
     * The HTMLElement to bind to.
     * @props {HTMLElement} attach
     */
    attach: {
      type: HTMLElement
    },
    /**
     * The name of the property to be used as action to execute when selected.
     * @prop {String} sourceAction
     * @memberof listComponent
     */
    sourceAction: {
      type: [String, Function],
      default: 'action'
    },
    /**
     * The name of the property to be used as URL to go to when selected.
     * @prop {String} sourceUrl
     * @memberof listComponent
     */
    sourceUrl: {
      type: [String, Function],
      default: 'url'
    },
    /**
     * The HTML element to be used as portal
     * @prop {HTMLElement} portal
     */
    portal: {
      type: HTMLElement
    }
  },
  data() {
    return {
      /**
       * True if the floating element of the menu is opened.
       * @data {Boolean} [false] showFloater
       */
      showFloater: false,
      /**
       * @data {Boolean} [false] docEvent
       */
      docEvent: false,
      currentLeft: null,
      currentTop: null,
      currentRight: null,
      currentBottom: null,
      currentMinWidth: this.minWidth || 0,
      currentMaxWidth: this.maxWidth || bbn.env.width,
      currentMinHeight: this.minHeight || 0,
      currentMaxHeight: this.maxHeight || bbn.env.height
    };
  },
  methods: {
    /**
     * Based on the type of event and on the property context, shows or hides the floating element of the menu.
     * @method clickItem
     * @param {Event} e 
     * @fires updateData
     */
    clickItem(e) {
      if (!this.disabled && (e.type === 'keydown' || e.type === 'contextmenu' && this.context || e.type === 'click' && !this.context)) {
        //bbn.fn.log("CLICK ITEM", e.target, this.currentData);
        if (e.preventDefault) {
          e.preventDefault();
          e.stopPropagation();
        }
        // Don't execute if in the floater
        if (!e.target.closest('.bbn-floater-context-' + this.bbnUid)) {
          if (!this.showFloater && !this.attach) {
            if (e.pageX > bbn.env.width / 2) {
              this.currentLeft = null;
              this.currentRight = bbn.env.width - e.pageX + 5;
            } else {
              this.currentLeft = e.pageX - 5;
              this.currentRight = null;
            }
            if (e.pageY > bbn.env.height / 2) {
              this.currentTop = null;
              this.currentBottom = bbn.env.height - e.pageY + 5;
            } else {
              this.currentTop = e.pageY - 5;
              this.currentBottom = null;
            }
          }
          this.toggle();
        }
      }
    },
    /**
     * @method clickOut
     * @param e
     */
    clickOut(e) {
      if (!e.target.closest('.bbn-floater-context-' + this.bbnUid) && this.showFloater) {
        this.showFloater = false;
        if (e.preventDefault) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    },
    /**
     * @method toggle
     */
    toggle() {
      if (!this.showFloater) {
        this.updateData().then(() => {
          this.showFloater = !this.showFloater;
        });
      } else {
        this.showFloater = !this.showFloater;
      }
    },
    onMouseDown(e) {
      /*
      if (!(e instanceof CustomEvent)) {
        let event = new CustomEvent('mousedown', {
          cancelable: true,
          detail: e
        });
        this.$emit('mousedown', event);
        if (!event.defaultPrevented) {
          event.preventDefault();
          event.stopPropagation();
          return false;
        }
      }
      */
    }
  },
  /**
   * @method beforeDestroy
   */
  beforeDestroy() {
    if (this.docEvent) {
      document.removeEventListener('click', this.clickout);
    }
  },
  watch: {
    showFloater(v) {
      if (v) {
        document.addEventListener('click', this.clickOut, true);
        this.docEvent = true;
      } else {
        document.removeEventListener('click', this.clickout);
        this.docEvent = false;
      }
    }
  }
};
import cpHtml from './context.html';
import cpStyle from './context.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./context.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-context',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-countdown component
 * @description bbn-countdown is a component that performs a countdown of a user-defined date, based on the measure of time defined in the construction.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 13/02/2017.
*/

/** @todo try this way

 const timestamp = 1519482900000;
 const formatted = dayjs(timestamp).format('L');

 console.log(formatted);*/

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  statics() {
    return {
      VALUES: [{
        name: 'year',
        title: bbn._('year'),
        titles: bbn._('years'),
        code: 'y',
        separator: 'y',
        timeout: 3600000
      }, {
        name: 'month',
        title: bbn._('month'),
        titles: bbn._('months'),
        code: 'm',
        separator: 'm',
        diff: 12,
        timeout: 3600000
      }, {
        name: 'day',
        title: bbn._('day'),
        titles: bbn._('days'),
        code: 'd',
        diff: 31,
        separator: 'd',
        timeout: 3600000
      }, {
        name: 'hour',
        title: bbn._('hour'),
        titles: bbn._('hours'),
        code: 'h',
        diff: 24,
        separator: ':',
        timeout: 3600000
      }, {
        name: 'minute',
        title: bbn._('minute'),
        titles: bbn._('minutes'),
        code: 'i',
        diff: 60,
        separator: ':',
        timeout: 60000
      }, {
        name: 'second',
        title: bbn._('second'),
        titles: bbn._('seconds'),
        code: 's',
        diff: 60,
        separator: '.',
        timeout: 1000
      }, {
        name: 'millisecond',
        title: bbn._('millisecond'),
        titles: bbn._('milliseconds'),
        code: 'x',
        diff: 1000,
        separator: '',
        timeout: 50
      }]
    };
  },
  props: {
    /**
     * The precision of the countdown.
     * @prop {precision} ['second'] precision
     */
    precision: {
      type: String,
      default: 'second'
    },
    /**
     * The scale of the countdown.
     * @prop {precision} ['year'] scale
     */
    scale: {
      type: String,
      default: 'year'
    },
    /**
     * The target date.
     * @prop {Date|String|Function} target
     */
    target: {
      type: [Date, String, Function]
    },
    /**
     * Shows unit even if empty.
     * @prop {Boolean} [false] showZero
     */
    showZero: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true the remaining day and month and year will be displayed.
     * @prop {Boolean} [true] zeroFill
     */
    zeroFill: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * The target year.
       * @data {Boolean} [false] targetYear
       */
      targetYear: false,
      /**
       * The target month.
       * @data {Boolean} [false] targetMonth
       */
      targetMonth: false,
      /**
       * The target day.
       * @data {Boolean} [false] targetDay
       */
      targetDay: false,
      /**
       * The target hour.
       * @data {Boolean} [false] targetHour
       */
      targetHour: false,
      /**
       * The target minute.
       * @data {Boolean} [false] targetMinute
       */
      targetMinute: false,
      /**
       * The target second.
       * @data {Boolean} [false] targetSecond
       */
      targetSecond: false,
      /**
       * The target millisecond.
       * @data {Boolean} [false] targetMillisecond
       */
      targetMillisecond: false,
      /* year: false,
      month: false,
      day: false,
      hour: false,
      minute: false,
      second: false,
      millisecond: false,*/
      /**
       * The interval of the countdown.
       * @data {Number} [0] interval
       */
      interval: 0,
      /**
       * The timestamp of the real target date.
       * @data {Boolean|Number} [false] time
       */
      time: false,
      /**
       * @data {String} ["{}"] prevValues
       */
      prevValues: JSON.stringify({}),
      /**
       * @data {Object} [{}] shown
       */
      shown: {},
      /**
       * @data {Object} [{}] text
       */
      text: {},
      /**
       * @data {Boolean} [false] isValid
       */
      isValid: false,
      /**
       * @data {Boolean} [false] realTarget
       */
      realTarget: false
    };
  },
  computed: {
    /**
     * The index of the 'precision' property in the array of the constant bbnCountdownCp.VALUES.
     * @return {Number} [5] precisionIdx
     */
    precisionIdx() {
      return bbn.fn.search(bbnCountdownCp.VALUES, this.precision.length === 1 ? 'code' : 'name', this.precision);
    },
    /**
     * The index of the 'scale' property in the array of the constant bbnCountdownCp.VALUES.
     * @return {Number} [5] scaleIdx
     */
    scaleIdx() {
      return bbn.fn.search(bbnCountdownCp.VALUES, this.scale.length === 1 ? 'code' : 'name', this.scale);
    },
    /**
     * List type of periods.
     * @return {Array} periods
     */
    periods() {
      return bbnCountdownCp.VALUES;
    },
    // @todo incomplete
    rendered() {
      if (this.template) {}
      return false;
    }
  },
  methods: {
    /**
     * Checks if the component has been correctly set up.
     * @method check
     * @return {Boolean}
     */
    check() {
      return this.realTarget && this.precisionIdx > -1 && this.scaleIdx > -1 && this.precisionIdx >= this.scaleIdx;
    },
    /**
     * Initializes the component.
     * @method init
     * @fires update
     */
    init() {
      clearInterval(this.interval);
      if (this.precisionIdx === -1) {
        throw new Error(bbn._("The precision is incorrect"));
      } else if (this.scaleIdx === -1) {
        throw new Error(bbn._("The scale is incorrect"));
      } else {
        let tmp = bbn.fn.isFunction(this.target) ? this.target() : this.target;
        if (bbn.fn.isString(tmp)) {
          tmp = bbn.fn.date(tmp);
        }
        this.realTarget = new dayjs(tmp);
        this.time = this.realTarget.unix();
        let timeout = bbnCountdownCp.VALUES[this.precisionIdx].timeout;
        this.update();
        this.interval = setInterval(this.update, timeout);
      }
    },
    /**
     * Udates the component.
     * @method update
     * @fires check
     * @fires getShown
     * @fires getText
     */
    update() {
      if (this.check()) {
        let d = new dayjs();
        let secs = this.time - d.unix();
        if (secs <= 0) {
          if (this.isValid) {
            bbn.fn.each(bbnCountdownCp.VALUES, (a, i) => {
              this[a.name] = 0;
            });
            this.isValid = false;
          }
        } else if (secs) {
          let diff = dayjs.duration(secs, 'seconds');
          let diffs = {};
          bbn.fn.each(bbnCountdownCp.VALUES, (a, i) => {
            diffs[a.name] = diff['as' + a.name[0].toUpperCase() + bbn.fn.substr(a.name, 1) + 's']();
            if (i >= this.scaleIdx && i <= this.precisionIdx) {
              let round = Math.floor(diffs[a.name]);
              diffs[a.name] = round;
              if (i < this.precisionIdx) {
                diff = diff.subtract(dayjs.duration(round, a.name + 's'));
              }
            }
          });
          bbn.fn.iterate(diffs, (b, n) => {
            this[n] = b;
          });
          if (!this.isValid) {
            this.isValid = true;
          }
          this.shown = this.getShown();
          this.text = this.getText();
          this.$forceUpdate();
        }
      }
    },
    /**
     * Returns the descriptive list of units used in the countdown.
     *
     * @method getShow
     * @return {Object}
     */
    getShown() {
      let res = {};
      bbn.fn.each(bbnCountdownCp.VALUES, (a, i) => {
        res[a.name] = (this.showZero || this[a.name] || this.zeroFill) && this.precisionIdx >= i && this.scaleIdx <= i;
      });
      return res;
    },
    /**
     * Returns the descriptive list of units used in the countdown with the value that contains it when calling this function.
     *
     * @method getText
     * @return {Object}
     */
    getText() {
      let res = {};
      bbn.fn.each(bbnCountdownCp.VALUES, (a, i) => {
        res[a.name] = this[a.name] || 0;
        if (this.zeroFill && this.scaleIdx !== i && res[a.name].toString().length <= 1) {
          res[a.name] = '0' + res[a.name];
        }
      });
      return res;
    }
  },
  /**
   * @event created
   * @fires init
   */
  created() {
    this.init();
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  },
  watch: {
    /**
    * @watch target
    * @fires init
    */
    target() {
      this.init();
    }
  }
};
import cpHtml from './countdown.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./countdown.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-countdown',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-block component
 * @description bbn-block
 * @copyright BBN Solutions
 * @author Loredana Bruno
 * @created 09/11/2020.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input],
  props: {
    /**
     * @prop {Number} [1] step
     */
    step: {
      type: Number,
      default: 1
    },
    /**
     * The aduio's URL
     */
    /*source: {
      type: Number,
      required: true
    },*/
    /**
     * The audio's title
     * {String} [''] title
     */
    /**
     * @prop {Number} [0] min
     */
    min: {
      type: Number,
      default: 0
    },
    /**
     * @prop {Number} [500] max
     */
    max: {
      type: Number,
      default: 500
    },
    /**
     * @prop {String} [''] title
     */
    title: {
      type: String,
      default: ''
    },
    /**
     * @prop {(Number|String)} [] value
     */
    value: {
      type: Number | String
    },
    /**
     * @prop {String} [''] unit
     */
    unit: {
      type: String,
      default: ''
    }
  },
  computed: {
    label() {
      return this.value;
    }
  }
};
import cpHtml from './cursor.html';
import cpStyle from './cursor.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./cursor.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-cursor',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-dashboard component
 *
 * @description bbn-dashboard represents a user's interface containing bbn-widgets.
 * Details of widgets, such as data and positions, can be easily managed.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 *
 * @created 15/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.localStorage],
  statics() {
    return {
      limits: [5, 10, 15, 20, 25, 30, 40, 50]
    };
  },
  props: {
    /**
     * @prop {Object} [{}] components
     */
    components: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * @prop {Number} max
     */
    max: {
      type: Number
    },
    /**
     * @prop {Boolean} [true] selectable
     */
    selectable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true makes the widgets inside the dashboard closeable.
     * @prop {Boolean} [true] closable
     */
    closable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true makes the widgets in the dashboard sortable.
     * @prop {Boolean} [true] sortable
     */
    sortable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true makes the dashboard scrollable.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * The source of the dashboard.
     * @prop {Array} [[]] source
     */
    source: {
      default() {
        return [];
      }
    },
    /**
     * The url for the post, in case of actions on the dashboard's widgets.
     * @prop {String} url
     */
    url: {},
    /**
     * @prop {Object} loadedConfig
     */
    loadedConfig: {
      type: Object
    },
    /**
     * @prop {Array} order
     */
    order: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The object of configuration of the dashboard.
     * @prop {Object} cfg
     */
    cfg: {
      type: Object,
      default() {
        return {
          sortable: true,
          url: false,
          source: [],
          components: {}
        };
      }
    }
  },
  data() {
    return {
      /**
       * @data {Array} [[]] originalSource
       */
      originalSource: [],
      /**
       * @data {Array} [[]] menu
       */
      menu: [],
      /**
       * @data {Boolean} [false] isRefreshing
       */
      isRefreshing: false,
      /**
       * @data {Array} [[]] widgets
       */
      widgets: [],
      /**
       * @data {Array} [[]] currentOrder
       */
      currentOrder: this.order.slice(),
      /**
       * @data sortTargetIndex
       */
      sortTargetIndex: null,
      /**
       * @data sortOriginIndex
       */
      sortOriginIndex: null,
      /**
       * @data {Boolean} [false] isSorting
       */
      isSorting: false,
      /**
       * @data {Boolean} [false] isDragging
       */
      isDragging: false,
      /**
       * @data {Boolean} [false] sortTimeout
       */
      sortTimeout: false,
      /**
       * @data {Boolean} [false] sortingElement
       */
      sortingElement: false,
      /**
       * @data {Number} [0] sortHelperWidth
       */
      sortHelperWidth: 0,
      /**
       * @data {Number} [0] sortHelperHeight
       */
      sortHelperHeight: 0,
      /**
       * @data {Number} [0] sortHelperX
       */
      sortHelperX: 0,
      /**
       * @data {Number} [0] sortHelperY
       */
      sortHelperY: 0,
      /**
       * @data {Boolean} [[]] currentSlots
       */
      currentSlots: [],
      /**
       * @data {Number} [1] numCols
       */
      numCols: 1
    };
  },
  computed: {
    /**
     * Widget order list.
     * @return {Array} originalOrder
     */
    originalOrder() {
      return bbn.fn.map(this.originalSource, d => d.key);
    },
    /**
     * Widget order listInforms whether the widget origin has been changed.
     * @return {Boolean} isOrderChanged
     */
    isOrderChanged() {
      if (!this.originalOrder) {
        return false;
      }
      return JSON.stringify(this.originalOrder) !== JSON.stringify(this.currentOrder);
    }
  },
  methods: {
    /**
     * Sets the configuration of the dashboard.
     * @method setConfig
     * @param {String} uid
     * @param {Object} config
     * @fires setStorage
     */
    setConfig(uid, config) {
      bbn.fn.log("SET CONFIG", uid, config);
      this.setStorage({
        order: config.order
      }, uid);
    },
    /**
     * Close widget in dashboard.
     * @method closeWidget
     * @param {String} uid
     * @param {Object} widget
     * @fires updateWidget
     * @emits close
     */
    closeWidget(uid, widget) {
      let ev = new Event('close', {
        cancelable: true
      });
      this.$emit('close', uid, widget);
      if (!ev.defaultPrevented) {
        this.updateWidget(uid, {
          hidden: true
        });
      }
    },
    /**
     * Gets the widget corresponding to the given key.
     * @method getWidget
     * @param {Number} key
     * @fires closest
     * @return {Object | undefined}
     */
    getWidget(key) {
      let idx = bbn.fn.search(this.widgets, {
        key: key
      });
      if (idx > -1) {
        return this.widgets[idx];
      }
      return null;
    },
    /**
     * Hides the widget corresponding to the given key.
     * @method hideWidget
     * @param {Number} key
     * @fires toggleWidget
     */
    hideWidget(key) {
      return this.toggleWidget(key, true);
    },
    /**
     * Shows the widget corresponding to the given key.
     * @method hideWidget
     * @param {Number} key
     * @fires toggleWidget
     */
    showWidget(key) {
      return this.toggleWidget(key, false);
    },
    /**
     * Hides or not the widget corresponding to the given key.
     * @method toggleWidget
     * @param {Number} key
     * @param {Boolean} hidden
     * @fires updateWidget
     */
    toggleWidget(key, hidden) {
      if (this.widgets) {
        let w = bbn.fn.getRow(this.widgets, {
          key: key
        });
        if (w && w.closable !== false) {
          this.updateWidget(key, {
            hidden: hidden === undefined ? !w.hidden : hidden
          });
        }
      }
    },
    /**
     * Handles the resize of the component.
     * @method onResize
     * @fires getRef
     * @fires resizeScroll
     */
    onResize() {
      bbn.fn.log("RESIZE DASH");
      let ele = this.getRef('container');
      if (ele) {
        let actualWidth = parseInt(window.getComputedStyle(ele).width),
          num = 1,
          steps = [800, 1150, 1550, 2200, 3000, 3800];
        bbn.fn.each(steps, (step, i) => {
          if (this.max && this.max <= num) {
            return false;
          }
          if (actualWidth >= step) {
            num++;
          } else {
            return false;
          }
        });
        if (this.numCols !== num) {
          this.numCols = num;
        }
        this.resizeScroll();
      }
    },
    /**
     * Move the widget from the old index to the new index
     * @method moveWidgets
     * @param {Number} oldIdx
     * @param {Number} newIdx
     */
    moveWidgets(oldIdx, newIdx) {
      bbn.fn.move(this.widgets, oldIdx, newIdx);
      bbn.fn.each(this.widgets, (a, i) => {
        if (i !== a.index) {
          this.widgets[i].index = i;
        }
      });
    },
    /**
     * Move the widget from the old index to the new index considering the hidden widgets.
     * @method move
     * @param {Number} oldIdx
     * @param {Number} newIdx
     * @emits sort
     * @return {Boolean}
     */
    move(oldIdx, newIdx) {
      if (this.widgets[oldIdx] && this.widgets[newIdx]) {
        bbn.fn.move(this.widgets, oldIdx, newIdx);
        let order = [];
        bbn.fn.each(this.widgets, (a, i) => {
          if (i !== a.index) {
            a.index = i;
          }
          order.push(a.key);
        });
        this.currentOrder = order;
        if (this.url) {
          return this.post(this.url + 'order', {
            id_dashboard: this.code,
            order: order
          }, d => {
            if (d && d.data && d.data.success) {
              appui.success();
            } else {
              appui.error();
            }
          });
        }
        bbn.fn.log("EMIT SORT");
        this.$emit('sort', this.currentOrder);
        return true;
      }
      return false;
    },
    /**
     * Updates the menu of the parent container.
     * @method updateMenu
     * @fires closest
     * @fires toggleWidget
     * @fires showWidget
     * @fires hideWidget
     * @fires initWidgets
     * @emits sort
     */
    updateMenu() {
      bbn.fn.log("UPDATE MENU");
      let tab = this.closest("bbn-container");
      if (tab) {
        if (this.selectable && this.menu && this.menu.length) {
          bbn.fn.each(this.menu, a => {
            tab.deleteMenu(a);
          });
        }
        this.menu = [];
        let items = [];
        let i = 0;
        if (this.widgets) {
          //bbn.fn.log("THERE IS A MENU AND WIDGETS IN DASHBOARD");
          bbn.fn.each(this.originalSource, a => {
            let w = bbn.fn.getRow(this.widgets, {
              uid: a.uid
            });
            if (w && w.showable) {
              items.push({
                disabled: !this.closable || w.closable === false,
                selected: !w.hidden,
                text: w.text ? w.text : w.title ? w.title : bbn._('Untitled'),
                action: () => {
                  this.toggleWidget(w.uid);
                }
              });
              i++;
            }
          });
          this.menu.push(tab.addMenu({
            text: bbn._("Widgets"),
            mode: 'options',
            icon: 'nf nf-mdi-widgets',
            items: items
          }));
          this.menu.push(tab.addMenu({
            text: bbn._("Show every widget"),
            icon: 'nf nf-mdi-check_circle',
            action: () => {
              bbn.fn.each(this.widgets, w => {
                if (w.hidden) {
                  this.showWidget(w.uid);
                }
              });
            }
          }));
          this.menu.push(tab.addMenu({
            text: bbn._("Hide every widget"),
            icon: 'nf nf-mdi-checkbox_blank_circle',
            action: () => {
              bbn.fn.each(this.widgets, w => {
                if (!w.hidden) {
                  this.hideWidget(w.uid);
                }
              });
            }
          }));
          if (this.isOrderChanged) {
            this.menu.push(tab.addMenu({
              text: bbn._("Reset widgets order"),
              icon: 'nf nf-fa-sort_numeric_asc',
              action: () => {
                this.currentOrder.splice(0, this.currentOrder.length);
                this.initWidgets();
                bbn.fn.log("EMIT SORT 2");
                this.$emit('sort', this.currentOrder);
              }
            }));
          }
        }
      }
    },
    /**
     *
     * @method mouseEnterWidget
     * @param {Number} idx
     */
    mouseEnterWidget(idx) {
      if (this.isSorting && idx !== this.sortOriginIndex) {
        this.sortTargetIndex = idx > this.sortOriginIndex ? idx - 1 : idx;
      } else if (this.sortTargetIndex !== null) {
        this.sortTargetIndex = null;
      }
    },
    /**
    * Update configuration of the given widget.
    * @method updateWidget
    * @param {Number} key
    * @param {Object} cfg
    * @fires setWidgetStorage
    * @fires updateMenu
    * @fires post
    */
    updateWidget(key, cfg) {
      bbn.fn.log("UPDATE WIDGET");
      let idx = bbn.fn.search(this.widgets || [], 'key', key),
        params = {
          id: key,
          cfg: bbn.fn.extend({}, cfg),
          id_dashboard: this.code
        },
        no_save = ['items', 'num', 'start', 'index'];
      if (idx > -1) {
        bbn.fn.each(no_save, function (a, i) {
          if (cfg[a] !== undefined) {
            delete params.cfg[a];
          }
        });
        let numProps = bbn.fn.numProperties(params.cfg);
        if (numProps) {
          // If it's only the default limit we don't save
          if (numProps === 1 && params.cfg.limit && this.widgets[idx].limit === undefined) {
            this.widgets[idx].limit = params.cfg.limit;
            return;
          }
          bbn.fn.iterate(params.cfg, (a, k) => {
            if (this.widgets[idx][k] === undefined) {
              this.$set(this.widgets[idx], k, a);
            } else {
              this.widgets[idx][k] = a;
            }
          });
          this.$nextTick(() => {
            this.setWidgetStorage(idx);
            if (params.cfg.hidden !== undefined) {
              this.updateMenu();
            }
            if (this.hasStorage) {
              let cps = this.$root.findAll('bbn-dashboard');
              bbn.fn.each(cps, (cp, i) => {
                if (cp !== this && cp.storageFullName === this.storageFullName) {
                  bbn.fn.iterate(params.cfg, (a, k) => {
                    if (cp.widgets[idx][k] === undefined) {
                      cp.$set(cp.widgets[idx], k, a);
                    } else if (cp.widgets[idx][k] !== a) {
                      cp.widgets[idx][k] = a;
                    }
                  });
                  if (params.cfg.hidden !== undefined) {
                    cp.updateMenu();
                  }
                }
              });
            }
          });
          if (this.url !== undefined) {
            return this.post(this.url + 'save', params, d => {
              if (d && d.data && d.data.success) {
                appui.success();
              } else {
                appui.error();
              }
            });
          } else {
            appui.success();
          }
        }
      }
      new Error("No corresponding widget found for key " + key);
    },
    /**
     * Sets the storage of the given widget.
     * @method setWidgetStorage
     * @param {Number} idx
     * @fires getStorage
     */
    getWidgetStorage(idx) {
      if (this.widgets[idx]) {
        this.getStorage(this.widgets[idx].storageFullName, true);
      }
    },
    /**
     * Sets the storage of the given widget.
     * @method setWidgetStorage
     * @param {Number} idx
     * @fires setStorage
     */
    setWidgetStorage(idx) {
      this.setStorage({
        uid: this.widgets[idx].uid,
        hidden: this.widgets[idx].hidden,
        limit: this.widgets[idx].limit
      }, this.widgets[idx].storageFullName, true);
    },
    /**
     * Normalizes the properties of the given object.
     * @method normalize
     * @param {Object} obj_orig
     * @fires _getStorageRealName
     * @returns {Object}
     */
    normalize(obj_orig) {
      //bbn.fn.log("NORMALIZE");
      let obj = obj_orig || {};
      obj.hidden = !!obj.hidden;
      if (!obj.key) {
        obj.key = obj.uid ? obj.uid : bbn.fn.randomString(10, 20).toLowerCase();
      }
      if (!obj.uid) {
        obj.uid = obj.key;
      }
      if (obj.showable === undefined) {
        obj.showable = true;
      }
      if (!this.sortable) {
        obj.sortable = false;
      }
      obj.storageFullName = (this.storageFullName || this._getStorageRealName()) + '-' + obj.key;
      return obj;
    },
    /**
     * Adds the given widget.
     * @method add
     * @param {Object} obj
     * @param {Number} idx
     * @fires getWidgetStorage
     * @returns {Object}
     */
    add(obj, idx) {
      bbn.fn.log("ADD WIDGET");
      let checkIdx = bbn.fn.search(this.widgets, {
        key: obj.key
      });
      if (checkIdx > -1) {
        return this.widgets[checkIdx];
      }
      if (idx === undefined || idx < 0 || idx >= this.widgets.length) {
        if (obj.hidden === undefined) {
          obj.hidden = false;
        }
        obj.index = this.widgets.length;
        this.widgets.push(obj);
      } else if (idx < this.widgets.length) {
        this.widgets.each(a => {
          if (a.index >= idx) {
            a.index++;
          }
        });
        obj.index = idx;
        this.widgets.splice(idx, 0, obj);
      }
      if (obj.storageFullName) {
        let tmp = this.getWidgetStorage(idx);
        if (tmp) {
          //bbn.fn.extend(obj, tmp);
        }
      }
      return obj;
    },
    /**
     * Handles the resize of the scroll.
     * @method resizeScroll
     * @fires getRef
     */
    resizeScroll() {
      bbn.fn.log("RESIZE SCROLL");
      if (this.scrollable && this.$refs.scroll) {
        this.getRef('scroll').onResize();
      }
    },
    /**
     * Adds bbns-widget from the slot.
     * @method init
     * @fires normalize
     * @fires initWidgets
     * @fires updateMenu
     */
    init() {
      this.originalSource = [];
      // Adding bbns-widget from the slot.
      if (this.$el.bbnSlots.default) {
        for (let node of this.$el.bbnSlots.default) {
          if (node && node.tag === 'bbns-widget') {
            this.originalSource.push(this.normalize(node.data.attrs));
          }
        }
      }
      bbn.fn.each(this.source, (w, i) => {
        this.originalSource.push(this.normalize(w));
      });
      this.initWidgets();
      this.updateMenu();
    },
    /**
     * Adds bbns-widget.
     * @method initWidgets
     * @fires add
     */
    initWidgets() {
      bbn.fn.log("INIT WIDGETS");
      this.widgets = [];
      bbn.fn.each(this.currentOrder, id => {
        let w = bbn.fn.getRow(this.originalSource, {
          key: id
        });
        if (w) {
          this.add(w);
        }
      });
      bbn.fn.each(this.originalSource, (w, i) => {
        if (this.currentOrder.indexOf(w.key) === -1) {
          this.add(w);
        }
      });
    },
    /**
     * Sets the currentSlots property based to the widgets' visibility into the slots.
     * @method setCurrentSlots
     * @return {Boolean | Array}
     */
    setCurrentSlots() {
      //bbn.fn.log("SET CURRENT SLOTS");
      this.currentSlots = this.$el.bbnSlots.default ? this.$el.bbnSlots.default.filter(node => {
        return !!node.tag;
      }) : [];
    },
    /**
     * On widget drop.
     * @method drop
     * @param {Event} e
     */
    drop(e) {
      if (this.sortable && this.sortOriginIndex !== this.sortTargetIndex && this.widgets[this.sortOriginIndex] && this.widgets[this.sortTargetIndex]) {
        let ev = new Event('move', {
          cancelable: true
        });
        this.$emit('move', ev, this.sortOriginIndex, this.sortTargetIndex);
        if (!ev.defaultPrevented) {
          if (this.move(this.sortOriginIndex, this.sortTargetIndex) && this.storageFullName) {
            let cps = this.$root.findAll('bbn-dashboard');
            bbn.fn.each(cps, (cp, i) => {
              if (cp !== this && cp.storageFullName === this.storageFullName) {
                cp.move(this.sortOriginIndex, this.sortTargetIndex);
              }
            });
          }
        }
      }
      this.sortTargetIndex = null;
    }
  },
  /**
   * @event created
   * @fires init
   * @fires setCurrentSlots
   */
  created() {
    this.init();
    this.setCurrentSlots();
  },
  /**
   * @event mounted
   * @fires onResize
   * @fires init
   */
  mounted() {
    this.ready = true;
    this.onResize();
    /**
     * @watch currentSlots
     * @fires init
     */
    this.$watch('currentSlots', (newVal, oldVal) => {
      if (!bbn.fn.isSame(newVal, oldVal)) {
        this.init();
      }
    });
  },
  /**
   * @event updated
   * @fires selfEmit
   * @fires setCurrentSlots
   */
  updated() {
    /*
    this.selfEmit(true);
    this.setCurrentSlots();
    */
  },
  watch: {
    /**
     * @watch sortTargetIndex
     */
    sortTargetIndex(newVal) {},
    /**
     * @watch isSorting
     * @emits move
     * @fires move
     * @fires getRef
     */
    isSorting(newVal) {
      if (!newVal) {}
    },
    /**
     * @watch source
     * @fires init
     */
    source: {
      deep: true,
      handler() {
        bbn.fn.log("SOURCE CHANGED");
        this.init();
      }
    },
    widgets: {
      deep: true,
      handler() {
        bbn.fn.log("widgets CHANGED");
      }
    }
  }
};
import cpHtml from './dashboard.html';
import cpStyle from './dashboard.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./dashboard.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-dashboard',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
  * @file bbn-datepicker component
  *
  * @description bbn-datepicker is a component that combines input and calendar, allowing the user to choose a date value.
  * This component allows the association of data in a bidirectional way and allows the users to choose a validation interval period and the format of the value entered.
  *
  * @copyright BBN Solutions
  *
  * @author Mirko Argentino
  */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * The array of events for each day.
     * When a string is set, an ajax call will be made to the corresponding url.
     *
     * @prop {(String|Array)} [[]] source
    */
    source: {
      type: [String, Array],
      default() {
        return [];
      }
    },
    /**
     * The format of the date displayed.
     *
     * @prop {String} format
     */
    format: {
      type: String
    },
    /**
     * The format of the value.
     *
     * @prop {(String|Function)} valueFormat
     */
    valueFormat: {
      type: [String, Function]
    },
    /**
     * The mask for the date input.
     *
     * @prop {String} mask
     */
    mask: {
      type: String
    },
    /**
     * The maximum allowed value.
     *
     * @prop {String} max
     */
    max: {
      type: String
    },
    /**
     * The minimum allowed value.
     *
     * @prop {String} min
     */
    min: {
      type: String
    },
    /**
     * The visualization mode.
     * Allowed values: days, weeks, months and years.
     *
     * @prop {String} ['days'] type
    */
    type: {
      type: String,
      default: 'days',
      validator: m => ['days', 'weeks', 'months', 'years'].includes(m)
    },
    /**
     * The disabled dates.
     *
     * @prop {(Array|Function)} disableDates
     */
    disableDates: {
      type: [Array, Function]
    },
    /**
     * Array of date values insertable into a range.
     *
     * @prop {Array} [[]] datesRange
    */
    datesRange: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Set it to false if you dont' want to auto-resize the input's width based on its value (in characters).
     * @prop {Boolean} [true] autosize
     */
    autosize: {
      type: Boolean,
      default: true
    },
    /**
     * Shows only dates with events.
     *
     * @prop {Boolean} [false] onlyEvents
     */
    onlyEvents: {
      type: Boolean,
      default: false
    },
    /**
     * The calendar button's position
     * 
     * @prop {String} ['right'] buttonPosition
     */
    buttonPosition: {
      type: String,
      default: 'right',
      validator: pos => ['right', 'left'].includes(pos)
    }
  },
  data() {
    return {
      /**
       * Shows/hides the floater.
       *
       * @data {Boolean} [false] isOpened
      */
      isOpened: false,
      /**
       * Indicates if the bbn-masked is mounted.
       *
       * @data {Boolean} [false] maskedMounted
      */
      maskedMounted: false,
      /**
       * The current value displayed in the input.
       *
       * @data {String} [''] inputValue
      */
      inputValue: '',
      /**
       * The old value displayed in the input.
       *
       * @data {String} [''] oldInputvalue
       */
      oldInputValue: ''
    };
  },
  computed: {
    /**
     * The current mask for the date input.
     *
     * @computed currentMask
     * @return {String}
     */
    currentMask() {
      if (this.mask) {
        return this.mask;
      }
      switch (this.type) {
        case 'months':
          return '00/0000';
        case 'years':
          return '0000';
      }
      return '00/00/0000';
    },
    /**
     * The current value format.
     *
     * @computed currentValueFormat
     * @return {String}
     */
    currentValueFormat() {
      if (this.valueFormat) {
        return this.valueFormat;
      }
      switch (this.type) {
        case 'months':
          return 'YYYY-MM';
        case 'years':
          return 'YYYY';
      }
      return 'YYYY-MM-DD';
    },
    /**
     * The current format displayed in the input.
     *
     * @computed currentFormat
     * @return {String}
     */
    currentFormat() {
      if (this.format) {
        return this.format;
      }
      switch (this.type) {
        case 'months':
          return 'MM/YYYY';
        case 'years':
          return 'YYYY';
      }
      return 'DD/MM/YYYY';
    },
    /**
     * True if the values of the inputValue and the oldInputValue properties are different.
     *
     * @computed intuValueChanged
     * @return {Boolean}
     */
    inputValueChanged() {
      return this.inputValue !== this.oldInputValue;
    }
  },
  methods: {
    /**
     * Gets the correct value format.
     *
     * @method getValueFormat
     * @param {String} val The value.
     * @fires valueFormat
     * @return {String}
     */
    getValueFormat(val) {
      return bbn.fn.isFunction(this.valueFormat) ? this.valueFormat(val) : this.currentValueFormat;
    },
    /**
     * Sets the value to the 'YYYY-MM-DD' format.
     *
     * @method setDate
     * @param {String} val
     * @fires getValueFormat
     * @fires setValue
     */
    setDate(val, calendar, format) {
      this.setValue(dayjs(val, format).isValid() ? dayjs(val, format).format(this.getValueFormat(val)) : '');
    },
    /**
     * Sets the value.
     *
     * @method setValue
     * @param {String} val The value.
     * @fires getValueFormat
     * @fires disableDates
     * @fires setInputValue
     * @emits input
     */
    setValue(val) {
      let format = !!val ? this.getValueFormat(val.toString()) : false,
        value = format ? dayjs(val.toString(), format).isValid() ? dayjs(val.toString(), format).format(format) : '' : '';
      if (value) {
        if (this.min && value < this.min) {
          value = this.min;
        }
        if (this.max && value > this.max) {
          value = this.max;
        }
        if (this.disableDates && bbn.fn.isFunction(this.disableDates) && this.disableDates(value) || bbn.fn.isArray(this.disableDates) && this.disableDates.includes(value)) {
          value = this.nullable ? null : '';
        }
      } else if (this.nullable) {
        value = null;
      }
      if (value !== this.value) {
        this.emitInput(value);
      } else {
        this.setInputValue(value);
      }
      if (!value) {
        this.inputValue = '';
        this.oldInputValue = '';
      }
      this.isOpened = false;
    },
    /**
     * Updates the calendar.
     *
     * @method updateCalendar
     * @fires getRef
    */
    updateCalendar() {
      if (this.getRef('calendar')) {
        this.getRef('calendar').refresh();
      }
    },
    /**
     * The method called by the input blur event.
     *
     * @method inputChanged
     * @fires getRef
     * @fires getValueFormat
     * @fires disableDates
     * @fires setValue
     * @emits change
    */
    inputChanged() {
      let mask = this.getRef('element'),
        newVal = mask.inputValue,
        value = !!newVal ? dayjs(newVal, this.currentFormat).format(this.getValueFormat(newVal)) : '';
      if (mask.raw(newVal) !== this.oldInputValue) {
        if (value && this.min && value < this.min) {
          value = this.min;
        }
        if (value && this.max && value > this.max) {
          value = this.max;
        }
        if (this.disableDates && bbn.fn.isFunction(this.disableDates) && this.disableDates(value) || bbn.fn.isArray(this.disableDates) && this.disableDates.includes(value)) {
          this.setValue(false);
        } else {
          this.setValue(value);
          this.$nextTick(() => {
            if (this.value !== value) {
              this.$emit('change', value);
            }
          });
        }
      }
    },
    /**
     * Set the new value by updating the calendar.
     *
     * @method setInputValue
     * @param {String} newVal
     * @fires getRef
     * @fires getValueFormat
     * @fires setValue
     * @fires updateCalendar
     */
    setInputValue(newVal) {
      if (newVal) {
        let mask = this.getRef('element'),
          mom = dayjs(newVal.toString(), this.getValueFormat(newVal.toString()));
        this.inputValue = newVal && mask && mom.isValid() ? mask.raw(mom.format(this.currentFormat)) : '';
      } else {
        this.inputValue = '';
      }
      this.oldInputValue = this.inputValue;
      this.updateCalendar();
    },
    /**
     * Clears the value.
     *
     * @method clear
     * @fires getRef
     * @fires setValue
     */
    clear() {
      this.setValue('');
      this.$nextTick(() => {
        this.$set(this.getRef('element'), 'inputValue', '');
      });
    }
  },
  /**
   * @event beforeCreate
   */
  beforeCreate() {
    if (bbn.env && bbn.env.lang && bbn.env.lang !== dayjs.locale()) {
      dayjs.locale(bbn.env.lang);
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    this.ready = true;
  },
  watch: {
    /**
     * @watch min
     * @fires setValue
     * @fires updateCalendar
     */
    min() {
      this.setValue(this.value || '');
      this.updateCalendar();
    },
    /**
     * @watch max
     * @fires setValue
     * @fires updateCalendar
     */
    max() {
      this.setValue(this.value || '');
      this.updateCalendar();
    },
    /**
     * @watch valueFormat
     * @fires setValue
     */
    valueFormat() {
      this.setValue(this.value || '');
    },
    /**
     * @watch maskedMounted
     * @fires setInputValue
     */
    maskedMounted(newVal) {
      if (newVal) {
        this.setInputValue(this.value);
      }
    },
    /**
     * @watch value
     * @fires setInputValue
    */
    value(newVal) {
      this.setInputValue(newVal);
    }
  }
};
import cpHtml from './datepicker.html';
import cpStyle from './datepicker.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./datepicker.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-datepicker',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-datetimepicker component
 *
 * @description bbn-datetimepicker is a component that allows the user to choose a time and date.
 * The interval period and the value format are easuly customizable.
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * The format of the date and time displayed in the user interface.
     *
     * @prop {String} format
     */
    format: {
      type: String
    },
    /**
     * The format of the date and time sent to the server.
     *
     * @prop {String} valueFormat
     */
    valueFormat: {
      type: [String, Function]
    },
    /**
     * The mask for date input.
     *
     * @prop {String} mask
     */
    mask: {
      type: String
    },
    /**
     * The maximum allowed value.
     *
     * @prop {String} max
     */
    max: {
      type: String
    },
    /**
     * The minimum allowed value.
     *
     * @prop {String} min
     */
    min: {
      type: String
    },
    /**
     * The disabled dates.
     *
     * @prop {Array|Function} disableDates
     */
    disableDates: {
      type: [Array, Function]
    },
    /**
     * The array of date values insertable into a range.
     *
     * @prop {Array} [[]] datesRange
    */
    datesRange: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Shows/hides the seconds selection.
     *
     * @prop {Boolean} [false] showSecond
    */
    showSecond: {
      type: Boolean,
      default: false
    },
    /**
     * Shows an alternative view for the time selection instead of the dropdowns.
     *
     * @prop {Boolean} [true] scrollMode
    */
    scrollMode: {
      type: Boolean,
      default: false
    },
    /**
     * Shows an alternative view for the time selection instead of the dropdowns.
     *
     * @prop {Boolean} [false] blocksMode
    */
    blocksMode: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to false if you dont' want to auto-resize the input's width based on its value (in characters).
     * @prop {Boolean} [true] autosize
     */
    autosize: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * Shows/hides the calendar's floater.
       *
       * @data {Boolean} [false] isCalendarOpened
      */
      isCalendarOpened: false,
      /**
       * Shows/hides the time's floater.
       *
       * @data {Boolean} [false] isTimeOpened
      */
      isTimeOpened: false,
      /**
       * Indicates if the bbn-masked is mounted.
       *
       * @data {Boolean} [false] maskedMounted
      */
      maskedMounted: false,
      /**
        * The current value shown on the input.
        *
        * @data {String} [''] inputValue
      */
      inputValue: '',
      /**
       * The old value displayed in the input.
       *
       * @data {String} [''] oldInputvalue
       */
      oldInputValue: ''
    };
  },
  computed: {
    /**
     * The current mask for the input.
     *
     * @computed currentMask
     * @return {String}
     */
    currentMask() {
      return this.mask || (this.showSecond ? '00/00/0000 00:00:00' : '00/00/0000 00:00');
    },
    /**
     * The current value format.
     *
     * @computed currentValueFormat
     * @return {String}
     */
    currentValueFormat() {
      return this.valueFormat || 'YYYY-MM-DD HH:mm:ss';
    },
    /**
     * The current format shown on the input.
     *
     * @computed currentFormat
     * @return {String}
     */
    currentFormat() {
      return this.format || (this.showSecond ? 'DD/MM/YYYY HH:mm:ss' : 'DD/MM/YYYY HH:mm');
    },
    /**
     * True if the values of the inputValue and the oldInputValue properties are different.
     *
     * @computed intuValueChanged
     * @return {Boolean}
     */
    inputValueChanged() {
      return this.inputValue !== this.oldInputValue;
    }
  },
  methods: {
    /**
     * Shows/hides the calendar's floater.
     *
     * @method showCalendar
     */
    showCalendar() {
      this.isTimeOpened = false;
      this.$nextTick(() => {
        this.isCalendarOpened = !this.isCalendarOpened;
      });
    },
    /**
     * Shows/hides the time's floater
     *
     * @method showTime
     */
    showTime() {
      this.isCalendarOpened = false;
      this.$nextTick(() => {
        this.isTimeOpened = !this.isTimeOpened;
      });
    },
    /**
     * Gets the correct value format.
     *
     * @method getValueFormat
     * @param {String} val The value.
     * @fires valueFormat
     * @return {String}
     */
    getValueFormat(val) {
      return bbn.fn.isFunction(this.valueFormat) ? this.valueFormat(val) : this.currentValueFormat;
    },
    /**
     * Sets the value from 'YYYY-MM-DD' formatted value.
     *
     * @method setDate
     * @param {String} val The value.
     * @fires getValueFormat
     * @fires setValue
    */
    setDate(val) {
      val = dayjs(val, 'YYYY-MM-DD').isValid() ? dayjs(val, 'YYYY-MM-DD') : '';
      if (this.value && val) {
        let mom = dayjs(this.value.toString(), this.getValueFormat(this.value.toString()));
        val = dayjs(dayjs(val, 'YYYY-MM-DD').hour(mom.hour())).minute(mom.minute());
        if (this.showSecond) {
          val = dayjs(val).second(mom.second());
        }
      }
      this.setValue(val ? dayjs(val).format(this.getValueFormat(dayjs(val).format(this.currentValueFormat))) : '');
    },
    /**
     * Sets the value format from 'HH:mm' to 'HH:mm:ss'.
     *
     * @method setTime
     * @param {String} val The value.
     * @fires getValueFormat
     * @fires setValue
    */
    setTime(val) {
      //val = dayjs(val, 'HH:mm' + (this.showSecond ? ':ss' : ''));
      val = dayjs(val, this.currentValueFormat);
      if (this.value) {
        let mom = dayjs(this.value.toString(), this.getValueFormat(this.value.toString()));
        val = dayjs(dayjs(dayjs(val).date(mom.date())).month(mom.month())).year(mom.year());
      }
      this.setValue(dayjs(val).format(this.getValueFormat(dayjs(val).format(this.currentValueFormat))));
    },
    /**
     * Sets the value.
     *
     * @method setValue
     * @param {String} val The value.
     * @param {String} format Type format.
     * @fires getValueFormat
     * @fires setInputValue
     * @fires disabledDates
     * @emits input
    */
    setValue(val, format) {
      if (!format) {
        format = !!val ? this.getValueFormat(val.toString()) : false;
      }
      let value = !!format && !!val ? dayjs(val.toString(), format).isValid() ? dayjs(val.toString(), format).format(format) : '' : '';
      if (value) {
        if (this.min && value < this.min) {
          value = this.min;
        }
        if (this.max && value > this.max) {
          value = this.max;
        }
        if (this.disableDates && bbn.fn.isFunction(this.disableDates) && this.disableDates(value) || bbn.fn.isArray(this.disableDates) && this.disableDates.includes(value)) {
          value = this.nullable ? null : '';
        }
      } else if (this.nullable) {
        value = null;
      }
      if (value !== this.value) {
        this.emitInput(value);
      } else {
        this.setInputValue(value);
      }
      if (!value) {
        this.inputValue = '';
        this.oldInputValue = '';
      }
      this.isCalendarOpened = false;
      this.isTimeOpened = false;
    },
    /**
     * Updates the calendar.
     *
     * @method updateCalendar
     * @fires getRef
     * @fires calendar.refresh
    */
    updateCalendar() {
      if (this.getRef('calendar')) {
        this.getRef('calendar').refresh();
      }
    },
    /**
     * The method initialized by the input blur event.
     *
     * @method inputChanged
     * @fires getValueFormat
     * @fires disableDates
     * @fires setValue
     * @emits change
    */
    inputChanged() {
      let mask = this.getRef('element'),
        newVal = mask.inputValue,
        value = !!newVal ? dayjs(newVal, this.currentFormat).format(this.getValueFormat(newVal)) : '';
      if (mask.raw(newVal) !== this.oldInputValue) {
        if (value && this.min && value < this.min) {
          value = this.min;
        }
        if (value && this.max && value > this.max) {
          value = this.max;
        }
        if (this.disableDates && bbn.fn.isFunction(this.disableDates) && this.disableDates(value) || bbn.fn.isArray(this.disableDates) && this.disableDates.includes(value)) {
          this.setValue(false);
        } else {
          this.setValue(value);
          this.$nextTick(() => {
            if (this.value !== value) {
              this.$emit('change', value);
            }
          });
        }
      }
    },
    /**
     * The method value input.
     *
     * @method setInputValue
     * @param {String} newVal
     * @fires getValueFormat
     * @fires updateCalendar
     * @fires getRef
     */
    setInputValue(newVal) {
      if (newVal) {
        let mask = this.getRef('element'),
          mom = dayjs(newVal.toString(), this.getValueFormat(newVal.toString()));
        this.inputValue = newVal && mask && mom.isValid() ? mask.raw(mom.format(this.currentFormat)) : '';
      } else {
        this.inputValue = '';
      }
      this.oldInputValue = this.inputValue;
      this.updateCalendar();
    },
    /**
     * clears any contained value in input.
     *
     * @method clear
     * @fires setValue
     * @fires getRef
     */
    clear() {
      this.setValue('');
      this.$nextTick(() => {
        this.$set(this.getRef('element'), 'inputValue', '');
      });
    }
  },
  /**
   * @event beforeCreate
   */
  beforeCreate() {
    if (bbn.env && bbn.env.lang && bbn.env.lang !== dayjs.locale()) {
      dayjs.locale(bbn.env.lang);
    }
  },
  /**
   * @event mounted
   *
   */
  mounted() {
    this.ready = true;
  },
  watch: {
    /**
     * @watch min
     * @fires setValue
     * @fires updateCalendar
     */
    min() {
      this.setValue(this.value || '');
      this.updateCalendar();
    },
    /**
     * @watch max
     * @fires setValue
     * @fires updateCalendar
     */
    max() {
      this.setValue(this.value || '');
      this.updateCalendar();
    },
    /**
     * @watch valueFormat
     * @fires setValue
     */
    valueFormat() {
      this.setValue(this.value || '');
    },
    /**
     * @watch maskedMounted
     * @fires setInputValue
     */
    maskedMounted(newVal) {
      if (newVal) {
        this.setInputValue(this.value);
      }
    },
    /**
     * @watch value
     * @fires setInputValue
     */
    value(newVal) {
      this.setInputValue(newVal);
    }
  }
};
import cpHtml from './datetimepicker.html';
import cpStyle from './datetimepicker.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./datetimepicker.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-datetimepicker',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-dropdown component
 *
 * @description The easy-to-implement bbn-dropdown component allows you to choose a single value from a user-supplied list.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017.
 */
import basic from '../../cp/mixins/basic.js';
import resizer from '../../cp/mixins/resizer.js';
import input from '../../cp/mixins/input.js';
import events from '../../cp/mixins/events.js';
import list from '../../cp/mixins/list.js';
import keynav from '../../cp/mixins/keynav.js';
import url from '../../cp/mixins/url.js';
import dropdown from '../../cp/mixins/dropdown.js';
import localStorage from '../../cp/mixins/localStorage.js';
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
   * @mixin bbn.cp.mixins.dropdown
   * @mixin bbn.cp.mixins.localStorage
    */
  mixins: [basic, events, input, resizer, list, keynav, url, dropdown, localStorage],
  props: {
    /**
     * @prop {Boolean} [false] notext
     */
    notext: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      startingTmpValue: '',
      startingTmpTimeout: null
    };
  },
  /**
   * The current icon.
   *
   * @computed currentIcon
   * @return {String}
  */
  beforeMount() {
    if (this.hasStorage) {
      let v = this.getStorage();
      if (v && v !== this.value) {
        this.emitInput(v);
      }
    }
  },
  methods: {
    /**
     * States the role of the enter key on the dropdown menu.
     *
     * @method keydown
     * @param {Event} e
     * @fires widget.select
     * @fires widget.open
     * @fires commonKeydown
     * @fires resetDropdown
     * @fires keynav
     */
    keydown(e) {
      if (this.commonKeydown(e)) {
        return;
      } else if (this.isOpened && e.key === 'Escape') {
        e.stopPropagation();
        e.preventDefault();
        this.resetDropdown();
      } else if (bbn.var.keys.dels.includes(e.which) && !this.filterString) {
        e.preventDefault();
        this.resetDropdown();
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        e.preventDefault();
        this.keynav(e);
      } else if (!this.isSearching && e.key === ' ') {
        e.preventDefault();
        this.isOpened = !this.isOpened;
      } else if (this.isOpened && e.key === 'Enter') {
        e.preventDefault();
        this.selectOver();
      }
    },
    paste() {
      //alert("PASTE");
    },
    keyup(e) {
      if (e.key.match(/^[A-z0-9\s]{1}$/)) {
        this.startingTmpValue += e.key;
        if (!this.isOpened) {
          this.isOpened = true;
        }
      }
    },
    selectOnNative(ev) {
      if (!ev.defaultPrevented) {
        let idx = bbn.fn.search(this.filteredData, 'data.' + this.sourceValue, ev.target.value);
        if (idx > -1) {
          let item = this.filteredData[idx].data;
          if (this.sourceAction && item[this.sourceAction] && bbn.fn.isFunction(item[this.sourceAction])) {
            item[this.sourceAction](item);
          } else if (this.sourceUrl !== undefined && item[this.sourceUrl]) {
            bbn.fn.link(item[this.sourceUrl]);
          } else if (item[this.uid || this.sourceValue] !== undefined) {
            this.emitInput(item[this.uid || this.sourceValue]);
            this.$emit('change', item[this.uid || this.sourceValue], idx, this.filteredData[idx].index, ev);
          }
        }
      }
      this.isOpened = false;
    }
  },
  /**
   * @event created
   */
  created() {
    this.$on('dataloaded', () => {
      if (this.value !== undefined && !this.currentText.length) {
        let row = bbn.fn.getRow(this.currentData, a => {
          return a.data[this.sourceValue] === this.value;
        });
        if (row) {
          this.currentText = this.clearHtml ? bbn.fn.html2text(row.data[this.sourceText]) : row.data[this.sourceText];
        }
      }
    });
  },
  beforeDestroy() {
    let fl = this.getRef('list');
    if (fl && fl.$el) {
      fl.$destroy();
      fl.$el.parentNode.removeChild(fl.$el);
    }
  },
  mounted() {
    this.ready = true;
  },
  watch: {
    startingTmpValue(v) {
      if (v) {
        let fl = this.getRef('list');
        if (fl) {
          let lst = fl.getRef('list');
          if (lst) {
            lst.overByString(v);
          }
        }
        if (this.startingTmpTimeout) {
          clearTimeout(this.startingTmpTimeout);
        }
        this.startingTmpTimeout = setTimeout(() => {
          this.startingTmpValue = '';
        }, 1000);
      }
    },
    /**
    * @watch  isActive
    */
    isActive(v) {
      if (!v && this.filterString) {
        this.currentText = this.currentTextValue || '';
      }
    },
    /**
     * @watch  isOpened
     */
    isOpened(val) {
      if (this.popup && val && !this.native) {
        this.popupComponent.open({
          title: false,
          element: this.$el,
          maxHeight: this.maxHeight,
          minWidth: this.$el.clientWidth,
          autoHide: true,
          uid: this.sourceValue,
          itemComponent: this.realComponent,
          onSelect: this.select,
          position: 'bottom',
          suggest: true,
          modal: false,
          selected: [this.value],
          onClose: () => {
            this.isOpened = false;
          },
          source: this.filteredData.map(a => bbn.fn.extend({
            value: a.data.text
          }, a.data)),
          sourceAction: this.sourceAction,
          sourceText: this.sourceText,
          sourceValue: this.sourceValue
        });
      }
      if (!val && this.preload && !this.native) {
        this.getRef('list').currentVisible = true;
      }
    },
    /**
     * @watch  currentText
     */
    currentText(newVal) {
      if (this.ready) {
        if (!newVal && this.value) {
          this.emitInput(this.isNullable && this.nullable !== null ? this.nullValue : '');
          this.filterString = '';
        } else {
          this.filterString = newVal === this.currentTextValue ? '' : newVal;
        }
      }
    },
    /**
     * @watch  currentSelectValue
     */
    currentSelectValue(newVal) {
      if (this.ready && newVal !== this.value) {
        this.emitInput(newVal);
      }
    },
    filterString(v) {
      let args = [0, this.currentFilters.conditions.length ? 1 : 0];
      if (v && this.isActive) {
        args.push({
          field: this.sourceText,
          operator: 'startswith',
          value: v
        });
      }
      this.currentFilters.conditions.splice(...args);
    },
    value(v) {
      this.currentSelectValue = v;
      this.currentText = this.currentTextValue || '';
      if (this.storage) {
        if (v) {
          this.setStorage(v);
        } else {
          this.unsetStorage();
        }
      }
    }
  }
};
import cpHtml from './dropdown.html';
import cpStyle from './dropdown.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./dropdown.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-dropdown',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-cms-block component
 * @description bbn-cms-block
 * @copyright BBN Solutions
 * @author Loredana Bruno
 * @created 09/11/2020.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.componentInside
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.componentInside],
  statics() {
    const titleTemplates = {
      h1: `<h1 v-text="currentValue"></h1>`,
      h2: `<h2 v-text="currentValue"></h2>`,
      h3: `<h3 v-text="currentValue"></h3>`,
      h4: `<h4 v-text="currentValue"></h4>`,
      h5: `<h5 v-text="currentValue"></h5>`
    };
    const htmlTemplates = {
      p: `<p v-html="currentValue"></p>`,
      span: `<span v-html="currentValue"></span>`
    };
    const templates = {
      text: {
        view: '<div v-text="currentValue"></div>',
        edit: '<bbn-input v-model="currentValue"></bbn-input>'
      },
      multilines: {
        view: '<div v-text="currentValue" style="white-space: pre-wrap; word-break: break-word"></div>',
        edit: '<bbn-textarea v-model="currentValue" class="bbn-100"></bbn-textarea>'
      },
      inline: {
        view: '<div v-text="value"></div>',
        edit: '<bbn-inline-editor v-model="currentValue"></bbn-inline-editor>'
      },
      component: {
        view: '<div v-text="currentValue" style="white-space: pre-wrap; word-break: break-word"></div>',
        edit: '<div class="bbn-100"><bbn-anon :is="component" v-bind="componentOptions" v-model="currentValue"></bbn-anon></div>'
      },
      html: {
        view: `<div  @click="$parent.editMode" @mouseover="$parent.mouseover" @mouseleave="$parent.mouseleave"
                      :class="['component-container', 'bbn-block-html', alignClass]"
                      v-html="currentValue"
                      :style="style">
    
                </div>`,
        edit: `<div :class="['component-container', 'bbn-block-html', alignClass ]">
                  <bbn-rte v-model="currentValue">
                  </bbn-rte>
                </div>`
      },
      title: {
        view: `<div @click="$parent.editMode" @mouseover="$parent.mouseover" @mouseleave="$parent.mouseleave"  :class="['component-container', 'bbn-block-title', {'has-hr': source.hr}, alignClass]":style="style">
                  <hr v-if="source.hr">
                  <bbn-anon :is="cpHTML(source.tag, 'title')" :source="source"></bbn-anon>
                  <hr v-if="source.hr">
                 </div>`,
        edit: `<div :class="['component-container','bbn-cms-block-edit' ,'bbn-block-title', 'bbn-flex-height', {'has-hr': source.hr}, alignClass]" :style="style">
                  <div class="edit-title bbn-w-100">
                    <hr v-show="source.hr"><bbn-anon :is="cpHTML(source.tag,'title')" :source="source"></bbn-anon><hr v-if="source.hr">
                  </div>
                  <div class="bbn-grid-fields bbn-vspadded bbn-w-100">
                    <label v-text="_('Title tag')"></label>
                    <div>
                      <bbn-dropdown :source="tags" v-model="source.tag"></bbn-dropdown>
                    </div>
                    <label v-text="_('Title text')"></label>
                    <bbn-input v-model="currentValue"></bbn-input>
                    <label>Title color</label>
                      <div>
                        <bbn-colorpicker @change="setColor"
                        ></bbn-colorpicker>
                      </div>
                    <label v-text="_('Title alignment')"></label>
                    <bbn-block-align-buttons></bbn-block-align-buttons>
                    <label v-text="_('Line')"></label>
                    <bbn-checkbox v-model="source.hr"></bbn-checkbox>
                  </div>
                </div>`
      },
      image: {
        //taglia originale 100% width,width 50% 33% 25%
        view: `
          <div class="component-container bbn-block-image" :class="alignClass">
            <a v-if="source.href" target="_self" :href="$parent.linkURL + source.href" class="bbn-c">
              <img :src="$parent.path + source.src"
                    style="heigth:500px;width:100%"
                   :style="style"
                   :alt="source.alt ? source.alt : ''"
              >
            </a>
            <img v-else
                 :src="$parent.path + source.src"
                 :style="style"
                 :alt="source.alt ? source.alt : ''"
            >
            <p class="image-caption bbn-l bbn-s bbn-vsmargin"
               v-if="source.caption"
               v-html="source.caption"
            ></p>
            <!--error when using decodeuricomponent on details of home image-->
            <a class="image-details-title bbn-l bbn-vsmargin bbn-w-100"
               v-if="source.details_title"
               v-html="(source.details_title)"
               :href="source.href"
               target="_blank"
            ></a>
            <p class="image-details bbn-l bbn-vsmargin"
               v-if="source.details"
               v-html="(source.details)"
            ></p>
          </div>`,
        edit: `
          <div class="component-container bbn-block-image" :class="alignClass">
            <div class="bbn-padded">
              <div class="bbn-grid-fields bbn-vspadded">
                <label v-text="_('Upload your image')"></label>
                <bbn-upload :save-url="'upload/save/' + ref"
                            remove-url="test/remove"
                            :json="true"
                            :paste="true"
                            :multiple="false"
                            v-model="image"
                            @success="imageSuccess"
                ></bbn-upload>
    
                <label v-text="_('Image size')"></label>
                <bbn-cursor v-model="source.style['width']"
                            unit="%"
                            :min="0"
                            :max="100"
                            :step="20"
                ></bbn-cursor>
    
                <label v-text="_('Image alignment')"></label>
                <bbn-block-align-buttons></bbn-block-align-buttons>
              </div>
            </div>
            <img :src="$parent.path + source.src" :style="style">
            <p class="image-caption bbn-l bbn-s bbn-vsmargin" v-if="source.caption" v-html="source.caption"></p>
          </div>
                    `
      },
      carousel: {
        view: `
          <div :class="['component-container', 'bbn-block-carousel', 'bbn-w-100',  alignClass]" :style="style" v-if="show">
            <div v-for="(group, idx) in carouselSource"
                 v-if="idx === currentCarouselIdx"
            >
              <bbn-cms-carousel-control :source="idx"
                                        :key="idx"
                                        v-if="carouselSource.length > 3"
              ></bbn-cms-carousel-control>
              <div :class="['bbn-w-100',carouselCols]">
                <bbn-cms-block-gallery-item v-for="(image, imgIdx) in group" :source="image" :key="imgIdx" :index="imgIdx"></bbn-cms-block-gallery-item>
              </div>
            </div>
          </div>
          `,
        edit: `<div>edit</div>`
      },
      gallery: {
        view: `
          <div :class="['component-container', 'bbn-block-gallery', alignClass, galleryCols]" :style="style" v-if="show">
            <bbn-cms-block-gallery-item v-for="(image, idx) in source.source" :source="image" :key="idx" :index="idx"></bbn-cms-block-gallery-item>
          </div>
          `,
        edit: `
          <div>
            <div :class="['component-container', 'bbn-block-gallery', alignClass, galleryCols]" :style="style" v-if="show">
              <!-- GIVE HREF TO VIEW FULL IMAGE -->
              <bbn-cms-block-gallery-item v-for="(image, idx) in currentValue" :source="image" :key="idx" :index="idx"></bbn-cms-block-gallery-item>
            </div>
            <div class="bbn-grid-fields bbn-padded">
              <label>Columns number</label>
              <div>
                <bbn-dropdown v-model="source.columns"
                              :source="tinyNumbers"
                ></bbn-dropdown>
              </div>
              <label v-text="_('Upload your images')"></label>
              <bbn-upload :save-url="'upload/save/' + ref"
                          remove-url="test/remove"
                          :data="{gallery: true}"
                          :paste="true"
                          :multiple="true"
                          v-model="currentValue"
                          @success="imageSuccess"
              ></bbn-upload>
    
            </div>
          </div>
          `
      },
      video: {
        view: `
            <div :class="['component-container', 'bbn-cms-block-video', alignClass]">
              <!--ERROR ON HOME-->
              <!--bbn-video :width="source.width"
                         :style="style"
                         :height="source.height"
                         :autoplay="autoplay"
                         :muted="muted"
                         :youtube="youtube"
                         :source="source.src"
              ></bbn-video-->
              <iframe
                      :style="style"
    
                      :autoplay="false"
    
                      :src="source.src"
               ></iframe>
            </div>`,
        edit: `
          <div class="component-container" id="video-container">
            <div class="bbn-grid-fields bbn-padded">
              <label v-text="_('Video source')"></label>
              <bbn-input v-model="currentValue"></bbn-input>
              <label>Muted</label>
              <div>
                <bbn-button :notext="true"
                            :title="_('Mute the video')"
                            @click="muted = !muted"
                            :icon="muted ? 'nf nf-oct-mute' : 'nf nf-oct-unmute'"
                >
                </bbn-button>
              </div>
              <label>Autoplay</label>
              <div>
                <bbn-button :notext="true"
                            :title="_('Autoplay')"
                            @click="autoplay = !autoplay"
                            :icon="autoplay ? 'nf nf-fa-pause' : 'nf nf-fa-play'"
                >
                </bbn-button>
              </div>
              <label>Video alignment</label>
              <bbn-block-align-buttons></bbn-block-align-buttons>
              <label>Video width</label>
              <div>
                <bbn-cursor v-model="source.style['width']"
                            :min="100"
                            :max="1000"
                            :step="10"
                            class="bbn-w-70"
                ></bbn-cursor>
              </div>
              <label>Video height</label>
              <div>
                <bbn-cursor v-model="source.style['height']"
                            :min="100"
                            :max="1000"
                            :step="10"
                            class="bbn-w-70"
                ></bbn-cursor>
              </div>
            </div>
            <div :class="alignClass">
              <bbn-video :width="source.style.width"
                        :style="style"
                        :height="source.style.height"
                        :autoplay="autoplay"
                        :muted="muted"
                        :youtube="youtube"
                        :source="currentValue"
              ></bbn-video>
            </div>
          </div>
          `
      },
      line: {
        view: `<div class="component-container"><hr :style="style"></div>`,
        edit: `<div class="block-line-edit component-container">
                  <hr :style="style">
                  <div class="block-line-edit-command bbn-padded">
                    <div class="bbn-grid-fields bbn-vspadded">
                      <label>Line width</label>
                      <div>
                        <bbn-cursor v-model="source.style['width']"
                                    :min="0"
                                    :max="100"
                                    unit="%"
                        ></bbn-cursor>
                      </div>
                      <label>Line height</label>
                      <div>
                        <bbn-cursor v-model="source.style['border-width']"
                                    :min="1"
                                    :max="10"
                                    unit="px"
                        ></bbn-cursor>
                      </div>
                      <label>Line style</label>
                      <div>
                        <bbn-dropdown v-model="source.style['border-style']"
                                      :source="borderStyle"
                        ></bbn-dropdown>
                      </div>
    
                      <label>Line color</label>
                      <div>
                        <bbn-colorpicker v-model="source.style['border-color']"
                        ></bbn-colorpicker>
                      </div>
                      <label>Line alignment</label>
                      <bbn-block-align-buttons></bbn-block-align-buttons>
                    </div>
                  </div>
                 </div>`
      },
      space: {
        view: `<div class="component-container" :style="style">
                  <div class="block-space-view"></div>
                </div>`,
        edit: `
              <div class="component-container" :style="style">
                <div :style="style" class="block-space-edit">
                  <bbn-cursor v-model="source.style.height"
                              unit="px"
                              :min="0"
                              :step="50"
                  ></bbn-cursor>
                </div>
              </div>`
      }
    };
    const borderStyle = [{
      "text": "hidden",
      "value": "hidden"
    }, {
      "text": "dotted",
      "value": "dotted"
    }, {
      "text": "dashed",
      "value": "dashed"
    }, {
      "text": "solid",
      "value": "solid"
    }, {
      "text": "double",
      "value": "double"
    }, {
      "text": "groove",
      "value": "groove"
    }, {
      "text": "ridge",
      "value": "ridge"
    }];
    return {
      titleTemplates,
      htmlTemplates,
      templates,
      borderStyle
    };
  },
  props: {
    /**
     * @prop {String} ['nf nf-fa-edit bbn-xlarge bbn-blue'] editIcon
     */
    editIcon: {
      type: String,
      default: 'nf nf-fa-edit bbn-xlarge bbn-blue'
    },
    /**
     * @prop {String} ['nf nf-fa-check bbn-xlarge bbn-green'] saveIcon
     */
    saveIcon: {
      type: String,
      default: 'nf nf-fa-check bbn-xlarge bbn-green'
    },
    /**
     * @prop {String} ['nf nf-fa-check bbn-xlarge bbn-red'] cancelIcon
     */
    cancelIcon: {
      type: String,
      default: 'nf nf-fa-close bbn-xlarge bbn-red'
    },
    /**
     * The aduio's URL
     * @prop {Object} [{}] source
     */
    source: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * The audio's title
     * @prop {String} [''] title
     */
    title: {
      type: String,
      default: ''
    },
    /**
     * @prop {Number} index
     */
    index: {
      type: Number
    },
    //the path for the index showing the images ('ex: image/')
    /**
     * @prop {String} [''] path
     */
    path: {
      type: String,
      default: ''
    },
    //the path for the links (give a path to a controller to manage the links)
    /**
     * @prop {String} [''] linkURL
     */
    linkURL: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} [] novalue
     */
    novalue: {
      type: String
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] over
       */
      over: false,
      /**
       * @data {Boolean} [false] isEditing
       */
      isEditing: false,
      /**
       * @data {Boolean} [true] editing
       */
      editing: true,
      /***
       * @data {String} ['100%'] width
       */
      width: '100%',
      /**
       * @data {String} ['100%']
       */
      height: '100%',
      /**
       * Ready is important for the component template to be defined.
       *
       * @prop {Boolean} [true] ready
       */
      ready: true,
      /**
       * @prop {Object} [{}] initialSource
       */
      initialSource: {},
      /**
       * @prop {(Object|Null|String)} currentValue
       */
      currentValue: this.value ? bbn.fn.clone(this.value) : this.source.nullable ? null : ''
    };
  },
  computed: {
    /**
     * @computed changed
     * @return {Boolean}
     */
    changed() {
      return !bbn.fn.isSame(this.currentValue, this.value);
    },
    /**
     * @computed type
     * @return {String}
     */
    type() {
      if (this.component) {
        return 'component';
      }
      if (this.source && this.source.type) {
        return this.source.type;
      }
      return 'text';
    },
    /**
     * @computed parent
     * @return {(Object|null)}
     */
    parent() {
      const ct = this.closest('bbn-container');
      if (this.ready && ct) {
        return ct.getComponent();
      }
      return null;
    }
  },
  /**
   * getCurrentValue
   */
  methods: {
    /**
     * @method getCurrentValue
     * @return {*}
     */
    getCurrentValue() {
      return this.currentValue;
    },
    /**
     * @method save
     * @emits save
     */
    save() {
      if (this.currentValue !== this.value) {
        this.originalValue = bbn.fn.clone(this.value);
        this.$emit('save', this.currentValue, this.originalValue);
        this.emitInput(this.currentValue);
      }
      this.isEditing = false;
    },
    /**
     * @method focusout
     * @fires save
     */
    focusout() {
      if (this.isEditing) {
        this.save();
      }
    },
    /**
     * @method onCancel
     */
    async onCancel() {
      bbn.fn.log("CANCEL");
      this.currentValue = this.value ? bbn.fn.clone(this.value) : this.source.nullable ? null : '';
      this.isEditing = false;
      await this.$forceUpdate();
    },
    /**
     * @method mouseleave
     */
    mouseleave() {
      this.over = false;
    },
    /**
     * @method mouseover
     */
    mouseover() {
      this.over = true;
      /*console.log('over: ' + this.over)
      if ( !e.target.closest(".component-container") ){
        e.preventDefault();
        e.stopImmediatePropagation();
        this.over = false;
      }
      else{
        this.over = true;
      }*/
    },

    /**
     * @method mouseenter
     */
    mouseenter() {
      alert('enter');
    },
    /**
     * @method selectImg
     * @param {String} st
     */
    selectImg(st) {
      bbn.fn.link(st);
    },
    /**
     * @method alert
     */
    alert() {
      alert('test');
    },
    /**
     * adds the events listener when edit = true
     * @method _setEvents
     * @param {boolean} edit
     */
    _setEvents() {
      /*
      document.addEventListener('mousedown', this.checkMouseDown);
      document.addEventListener('touchstart', this.checkMouseDown);
      document.addEventListener('keydown', this.checkKeyCode);
      */
      /*if ( edit ){
        document.addEventListener('mousedown', this.checkMouseDown);
        document.addEventListener('touchstart', this.checkMouseDown);
        document.addEventListener('keydown', this.checkKeyCode);
      }
      else{
        document.addEventListener('mouseover', this.mouseover);
        document.removeEventListener('mousedown', this.checkMouseDown);
        document.removeEventListener('touchstart', this.checkMouseDown);
      }*/
    },
    /**
     * @method checkKeyCode
     * @param {Event} e
     */
    checkKeyCode(e) {
      if (e.keyCode === 27) {
        this.edit = false;
      }
    },
    /**
     * set edit to false
     * @method checkMouseDown
     * @param {Event} e
     */
    checkMouseDown(e) {
      if (!e.target.closest(".bbn-cms-block-edit")) {
        /*e.preventDefault();
        e.stopImmediatePropagation();*/
        this.edit = false;
        alert(this.edit);
      } else {
        alert(this.edit);
        this.editMode();
      }
    },
    /**
     * @method editBlock
     */
    editBlock() {
      if (this.changed) {
        appui.success(bbn._('Block changed'));
        //add a confirm
        this.$nextTick(() => {
          this.edit = false;
        });
      } else {
        this.edit = false;
      }
    },
    /**
     * @method edit
     * @emits edit
     */
    edit() {
      let ev = new Event('edit', {
        cancelable: true
      });
      this.$emit('edit', ev, this);
      if (!ev.defaultPrevented) {
        this.isEditing = true;
      }
    },
    /**
     * @method cancelEdit
     */
    cancelEdit() {},
    /**
     * @method editMode
     */
    editMode() {
      let blocks = this.closest('bbn-container').getComponent().findAll('bbn-cms-block');
      bbn.fn.each(blocks, (v, i) => {
        v.edit = false;
        v.over = false;
      });
      this.edit = true;
    },
    /**
     * returns the object of the component basing on the given type
     * @param {String} type
     * @return {Object}
     */
    getComponentObject(type) {
      return {
        props: {
          value: {},
          source: {}
        },
        template: this.isEditing ? bbnEditableCp.templates[type]['edit'] : bbnEditableCp.templates[type]['view'],
        data() {
          let tmp = Object.keys(bbnEditableCp.titleTemplates).map(a => {
            return a = {
              text: a,
              value: a
            };
          });
          return {
            //cp video
            muted: true,
            autoplay: false,
            align: '',
            tags: tmp,
            image: [],
            tinyNumbers: [{
              text: '1',
              value: 1
            }, {
              text: '2',
              value: 2
            }, {
              text: '3',
              value: 3
            }, {
              text: '4',
              value: 4
            }],
            borderStyle: bbnEditableCp.borderStyle,
            ref: new Date().getTime(),
            show: true,
            currentCarouselIdx: 0
          };
        },
        computed: {
          currentValue: {
            get() {
              return this.value;
            },
            set(v) {
              this.$emit('input', v);
            }
          },
          edit() {
            return this.$parent.edit;
          },
          path() {
            return this.$parent.path;
          },
          linkURL() {
            return this.$parent.linkURL;
          },
          carouselSource() {
            if (this.source.source && this.source.type === 'carousel') {
              let res = [];
              var i,
                j,
                temparray,
                chunk = 3;
              for (i = 0, j = this.source.source.length; i < j; i += chunk) {
                temparray = this.source.source.slice(i, i + chunk);
                res.push(temparray);
                // do whatever
              }

              return res;
            }
          },
          mobile() {
            if (bbn.env.width <= 640) {
              this.$parent.isMobile = true;
              return true;
            }
            return false;
          },
          galleryCols() {
            if (this.source.type === 'gallery' && !this.mobile) {
              if (this.source.columns === 1) {
                return 'cols-1';
              } else if (this.source.columns === 2) {
                return 'cols-2';
              } else if (this.source.columns === 4) {
                return 'cols-4';
              }
              return 'cols-3';
            } else if (this.mobile) {
              if (this.source.columns !== 2) {
                return 'cols-2';
              } else {
                return 'cols-1';
              }
            }
          },
          carouselCols() {
            if (this.source.type === 'carousel' && !this.mobile) {
              if (this.source.columns === 1) {
                return 'cols-1';
              } else if (this.source.columns === 2) {
                return 'cols-2';
              } else if (this.source.columns === 4) {
                return 'cols-4';
              }
              return 'cols-3';
            } else if (this.mobile) {
              return 'cols-2';
            }
          },
          youtube() {
            if (this.source.src) {
              return this.source.src.indexOf('youtube') > -1;
            }
            return false;
          },
          contentStyle() {
            var _this$source$style;
            let st = '';
            if ((_this$source$style = this.source.style) !== null && _this$source$style !== void 0 && _this$source$style['border-radius']) {
              st += 'border-radius:' + this.source.style['border-radius'] + (bbn.fn.isNumber(this.source.style['border-radius']) ? 'px;' : ';');
            }
            return st;
          },
          alignClass() {
            let st = 'bbn-c';
            if (this.source.align === 'left') {
              st = 'bbn-l';
            }
            if (this.source.align === 'right') {
              st = 'bbn-r';
            }
            return st;
          },
          style() {
            let st = '';
            if (this.source.style) {
              if (this.source.style['color']) {
                st += 'color: ' + this.source.style['color'] + ';';
              }
              if (this.source.style['font-size']) {
                st += 'font-size:' + this.source.style['font-size'] + (bbn.fn.isNumber(this.source.style['font-size']) ? 'px;' : ';');
              }
              if (this.source.style['width']) {
                st += 'width:' + this.source.style['width'] + (bbn.fn.isNumber(this.source.style['width']) ? 'px;' : ';');
              }
              if (this.source.style['height']) {
                st += 'height:' + this.source.style['height'] + (bbn.fn.isNumber(this.source.style['height']) ? 'px;' : ';');
              }
              if (this.source.style['border-style']) {
                st += 'border-style:' + this.source.style['border-style'] + ';';
              }
              if (this.source.style['border-color']) {
                st += 'border-color:' + this.source.style['border-color'] + ';';
              }
              if (this.source.type === 'line') {
                if (bbn.fn.isEmpty(this.source.style) || !this.source.style['border-width']) {
                  this.source.style['border-width'] = '100%';
                  st += 'border-top-width:' + this.source.style['border-width'] + (bbn.fn.isNumber(this.source.style['border-width']) ? 'px;' : ';');
                  st += 'border-bottom:0';
                }
              } else {
                if (this.source.style['border-width']) {
                  st += 'border-width:' + this.source.style['border-width'] + (bbn.fn.isNumber(this.source.style['border-width']) ? 'px;' : ';');
                }
              }
            }
            if (this.source.align && (this.source.type === 'line' || this.source.type === 'video')) {
              let margin = '';
              switch (this.source.align) {
                case 'center':
                  margin = 'margin-left: auto;margin-right:auto';
                  break;
                case 'left':
                  this.source.type === 'video' ? margin = 'float: left' : margin = 'margin-left: 0';
                  break;
                case 'right':
                  this.source.type === 'video' ? margin = 'float: right' : margin = 'margin-right: 0';
                  break;
              }
              st += margin;
            }
            return st;
          }
        },
        methods: {
          decodeURIComponent(st) {
            //the regular expression to match the new line
            /*let reg = /\r?\n|\r/g;
            if(st.match(reg)){
              st = st.replace(reg, '');
            }*/
            //var st = bbn.fn.nl2br(st);
            return decodeURIComponent(this.escape(st));
          },
          escape(st) {
            return escape(st);
          },
          /**
           * calculate the height of the images in gallery basing on source.columns
           */
          makeSquareImg() {
            if (!this.source.noSquare) {
              //creates square container for the a
              var items = this.$el.querySelectorAll('a'),
                images = this.$el.querySelectorAll('img');
              this.show = false;
              if (this.source.columns === 1) {
                for (let i in items) {
                  if (images[i].tagName === 'IMG') {
                    this.$nextTick(() => {
                      images[i].style.height = 'auto';
                      images[i].style.width = '100%';
                    });
                  }
                }
              } else {
                for (let i in images) {
                  if (images[i].tagName === 'IMG') {
                    this.$nextTick(() => {
                      images[i].style.height = items[i].offsetWidth + 'px';
                    });
                  }
                }
              }
              this.show = true;
            }
          },
          setColor(a) {
            this.source.style.color = a;
            this.$parent.edit = false;
            //this.$forceUpdate()
          },

          //returns the component for the blocks of type title
          cpHTML(tag, type) {
            return {
              props: ['source'],
              template: type === 'title' ? bbnEditableCp.titleTemplates[tag] : bbnEditableCp.htmlTemplates[tag]
            };
          },
          /** @todo Seriously these arguments names??  */
          imageSuccess(a, b, c, d) {
            if (c.success && c.image.src.length) {
              if (this.source.type === 'gallery') {
                c.image.src = c.image.name;
                c.image.alt = '';
                setTimeout(() => {
                  this.show = false;
                  //this.currentValue.push(c.image);//
                  this.makeSquareImg();
                }, 200);
              } else {
                this.emitInput(c.image.name);
              }
              appui.success(bbn._('Image correctly uploaded'));
            } else {
              appui.error(bbn._('An error occurred while uploading the image'));
            }
          }
        },
        components: {
          'bbn-cms-block-gallery-item': {
            props: ['source', 'index'],
            //:src="'image/' + currentValue"
            //the template below to take the image from index
            template: `
                <!--IMPORTANT CHANGE FROM CLICK TO HREF WHEN WILL BE POSSIBLE TO MAKE LINK-->
                <!--a  target="_self" :href="(source.href ? (linkURL + source.href) : source.src)"-->
                <a  target="_self" @click="selectImg">
                  <!--TO TAKE IMAGE FROM THE INDEX-->
                  <img :src="path + source.src" :alt="source.alt ? source.alt : ''" :style="$parent.source.style">
                  <div v-if="source.caption || (source.title && (type === 'carousel'))"
                       :class="['bbn-block-gallery-caption',$parent.alignClass]"
                       v-html="(source.caption && (type === 'gallery')) ? source.caption : source.title"
                  ></div>
                  <div v-if="source.details_title"
                       :class="['image-details-title',$parent.alignClass]"
                       v-html="source.details_title"
                  ></div>
                  <div v-if="source.details"
                       :class="['image-details',$parent.alignClass]"
                       v-html="source.details"
                  ></div>
                  <div v-if="source.price"
                       :class="['image-price',$parent.alignClass]"
                       v-text="source.price"
                  ></div>
                  <time v-if="source.time" v-text="source.time" :class="$parent.alignClass"></time>
                </a>
                `

            /*template: `
             <a :href="(source.src ? source.src : source.name)" target="_blank">
               <!--TO TAKE IMAGE FROM THE INDEX-->
               <!--img :src="'image/gallery/' + (source.src ? source.src : source.name)" :alt="source.alt ? source.alt : ''"-->
               <img :src="source.src" :alt="source.alt ? source.alt : ''">
             </a>
             `*/,
            methods: {
              //IMPORTANT TO RENDER CHINESE CHARACTERS
              decodeURIComponent(st) {
                return this.$parent.decodeURIComponent(st);
              },
              escape(st) {
                return this.$parent.escape(st);
              },
              selectImg() {
                bbn.fn.log(this.closest('bbn-container'), this.closest('bbn-container').getComponent());
                return this.closest('bbn-cms-block').selectImg(this.source.href);
              }
            },
            computed: {
              path() {
                return this.$parent.path;
              },
              linkURL() {
                return this.$parent.linkURL;
              },
              type() {
                return this.$parent.source.type;
              }
            },
            mounted() {
              bbn.fn.happy(this.source.price);
            }
          },
          'bbn-cms-carousel-control': {
            template: `
              <div class="bbn-r control">
                <span>
                  <i @click="prev" class="prev nf nf-oct-chevron_left"></i>
                  <i @click="next" class="next nf nf-oct-chevron_right"></i>
                </span>
              </div>`,
            methods: {
              next() {
                if (this.$parent.currentCarouselIdx < this.$parent.carouselSource.length - 1) {
                  this.$parent.currentCarouselIdx++;
                }
              },
              prev() {
                if (this.$parent.currentCarouselIdx > 0) {
                  this.$parent.currentCarouselIdx--;
                }
              }
            }
          },
          //internal component for align buttons in edit of the block
          'bbn-block-align-buttons': {
            template: `
              <div>
                <bbn-button icon="nf nf-fa-align_left"
                            :title="_('Align left')"
                            :notext="true"
                            @click="align = 'left'"
                            :class="{'bbn-state-active': ($parent.source.align === 'left')}"
                ></bbn-button>
                <bbn-button icon="nf nf-fa-align_center" :title="_('Align left')"
                            :notext="true"
                            @click="align = 'center'"
                            :class="{'bbn-state-active': ($parent.source.align === 'center')}"
                ></bbn-button>
                <bbn-button icon="nf nf-fa-align_right"
                            :title="_('Align left')"
                            :notext="true"
                            @click="align = 'right'"
                            :class="{'bbn-state-active': ($parent.source.align === 'right')}"
                ></bbn-button>
              </div>`,
            data() {
              return {
                align: ''
              };
            },
            watch: {
              align(val) {
                this.$parent.source.align = val;
                this.$parent.$parent.$forceUpdate();
              }
            }
          }
        },
        watch: {
          'source.columns': {
            handler(val) {
              this.makeSquareImg();
            }
          }
        },
        beforeMount() {
          if (bbn.fn.isEmpty(this.source.style)) {
            this.source.style = {};
          }
          if (this.$parent.edit) {
            if (this.type === 'image' && this.currentValue && this.currentValue.length) {
              let extension = bbn.fn.substr(this.currentValue, this.currentValue.lastIndexOf('.'), this.currentValue.length);
              //take the correct size
              this.image.push({
                "name": this.currentValue,
                "size": 574906,
                "extension": extension
              });
            } else if (this.type === 'gallery' && this.currentValue && this.currentValue.length) {
              /*this.image = bbn.fn.map(this.currentValue, a => {
                let extension = bbn.fn.substr(a.src, a.src.lastIndexOf('.'), a.src.length);
                a.name = a.src;
                a.size = 465464;
                a.extension = extension;
                return a
              })*/
            }
          }
        },
        mounted() {
          if (this.source.type === 'gallery' || this.source.type === 'carousel') {
            this.makeSquareImg();
          }
        }
      };
    }
  },
  /**
   * @event beforeMount
   * @fires getComponentObject
   */
  beforeCreate() {
    this.componentObject = {};
  },
  created() {
    this.componentObject = this.getComponentObject(this.type);
  },
  /**
   * @event mounted
   */
  mounted() {
    this.initialSource = bbn.fn.extend({}, this.source);
    this.ready = true;
    if (bbn.fn.isEmpty(this.source.style)) {
      bbn.fn.warning(this.source.type + "  HAS STYLE WHICH IS EMPTY?");
      this.source.style = {};
    }
    if (bbn.fn.isEmpty(this.source.style) || !this.source.style.color) {
      this.source.style.color = '';
    }
    if (!this.source.align) {
      this.source.align = 'left';
    }
    if (bbn.fn.isEmpty(this.source.style) || !this.source.style.width) {
      this.source.width = '100%';
    }
    //if alignment is already defined as style property
    if (this.source.style && this.source.style.align) {
      this.source.align = this.source.style.align;
    }
    bbn.fn.log("I AM THE BLOCK! ", this.source);
  },
  watch: {
    /**
     * @watch isEditing
     */
    isEditing() {
      this.componentObject = this.getComponentObject(this.type);
    },
    /**
     * @watch type
     */
    type() {
      this.componentObject = this.getComponentObject(this.type);
    },
    /**
     * @watch edit
     * @param {Boolean} val
     */
    edit(val) {
      //if adding a new block
      throw new Error('watch');
      if (val === false && this.newBlock === true) {
        this.parent.source.lines.push(this.source);
        this.parent.lines.push({
          content: {
            data: '<div>[CONTENT]</div>'
          },
          type: ''
        });
        appui.success(bbn._('New block ' + this.source.type + ' added!'));
        this.newBlock = false;
      }
      //this._setEvents()
    }
  }
};

import cpHtml from './editable.html';
import cpStyle from './editable.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./editable.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-editable',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-icon component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 */
const cpDef = {
  name: 'bbn-editable-content',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.field
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.field],
  props: {
    /**
     * @prop {String} ['nf nf-fa-edit'] editIcon
     */
    editIcon: {
      type: String,
      default: 'nf nf-fa-edit'
    },
    /**
     * @prop {String} ['nf nf-fa-save'] saveIcon
     */
    saveIcon: {
      type: String,
      default: 'nf nf-fa-save'
    },
    /**
     * @prop {String} ['nf nf-mdi-cancel'] cancelIcon
     */
    cancelIcon: {
      type: String,
      default: 'nf nf-mdi-cancel'
    },
    /**
     * @prop {(String|Function)} help
     */
    help: {
      type: [String, Function]
    },
    /**
     * @prop {String} type
     */
    type: {
      type: String
    },
    /**
     * @prop {} editor
     */
    editor: {},
    /**
     * @prop {} editorOptions
     */
    editorOptions: {},
    /**
     * @prop {Boolean} [true] editable
     */
    editable: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      isEditing: false,
      currentValue: this.value
    };
  },
  methods: {
    save() {
      this.emitInput(this.currentValue);
      this.isEditing = false;
    },
    cancel() {
      this.emitInput(this.originalValue);
      this.currentValue = this.value;
      this.isEditing = false;
    }
  }
};
import cpHtml from './editable-content.html';
import cpStyle from './editable-content.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./editable-content.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-editable-content',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-emoji component
 * @description bbn-emoji
 * @author Mirko Argentino
 * @copyright BBN Solutions
 * @created 13/11/2020
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],
  data() {
    return {
      /**
       * The floater status
       * @data {Boolean} [false] isOpened
       */
      isOpened: false,
      /**
       * The selected category
       * @data {String} ['1F600'] category
       */
      category: '1F600',
      /**
       * The emoji list
       * @data {Array} list
       */
      list: [{
        "text": "Smileys & emotion",
        "icon": "1F600",
        "items": {
          "1F600": "grinning face",
          "1F603": "grinning face with big eyes",
          "1F604": "grinning face with smiling eyes",
          "1F601": "beaming face with smiling eyes",
          "1F606": "grinning squinting face",
          "1F605": "grinning face with sweat",
          "1F923": "rolling on the floor laughing",
          "1F602": "face with tears of joy",
          "1F642": "slightly smiling face",
          "1F643": "upside-down face",
          "1F609": "winking face",
          "1F60A": "smiling face with smiling eyes",
          "1F607": "smiling face with halo",
          "1F970": "smiling face with hearts",
          "1F60D": "smiling face with heart-eyes",
          "1F929": "star-struck",
          "1F618": "face blowing a kiss",
          "1F617": "kissing face",
          "263A": "smiling face",
          "1F61A": "kissing face with closed eyes",
          "1F619": "kissing face with smiling eyes",
          "1F972": "smiling face with tear",
          "1F60B": "face savoring food",
          "1F61B": "face with tongue",
          "1F61C": "winking face with tongue",
          "1F92A": "zany face",
          "1F61D": "squinting face with tongue",
          "1F911": "money-mouth face",
          "1F917": "hugging face",
          "1F92D": "face with hand over mouth",
          "1F92B": "shushing face",
          "1F914": "thinking face",
          "1F910": "zipper-mouth face",
          "1F928": "face with raised eyebrow",
          "1F610": "neutral face",
          "1F611": "expressionless face",
          "1F636": "face without mouth",
          "1F60F": "smirking face",
          "1F612": "unamused face",
          "1F644": "face with rolling eyes",
          "1F62C": "grimacing face",
          "1F62E": "face exhaling",
          "1F925": "lying face",
          "1F60C": "relieved face",
          "1F614": "pensive face",
          "1F62A": "sleepy face",
          "1F924": "drooling face",
          "1F634": "sleeping face",
          "1F637": "face with medical mask",
          "1F912": "face with thermometer",
          "1F915": "face with head-bandage",
          "1F922": "nauseated face",
          "1F92E": "face vomiting",
          "1F927": "sneezing face",
          "1F975": "hot face",
          "1F976": "cold face",
          "1F974": "woozy face",
          "1F635": "knocked-out face",
          "1F92F": "exploding head",
          "1F920": "cowboy hat face",
          "1F973": "partying face",
          "1F978": "disguised face",
          "1F60E": "smiling face with sunglasses",
          "1F913": "nerd face",
          "1F9D0": "face with monocle",
          "1F615": "confused face",
          "1F61F": "worried face",
          "1F641": "slightly frowning face",
          2639: "frowning face",
          "1F62F": "hushed face",
          "1F632": "astonished face",
          "1F633": "flushed face",
          "1F97A": "pleading face",
          "1F626": "frowning face with open mouth",
          "1F627": "anguished face",
          "1F628": "fearful face",
          "1F630": "anxious face with sweat",
          "1F625": "sad but relieved face",
          "1F622": "crying face",
          "1F62D": "loudly crying face",
          "1F631": "face screaming in fear",
          "1F616": "confounded face",
          "1F623": "persevering face",
          "1F61E": "disappointed face",
          "1F613": "downcast face with sweat",
          "1F629": "weary face",
          "1F62B": "tired face",
          "1F971": "yawning face",
          "1F624": "face with steam from nose",
          "1F621": "pouting face",
          "1F620": "angry face",
          "1F92C": "face with symbols on mouth",
          "1F608": "smiling face with horns",
          "1F47F": "angry face with horns",
          "1F480": "skull",
          2620: "skull and crossbones",
          "1F4A9": "pile of poo",
          "1F921": "clown face",
          "1F479": "ogre",
          "1F47A": "goblin",
          "1F47B": "ghost",
          "1F47D": "alien",
          "1F47E": "alien monster",
          "1F916": "robot",
          "1F63A": "grinning cat",
          "1F638": "grinning cat with smiling eyes",
          "1F639": "cat with tears of joy",
          "1F63B": "smiling cat with heart-eyes",
          "1F63C": "cat with wry smile",
          "1F63D": "kissing cat",
          "1F640": "weary cat",
          "1F63F": "crying cat",
          "1F63E": "pouting cat",
          "1F648": "see-no-evil monkey",
          "1F649": "hear-no-evil monkey",
          "1F64A": "speak-no-evil monkey",
          "1F48B": "kiss mark",
          "1F48C": "love letter",
          "1F498": "heart with arrow",
          "1F49D": "heart with ribbon",
          "1F496": "sparkling heart",
          "1F497": "growing heart",
          "1F493": "beating heart",
          "1F49E": "revolving hearts",
          "1F495": "two hearts",
          "1F49F": "heart decoration",
          2763: "heart exclamation",
          "1F494": "broken heart",
          2764: "heart on fire",
          "1F9E1": "orange heart",
          "1F49B": "yellow heart",
          "1F49A": "green heart",
          "1F499": "blue heart",
          "1F49C": "purple heart",
          "1F90E": "brown heart",
          "1F5A4": "black heart",
          "1F90D": "white heart",
          "1F4AF": "hundred points",
          "1F4A2": "anger symbol",
          "1F4A5": "collision",
          "1F4AB": "dizzy",
          "1F4A6": "sweat droplets",
          "1F4A8": "dashing away",
          "1F573": "hole",
          "1F4A3": "bomb",
          "1F4AC": "speech balloon",
          "1F441": "eye in speech bubble",
          "1F5E8": "left speech bubble",
          "1F5EF": "right anger bubble",
          "1F4AD": "thought balloon",
          "1F4A4": "zzz"
        }
      }, {
        "text": "People & body",
        "icon": "1F44B",
        "items": {
          "1F44B": "waving hand",
          "1F91A": "raised back of hand",
          "1F590": "hand with fingers splayed",
          "270B": "raised hand",
          "1F596": "vulcan salute",
          "1F44C": "OK hand",
          "1F90C": "pinched fingers",
          "1F90F": "pinching hand",
          "270C": "victory hand",
          "1F91E": "crossed fingers",
          "1F91F": "love-you gesture",
          "1F918": "sign of the horns",
          "1F919": "call me hand",
          "1F448": "backhand index pointing left",
          "1F449": "backhand index pointing right",
          "1F446": "backhand index pointing up",
          "1F595": "middle finger",
          "1F447": "backhand index pointing down",
          "261D": "index pointing up",
          "1F44D": "thumbs up",
          "1F44E": "thumbs down",
          "270A": "raised fist",
          "1F44A": "oncoming fist",
          "1F91B": "left-facing fist",
          "1F91C": "right-facing fist",
          "1F44F": "clapping hands",
          "1F64C": "raising hands",
          "1F450": "open hands",
          "1F932": "palms up together",
          "1F91D": "handshake",
          "1F64F": "folded hands",
          "270D": "writing hand",
          "1F485": "nail polish",
          "1F933": "selfie",
          "1F4AA": "flexed biceps",
          "1F9BE": "mechanical arm",
          "1F9BF": "mechanical leg",
          "1F9B5": "leg",
          "1F9B6": "foot",
          "1F442": "ear",
          "1F9BB": "ear with hearing aid",
          "1F443": "nose",
          "1F9E0": "brain",
          "1FAC0": "anatomical heart",
          "1FAC1": "lungs",
          "1F9B7": "tooth",
          "1F9B4": "bone",
          "1F440": "eyes",
          "1F441": "eye",
          "1F445": "tongue",
          "1F444": "mouth",
          "1F476": "baby",
          "1F9D2": "child",
          "1F466": "boy",
          "1F467": "girl",
          "1F9D1": "person",
          "1F471": "person: blond hair",
          "1F468": "man",
          "1F9D4": "person: beard",
          "1F469": "woman",
          "1F9D3": "older person",
          "1F474": "old man",
          "1F475": "old woman",
          "1F64D": "person frowning",
          "1F64E": "person pouting",
          "1F645": "person gesturing NO",
          "1F646": "person gesturing OK",
          "1F481": "person tipping hand",
          "1F64B": "person raising hand",
          "1F9CF": "deaf person",
          "1F647": "person bowing",
          "1F926": "person facepalming",
          "1F937": "person shrugging",
          "1F46E": "police officer",
          "1F575": "detective",
          "1F482": "guard",
          "1F977": "ninja",
          "1F477": "construction worker",
          "1F934": "prince",
          "1F478": "princess",
          "1F473": "person wearing turban",
          "1F472": "person with skullcap",
          "1F9D5": "woman with headscarf",
          "1F935": "person in tuxedo",
          "1F470": "person with veil",
          "1F930": "pregnant woman",
          "1F931": "breast-feeding",
          "1F47C": "baby angel",
          "1F385": "Santa Claus",
          "1F936": "Mrs. Claus",
          "1F9B8": "superhero",
          "1F9B9": "supervillain",
          "1F9D9": "mage",
          "1F9DA": "fairy",
          "1F9DB": "vampire",
          "1F9DC": "merperson",
          "1F9DD": "elf",
          "1F9DE": "genie",
          "1F9DF": "zombie",
          "1F486": "person getting massage",
          "1F487": "person getting haircut",
          "1F6B6": "person walking",
          "1F9CD": "person standing",
          "1F9CE": "person kneeling",
          "1F3C3": "person running",
          "1F483": "woman dancing",
          "1F57A": "man dancing",
          "1F574": "person in suit levitating",
          "1F46F": "people with bunny ears",
          "1F9D6": "person in steamy room",
          "1F9D7": "person climbing",
          "1F93A": "person fencing",
          "1F3C7": "horse racing",
          "26F7": "skier",
          "1F3C2": "snowboarder",
          "1F3CC": "person golfing",
          "1F3C4": "person surfing",
          "1F6A3": "person rowing boat",
          "1F3CA": "person swimming",
          "26F9": "person bouncing ball",
          "1F3CB": "person lifting weights",
          "1F6B4": "person biking",
          "1F6B5": "person mountain biking",
          "1F938": "person cartwheeling",
          "1F93C": "people wrestling",
          "1F93D": "person playing water polo",
          "1F93E": "person playing handball",
          "1F939": "person juggling",
          "1F9D8": "person in lotus position",
          "1F6C0": "person taking bath",
          "1F6CC": "person in bed",
          "1F46D": "women holding hands",
          "1F46B": "woman and man holding hands",
          "1F46C": "men holding hands",
          "1F48F": "kiss",
          "1F491": "couple with heart",
          "1F46A": "family",
          "1F5E3": "speaking head",
          "1F464": "bust in silhouette",
          "1F465": "busts in silhouette",
          "1FAC2": "people hugging",
          "1F463": "footprints"
        }
      }, {
        "text": "Animals & nature",
        "icon": "1F435",
        "items": {
          "1F435": "monkey face",
          "1F412": "monkey",
          "1F98D": "gorilla",
          "1F9A7": "orangutan",
          "1F436": "dog face",
          "1F415": "dog",
          "1F9AE": "guide dog",
          "1F429": "poodle",
          "1F43A": "wolf",
          "1F98A": "fox",
          "1F99D": "raccoon",
          "1F431": "cat face",
          "1F408": "cat",
          "1F981": "lion",
          "1F42F": "tiger face",
          "1F405": "tiger",
          "1F406": "leopard",
          "1F434": "horse face",
          "1F40E": "horse",
          "1F984": "unicorn",
          "1F993": "zebra",
          "1F98C": "deer",
          "1F9AC": "bison",
          "1F42E": "cow face",
          "1F402": "ox",
          "1F403": "water buffalo",
          "1F404": "cow",
          "1F437": "pig face",
          "1F416": "pig",
          "1F417": "boar",
          "1F43D": "pig nose",
          "1F40F": "ram",
          "1F411": "ewe",
          "1F410": "goat",
          "1F42A": "camel",
          "1F42B": "two-hump camel",
          "1F999": "llama",
          "1F992": "giraffe",
          "1F418": "elephant",
          "1F9A3": "mammoth",
          "1F98F": "rhinoceros",
          "1F99B": "hippopotamus",
          "1F42D": "mouse face",
          "1F401": "mouse",
          "1F400": "rat",
          "1F439": "hamster",
          "1F430": "rabbit face",
          "1F407": "rabbit",
          "1F43F": "chipmunk",
          "1F9AB": "beaver",
          "1F994": "hedgehog",
          "1F987": "bat",
          "1F43B": "bear",
          "1F428": "koala",
          "1F43C": "panda",
          "1F9A5": "sloth",
          "1F9A6": "otter",
          "1F9A8": "skunk",
          "1F998": "kangaroo",
          "1F9A1": "badger",
          "1F43E": "paw prints",
          "1F983": "turkey",
          "1F414": "chicken",
          "1F413": "rooster",
          "1F423": "hatching chick",
          "1F424": "baby chick",
          "1F425": "front-facing baby chick",
          "1F426": "bird",
          "1F427": "penguin",
          "1F54A": "dove",
          "1F985": "eagle",
          "1F986": "duck",
          "1F9A2": "swan",
          "1F989": "owl",
          "1F9A4": "dodo",
          "1FAB6": "feather",
          "1F9A9": "flamingo",
          "1F99A": "peacock",
          "1F99C": "parrot",
          "1F438": "frog",
          "1F40A": "crocodile",
          "1F422": "turtle",
          "1F98E": "lizard",
          "1F40D": "snake",
          "1F432": "dragon face",
          "1F409": "dragon",
          "1F995": "sauropod",
          "1F996": "T-Rex",
          "1F433": "spouting whale",
          "1F40B": "whale",
          "1F42C": "dolphin",
          "1F9AD": "seal",
          "1F41F": "fish",
          "1F420": "tropical fish",
          "1F421": "blowfish",
          "1F988": "shark",
          "1F419": "octopus",
          "1F41A": "spiral shell",
          "1F40C": "snail",
          "1F98B": "butterfly",
          "1F41B": "bug",
          "1F41C": "ant",
          "1F41D": "honeybee",
          "1FAB2": "beetle",
          "1F41E": "lady beetle",
          "1F997": "cricket",
          "1FAB3": "cockroach",
          "1F577": "spider",
          "1F578": "spider web",
          "1F982": "scorpion",
          "1F99F": "mosquito",
          "1FAB0": "fly",
          "1FAB1": "worm",
          "1F9A0": "microbe",
          "1F490": "bouquet",
          "1F338": "cherry blossom",
          "1F4AE": "white flower",
          "1F3F5": "rosette",
          "1F339": "rose",
          "1F940": "wilted flower",
          "1F33A": "hibiscus",
          "1F33B": "sunflower",
          "1F33C": "blossom",
          "1F337": "tulip",
          "1F331": "seedling",
          "1FAB4": "potted plant",
          "1F332": "evergreen tree",
          "1F333": "deciduous tree",
          "1F334": "palm tree",
          "1F335": "cactus",
          "1F33E": "sheaf of rice",
          "1F33F": "herb",
          2618: "shamrock",
          "1F340": "four leaf clover",
          "1F341": "maple leaf",
          "1F342": "fallen leaf",
          "1F343": "leaf fluttering in wind"
        }
      }, {
        "text": "Food & drink",
        "icon": "1F347",
        "items": {
          "1F347": "grapes",
          "1F348": "melon",
          "1F349": "watermelon",
          "1F34A": "tangerine",
          "1F34B": "lemon",
          "1F34C": "banana",
          "1F34D": "pineapple",
          "1F96D": "mango",
          "1F34E": "red apple",
          "1F34F": "green apple",
          "1F350": "pear",
          "1F351": "peach",
          "1F352": "cherries",
          "1F353": "strawberry",
          "1FAD0": "blueberries",
          "1F95D": "kiwi fruit",
          "1F345": "tomato",
          "1FAD2": "olive",
          "1F965": "coconut",
          "1F951": "avocado",
          "1F346": "eggplant",
          "1F954": "potato",
          "1F955": "carrot",
          "1F33D": "ear of corn",
          "1F336": "hot pepper",
          "1FAD1": "bell pepper",
          "1F952": "cucumber",
          "1F96C": "leafy green",
          "1F966": "broccoli",
          "1F9C4": "garlic",
          "1F9C5": "onion",
          "1F344": "mushroom",
          "1F95C": "peanuts",
          "1F330": "chestnut",
          "1F35E": "bread",
          "1F950": "croissant",
          "1F956": "baguette bread",
          "1FAD3": "flatbread",
          "1F968": "pretzel",
          "1F96F": "bagel",
          "1F95E": "pancakes",
          "1F9C7": "waffle",
          "1F9C0": "cheese wedge",
          "1F356": "meat on bone",
          "1F357": "poultry leg",
          "1F969": "cut of meat",
          "1F953": "bacon",
          "1F354": "hamburger",
          "1F35F": "french fries",
          "1F355": "pizza",
          "1F32D": "hot dog",
          "1F96A": "sandwich",
          "1F32E": "taco",
          "1F32F": "burrito",
          "1FAD4": "tamale",
          "1F959": "stuffed flatbread",
          "1F9C6": "falafel",
          "1F95A": "egg",
          "1F373": "cooking",
          "1F958": "shallow pan of food",
          "1F372": "pot of food",
          "1FAD5": "fondue",
          "1F963": "bowl with spoon",
          "1F957": "green salad",
          "1F37F": "popcorn",
          "1F9C8": "butter",
          "1F9C2": "salt",
          "1F96B": "canned food",
          "1F371": "bento box",
          "1F358": "rice cracker",
          "1F359": "rice ball",
          "1F35A": "cooked rice",
          "1F35B": "curry rice",
          "1F35C": "steaming bowl",
          "1F35D": "spaghetti",
          "1F360": "roasted sweet potato",
          "1F362": "oden",
          "1F363": "sushi",
          "1F364": "fried shrimp",
          "1F365": "fish cake with swirl",
          "1F96E": "moon cake",
          "1F361": "dango",
          "1F95F": "dumpling",
          "1F960": "fortune cookie",
          "1F961": "takeout box",
          "1F980": "crab",
          "1F99E": "lobster",
          "1F990": "shrimp",
          "1F991": "squid",
          "1F9AA": "oyster",
          "1F366": "soft ice cream",
          "1F367": "shaved ice",
          "1F368": "ice cream",
          "1F369": "doughnut",
          "1F36A": "cookie",
          "1F382": "birthday cake",
          "1F370": "shortcake",
          "1F9C1": "cupcake",
          "1F967": "pie",
          "1F36B": "chocolate bar",
          "1F36C": "candy",
          "1F36D": "lollipop",
          "1F36E": "custard",
          "1F36F": "honey pot",
          "1F37C": "baby bottle",
          "1F95B": "glass of milk",
          2615: "hot beverage",
          "1FAD6": "teapot",
          "1F375": "teacup without handle",
          "1F376": "sake",
          "1F37E": "bottle with popping cork",
          "1F377": "wine glass",
          "1F378": "cocktail glass",
          "1F379": "tropical drink",
          "1F37A": "beer mug",
          "1F37B": "clinking beer mugs",
          "1F942": "clinking glasses",
          "1F943": "tumbler glass",
          "1F964": "cup with straw",
          "1F9CB": "bubble tea",
          "1F9C3": "beverage box",
          "1F9C9": "mate",
          "1F9CA": "ice",
          "1F962": "chopsticks",
          "1F37D": "fork and knife with plate",
          "1F374": "fork and knife",
          "1F944": "spoon",
          "1F52A": "kitchen knife",
          "1F3FA": "amphora"
        }
      }, {
        "text": "Activities",
        "icon": "1F383",
        "items": {
          "1F383": "jack-o-lantern",
          "1F384": "Christmas tree",
          "1F386": "fireworks",
          "1F387": "sparkler",
          "1F9E8": "firecracker",
          2728: "sparkles",
          "1F388": "balloon",
          "1F389": "party popper",
          "1F38A": "confetti ball",
          "1F38B": "tanabata tree",
          "1F38D": "pine decoration",
          "1F38E": "Japanese dolls",
          "1F38F": "carp streamer",
          "1F390": "wind chime",
          "1F391": "moon viewing ceremony",
          "1F9E7": "red envelope",
          "1F380": "ribbon",
          "1F381": "wrapped gift",
          "1F397": "reminder ribbon",
          "1F39F": "admission tickets",
          "1F3AB": "ticket",
          "1F396": "military medal",
          "1F3C6": "trophy",
          "1F3C5": "sports medal",
          "1F947": "1st place medal",
          "1F948": "2nd place medal",
          "1F949": "3rd place medal",
          "26BD": "soccer ball",
          "26BE": "baseball",
          "1F94E": "softball",
          "1F3C0": "basketball",
          "1F3D0": "volleyball",
          "1F3C8": "american football",
          "1F3C9": "rugby football",
          "1F3BE": "tennis",
          "1F94F": "flying disc",
          "1F3B3": "bowling",
          "1F3CF": "cricket game",
          "1F3D1": "field hockey",
          "1F3D2": "ice hockey",
          "1F94D": "lacrosse",
          "1F3D3": "ping pong",
          "1F3F8": "badminton",
          "1F94A": "boxing glove",
          "1F94B": "martial arts uniform",
          "1F945": "goal net",
          "26F3": "flag in hole",
          "26F8": "ice skate",
          "1F3A3": "fishing pole",
          "1F93F": "diving mask",
          "1F3BD": "running shirt",
          "1F3BF": "skis",
          "1F6F7": "sled",
          "1F94C": "curling stone",
          "1F3AF": "bullseye",
          "1FA80": "yo-yo",
          "1FA81": "kite",
          "1F3B1": "pool 8 ball",
          "1F52E": "crystal ball",
          "1FA84": "magic wand",
          "1F9FF": "nazar amulet",
          "1F3AE": "video game",
          "1F579": "joystick",
          "1F3B0": "slot machine",
          "1F3B2": "game die",
          "1F9E9": "puzzle piece",
          "1F9F8": "teddy bear",
          "1FA85": "piata",
          "1FA86": "nesting dolls",
          2660: "spade suit",
          2665: "heart suit",
          2666: "diamond suit",
          2663: "club suit",
          "265F": "chess pawn",
          "1F0CF": "joker",
          "1F004": "mahjong red dragon",
          "1F3B4": "flower playing cards",
          "1F3AD": "performing arts",
          "1F5BC": "framed picture",
          "1F3A8": "artist palette",
          "1F9F5": "thread",
          "1FAA1": "sewing needle",
          "1F9F6": "yarn",
          "1FAA2": "knot"
        }
      }, {
        "text": "Travel & places",
        "icon": "1F30D",
        "items": {
          "1F30D": "globe showing Europe-Africa",
          "1F30E": "globe showing Americas",
          "1F30F": "globe showing Asia-Australia",
          "1F310": "globe with meridians",
          "1F5FA": "world map",
          "1F5FE": "map of Japan",
          "1F9ED": "compass",
          "1F3D4": "snow-capped mountain",
          "26F0": "mountain",
          "1F30B": "volcano",
          "1F5FB": "mount fuji",
          "1F3D5": "camping",
          "1F3D6": "beach with umbrella",
          "1F3DC": "desert",
          "1F3DD": "desert island",
          "1F3DE": "national park",
          "1F3DF": "stadium",
          "1F3DB": "classical building",
          "1F3D7": "building construction",
          "1F9F1": "brick",
          "1FAA8": "rock",
          "1FAB5": "wood",
          "1F6D6": "hut",
          "1F3D8": "houses",
          "1F3DA": "derelict house",
          "1F3E0": "house",
          "1F3E1": "house with garden",
          "1F3E2": "office building",
          "1F3E3": "Japanese post office",
          "1F3E4": "post office",
          "1F3E5": "hospital",
          "1F3E6": "bank",
          "1F3E8": "hotel",
          "1F3E9": "love hotel",
          "1F3EA": "convenience store",
          "1F3EB": "school",
          "1F3EC": "department store",
          "1F3ED": "factory",
          "1F3EF": "Japanese castle",
          "1F3F0": "castle",
          "1F492": "wedding",
          "1F5FC": "Tokyo tower",
          "1F5FD": "Statue of Liberty",
          "26EA": "church",
          "1F54C": "mosque",
          "1F6D5": "hindu temple",
          "1F54D": "synagogue",
          "26E9": "shinto shrine",
          "1F54B": "kaaba",
          "26F2": "fountain",
          "26FA": "tent",
          "1F301": "foggy",
          "1F303": "night with stars",
          "1F3D9": "cityscape",
          "1F304": "sunrise over mountains",
          "1F305": "sunrise",
          "1F306": "cityscape at dusk",
          "1F307": "sunset",
          "1F309": "bridge at night",
          2668: "hot springs",
          "1F3A0": "carousel horse",
          "1F3A1": "ferris wheel",
          "1F3A2": "roller coaster",
          "1F488": "barber pole",
          "1F3AA": "circus tent",
          "1F682": "locomotive",
          "1F683": "railway car",
          "1F684": "high-speed train",
          "1F685": "bullet train",
          "1F686": "train",
          "1F687": "metro",
          "1F688": "light rail",
          "1F689": "station",
          "1F68A": "tram",
          "1F69D": "monorail",
          "1F69E": "mountain railway",
          "1F68B": "tram car",
          "1F68C": "bus",
          "1F68D": "oncoming bus",
          "1F68E": "trolleybus",
          "1F690": "minibus",
          "1F691": "ambulance",
          "1F692": "fire engine",
          "1F693": "police car",
          "1F694": "oncoming police car",
          "1F695": "taxi",
          "1F696": "oncoming taxi",
          "1F697": "automobile",
          "1F698": "oncoming automobile",
          "1F699": "sport utility vehicle",
          "1F6FB": "pickup truck",
          "1F69A": "delivery truck",
          "1F69B": "articulated lorry",
          "1F69C": "tractor",
          "1F3CE": "racing car",
          "1F3CD": "motorcycle",
          "1F6F5": "motor scooter",
          "1F9BD": "manual wheelchair",
          "1F9BC": "motorized wheelchair",
          "1F6FA": "auto rickshaw",
          "1F6B2": "bicycle",
          "1F6F4": "kick scooter",
          "1F6F9": "skateboard",
          "1F6FC": "roller skate",
          "1F68F": "bus stop",
          "1F6E3": "motorway",
          "1F6E4": "railway track",
          "1F6E2": "oil drum",
          "26FD": "fuel pump",
          "1F6A8": "police car light",
          "1F6A5": "horizontal traffic light",
          "1F6A6": "vertical traffic light",
          "1F6D1": "stop sign",
          "1F6A7": "construction",
          2693: "anchor",
          "26F5": "sailboat",
          "1F6F6": "canoe",
          "1F6A4": "speedboat",
          "1F6F3": "passenger ship",
          "26F4": "ferry",
          "1F6E5": "motor boat",
          "1F6A2": "ship",
          2708: "airplane",
          "1F6E9": "small airplane",
          "1F6EB": "airplane departure",
          "1F6EC": "airplane arrival",
          "1FA82": "parachute",
          "1F4BA": "seat",
          "1F681": "helicopter",
          "1F69F": "suspension railway",
          "1F6A0": "mountain cableway",
          "1F6A1": "aerial tramway",
          "1F6F0": "satellite",
          "1F680": "rocket",
          "1F6F8": "flying saucer",
          "1F6CE": "bellhop bell",
          "1F9F3": "luggage",
          "231B": "hourglass done",
          "23F3": "hourglass not done",
          "231A": "watch",
          "23F0": "alarm clock",
          "23F1": "stopwatch",
          "23F2": "timer clock",
          "1F570": "mantelpiece clock",
          "1F55B": 0x7477656c7665206fe28099636c6f636b,
          "1F567": "twelve-thirty",
          "1F550": "one oclock",
          "1F55C": "one-thirty",
          "1F551": "two oclock",
          "1F55D": "two-thirty",
          "1F552": "three oclock",
          "1F55E": "three-thirty",
          "1F553": "four oclock",
          "1F55F": "four-thirty",
          "1F554": "five oclock",
          "1F560": "five-thirty",
          "1F555": "six oclock",
          "1F561": "six-thirty",
          "1F556": "seven oclock",
          "1F562": "seven-thirty",
          "1F557": "eight oclock",
          "1F563": "eight-thirty",
          "1F558": "nine oclock",
          "1F564": "nine-thirty",
          "1F559": "ten oclock",
          "1F565": "ten-thirty",
          "1F55A": 0x656c6576656e206fe28099636c6f636b,
          "1F566": "eleven-thirty",
          "1F311": "new moon",
          "1F312": "waxing crescent moon",
          "1F313": "first quarter moon",
          "1F314": "waxing gibbous moon",
          "1F315": "full moon",
          "1F316": "waning gibbous moon",
          "1F317": "last quarter moon",
          "1F318": "waning crescent moon",
          "1F319": "crescent moon",
          "1F31A": "new moon face",
          "1F31B": "first quarter moon face",
          "1F31C": "last quarter moon face",
          "1F321": "thermometer",
          2600: "sun",
          "1F31D": "full moon face",
          "1F31E": "sun with face",
          "1FA90": "ringed planet",
          "2B50": "star",
          "1F31F": "glowing star",
          "1F320": "shooting star",
          "1F30C": "milky way",
          2601: "cloud",
          "26C5": "sun behind cloud",
          "26C8": "cloud with lightning and rain",
          "1F324": "sun behind small cloud",
          "1F325": "sun behind large cloud",
          "1F326": "sun behind rain cloud",
          "1F327": "cloud with rain",
          "1F328": "cloud with snow",
          "1F329": "cloud with lightning",
          "1F32A": "tornado",
          "1F32B": "fog",
          "1F32C": "wind face",
          "1F300": "cyclone",
          "1F308": "rainbow",
          "1F302": "closed umbrella",
          2602: "umbrella",
          2614: "umbrella with rain drops",
          "26F1": "umbrella on ground",
          "26A1": "high voltage",
          2744: "snowflake",
          2603: "snowman",
          "26C4": "snowman without snow",
          2604: "comet",
          "1F525": "fire",
          "1F4A7": "droplet",
          "1F30A": "water wave"
        }
      }, {
        "text": "Objects",
        "icon": "1F453",
        "items": {
          "1F453": "glasses",
          "1F576": "sunglasses",
          "1F97D": "goggles",
          "1F97C": "lab coat",
          "1F9BA": "safety vest",
          "1F454": "necktie",
          "1F455": "t-shirt",
          "1F456": "jeans",
          "1F9E3": "scarf",
          "1F9E4": "gloves",
          "1F9E5": "coat",
          "1F9E6": "socks",
          "1F457": "dress",
          "1F458": "kimono",
          "1F97B": "sari",
          "1FA71": "one-piece swimsuit",
          "1FA72": "briefs",
          "1FA73": "shorts",
          "1F459": "bikini",
          "1F45A": "womans clothes",
          "1F45B": "purse",
          "1F45C": "handbag",
          "1F45D": "clutch bag",
          "1F6CD": "shopping bags",
          "1F392": "backpack",
          "1FA74": "thong sandal",
          "1F45E": "mans shoe",
          "1F45F": "running shoe",
          "1F97E": "hiking boot",
          "1F97F": "flat shoe",
          "1F460": "high-heeled shoe",
          "1F461": 0x776f6d616ee28099732073616e64616c,
          "1FA70": "ballet shoes",
          "1F462": "womans boot",
          "1F451": "crown",
          "1F452": "womans hat",
          "1F3A9": "top hat",
          "1F393": "graduation cap",
          "1F9E2": "billed cap",
          "1FA96": "military helmet",
          "26D1": "rescue workers helmet",
          "1F4FF": "prayer beads",
          "1F484": "lipstick",
          "1F48D": "ring",
          "1F48E": "gem stone",
          "1F507": "muted speaker",
          "1F508": "speaker low volume",
          "1F509": "speaker medium volume",
          "1F50A": "speaker high volume",
          "1F4E2": "loudspeaker",
          "1F4E3": "megaphone",
          "1F4EF": "postal horn",
          "1F514": "bell",
          "1F515": "bell with slash",
          "1F3BC": "musical score",
          "1F3B5": "musical note",
          "1F3B6": "musical notes",
          "1F399": "studio microphone",
          "1F39A": "level slider",
          "1F39B": "control knobs",
          "1F3A4": "microphone",
          "1F3A7": "headphone",
          "1F4FB": "radio",
          "1F3B7": "saxophone",
          "1FA97": "accordion",
          "1F3B8": "guitar",
          "1F3B9": "musical keyboard",
          "1F3BA": "trumpet",
          "1F3BB": "violin",
          "1FA95": "banjo",
          "1F941": "drum",
          "1FA98": "long drum",
          "1F4F1": "mobile phone",
          "1F4F2": "mobile phone with arrow",
          "260E": "telephone",
          "1F4DE": "telephone receiver",
          "1F4DF": "pager",
          "1F4E0": "fax machine",
          "1F50B": "battery",
          "1F50C": "electric plug",
          "1F4BB": "laptop",
          "1F5A5": "desktop computer",
          "1F5A8": "printer",
          2328: "keyboard",
          "1F5B1": "computer mouse",
          "1F5B2": "trackball",
          "1F4BD": "computer disk",
          "1F4BE": "floppy disk",
          "1F4BF": "optical disk",
          "1F4C0": "dvd",
          "1F9EE": "abacus",
          "1F3A5": "movie camera",
          "1F39E": "film frames",
          "1F4FD": "film projector",
          "1F3AC": "clapper board",
          "1F4FA": "television",
          "1F4F7": "camera",
          "1F4F8": "camera with flash",
          "1F4F9": "video camera",
          "1F4FC": "videocassette",
          "1F50D": "magnifying glass tilted left",
          "1F50E": "magnifying glass tilted right",
          "1F56F": "candle",
          "1F4A1": "light bulb",
          "1F526": "flashlight",
          "1F3EE": "red paper lantern",
          "1FA94": "diya lamp",
          "1F4D4": "notebook with decorative cover",
          "1F4D5": "closed book",
          "1F4D6": "open book",
          "1F4D7": "green book",
          "1F4D8": "blue book",
          "1F4D9": "orange book",
          "1F4DA": "books",
          "1F4D3": "notebook",
          "1F4D2": "ledger",
          "1F4C3": "page with curl",
          "1F4DC": "scroll",
          "1F4C4": "page facing up",
          "1F4F0": "newspaper",
          "1F5DE": "rolled-up newspaper",
          "1F4D1": "bookmark tabs",
          "1F516": "bookmark",
          "1F3F7": "label",
          "1F4B0": "money bag",
          "1FA99": "coin",
          "1F4B4": "yen banknote",
          "1F4B5": "dollar banknote",
          "1F4B6": "euro banknote",
          "1F4B7": "pound banknote",
          "1F4B8": "money with wings",
          "1F4B3": "credit card",
          "1F9FE": "receipt",
          "1F4B9": "chart increasing with yen",
          2709: "envelope",
          "1F4E7": "e-mail",
          "1F4E8": "incoming envelope",
          "1F4E9": "envelope with arrow",
          "1F4E4": "outbox tray",
          "1F4E5": "inbox tray",
          "1F4E6": "package",
          "1F4EB": "closed mailbox with raised flag",
          "1F4EA": "closed mailbox with lowered flag",
          "1F4EC": "open mailbox with raised flag",
          "1F4ED": "open mailbox with lowered flag",
          "1F4EE": "postbox",
          "1F5F3": "ballot box with ballot",
          "270F": "pencil",
          2712: "black nib",
          "1F58B": "fountain pen",
          "1F58A": "pen",
          "1F58C": "paintbrush",
          "1F58D": "crayon",
          "1F4DD": "memo",
          "1F4BC": "briefcase",
          "1F4C1": "file folder",
          "1F4C2": "open file folder",
          "1F5C2": "card index dividers",
          "1F4C5": "calendar",
          "1F4C6": "tear-off calendar",
          "1F5D2": "spiral notepad",
          "1F5D3": "spiral calendar",
          "1F4C7": "card index",
          "1F4C8": "chart increasing",
          "1F4C9": "chart decreasing",
          "1F4CA": "bar chart",
          "1F4CB": "clipboard",
          "1F4CC": "pushpin",
          "1F4CD": "round pushpin",
          "1F4CE": "paperclip",
          "1F587": "linked paperclips",
          "1F4CF": "straight ruler",
          "1F4D0": "triangular ruler",
          2702: "scissors",
          "1F5C3": "card file box",
          "1F5C4": "file cabinet",
          "1F5D1": "wastebasket",
          "1F512": "locked",
          "1F513": "unlocked",
          "1F50F": "locked with pen",
          "1F510": "locked with key",
          "1F511": "key",
          "1F5DD": "old key",
          "1F528": "hammer",
          "1FA93": "axe",
          "26CF": "pick",
          2692: "hammer and pick",
          "1F6E0": "hammer and wrench",
          "1F5E1": "dagger",
          2694: "crossed swords",
          "1F52B": "water pistol",
          "1FA83": "boomerang",
          "1F3F9": "bow and arrow",
          "1F6E1": "shield",
          "1FA9A": "carpentry saw",
          "1F527": "wrench",
          "1FA9B": "screwdriver",
          "1F529": "nut and bolt",
          2699: "gear",
          "1F5DC": "clamp",
          2696: "balance scale",
          "1F9AF": "white cane",
          "1F517": "link",
          "26D3": "chains",
          "1FA9D": "hook",
          "1F9F0": "toolbox",
          "1F9F2": "magnet",
          "1FA9C": "ladder",
          2697: "alembic",
          "1F9EA": "test tube",
          "1F9EB": "petri dish",
          "1F9EC": "dna",
          "1F52C": "microscope",
          "1F52D": "telescope",
          "1F4E1": "satellite antenna",
          "1F489": "syringe",
          "1FA78": "drop of blood",
          "1F48A": "pill",
          "1FA79": "adhesive bandage",
          "1FA7A": "stethoscope",
          "1F6AA": "door",
          "1F6D7": "elevator",
          "1FA9E": "mirror",
          "1FA9F": "window",
          "1F6CF": "bed",
          "1F6CB": "couch and lamp",
          "1FA91": "chair",
          "1F6BD": "toilet",
          "1FAA0": "plunger",
          "1F6BF": "shower",
          "1F6C1": "bathtub",
          "1FAA4": "mouse trap",
          "1FA92": "razor",
          "1F9F4": "lotion bottle",
          "1F9F7": "safety pin",
          "1F9F9": "broom",
          "1F9FA": "basket",
          "1F9FB": "roll of paper",
          "1FAA3": "bucket",
          "1F9FC": "soap",
          "1FAA5": "toothbrush",
          "1F9FD": "sponge",
          "1F9EF": "fire extinguisher",
          "1F6D2": "shopping cart",
          "1F6AC": "cigarette",
          "26B0": "coffin",
          "1FAA6": "headstone",
          "26B1": "funeral urn",
          "1F5FF": "moai",
          "1FAA7": "placard"
        }
      }, {
        "text": "Symbols",
        "icon": "1F3E7",
        "items": {
          "1F3E7": "ATM sign",
          "1F6AE": "litter in bin sign",
          "1F6B0": "potable water",
          "267F": "wheelchair symbol",
          "1F6B9": "mens room",
          "1F6BA": "womens room",
          "1F6BB": "restroom",
          "1F6BC": "baby symbol",
          "1F6BE": "water closet",
          "1F6C2": "passport control",
          "1F6C3": "customs",
          "1F6C4": "baggage claim",
          "1F6C5": "left luggage",
          "26A0": "warning",
          "1F6B8": "children crossing",
          "26D4": "no entry",
          "1F6AB": "prohibited",
          "1F6B3": "no bicycles",
          "1F6AD": "no smoking",
          "1F6AF": "no littering",
          "1F6B1": "non-potable water",
          "1F6B7": "no pedestrians",
          "1F4F5": "no mobile phones",
          "1F51E": "no one under eighteen",
          2622: "radioactive",
          2623: "biohazard",
          "2B06": "up arrow",
          2197: "up-right arrow",
          "27A1": "right arrow",
          2198: "down-right arrow",
          "2B07": "down arrow",
          2199: "down-left arrow",
          "2B05": "left arrow",
          2196: "up-left arrow",
          2195: "up-down arrow",
          2194: "left-right arrow",
          "21A9": "right arrow curving left",
          "21AA": "left arrow curving right",
          2934: "right arrow curving up",
          2935: "right arrow curving down",
          "1F503": "clockwise vertical arrows",
          "1F504": "counterclockwise arrows button",
          "1F519": "BACK arrow",
          "1F51A": "END arrow",
          "1F51B": "ON! arrow",
          "1F51C": "SOON arrow",
          "1F51D": "TOP arrow",
          "1F6D0": "place of worship",
          "269B": "atom symbol",
          "1F549": "om",
          2721: "star of David",
          2638: "wheel of dharma",
          "262F": "yin yang",
          "271D": "latin cross",
          2626: "orthodox cross",
          "262A": "star and crescent",
          "262E": "peace symbol",
          "1F54E": "menorah",
          "1F52F": "dotted six-pointed star",
          2648: "Aries",
          2649: "Taurus",
          "264A": "Gemini",
          "264B": "Cancer",
          "264C": "Leo",
          "264D": "Virgo",
          "264E": "Libra",
          "264F": "Scorpio",
          2650: "Sagittarius",
          2651: "Capricorn",
          2652: "Aquarius",
          2653: "Pisces",
          "26CE": "Ophiuchus",
          "1F500": "shuffle tracks button",
          "1F501": "repeat button",
          "1F502": "repeat single button",
          "25B6": "play button",
          "23E9": "fast-forward button",
          "23ED": "next track button",
          "23EF": "play or pause button",
          "25C0": "reverse button",
          "23EA": "fast reverse button",
          "23EE": "last track button",
          "1F53C": "upwards button",
          "23EB": "fast up button",
          "1F53D": "downwards button",
          "23EC": "fast down button",
          "23F8": "pause button",
          "23F9": "stop button",
          "23FA": "record button",
          "23CF": "eject button",
          "1F3A6": "cinema",
          "1F505": "dim button",
          "1F506": "bright button",
          "1F4F6": "antenna bars",
          "1F4F3": "vibration mode",
          "1F4F4": "mobile phone off",
          2640: "female sign",
          2642: "male sign",
          "26A7": "transgender symbol",
          2716: "multiply",
          2795: "plus",
          2796: "minus",
          2797: "divide",
          "267E": "infinity",
          "203C": "double exclamation mark",
          2049: "exclamation question mark",
          2753: "red question mark",
          2754: "white question mark",
          2755: "white exclamation mark",
          2757: "red exclamation mark",
          3030: "wavy dash",
          "1F4B1": "currency exchange",
          "1F4B2": "heavy dollar sign",
          2695: "medical symbol",
          "267B": "recycling symbol",
          "269C": "fleur-de-lis",
          "1F531": "trident emblem",
          "1F4DB": "name badge",
          "1F530": "Japanese symbol for beginner",
          "2B55": "hollow red circle",
          2705: "check mark button",
          2611: "check box with check",
          2714: "check mark",
          "274C": "cross mark",
          "274E": "cross mark button",
          "27B0": "curly loop",
          "27BF": "double curly loop",
          "303D": "part alternation mark",
          2733: "eight-spoked asterisk",
          2734: "eight-pointed star",
          2747: "sparkle",
          "00A9": "copyright",
          "00AE": "registered",
          2122: "trade mark",
          "0023": "keycap: #",
          "002A": "keycap: *",
          "0030": "keycap: 0",
          "0031": "keycap: 1",
          "0032": "keycap: 2",
          "0033": "keycap: 3",
          "0034": "keycap: 4",
          "0035": "keycap: 5",
          "0036": "keycap: 6",
          "0037": "keycap: 7",
          "0038": "keycap: 8",
          "0039": "keycap: 9",
          "1F51F": "keycap: 10",
          "1F520": "input latin uppercase",
          "1F521": "input latin lowercase",
          "1F522": "input numbers",
          "1F523": "input symbols",
          "1F524": "input latin letters",
          "1F170": "A button (blood type)",
          "1F18E": "AB button (blood type)",
          "1F171": "B button (blood type)",
          "1F191": "CL button",
          "1F192": "COOL button",
          "1F193": "FREE button",
          2139: "information",
          "1F194": "ID button",
          "24C2": "circled M",
          "1F195": "NEW button",
          "1F196": "NG button",
          "1F17E": "O button (blood type)",
          "1F197": "OK button",
          "1F17F": "P button",
          "1F198": "SOS button",
          "1F199": "UP! button",
          "1F19A": "VS button",
          "1F201": "Japanese here button",
          "1F202": "Japanese service charge button",
          "1F237": "Japanese monthly amount button",
          "1F236": "Japanese not free of charge button",
          "1F22F": "Japanese reserved button",
          "1F250": "Japanese bargain button",
          "1F239": "Japanese discount button",
          "1F21A": "Japanese free of charge button",
          "1F232": "Japanese prohibited button",
          "1F251": "Japanese acceptable button",
          "1F238": "Japanese application button",
          "1F234": "Japanese passing grade button",
          "1F233": "Japanese vacancy button",
          3297: "Japanese congratulations button",
          3299: "Japanese secret button",
          "1F23A": "Japanese open for business button",
          "1F235": "Japanese no vacancy button",
          "1F534": "red circle",
          "1F7E0": "orange circle",
          "1F7E1": "yellow circle",
          "1F7E2": "green circle",
          "1F535": "blue circle",
          "1F7E3": "purple circle",
          "1F7E4": "brown circle",
          "26AB": "black circle",
          "26AA": "white circle",
          "1F7E5": "red square",
          "1F7E7": "orange square",
          "1F7E8": "yellow square",
          "1F7E9": "green square",
          "1F7E6": "blue square",
          "1F7EA": "purple square",
          "1F7EB": "brown square",
          "2B1B": "black large square",
          "2B1C": "white large square",
          "25FC": "black medium square",
          "25FB": "white medium square",
          "25FE": "black medium-small square",
          "25FD": "white medium-small square",
          "25AA": "black small square",
          "25AB": "white small square",
          "1F536": "large orange diamond",
          "1F537": "large blue diamond",
          "1F538": "small orange diamond",
          "1F539": "small blue diamond",
          "1F53A": "red triangle pointed up",
          "1F53B": "red triangle pointed down",
          "1F4A0": "diamond with a dot",
          "1F518": "radio button",
          "1F533": "white square button",
          "1F532": "black square button"
        }
      }, {
        "text": "Flags",
        "icon": "1F3C1",
        "items": {
          "1F3C1": "chequered flag",
          "1F6A9": "triangular flag",
          "1F38C": "crossed flags",
          "1F3F4": "black flag",
          "1F3F3": "white flag",
          "1F1E6": "flag: Ascension Island",
          "1F1E7": "flag: Bosnia & Herzegovina",
          "1F1E8": "flag: Canada",
          "1F1E9": "flag: Germany",
          "1F1EA": "flag: Ceuta & Melilla",
          "1F1EB": "flag: Finland",
          "1F1EC": "flag: Gabon",
          "1F1ED": "flag: Hong Kong SAR China",
          "1F1EE": "flag: Canary Islands",
          "1F1EF": "flag: Jersey",
          "1F1F0": "flag: Kenya",
          "1F1F1": "flag: Laos",
          "1F1F2": "flag: Morocco",
          "1F1F3": "flag: Namibia",
          "1F1F4": "flag: Oman",
          "1F1F5": "flag: Panama",
          "1F1F6": "flag: Qatar",
          "1F1F7": "flag: Runion",
          "1F1F8": "flag: Saudi Arabia",
          "1F1F9": "flag: Tristan da Cunha",
          "1F1FA": "flag: Ukraine",
          "1F1FB": "flag: Vatican City",
          "1F1FC": "flag: Wallis & Futuna",
          "1F1FD": "flag: Kosovo",
          "1F1FE": "flag: Yemen",
          "1F1FF": "flag: South Africa"
        }
      }]
    };
  },
  computed: {
    /**
     * The emoji list of the current category
     * @computed items
     * @returns {Array}
     */
    items() {
      let idx = bbn.fn.search(this.list, {
        icon: this.category
      });
      if (idx > -1) {
        return this.list[idx].items;
      }
    }
  },
  methods: {
    /**
     * The called method on emoji select
     * @method select
     * @param {String} emoji
     * @emits select
     */
    select(emoji) {
      this.$emit('select', emoji);
      this.isOpened = false;
    },
    /**
     * Returns the emoji code
     * @method get
     * @param {String} code
     * @returns {String}
     */
    get(code) {
      return '&#x' + code + ';';
    }
  },
  watch: {
    /**
     * @watch category
     * @fires getRef
     * @fires $nextTick
     */
    category() {
      this.$nextTick(() => {
        this.getRef('scroll').scrollStartY();
      });
    }
  }
};
import cpHtml from './emoji.html';
import cpStyle from './emoji.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./emoji.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-emoji',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/*bbn-field is a generic component of simple construction, its potential lies in the versatility of use, assigning to the property "type" a well-defined value, it becomes a "bbn" component.
  * For example if we assign the value "numeric" to the property type, it will become "bbn-numeric"*/

/**
  * @file bbn-field component
  *
  * @description 
  * 
  * bbn-field is a versatile component that adapts itself to the type of the data given by the user. 
  *
  * @copyright BBN Solutions
  *
  * @author BBN Solutions
  *
  * @created 15/02/2017.
  */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.field
   * @mixin bbn.cp.mixins.data
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.field, bbn.cp.mixins.data],
  props: {
    value: {},
    /**
     * The mode of the component.
     *
     * @prop {String} [read] mode
     */
    mode: {
      type: String,
      default: 'read'
    }
  },
  data() {
    return {
      /**
       * The component to render in bbn-field.
       * @data {Boolean|String} renderedComponent
       */
      renderedComponent: false,
      /**
       * The content to render.
       * @data renderedContent 
       */
      renderedContent: '',
      /**
       * The options to bind the component with.
       * @data {Object} renderedOptions
       */
      renderedOptions: bbn.fn.extend({}, this.options),
      /**
       * The current value.
       * @data currentValue 
       */
      currentValue: this.value
    };
  },
  computed: {
    /**
     * Returns the data or the value.
     *
     * @computed actualData
     * @return {Object}
     */
    actualData() {
      if (this.data) {
        return this.data;
      }
      if (this.field && this.value !== undefined) {
        let d = {};
        d[this.field] = this.value;
        return d;
      }
    },
    /**
     * The actual value of the component.
     *
     * @computed actualValue
     * @return {Object}
     */

    actualValue() {
      let v = this.value;
      if (this.type === 'json' && (bbn.fn.isObject(v) || bbn.fn.isArray(v))) {
        v = JSON.stringify(v);
      }
      return v === undefined ? this.data && this.field ? this.data[this.field] || '' : undefined : v;
    }
  },
  methods: {
    /**
     * Initializes the component.
     * @method init
     * @fires render
     * @fires renderData
     */
    init() {
      if (this.field) {
        if (this.mode === 'write' && this.editable) {
          if (this.required !== undefined) {
            this.renderedOptions.required = this.required;
          }
          if (this.editor) {
            return this.editor;
          } else if (this.render !== undefined && bbn.fn.isFunction(this.render)) {
            this.renderedComponent = 'div';
            this.renderedContent = this.render(this.actualData, this.index, this.field, this.value);
          } else if (this.type) {
            switch (this.type) {
              case "datetime":
                this.renderedComponent = 'bbn-datetimepicker';
                break;
              case "date":
                this.renderedComponent = 'bbn-datepicker';
                break;
              case "time":
                this.renderedComponent = 'bbn-timepicker';
                break;
              case "email":
                this.renderedComponent = 'bbn-input';
                break;
              case "url":
                this.renderedComponent = 'bbn-input';
                break;
              case "number":
                this.renderedComponent = 'bbn-numeric';
                break;
              case "percent":
                this.renderedComponent = 'bbn-numeric';
                this.renderedOptions.unit = '%';
                this.renderedOptions.decimals = 2;
                break;
              case "money":
                this.renderedComponent = 'bbn-numeric';
                this.renderedOptions.decimals = 2;
                break;
              case "json":
                this.renderedComponent = 'bbn-json-editor';
                if (!bbn.fn.isString(this.value)) {
                  this.renderedOptions.value = this.value ? JSON.stringify(this.value) : '';
                }
                break;
              case "bool":
              case "boolean":
                this.renderedComponent = 'bbn-checkbox';
                this.renderedOptions.value = this.options && this.options.value !== undefined ? this.options.value : 1;
                this.renderedOptions.novalue = this.options && this.options.novalue !== undefined ? this.options.novalue : 0;
                break;
              case "multilines":
              case "textarea":
                this.renderedComponent = 'bbn-textarea';
                break;
              default:
                this.renderedComponent = 'bbn-input';
                break;
            }
          } else if (this.source) {
            this.renderedComponent = 'bbn-dropdown';
            this.renderedOptions.source = this.source;
          } else {
            this.renderedComponent = 'bbn-input';
          }
          /*
          if( this.renderedComponent !== undefined){
            this.renderedOptions.value = this.value
          }
          */
        } else {
          if (this.component) {
            this.renderedComponent = this.component;
          } else {
            this.renderedComponent = 'div';
            if (this.render !== undefined && bbn.fn.isFunction(this.render)) {
              this.renderedContent = this.render(this.actualData, this.index, this.field, this.value);
            } else {
              this.renderedContent = this.renderData(this.actualData, this);
            }
          }
          /*
          if( this.renderedComponent !== undefined){
            this.renderedOptions.value = this.value
          }
          */
        }

        if (this.options && Object.keys(this.options).length) {
          bbn.fn.extend(this.renderedOptions, this.options);
        }
      }
    }
  },
  watch: {
    /**
     * @watch currentValue
     * @param val 
     */
    currentValue(val) {
      if (this.mode === 'write' && val !== this.actualValue) {
        this.$emit('input', val);
      }
      //this.init();
    },

    /**
     * @watch actualValue
     * @param val 
     */
    actualValue(val) {
      if (val !== this.currentValue) {
        this.currentValue = this.actualValue;
      }
    },
    /**
     * @watch value
     * @param val 
     */
    value(val, oldVal) {
      if (val !== oldVal) {
        this.init();
      }
    }
  },
  /**
   * @event created
   * @fires init
   */
  created() {
    this.init();
  }
};
import cpHtml from './field.html';
import cpStyle from './field.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./field.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-field',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-file component
 *
 * @description
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 13/06/2017.
 */
import FileDrop from 'filedrop';
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input],
  props: {
    /**
     * @prop {(Array|Function)} [[]] extensions
     */
    extensions: {
      type: [Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop {(Array|String)} [[]] value
     */
    value: {
      type: [Array, String],
      default() {
        return [];
      }
    },
    /**
     * @prop {String} [null] saveUrl
     */
    saveUrl: {
      type: String,
      default: null
    },
    /**
     * @prop {String} [null] removeUrl
     */
    removeUrl: {
      type: String,
      default: null
    },
    /**
     * @prop {Boolean} [true] autoUpload
     */
    autoUpload: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] multiple
     */
    multiple: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} thumbNot
     */
    thumbNot: {
      type: String
    },
    /**
     * @prop {Number} [null] maxSize
     */
    maxSize: {
      type: Number,
      default: null
    },
    /**
     * @prop {String} thumWaiting
     */
    thumbWaiting: {
      type: String
    },
    /**
     * @prop {Boolean} [false] json
     */
    json: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Object} [{}] lng
     */
    lng: {
      type: Object,
      default() {
        return {
          uploading: bbn._('uploading'),
          uploadButton: bbn._('Upload a file'),
          clickHere: bbn._('Or click here to'),
          pasteContainer: '<i class="nf nf-fa-paste bbn-xl"></i> Ctrl+V',
          dropHere: bbn._('Drop files here'),
          processingDropped: bbn._('Processing dropped files') + '...',
          retry: bbn._('Retry'),
          editFilename: bbn._('Edit filename'),
          remove: bbn._('Delete'),
          pause: bbn._('Pause'),
          cont: bbn._('Continue'),
          close: bbn._('Close'),
          no: bbn._('No'),
          yes: bbn._('Yes'),
          cancel: bbn._('Cancel'),
          ok: bbn._('OK'),
          browse: bbn._('Browse')
        };
      }
    },
    /**
     * @prop {String} ['nf nf-fa-upload'] icon
     */
    icon: {
      type: String,
      default: 'nf nf-fa-upload'
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] uploading
       */
      uploading: false,
      /**
       * @data {Number} [0] progress
       */
      progress: 0,
      /**
       * @data [null] widget
       */
      widget: null,
      /**
       * @data {Boolean} [true] isEnabled
       */
      isEnabled: !this.isDisabled,
      /**
       * @data {Array} [[]] widgedValue
       */
      widgetValue: [],
      /**
       * @data {fd.FileList} files
       */
      files: new fd.FileList()
    };
  },
  computed: {
    /**
     * @computed fileList
     * @return {Array}
     */
    fileList() {
      let res = [];
      if (this.files && this.files.length) {
        this.files.each(a => {
          res.push(a);
        });
      }
      return res;
    }
  },
  methods: {
    /**
     * @method getExtension
     * @param {Object} file
     * @return {string}
     */
    getExtension(file) {
      if (file.name) {
        let bits = file.name.split('.');
        return bits[bits.length - 1].toLowerCase();
      }
      return '';
    },
    /**
     * @method isAllowed
     * @param {Object} file
     * @return {boolean}
     */
    isAllowed(file) {
      if (!this.extensions.length) {
        return true;
      }
      return (bbn.fn.isFunction(this.extensions) ? this.extensions() : this.extensions).indexOf(this.getExtension(file)) > -1;
    }
  },
  /**
   * @event mounted
   * @fires $nextTick
   */
  mounted() {
    this.ready = true;
    this.$nextTick(() => {
      /*
      if ( !this.window ){
        this.window = this.closest("bbn-floater");
      }
      if ( !this.tab ){
        this.tab = this.closest("bbns-tab");
      }
      this.widget = new qq.FineUploader(this.getCfg);
      if ( this.value && this.getSource ){
        this.widget.addInitialFiles(this.getSource);
      }
      if ( this.isDisabled ){
        this.enable(false);
      }
      */
      let widget = new FileDrop(this.getRef('zone'), {
        upload() {
          bbn.fn.log("UPLOADING", arguments);
        },
        /* iframe: {
          url: this.saveUrl
        } */
        xRequestedWith: 'XMLHttpRequest'
      });
      widget.event('send', files => {
        if (!this.isDisabled) {
          this.uploading = true;
          files.each(file => {
            if (!this.isAllowed(file)) {
              appui.error(bbn._("This type of file is not allowed, only files of type") + ' ' + this.extensions.join(', '));
            } else if (this.maxSize && file.size / 1024 / 1024 > this.maxSize) {
              appui.error(bbn._("The file si too big, the maximum size is") + ' ' + this.maxSize + 'MB');
            } else {
              file.event('done', xhr => {
                this.uploading = false;
                appui.success('Done uploading ' + file.name);
              });
              file.event('progress', (sent, total) => {
                this.progress = Math.round(sent / total * 100);
              });
              file.sendTo(this.saveUrl, {
                xRequestedWith: 'XMLHttpRequest'
              });
              //bbn.fn.log("FROM FILE", file);
              this.files.push(file);
            }
          });
          if (!this.files.length) {
            this.uploading = false;
          }
        }
      });
    });
  },
  watch: {
    /**
     * @watch enabled
     * @param {Boolean} val
     */
    enabled(val) {
      this.isEnabled = !val;
    },
    /**
     * @watch isEnabled
     * @param {String} val
     */
    isEnabled(val) {
      this.enable(val);
    },
    /**
     * @watch widgetValue
     * @param {String} val
     */
    widgetValue(val) {
      this.$emit('input', this.getValue);
      this.$emit('change', this.getValue);
    }
  }
};
import cpHtml from './file.html';
import cpStyle from './file.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./file.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
const def = {
  name: 'bbn-file',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
export { def as default, FileDrop };
/**
 * @file bbn-filter component
 *
 * @description The purpose of this component is to apply filters to a complex structure of data.
 * Used on the "bbn-table" component.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.dataEditor
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.dataEditor],
  statics() {
    const get_operator_type = function (field) {
      if (typeof field === 'object') {
        switch (field.type) {
          case 'int':
            // maxlength is a string!
            if (field.maxlength == 1) {
              return 'boolean';
            }
            if (field.maxlength == 10 && field.keys) {
              return 'enums';
            }
            return 'number';
          case 'boolean':
          case 'bool':
            return 'boolean';
          case 'float':
          case 'decimal':
          case 'number':
          case 'money':
            return 'number';
          case 'date':
            return 'date';
          case 'datetime':
            return 'date';
          case 'time':
            return 'date';
          case 'enum':
          case 'enums':
            return 'enums';
          default:
            return 'string';
        }
      }
    };
    const get_component_type = function (sqlType) {
      switch (sqlType) {
        case 'int':
        case 'float':
        case 'decimal':
          return 'numeric';
        case 'date':
          return 'datepicker';
        case 'datetime':
          return 'datetimepicker';
        case 'time':
          return 'timepicker';
        default:
          return 'input';
      }
    };

    // var  borders = ['#414d40', '#5a6559', '#7f897e', '#6c7a78', '#515963']
    // var  borders = ['red', 'green', 'yellow', 'pink', 'blue']
    const borders = ['#e47777', '#fa4a4a', '#8d0e0e', '#b44f4f', '#c16262'];
    const bg_colors = ['rgba(228,119,119,0.2)', 'rgba(250,74,74,0.2)', 'rgba(141,14,14,0.2)', 'rgba(180,79,79,0.2)', 'rgba(193,98,98,0.2)'];
    return {
      get_operator_type,
      get_component_type,
      borders,
      bg_colors
    };
  },
  name: 'bbn-filter',
  props: {
    /**
     * The value of the filter.
     * @prop {Object} value
     */
    value: {},
    /**
     * The operator of the filter.
     * @prop operator
     */
    operator: {},
    /**
     * @prop operators
     */
    operators: {},
    /**
     * The pre-existing conditions.
     * @prop {Array} [[]] conditions
     */
    conditions: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The previously chosen logic 'AND' or 'OR'.
     * @prop {String} ['AND'] logic
     */
    logic: {
      type: String,
      default: 'AND'
    },
    /**
     * The list of fields given to the filter.
     * @prop {(Object|Array)} [{}] fields
     */
    fields: {
      type: [Object, Array],
      default() {
        return {};
      }
    },
    /**
     * @prop {Number} [0] num
     */
    num: {
      type: Number,
      default: 0
    },
    /**
     * @prop {} index
     */
    index: {},
    // @todo not used
    first: {},
    /**
     * The component used for a single filter.
     * @prop {Object} [{}] component
     */
    component: {
      type: [String, Object, Function]
    },
    /**
     * The component options used for a single filter.
     * @prop {Object} [{}] componentOptions
     *
     */
    componentOptions: {
      type: [Object, String],
      default() {
        return {};
      }
    },
    /**
     * The column's value for a single column filter.
     * @prop {String} field
     */
    field: {
      type: String
    },
    /**
     * True if the component is multi-filter.
     * @prop {Boolean} [false] multi
     */
    multi: {
      type: Boolean,
      default: false
    },
    /**
     * The type of data for the operators.
     * @prop {String} ['string'] type
     */
    type: {
      type: String,
      default: 'string'
    }
  },
  data() {
    return {
      /**
       * The value of the property 'logic'.
       * @data {String} ['AND'] currentLogic
       */
      currentLogic: this.logic,
      /**
       * The current value of the filter.
       * @data currentValue
       */
      currentValue: this.value !== undefined ? this.value : null,
      /**
       * The current operator.
       * @data currentOperator
       */
      currentOperator: this.operator !== undefined ? this.value : null
    };
  },
  computed: {
    /**
     * Returns the border color.
     * @computed border_color
     * @return {String}
     */
    border_color() {
      if (this.num > bbnFilterCp.borders.length) {
        return bbnFilterCp.borders[this.num % bbnFilterCp.borders.length];
      } else {
        return bbnFilterCp.borders[this.num];
      }
    },
    /**
     * @todo not used
     * @return {bbnCp}
     */
    is_not_root() {
      return this.$parent.$el.classList.contains("bbn-filter-control");
    }
  },
  methods: {
    /**
     * Alters the filter's style on mouseover event.
     *
     * @method over
     * @param {Event} e
     */
    over(e) {
      e.target.style.color = 'red';
      e.target.parentElement.parentElement.querySelector('.bbn-filter-main').style.backgroundColor = 'rgba(158,158,158, 0.3)';
    },
    /**
     * Alters the filter's style on mouseout event.
     *
     * @method out
     * @param {Event} e
     */
    out(e) {
      e.target.style.color = null;
      e.target.parentElement.parentElement.querySelector('.bbn-filter-main').style.backgroundColor = 'inherit';
    },
    /**
     * Sets the conditions for the filter.
     *
     * @method setCondition
     * @param {Object} obj
     * @emits set
     * @return {Object}
     */
    setCondition(obj) {
      if (obj.field && obj.operator) {
        //bbn.fn.log("setCondition", obj, this.multi);
        obj.time = new Date().getTime();
        if (this.multi) {
          this.conditions.push(obj);
          this.$forceUpdate();
        }
        this.$emit('set', obj);
      }
      return obj;
    },
    /**
     * Removes the set filter conditions.
     *
     * @method unsetCondition
     * @param {Object} obj
     * @emits set
     * @return {Object}
     */
    unsetCondition(obj) {
      if (obj.field && obj.operator && obj.time) {
        if (this.multi) {
          this.conditions.push(obj);
        } else {
          this.$emit('set', obj);
        }
      }
      return obj;
    },
    /**
     * Returns the number of fields.
     *
     * @method hasFields
     * @return {Boolean}
     */
    hasFields() {
      return this.fields && Object.keys(this.fields).length;
    },
    /**
     * Styles the text based on the given condition.
     *
     * @method condition_text
     * @param {Object} cd
     * @return {String}
     */
    condition_text(cd) {
      let st = '';
      if (cd && cd.field) {
        let index = bbn.fn.search(this.fields, {
          field: cd.field
        });
        if (index > -1) {
          let f = this.fields[index];
          st += '<strong>' + (f.ftitle ? f.ftitle : f.title ? f.title : cd.field) + '</strong> ' + this.editorOperators[bbnFilterCp.get_operator_type(f)][cd.operator] + ' <em>';
          if (cd.value) {
            if (cd.value === true) {
              st += 'true';
            } else if (f.source) {
              if (bbn.fn.isArray(f.source)) {
                st += bbn.fn.getField(f.source, 'text', 'value', cd.value);
              } else if (typeof f.source === 'object') {
                st += f.source[cd.value];
              }
            } else {
              st += cd.value;
            }
          } else if (cd.value === 0) {
            st += '0';
          } else if (cd.value === false) {
            st += 'false';
          }
          st += '</em>';
        }
      }
      return st;
    },
    /**
     * Completely deletes the conditions of the given index.
     * @method delete_full_condition
     * @param {Number} idx
     * @emits unset
     */
    delete_full_condition(idx) {
      this.$emit('unset', this.conditions.splice(idx, 1));
    },
    /**
     * Deletes the given condition.
     *
     * @method delete_condition
     * @param {Object} condition
     * @fires confirm
     * @emits unset
     */
    delete_condition(condition) {
      let del = arr => {
        let idx = bbn.fn.search(arr, {
          time: condition.time
        });
        //bbn.fn.log("Is there the index?", idx);
        if (idx > -1) {
          if (arr[idx].conditions && arr[idx].conditions.length) {
            this.confirm(bbn._("Are you sure you want to delete this group of conditions?"), () => {
              arr.splice(idx, 1);
            });
          } else {
            arr.splice(idx, 1);
          }
          return true;
        }
        for (let i = 0; i < arr.length; i++) {
          if (arr[i].conditions) {
            if (del(arr[i].conditions)) {
              return true;
            }
          }
        }
      };
      if (del(this.conditions)) {
        this.$forceUpdate();
        this.$emit('unset', condition);
      }
    },
    /**
     * Adds a condition to the given index.
     * @method add_group
     * @param {Number} idx
     */
    add_group(idx) {
      let cond = bbn.fn.extend(true, {}, this.conditions[idx]);
      this.conditions.splice(idx, 1);
      this.$nextTick(() => {
        this.conditions.splice(idx, 0, {
          logic: this.currentLogic,
          conditions: [cond]
        });
        this.$forceUpdate();
      });
    },
    /**
     * Deletes a condition.
     * @method delete_group
     */
    delete_group() {
      this.$parent.conditions.splice(idx, 1);
    }
  },
  components: {
    /**
     * @component bbn-filter-form
     */
    'bbn-filter-form': {
      name: 'bbn-filter-form',
      /**
       * @mixin bbn.cp.mixins.dataEditor
       * @memberof bbn-filter-form
       */
      mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.dataEditor],
      props: {
        /**
         * The list of fields available for the filter.
         * @prop {Object|Array} [{}] fields
         * @memberof bbn-filter-form
         */
        fields: {},
        /**
         * The column's value for a single column filter.
         * @prop {String} field
         * @memberof bbn-filter-form
         */
        field: {
          type: String
        },
        /**
         * The type of data of the operators.
         * @prop {String} ['string'] type
         * @memberof bbn-filter-form
         */
        type: {
          type: String
        },
        /**
         * The operator of the filter.
         * @prop operator
         * @memberof bbn-filter-form
         */
        operator: {
          type: String
        },
        /**
         * The value of the filter.
         * @prop value
         * @memberof bbn-filter-form
         */
        value: {},
        /**
         * The component used for a single filter.
         * @prop component
         * @memberof bbn-filter-form
         *
         */
        component: {
          type: [String, Object, Function]
        },
        /**
        * The component options used for a single filter.
        * @prop {Object} [{}] componentOptions
        * @memberof bbn-filter-form
        */
        componentOptions: {
          type: Object,
          default() {
            return {};
          }
        },
        /**
         * Set to true to show the button to delete a condition.
         * @prop {Boolean} [false] buttonDelete
         * @memberof bbn-filter-form
         */
        buttonDelete: {
          type: Boolean,
          default: false
        }
      },
      data() {
        return {
          /**
           * The current field.
           * @data {String} currentField
           * @memberof bbn-filter-form
           */
          currentField: this.field || '',
          /**
           * The current type.
           * @data currentType
           * @memberof bbn-filter-form
           */
          currentType: this.type || '',
          /**
           * The current value.
           * @data currentValue
           * @memberof bbn-filter-form
           */
          currentValue: this.value || '',
          /**
           * The current component.
           * @data {String} currentComponent
           * @memberof bbn-filter-form
           */
          currentComponent: this.component || false,
          /**
           * The current component's options.
           * @data {Object} currentComponentOptions
           * @memberof bbn-filter-form
           */
          currentComponentOptions: this.componentOptions,
          /**
           * The current operator.
           * @data {String} currentOperator
           * @memberof bbn-filter-form
           */
          currentOperator: this.operator || '',
          /**
           * The current operators.
           * @data {Array} [[]] currentOperators
           * @memberof bbn-filter-form
           */
          currentOperators: [],
          /**
           * The current condition.
           * @data {Boolean} [false] currentCondition
           * @memberof bbn-filter-form
           */
          currentCondition: false,
          /**
           * @todo not used
           */
          has_group: false,
          /**
           * @todo not used
           */
          has_condition: true,
          /**
           * @prop {Array} [[]] items
           * @memberof bbn-filter-form
           */
          items: [],
          /**
           * @prop cfg
           * @memberof bbn-filter-form
           */
          cfg: {}
        };
      },
      computed: {
        /**
         * Returns the object containing the operators.
         * @computed operators
         * @fires currentFullField
         * @memberof bbn-filter-form
         * @return {Object}
         */
        operators() {
          let ops = this.currentField && this.currentType && this.editorOperators[this.currentType] ? this.editorOperators[this.currentType] : [];
          if (this.currentFullField.nullable) {
            bbn.fn.extend(true, ops, this.editorNullOps);
          }
          return ops;
        },
        /**
         * True if the filter form has no value.
         * @computed no_value
         * @fires editorHasNoValue
         * @memberof bbn-filter-form
         * @return {Boolean}
         */
        no_value() {
          return this.editorHasNoValue(this.operator);
        },
        /**
         * Normalizes the array 'fields' to use as the source of the form's dropdown.
         * @computed columns
         * @return {Array}
         * @memberof bbn-filter-form
         */
        columns() {
          let r = [];
          if (bbn.fn.isArray(this.fields)) {
            bbn.fn.each(this.fields, (a, i) => {
              if (a.field) {
                r.push({
                  text: a.ftitle ? a.ftitle : a.title ? a.title : a.field,
                  value: a.field
                });
              }
            });
          } else {
            for (let n in this.fields) {
              r.push(n);
            }
          }
          return r;
        },
        /**
         * Returns the object 'field' of the corresponding current field.
         * @computed currentFullField
         * @memberof bbn-filter-form
         * @return {Object}
         */
        currentFullField() {
          if (this.currentField) {
            let idx = bbn.fn.search(this.fields, {
              field: this.currentField
            });
            if (idx > -1) {
              return this.fields[idx];
            }
          }
          return {};
        },
        /**
         * Returns the title of the current field.
         * @computed currentTitle
         * @memberof bbn-filter-form
         * @return {String}
         */
        currentTitle() {
          if (this.currentField) {
            let idx = bbn.fn.search(this.fields, {
              field: this.currentField
            });
            if (idx > -1) {
              return this.fields[idx].title || this.fields[idx].ftitle || this.fields[idx].field || '';
            }
          }
          return '';
        }
      },
      methods: {
        /**
         * Resets the current operator, the current value and the current field value (if the number of columns is greater than) to their default.
         * @method _unset
         * @memberof bbn-filter-form
         */
        _unset() {
          this.currentOperator = '';
          this.currentValue = '';
          if (this.columns.length > 1) {
            this.currentField = '';
          }
        },
        /**
         * Validates the form.
         * @method validate
         * @param {Boolean} cancel
         * @fires editorHasNoValue
         * @fires _unset
         * @emits validate
         * @emits invalidate
         * @emits error
         * @memberof bbn-filter-form
         */
        validate(cancel) {
          if (this.currentField && this.currentOperator && (this.currentValue || this.editorHasNoValue(this.currentOperator))) {
            var tmp = {
              field: this.currentField,
              operator: this.currentOperator
            };
            if (!this.editorHasNoValue(this.currentOperator)) {
              tmp.value = this.currentValue;
            }
            if (cancel === true && this.currentCondition) {
              this.$parent.unsetCondition(this.currentCondition);
            } else {
              this.currentCondition = this.$parent.setCondition(tmp);
              if (this.$parent.multi) {
                this._unset();
              }
              //bbn.fn.log("CONDI", this.currentCondition);
            }

            this.$emit(cancel ? 'invalidate' : 'validate', tmp, cancel);
          } else {
            this.$emit('error', bbn._("Value is required. You should choose another operator if you want to look for an element empty or null"));
          }
        },
        /**
         * Calls the "_unset" method and emits "unset" event
         * @method unset
         * @memberof bbn-filter-form
         * @fires _unset
         * @emit $parent.unset
         */
        unset() {
          this._unset();
          this.$parent.$emit('unset');
        }
      },
      /**
       * @event created
       * @memberof bbn-filter-form
       */
      created() {
        if (this.type && this.editorOperators[this.type]) {
          this.currentOperators = this.editorOperators[this.type];
        }
        if (this.field && bbn.fn.isArray(this.fields) && this.fields.length && !this.component) {
          let fieldObj = bbn.fn.getRow(this.fields, {
            field: this.field
          });
          if (fieldObj) {
            let o = this.editorGetComponentOptions(fieldObj);
            if (o) {
              if (o.type !== this.currentType) {
                this.currentType = o.type;
              }
              this.currentComponent = o.component;
              this.currentComponentOptions = o.componentOptions;
            }
          }
        }
      },
      /**
       * @event mounted
       * @memberof bbn-filter-form
       */
      mounted() {
        this.ready = true;
        /*if ( this.columns.length === 1 ){
          this.currentField = this.fields[0].field;
        }*/
        //bbn.fn.log("FILTER FORM MOUNTED", this);
      },

      watch: {
        /**
         *
         * @watch currentField
         * @param {} newVal
         * @fires editorGetComponentOptions
         * @memberof bbn-filter-form
         */
        currentField(newVal) {
          let fieldObj = bbn.fn.getRow(this.fields, {
            field: newVal
          });
          if (fieldObj) {
            let o = this.editorGetComponentOptions(fieldObj);
            if (o) {
              this.currentType = o.type;
              this.currentComponent = o.component;
              this.currentComponentOptions = o.componentOptions;
            }
          }
        }
        /*
        currentColumn(newVal){
          let ds = [],
              idx = bbn.fn.search(this.fields, {field: newVal});
          this.cfg = {};
          if ( idx > -1 ){
            let c                = this.fields[idx],
                currentComponent = this.vueComponent;
            this.currentType = get_operator_type(c);
            if ( !newVal ){
              this.currentOperator = '';
              this.vueComponent = '';
              this.currentType = '';
            }
            else{
              bbn.fn.log("TYPE!!", c);
              switch ( c.currentType ){
                case 'int':
                  if ( !c.signed && (c.maxlength == 1) ){
                    this.vueComponent = 'radio';
                  }
                  else if ( c.maxlength == 10 ){
                    this.vueComponent = 'tree-input';
                    this.cfg.source = 'options/tree';
                  }
                  else{
                    if ( !c.signed ){
                      this.cfg.min = 0;
                    }
                    this.cfg.max = 1;
                    for ( var i = 0; i < c.maxlength; i++ ){
                      this.cfg.max = this.cfg.max * 10;
                    }
                    this.cfg.max--;
                    this.vueComponent = 'numeric';
                  }
                  break;
                case 'float':
                case 'decimal':
                  this.vueComponent = 'numeric';
                  var tmp = c.maxlength.split(","),
                      max = parseInt(tmp[0]) - parseInt(tmp[1]);
                  this.cfg.format = 'n' + tmp[1];
                  if ( !c.signed ){
                    this.cfg.min = 0;
                  }
                  this.cfg.max = 1;
                  for ( var i = 0; i < max; i++ ){
                    this.cfg.max = this.cfg.max * 10;
                  }
                  this.cfg.max--;
                  this.vueComponent = 'numeric';
                  break;
                case 'enum':
                  var tmp = eval('[' + c.extra + ']');
                  if (bbn.fn.isArray(tmp) ){
                    this.cfg.dataSource = bbn.fn.map(tmp, function (a){
                      return {
                        text: a,
                        value: a
                      };
                    });
                    this.cfg.optionLabel = bbn._("Choisir une valeur");
                    this.vueComponent = 'dropdown';
                  }
                  break;
                case 'date':
                  this.vueComponent = 'datepicker';
                  break;
                case 'datetime':
                  this.vueComponent = 'datetimepicker';
                  break;
                case 'time':
                  this.vueComponent = 'timepicker';
                  break;
                default:
                  this.vueComponent = 'input';
                  break;
              }
            }
              if ( currentComponent !== this.vueComponent ){
              if ( this.$refs.value && this.$refs.value.widget ){
                this.$refs.value.widget.destroy();
                var $ele = $(this.$refs.value.$el);
                $ele.prependTo($ele.closest(".bbn-db-value")).nextAll().remove();
              }
              this.$nextTick(() =>{
                this.$refs.operator.widget.select(0);
                this.$refs.operator.widget.trigger("change");
              });
            }
          }
        }
        */
      }
    }
  }
};

import cpHtml from './filter.html';
import cpStyle from './filter.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./filter.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-filter',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * Created by BBN on 15/08/2019.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  statics() {
    let fields = ['host', 'user', 'pass'],
      filesRules = {
        pdf: 'nf nf-mdi-file_pdf bbn-red',
        php: 'nf nf-mdi-language_php bbn-blue',
        doc: 'nf nf-mdi-file_word bbn-blue',
        docx: 'nf nf-mdi-file_word bbn-blue',
        xls: 'nf nf-mdi-file_excel bbn-green',
        xlsx: 'nf nf-mdi-file_excel bbn-green',
        ppt: 'nf nf-mdi-file_powerpoint bbn-red',
        pptx: 'nf nf-mdi-file_powerpoint bbn-red',
        psd: 'nf nf-dev-photoshop bbn-blue',
        js: 'nf nf-mdi-language_javascript bbn-red',
        html: 'nf nf-mdi-language_html5 bbn-green',
        txt: 'nf nf-oct-file_text',
        css: 'nf nf-dev-css3 bbn-orange',
        less: 'nf nf-dev-css3 bbn-orange',
        zip: 'nf nf-mdi-archive bbn-orange',
        gz: 'nf nf-mdi-archive',
        gzip: 'nf nf-mdi-archive',
        png: 'nf nf-mdi-file_image bbn-purple',
        jpeg: 'nf nf-mdi-file_image bbn-blue',
        jpg: 'nf nf-mdi-file_image bbn-blue',
        gif: 'nf nf-mdi-file_image bbn-pink',
        tiff: 'nf nf-mdi-file_image bbn-brown',
        json: 'nf nf-mdi-json bbn-red'
      },
      imageExt = ['jpeg', 'png', 'jpg', 'tiff', 'gif'];
    return {
      fields,
      filesRules,
      imageExt
    };
  },
  props: {
    /**
     * @prop {String} ['.'] path
     */
    path: {
      type: String,
      default: '.'
    },
    /**
     * @prop {} source
     */
    source: {},
    /**
     * @prop {String} origin
     */
    origin: {
      type: String
    },
    /**
     * @prop {String} root
     */
    root: {
      type: String
    },
    /**
     * @prop {Boolean} [true] preview
     */
    preview: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} ['nf nf-fa-folder bbn-yellow'] folderIcon
     */
    folderIcon: {
      type: String,
      default: 'nf nf-fa-folder bbn-yellow'
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] uploading
       */
      // takes the value of the path when the upload is clicked from the context menu - used to show / hide bbn-upload
      uploading: false,
      //v-model of bbn-upload
      /**
       * @data {Array} [[]] uploaded
       */
      uploaded: [],
      //defined when the button new folder/file is clicked on the bottom of the tree
      /**
       * @data {String} [''] currentContextPath
       */
      currentContextPath: '',
      /**
       * @data {Boolean} [false] isConnected
       */
      isConnected: false,
      /**
       * @data {Array} [[]] data
       */
      data: [],
      /**
       * @data {String} [''] host
       */
      host: '',
      /**
       * @data {String} [''] user
       */
      user: '',
      /**
       * @data {String} [''] pass
       */
      pass: '',
      /**
       * @data {Boolean} [false] copied
       */
      copied: false,
      /**
       * @data {String} [''] oldDir
       */
      oldDir: '',
      /**
       * @data {Array} [[{name:'',path:'.',empty_dirs:0,num_dirs:0,num_files:0,size:0}]] dirs
       */
      dirs: [{
        name: '',
        path: '.',
        empty_dirs: 0,
        num_dirs: 0,
        num_files: 0,
        size: 0
      }],
      /**
       * @data {Boolean} [false] currentFile
       */
      currentFile: false,
      /**
       * @data [null] dirInfo
       */
      dirInfo: null,
      /**
       * @data {Boolean} [false] editingNode
       */
      editingNode: false,
      /**
       * @data {Boolean} [false] isImage
       */
      isImage: false,
      /**
       * @data {Boolean} [false] isLoading}
       */
      isLoading: false,
      /**
       * @data {Boolean} [false] currentTitle
       */
      currentTitle: false
    };
  },
  computed: {
    /**
     * @computed mapUploaded
     * @return {(Array)}
     */
    mapUploaded() {
      if (this.uploaded.length) {
        return bbn.fn.map(this.uploaded, a => {
          a.name = a.name.replace(' ', '_');
          return a;
        });
      }
      return [];
    },
    /**
     * @computed currentPath
     * @return {String}
     */
    currentPath() {
      return this.dirs.map(a => {
        return a.name ? a.name + '/' : '';
      }).join('');
    },
    /**
     * @computed numCols
     * @return {Number}
     */
    numCols() {
      return this.dirs.length;
    },
    /**
     * @computed encodeURL
     * @return {String}
     */
    encodedURL() {
      if (this.currentFile && this.isImage) {
        //return btoa(this.origin + this.currentPath + this.currentFile.node.data.value)
        return btoa(this.currentPath + this.currentFile.node.data.value);
      }
    }
  },
  methods: {
    //abort the current request
    /**
     * Abord the current request.
     *
     * @method abortRequest
     * @param {Number} i
     */
    abortRequest(i) {
      bbn.fn.happy(i);
      let loadBar = this.closest('bbn-appui').getRef('loading');
      if (loadBar) {
        let loadUrl = loadBar.currentItem.url;
        if (bbn.fn.isNumber(i) && loadUrl === 'ide/finder') {
          bbn.fn.abort(loadBar.currentItem.key);
          appui.success(bbn._('Current request aborted'));
          this.currentFile = false;
          this.dirs.splice(i, 1);
        } else if (loadUrl.indexOf('ide/actions/finder/file') === 0) {
          this.currentFile = false;
          this.isLoading = false;
          bbn.fn.abort(loadBar.currentItem.key);
        }
      }
    },
    // at click on the button of the new folder/ file on the bottom of the tree defines the property path of the current tree. Is the only way to know the current context 
    /**
     * At click on the button of the new folder/ file on the bottom of the tree defines the property path of the current tree. Is the only way to know the current context.       *
     *
     * @method context
     * @param a
     * @param {Object} button
     */
    context(a, button) {
      this.currentContextPath = button.closest('bbn-context').data.path;
    },
    /**
     * Closes the preview of the file.
     *
     * @method closePreview
     */
    //closes the preview of the file
    closePreview() {
      this.currentFile = false;
      this.isLoading = false;
    },
    //refresh the tree data
    /**
     * Refresh the tree data0
     *
     * @method refresh
     * @param {String} name
     */
    refresh(name) {
      let trees = this.findAll('bbn-tree');
      if (trees.length) {
        let tree = bbn.fn.filter(trees, a => {
          return a.data.name === name;
        });
        if (tree.length) {
          tree[0].reload();
        }
      }
    },
    /**
     * Get the size of the current tree (the selected folder of the previous tree).
     *
     * @method get_size
     * @param {Object} p
     */
    get_size(p) {
      let idx = bbn.fn.search(this.dirs, 'name', p.name);
      this.post(this.root + 'actions/finder/dirsize', {
        path: p.path,
        origin: this.origin
      }, d => {
        if (d.success) {
          this.dirs[idx].size = d.size;
        } else {
          appui.error(bbn._('Something went wrong'));
        }
      });
    },
    /**
     * @method add
     * @param {String} path
     */
    add(path) {
      let fpath = path;
      if (this.dirs.length > 1) {
        fpath = this.currentPath + path;
      }
      this.dirs.push({
        name: path,
        path: fpath,
        empty_dirs: 0,
        num_dirs: 0,
        size: 0
      });
    },
    /**
     * Remove the current dirs.
     *
     * @method remove
     */
    remove() {
      this.dirs.pop();
    },
    /**
     * Method at @load of bbn-tree.
     *
     * @method updatInfo
     * @param {Object} res
     */
    updateInfo(res) {
      if (res && res.path) {
        setTimeout(() => {
          let idx = bbn.fn.search(this.dirs, {
            path: res.path
          });
          if (idx > -1) {
            this.dirs[idx].num_dirs = res.num_dirs;
            this.dirs[idx].num_files = res.num_files;
            this.isLoading = false;
          }
        }, 300);
      }
    },
    /**
     * Method at @select of bbn-tree, defines currentFile and makes the post to take the infos of the file.
     *
     * @method select
     * @param {Object} node
     */
    select(node) {
      // Reinit
      this.isImage = false;
      this.isLoading = true;
      this.currentFile = {
        node: node
      };
      if (node.data.value) {
        let path = '';
        let num = 2;
        if (node.tree.data.path && node.tree.data.path !== '.') {
          path += node.tree.data.path;
          num += path.split('/').length;
        }
        path += node.data.value;
        if (this.currentPath !== path) {
          while (num <= this.numCols) {
            this.remove();
          }
          if (node.data.dir) {
            this.currentFile = false;
            this.dirInfo = node.data;
            this.add(node.data.value);
          } else if (node.data.file) {
            let idx = node.data.value.lastIndexOf('.'),
              ext = '';
            if (idx > -1) {
              let val = node.data.value.length - idx;
              ext = node.data.value.slice(-val);
            }

            //isImage
            if (!bbnFinderCp.imageExt.includes(ext)) {
              this.post(this.root + 'actions/finder/file', {
                node: node.data,
                path: this.currentPath,
                origin: this.origin,
                ext: ext,
                width: 450,
                height: 300
              }, d => {
                if (d.success && d.info) {
                  this.currentFile = {
                    node: node,
                    height: d.info.height ? d.info.height : '',
                    width: d.info.width ? d.info.width : '',
                    info: d.info,
                    ext: ext
                  };
                  if (d.info.is_image) {
                    this.isImage = true;
                  }
                } else {
                  appui.error(bbn._('Something went wrong while loading the file infos'));
                }
                this.isLoading = false;
              });
            } else {
              return;
              bbn.fn.postOut(this.root + 'actions/finder/image/' + this.encodedURL);
            }
          }
        }
      }
    },
    /**
     * @method mapTree
     * @param {Object} node
     * @return {Object}
     */
    mapTree(node) {
      //bbn.fn.log("NODE", node);
      let bits = node.text.split('.');
      let ext = bits[bits.length - 1];
      if (node.dir) {
        node.icon = this.folderIcon;
      } else if (bbnFinderCp.filesRules[ext]) {
        node.icon = bbnFinderCp.filesRules[ext];
      }
      return node;
    },
    /**
     * @method getData
     * @param {Object} p
     */
    getData(p) {
      //return $.extend({
      return bbn.fn.extend({
        name: p.name,
        path: p.path,
        origin: this.origin
      }, this.isConnected ? {
        host: this.host,
        user: this.user,
        pass: this.pass
      } : {});
    },
    /**
     * @method contextMenuTree
     * @fires uploadFile
     * @fires newFolder
     * @return {[{action: uploadFile, text: string}, {action: newFolder, text: string}, {action: log, text: string}]}
     */
    contextMenuTree() {
      return [{
        text: '<i class="nf nf-fa-file"></i>' + bbn._('Add files to this folder'),
        action: () => {
          this.uploadFile(this.currentContextPath);
        }
      }, {
        text: '<i class="nf nf-custom-folder"></i>' + bbn._('Create new folder'),
        action: () => {
          this.newFolder();
        }
      }, {
        text: '<i class="nf nf-fa-paste"></i>' + bbn._('Paste'),
        action: node => {
          bbn.fn.log('context--->', arguments);
        }
      }];
    },
    /**
     * Returns the array of buttons of the context menu
     *
     * @method itemContextMenu
     * @param {Object} n the node
     * @param {Number} i the index of the node
     * @fires copy
     * @fires newFolder
     * @fires paste
     * @fires download
     * @fires edit
     * @fires delete
     * @return {Array}
     */
    itemsContextMenu(n, i) {
      let objContext = [{
        icon: 'nf nf-fa-copy',
        text: bbn._('Copy'),
        action: node => {
          this.copy(node);
        }
      }];
      if (n.data.dir) {
        objContext.push({
          icon: 'nf nf-fa-paste',
          text: bbn._('Create new folder'),
          action: node => {
            this.newFolder(node);
          }
        });
        if (this.copied !== false) {
          objContext.push({
            icon: 'nf nf-fa-paste',
            text: bbn._('Paste'),
            action: node => {
              this.paste(node);
            }
          });
        }
      } else {
        objContext.push({
          icon: 'nf nf-fa-download',
          text: bbn._('Download'),
          action: node => {
            this.download(node);
          }
        });
      }
      if (this.closest('appui-ide-explorer').source.type === 'nextcloud') {
        objContext.push({
          icon: 'nf nf-fa-edit',
          text: bbn._('Rename'),
          action: node => {
            this.edit(node);
          }
        }, {
          icon: 'nf nf-fa-trash_alt',
          text: bbn._('Delete'),
          action: node => {
            this.delete(node);
          }
        });
      }
      return objContext;
    },
    /**
     *
     * @method uploadFile
     * @param {String} path
     */
    uploadFile(path) {
      this.uploading = this.currentContextPath;
    },
    /**
     * @method uploadSuccess
     * @param a
     * @param b
     * @param {Object} d data
     * @fires getRef
     */
    uploadSuccess(a, b, d) {
      bbn.fn.happy('now');
      bbn.fn.log("FINDER", d.data, arguments, 'args');
      if (d.data.success) {
        if (d.data.name) {
          appui.success(bbn._(d.data.name + ' ' + 'successfully uploaded'));
          if (this.getRef('upload').filesSuccess.length && this.getRef('upload').filesSuccess.length === this.uploaded.length) {
            setTimeout(() => {
              this.uploading = false;
              this.uploaded = [];
            }, 500);
          }
        }
      } else {
        appui.error(bbn._('Something went wrong while uploading the file'));
      }
    },
    /**
     * @method newFolder
     *
     * @param {Object} node
     */
    newFolder(node) {
      if (node) {
        let tmp = node.tree.data.path,
          path = '';
        if (tmp.indexOf('/') === 0) {
          path = bbn.fn.substr(tmp, 1, tmp.length);
        } else {
          path = tmp + '/';
        }
        node.getPopup({
          title: bbn._('New Directory'),
          height: '150px',
          width: '350px',
          source: {
            treeUid: node.closest('bbn-tree')._uid,
            idx: node.idx,
            node: node.data,
            uid: node._uid,
            origin: this.origin,
            path: path,
            root: this.root,
            new: true,
            newDir: ''
          },
          component: this.$options.components.form
        });
      } else {
        if (this.currentContextPath.length) {
          let idx = bbn.fn.search(this.findAll('bbn-tree'), 'data.path', this.currentContextPath),
            treeUid,
            tree;
          if (idx > -1) {
            tree = this.findAll('bbn-tree')[idx];
            treeUid = tree._uid;
            tree.getPopup({
              title: bbn._('New Directory'),
              height: '150px',
              width: '350px',
              source: {
                treeUid: treeUid,
                node: {
                  //just because in the case of new folder from node the value is expected in the controller
                  value: ''
                },
                origin: this.origin,
                path: this.currentContextPath,
                root: this.root,
                new: true,
                newDir: '',
                isFromTree: true
              },
              component: this.$options.components.form
            });
          }
          bbn.fn.happy(this.currentContextPath);
        }
      }
    },
    /**
     * paste the node previously copied in the property this.copied in the current selected dir
     *
     * @method paste
     * @param {Object} n the node
     */
    paste(n) {
      n.isSelected = true;
      bbn.fn.log('PASTE', n, typeof n);
      //case of paste called from context menu and not from nodes of the tree
      let value = '';
      if (typeof n === 'string') {
        value = bbn._('the current folder');
      } else {
        value = n.data.value;
      }
      if ((typeof n === 'string' || n.data.dir) && this.copied) {
        let st = bbn._('Do you want to paste') + ' ' + this.copied.data.value + ' ' + bbn._('into') + ' ' + value + '?';
        let trees = this.findAll('bbn-tree'),
          path = '';
        this.confirm(bbn._(st), () => {
          this.post(this.root + 'actions/finder/paste', {
            node: this.copied.data,
            origin: this.origin,
            old_dir: this.oldDir,
            new_dir: this.currentPath
          }, d => {
            if (d.success) {
              bbn.fn.happy('pasted');
              //bbn.fn.log(n.tree.items)
              bbn.fn.each(trees, (v, i) => {
                //bbn.fn.log(n,( v.data.name === n.data.value ), v.data.name ,n.data.value )
                if (v.data.name === n.data.value) {
                  //bbn.fn.log(v.source)
                  v.reload();
                }
              });
              appui.success(this.copied.data.value + ' ' + bbn._('successfully pasted into ' + n.data.value));
            } else {
              appui.error(bbn._('Something went wrong'));
            }
            this.copied = false;
            this.oldDir = '';
          });
        });
      } else if (!this.copied) {
        this.alert(bbn._('The clipboard is empty!'));
      }
    },
    //download the file
    /**
     * @method download
     * @param {Object} n
     */
    download(n) {
      bbn.fn.postOut(this.root + 'actions/finder/download/' + n.data.value, {
        value: n.data.value,
        file: n.data.file,
        path: this.currentPath !== n.data.value + '/' ? this.currentPath : '',
        origin: this.origin,
        destination: this.origin + 'download/' + dayjs().format('x') + '/'
      });
    },
    /**
     * Edits the name of the current selected node.
     *
     * @method edit
     * @param {Object} node
     */
    edit(node) {
      this.editingNode = false;
      let oldValue = node.data.value,
        tmp = node.closest('bbn-tree').data.path,
        path = '';
      if (tmp.indexOf('/') === 0) {
        path = bbn.fn.substr(tmp, 1, tmp.length);
      } else {
        path = tmp + '/';
      }
      let currentPath = path;
      this.editingNode = node;
      node.getPopup({
        title: bbn._('Rename'),
        height: '150px',
        width: '350px',
        source: {
          treeUid: node.closest('bbn-tree')._uid,
          idx: node.idx,
          node: node.data,
          origin: this.origin,
          path: currentPath,
          oldValue: oldValue,
          root: this.root
        },
        component: this.$options.components.form
      });
    },
    /**
     * Deletes the current selected node.
     *
     * @method delete
     * @param {Object} node
     */
    delete(node) {
      this.confirm(bbn._('Do you want to delete') + ' ' + node.data.value + '?', () => {
        let st = node.tree.data.path,
          //st = ( (this.mode === 'ftp') || (this.mode === 'ssh')) ? this.origin + this.currentPath : this.currentPath,
          name = node.data.value;
        /*if ( node.data.dir && ( this.currentPath === '' ) ){
          st += node.data.value;
        }
        if ( node.data.file ){
          st += node.data.value;
        }
        */

        this.post(this.root + 'actions/finder/delete', {
          path: st,
          name: name,
          origin: this.origin
        }, d => {
          if (d.success) {
            let items = node.tree.items;
            if (items.length) {
              items.splice(node.idx, 1);
            }
            if (node.data.dir && this.dirs.length) {
              let idx = bbn.fn.search(this.dirs, 'path', node.tree.data.path + '/' + node.data.value);
              if (idx > -1) {
                this.dirs.splice(idx);
              }
            }
            //destroy the next tree in the case of elimination of a folder
            if (node.data.dir && this.dirs.length > 1) {
              this.dirs.pop();
            }
            appui.success(name + ' ' + bbn._('successfully deleted'));
            this.currentFile = false;
          } else {
            appui.error(bbn._('Something went wrong while deleting' + node.data.value));
          }
        });
      });
    },
    /**
     * @method dragStart
     */
    dragStart() {
      bbn.fn.log('START', arguments);
    },
    /**
     * @method dragEnd
     */
    dragEnd() {
      bbn.fn.log('END', arguments);
    },
    /**
     * Insert the current selected node in the property this.copied.
     * @method copy
     * @param {Object} n the node
     * @fires confirm
     */
    copy(n) {
      bbn.fn.happy('copy');
      bbn.fn.log(arguments);
      this.copied = false;
      this.confirm(bbn._('Do you want to copy') + ' ' + n.data.value + '?', () => {
        this.copied = n;
        /*if ( n.data.dir && this.dirs.length > 2){
          let st = this.currentPath.slice(0,-1),
          idx = st.lastIndexOf('/');
          if ( idx > -1 ){
            st = st.substring(0, idx);
          }
          this.oldDir = st + '/';
        }
        else if ( n.data.dir && this.dirs.length <= 2 ){
          this.oldDir = '';
        }
        else {
          this.oldDir = this.currentPath;
        }*/
        this.oldDir = n.tree.data.path;
        let st = n.data.file ? bbn._('File') : bbn._('Folder');
        st += ' ' + bbn._('successfully copied');
        appui.success(st);
      });
    },
    /**
     * @method updateScroll
     * @fires $nextTick
     * @fires getRef
     */
    updateScroll() {
      this.$nextTick(() => {
        let sc = this.getRef('scroll');
        if (sc) {
          //sc.onResize().then(() => {
          //setTimeout(() => {
          //bbn.fn.log("IT SHOULD GO TO THE END OF THE SCROLL")
          sc.scrollEndX(true);
          //}, 250);
          //});
        }
      });
    }
  },

  /**
   * @event mounted
   * @fires add
   */
  mounted() {
    if (this.path) {
      bbn.fn.each(this.path.split('/'), a => {
        if (a) {
          this.add(a);
        }
      });
    }
  },
  watch: {
    /**
     * @watch isLoading
     * @param val
     */
    isLoading(val) {
      //bbn.fn.log('isloading->>>>', val, new Date())
    },
    /**
     * @watch host
     * @param newVal
     * @param oldVal
     * @fires checkDisconnect
     */
    host(newVal, oldVal) {
      if (this.isConnected) {
        this.checkDisconnect(this.getRef('host'), oldVal);
      }
    },
    /**
     * @watch user
     * @param newVal
     * @param oldVal
     * @fires checkDisconnect
     */
    user(newVal, oldVal) {
      if (this.isConnected) {
        this.checkDisconnect(this.getRef('user'), oldVal);
      }
    },
    /**
     * @watch pass
     * @param newVal
     * @param oldVal
     * @fires checkDisconnect
     */
    pass(newVal, oldVal) {
      if (this.isConnected) {
        this.checkDisconnect(this.getRef('pass'), oldVal);
      }
    },
    /**
     * @watch isConnected
     * @fires remove
     * @fires add
     */
    isConnected() {
      while (this.numCols) {
        this.remove();
      }
      setTimeout(() => {
        this.add('');
      }, 250);
    },
    /**
     * @watch dirs
     * @fires updateScroll
     */
    dirs() {
      this.updateScroll();
    },
    /**
     * @watch currentFile
     * @fires updateScroll
     */
    currentFile() {
      this.updateScroll();
    },
    /**
     * @watch currentPath
     * @param v
     * @emits change
     */
    currentPath(v) {
      this.$emit('change', v);
    }
  },
  components: {
    form: {
      name: 'form',
      template: `
        <bbn-form class="bbn-flex-height"
                  :source="source" 
                  @success="success" 
                  :action="source.root + 'actions/finder/' + (!source.new ? 'rename' : 'new_dir')"
                  >
          <div class="bbn-grid-fields bbn-l bbn-padded">
            <label>` + bbn._('Name') + `</label>
            <div>
              <bbn-input v-if="!source.new" 
                         class="bbn-w-100" 
                         v-model="source.node.value"
                         
              ></bbn-input>
              <bbn-input v-else 
                         class="bbn-w-100" 
                         v-model="source.newDir"
              >
              </bbn-input>
            </div>
          </div>
        </bbn-form>`,
      props: ['source', 'data'],
      data() {
        return {
          dirIdx: false
        };
      },
      computed: {
        dirs() {
          return this.closest('bbn-container').getComponent().dirs;
        },
        finder() {
          return this.closest('bbn-finder');
        }
      },
      methods: {
        success(d) {
          if (d.success) {
            let trees = this.closest('bbn-container').getComponent().findAll('bbn-tree');

            //creating a new folder
            if (d.data && d.data.new_dir) {
              bbn.fn.happy('mpod');
              let treeIdx = bbn.fn.search(trees, '_uid', this.source.treeUid);
              bbn.fn.happy(treeIdx);
              if (treeIdx > -1 && trees[treeIdx + 1]) {
                trees[treeIdx + 1].reload();
                bbn.fn.happy(treeIdx);
              } else if (this.source.isFromTree) {
                //case of folder created from the context of the tree and not node
                trees[treeIdx].reload();
              }
              appui.success(d.data.new_dir + ' ' + bbn._('successfully created'));
            }
            //editing an existing folder
            else {
              bbn.fn.each(trees, (v, i) => {
                if (v._uid === this.source.treeUid) {
                  v.items[this.source.idx].value = this.source.node.value;
                  v.items[this.source.idx].text = this.source.node.value;
                }
              });
              appui.success((this.source.node.dir ? bbn._('Folder') : bbn._('File')) + ' ' + bbn._('successfully modified'));
            }
          } else {
            appui.error(bbn._('Something went wrong'));
          }
        }
      }
    }
  }
};
import cpHtml from './finder.html';
import cpStyle from './finder.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./finder.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-finder',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-fisheye component
 *
 * @description bbn-fisheye is a component that represents a horizontal menu, ideal for managing shortcuts.
 * The structure of data cannot be hierarchical.
 * Each element is represented by an icon capable of performing an action.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.list],
  props: {
    /**
     * The source of the component
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * True if you want to activate the possibility to remove an element.
     * @prop {Boolean} [false] removable
     */
    removable: {
      type: Boolean,
      default: false
    },
    /**
     * An array of items fixed on the left of the component
     * @prop {Array} [[]] fixedLeft
     */
    fixedLeft: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * An array of items fixed on the right of the component
     * @prop {Array} [[]] fixedRight
     */
    fixedRight: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The zIndex of the component
     * @prop {Number} [1] zIndex
     */
    zIndex: {
      type: Number,
      default: 1
    },
    /**
     * True if you want to render the component scrollable
     * @prop {Boolean} [false] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * True if you want to render the mobile version of the component
     * @prop {Boolean} [false] mobile
     */
    mobile: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] menu
       */
      menu: false,
      /**
       * @data {Boolean} [false] widget
       */
      widget: false,
      /**
       * @data {Boolean} [false] overBin
       */
      overBin: false,
      /**
       * @data {Boolean} [false] droppableBin
       */
      droppableBin: false,
      /**
       * @data {Boolean|Number} [false] timeout
       */
      timeout: false,
      /**
       * @data {Boolean|Number} [false] binTimeout
       */
      binTimeout: false,
      /**
       * @data {Boolean} [false] visibleBin
       */
      visibleBin: false,
      /**
       * @data {Number} [-1] visibleText
       */
      visibleText: -1,
      /**
       * @data {Number} [-1] draggedIdx
       */
      draggedIdx: -1,
      /**
       * @data {Boolean} [true] showIcons
       */
      showIcons: !this.mobile,
      /**
       * @data {Boolean} [false] visibleFloater
       */
      visibleFloater: false,
      /**
       * @data {Number} [0] floaterTop
       */
      floaterTop: 0
    };
  },
  computed: {
    /**
     * The icons list
     * @computed items
     * @returns {Array}
     */
    items() {
      let items = [];
      let i = 0;
      bbn.fn.each(this.fixedLeft, a => {
        items.push({
          data: a,
          fixed: true,
          index: i
        });
        i++;
      });
      bbn.fn.each(this.filteredData, a => {
        items.push({
          data: a.data,
          fixed: false,
          index: i
        });
        i++;
      });
      bbn.fn.each(this.fixedRight, a => {
        items.push({
          data: a,
          fixed: true,
          index: i
        });
        i++;
      });
      return items;
    },
    /**
     * The bin position.
     * @computed binPosition
     * @returns {String}
     */
    binPosition() {
      return this.mobile ? 'bottom: calc(-' + bbn.env.height + 'px + 5rem)' : 'top: 15rem';
    }
  },
  methods: {
    /**
     * Fires the action given to the item
     * @method onClick
     * @param {Object} it
     */
    onClick(it) {
      if (it.url) {
        bbn.fn.link(it.url);
      }
      if (it.action && bbn.fn.isFunction(it.action)) {
        it.action();
      }
      this.visibleFloater = false;
    },
    /**
     * The method called on the mouseover
     * @method mouseover
     * @param {Number} idx
     */
    mouseover(idx) {
      if (!bbn.fn.isMobile() && this.visibleText !== idx) {
        clearTimeout(this.timeout);
        this.visibleText = -1;
        this.timeout = setTimeout(() => {
          this.visibleText = idx;
        }, 500);
      }
    },
    /**
     * The method calledon the mouseout
     * @method mouseout
     */
    mouseout() {
      clearTimeout(this.timeout);
      this.visibleText = -1;
    },
    /**
     * The method called on the dragleave
     * @method dragleave
     */
    dragleave() {
      setTimeout(() => {
        this.overBin = false;
      }, 500);
    },
    /**
     * The method called on the dragstart
     * @method dragstart
     * @param {Number} idx
     * @param {Event} e
     */
    dragstart(idx, e) {
      if (this.removable) {
        this.draggedIdx = idx;
        this.visibleBin = true;
      } else {
        e.preventDefault();
      }
    },
    /**
     * The method called on the dragend
     * @method dragend
     */
    dragend() {
      if (this.removable) {
        this.visibleBin = false;
        this.draggedIdx = -1;
      }
    },
    /**
     * The method called on the drop
     * @method drop
     * @param {Event} e
     * @emits remove
     */
    drop(e) {
      if (this.items[this.draggedIdx]) {
        e.preventDefault();
        this.$emit('remove', this.items[this.draggedIdx].data, e);
      }
    },
    /**
     * Checks the measures of the main container and the icons container
     * @method checkMeasures
     * @fires getRef
     */
    checkMeasures() {
      let ct = this.getRef('container');
      if (ct && !this.mobile) {
        //this.showIcons = this.lastKnownWidth >= ct.offsetWidth;
      }
    },
    /**
     * Opens or closes the floater.
     * @method toggleFloater
     */
    toggleFloater() {
      if (!this.visibleFloater) {
        this.floaterTop = this.$el.getBoundingClientRect().height;
      }
      this.visibleFloater = !this.visibleFloater;
    },
    /**
     * The method called on scroll mounted
     * @fires checkMeasures
     */
    onScrollMounted() {
      this.$nextTick(() => {
        this.checkMeasures();
      });
    }
  },
  /**
   * @event mounted
   * @fires setResizeMeasures
   * @fires setContainerMeasures
   * @fires checkMeasures
   */
  mounted() {
    this.setResizeMeasures();
    this.setContainerMeasures();
    this.$nextTick(() => {
      this.ready = true;
      this.checkMeasures();
    });
  },
  watch: {
    /**
     * @watch source
     * @fires updateData
     */
    source() {
      this.updateData();
    },
    /**
     * @watch lastKnownWidth
     * @fires checkMeasures
     */
    lastKnownWidth(newVal) {
      this.checkMeasures();
    },
    /**
     * @watch items
     * @fires checkMeasures
     */
    items() {
      if (this.ready) {
        this.$nextTick(() => {
          this.checkMeasures();
        });
      }
    }
  }
};
import cpHtml from './fisheye.html';
import cpStyle from './fisheye.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./fisheye.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-fisheye',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-icon component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 */
import 'flag-icons/css/flag-icons.css';
const cpDef = {
  name: 'bbn-flag',
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    value: {
      type: String,
      required: true
    },
    width: {
      type: [Number, String]
    },
    height: {
      type: [Number, String]
    },
    square: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      dimensions: {
        xs: 16,
        s: 24,
        m: 32,
        l: 48,
        xl: 64,
        xxl: 128,
        xxxl: 256
      }
    };
  },
  computed: {
    currentFlag() {
      let code = this.value;
      if (code === 'en') {
        code = 'gb';
      }
      let st = 'flag-icon flag-icon-' + code;
      if (this.square) {
        st += ' flag-icon-squared';
      }
      return st;
    },
    currentWidth() {
      if (this.width) {
        if (bbn.fn.isNumber(this.width)) {
          return this.width + 'px';
        }
        if (this.dimensions[this.width]) {
          return this.dimensions[this.width] + 'px';
        }
        return this.width;
      }
      if (this.square && this.height) {
        return this.currentHeight;
      }
      if (this.height) {
        return 'auto';
      }
      return this.dimensions.m + 'px';
    },
    currentHeight() {
      if (this.height) {
        if (bbn.fn.isNumber(this.height)) {
          return this.height + 'px';
        }
        if (this.dimensions[this.height]) {
          return this.dimensions[this.height] + 'px';
        }
        return this.height;
      }
      if (this.square) {
        return this.currentWidth;
      }
      return 'auto';
    }
  }
};
import cpHtml from './flag.html';
import cpStyle from './flag.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./flag.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-flag',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-floater component
 *
 * @description bbn-floater is a component that represents a container that can be bound to another element.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
/**
 * Classic input with normalized appearance
 */
//bbn.vue.preloadBBN(['scroll', 'list', 'button']);
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.componentInside
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.keepCool
   * @mixin bbn.cp.mixins.toggle
   * @mixin bbn.cp.mixins.dimensions
   * @mixin bbn.cp.mixins.position
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.componentInside, bbn.cp.mixins.dimensions, bbn.cp.mixins.resizer, bbn.cp.mixins.keepCool, bbn.cp.mixins.toggle, bbn.cp.mixins.position],
  props: {
    /**
     * @prop {} container
     */
    container: {},
    /**
     * If an element is given this will force the position.
     * @prop {String} position
     */
    position: {
      type: String,
      validator: p => ['', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'top', 'bottom', 'left', 'right'].includes(p)
    },
    /**
     * The html content of the floater.
     * @prop {String} [''] content
     */
    content: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} css
     */
    css: {
      type: String
    },
    //@todo not used
    options: {
      type: Object
    },
    /**
     * The element used in the render of the floater.
     * @prop {Element} element
     */
    element: {
      type: HTMLElement
    },
    /**
     * If set to true the minimum width will be equal to the element width
     * @prop {Boolean} [true] elementWidth
     */
    elementWidth: {
      type: Boolean,
      default: true
    },
    /**
     * The floater's orientation.
     * @prop {String} ['vertical'] orientation
     */
    orientation: {
      type: String,
      default: 'vertical',
      validator: o => ['vertical', 'horizontal'].includes(o)
    },
    /**
     * Defines the ability of the floater to be scrollable.
     * @prop {Boolean}  [false] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * The axis where the scroll is applied ( 'x', 'y', 'both')
     * @prop {String} ['both'] axis
     */
    axis: {
      type: String,
      default: "both"
    },
    /**
     * Set to true to show the floater.
     * @prop {Boolean} [true] visible
     */
    visible: {
      type: Boolean,
      default: true
    },
    /**
     * The list selection mode.
     * Possible values: 'free', 'options', 'selection'.
     * @prop {String} ['free'] mode
     */
    mode: {
      type: String,
      default: "free",
      validator: m => ['free', 'options', 'selection'].includes(m)
    },
    /**
     * The hierarchical level, root is 0, and for each generation 1 is added to the level.
     * @prop {Number} [0] level
     */
    level: {
      type: Number,
      default: 0
    },
    /**
     * The component used for the items.
     * @prop {Object} itemComponent
     */
    itemComponent: {
      type: [Object, String, Function]
    },
    /**
     * Set to true to auto-hide the component.
     * @prop {(Number|Boolean)} [false] autoHide
     */
    autoHide: {
      type: [Number, Boolean],
      default: false
    },
    /**
     * The title of the floater's header.
     * @prop {(Boolean|String)} title
     */
    title: {
      type: [Boolean, String]
    },
    /**
     * The footer of the floater.
     * @prop {(Function|String|Object)} footer
     */
    footer: {
      type: [Function, String, Object]
    },
    /**
     * The buttons in the footer.
     * @prop {Array} [[]] buttons
     */
    buttons: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Set to true to show the icon that allows the closing of the floater.
     * @prop {Boolean} [false] closable
     */
    closable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to show the icon that allows the maximization of the window.
     * @prop {Boolean} [false] maximizable
     */
    maximizable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to open and close the window with opacity animation.
     * @prop {Boolean} [false] maximizable
     */
    animation: {
      type: Boolean,
      default: false
    },
    /**
     * The latency of the floater.
     * @prop {Number} [50] latency
     */
    latency: {
      type: Number,
      default: 50
    },
    /**
     * @prop {Function} onOpen
     */
    onOpen: {
      type: Function
    },
    /**
     * @prop {Function} onSelect
     */
    onSelect: {
      type: Function
    },
    /**
     * @prop {Function} beforeClose
     */
    beforeClose: {
      type: Function
    },
    /**
     * @prop {Function} onClose
     */
    onClose: {
      type: Function
    },
    /**
     * @prop {Function} afterClose
     */
    afterClose: {
      type: Function
    },
    /**
     * @prop {String} uid
     */
    uid: {
      type: String
    },
    /**
     * @prop {Boolean} [false] suggest
     */
    suggest: {
      type: [Boolean, Number],
      default: false
    },
    opener: {
      type: bbnCp
    },
    /**
     * Whatever will be given as arguments to the function action.
     */
    actionArguments: {
      type: Array
    },
    modal: {
      type: Boolean,
      default: false
    },
    pagerElement: {
      type: bbnCp
    },
    headerTitle: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true to make an arrow with position
     * @prop {Boolean} [false]
     */
    arrow: {
      type: Boolean,
      default: false
    },
    /*
      Tooltip offset from the icon
    */
    distance: {
      type: Number,
      default: 0
    },
    /**
     * Set to true to make the floater draggable
     * @prop {Boolean} [false] draggable
     */
    draggable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to make the floater resizable
     * @prop {Boolean} [false] resizable
     */
    resizable: {
      type: Boolean,
      default: false
    },
    /**
     * The distance on the given axis between the element and the floater
     * @prop {Number} [0] distanceX
     */
    distanceX: {
      type: Number,
      default: 0
    },
    /**
     * The distance on the given axis between the element and the floater
     * @prop {Number} [0] distanceY
     */
    distanceY: {
      type: Number,
      default: 0
    },
    /**
     * @prop {Boolean} [false] groupable
     */
    groupable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} ['group'] sourceGroup
     */
    sourceGroup: {
      type: String,
      default: 'group'
    },
    /**
     * @prop {(String|Object|bbnCp)} groupComponent
     */
    groupComponent: {
      type: [String, Object, bbnCp]
    },
    /**
     * @prop {String} groupStyle
     */
    groupStyle: {
      type: String
    },
    closeIcon: {
      type: String,
      default: 'nf nf-fa-times'
    },
    index: {
      type: Number
    },
    scrollHidden: {
      type: Boolean,
      default: false
    }
  },
  data() {
    let fns = [];
    if (this.onClose) {
      fns.push(this.onClose);
    }
    let opt = this.componentOptions || {};
    if (this.component && this.source && !bbn.fn.numProperties(opt)) {
      opt.source = this.source;
    }
    return {
      realComponentOptions: opt,
      /**
       * @data {Array} [[]] closingFunctions
       */
      closingFunctions: fns,
      /**
       * @data [null] currentTop
       */
      currentTop: null,
      /**
       * @data [null] currentLeft
       */
      currentLeft: null,
      /**
       * @data [null] currentHeight
       */
      realHeight: null,
      /**
       * @data [null] currentWidth
       */
      realWidth: null,
      /**
       * @data {Boolean} [false] currentScroll
       */
      scrollWidth: null,
      /**
       * @data {Boolean} [false] currentScroll
       */
      scrollHeight: null,
      /**
       * @data {Number} [0] currentWidth
       */
      containerWidth: 0,
      /**
       * @data {Number} [0] currentHeight
       */
      containerHeight: 0,
      /**
       * @data {Number} [0] opacity
       */
      opacity: 0,
      /**
       * @data {Number} [0] floaterHeight
       */
      floaterHeight: 0,
      /**
       * @data {Number} [0] floaterWidth
       */
      floaterWidth: 0,
      /**
       * @data {Boolean} [false] isMaximized
       */
      isMaximized: false,
      /**
       * @data {Number} [0] scrollMinWidth
       */
      scrollMinWidth: 0,
      /**
       * @data {Number} [0] outHeight
       */
      outHeight: 0,
      /**
       * @data {Boolean} [false] isOver
       */
      isOver: false,
      /**
       * @data {Number|Boolean} [false] mouseLeaveTimeout
       */
      mouseLeaveTimeout: false,
      /**
       * @data {Number|Boolean} [false] scrollResizeTimeout
       */
      scrollResizeTimeout: false,
      /**
       * @data {Boolean} [false] isResized Remains false until realWidth & realHeight are defined
       */
      isResized: false,
      /**
       * @data {Boolean} [false] isInit
       */
      currentButtons: this.buttons.slice(),
      isInit: false,
      definedWidth: null,
      definedHeight: null,
      resizerFn: null,
      scrollResized: false,
      /**
      * A list of form components contained in this container
      * @data {Array} [[]] forms
      */
      forms: []
    };
  },
  computed: {
    /**
     * @data {Array} [[]] currentButtons
     */
    shownButtons() {
      const res = [];
      bbn.fn.each(this.currentButtons, (b, i) => {
        const o = bbn.fn.createObject(b);
        o.class = ['bbn-no-radius', {
          'bbn-primary': b.preset === 'submit' || b.primary,
          'bbn-no-border-right': i === this.currentButtons.length - 1
        }, b.cls || ''];
        if (b.cls) {
          delete o.cls;
        }
        res.push(o);
      });
      return res;
    },
    /**
     * Normalizes the property 'left'.
     * @computed formattedLeft
     * @return {String}
     */
    formattedLeft() {
      return this.currentLeft !== null ? this.formatSize(this.currentLeft) : '0px';
    },
    /**
     * Normalizes the property 'top'.
     * @computed formattedTop
     * @return {String}
     */
    formattedTop() {
      return this.currentTop !== null ? this.formatSize(this.currentTop) : '0px';
    },
    /**
     * Normalizes the property 'width'.
     * @computed formattedWidth
     * @return {String}
     */
    formattedWidth() {
      return this.formatSize(this.width || (this.isResized ? this.realWidth : this.currentMaxWidth || '100%'));
    },
    /**
     * Normalizes the property 'height'.
     * @computed formattedHeight
     * @return {String}
     */
    formattedHeight() {
      return this.formatSize(this.height || (this.isResized ? this.realHeight : this.currentMaxHeight || '100%'));
    },
    /**
     * An object of css display properties to apply to the floater.
     *
     * @computed currentStyle
     * @return {Object}
     */
    currentStyle() {
      let s;
      if (this.isMaximized) {
        s = {
          top: 0,
          left: 0,
          width: '100%',
          height: '100%'
        };
      } else {
        s = {
          top: this.formattedTop,
          left: this.formattedLeft,
          width: this.formattedWidth,
          height: this.formattedHeight
        };
        if (this.currentMaxWidth) {
          bbn.fn.extend(s, {
            maxWidth: this.formatSize(this.currentMaxWidth),
            minWidth: this.formatSize(this.currentMinWidth),
            //maxHeight: this.formatSize(Math.min(this.currentMaxHeight, this.scrollMaxHeight - this.currentTop)),
            maxHeight: this.formatSize(this.currentMaxHeight),
            minHeight: this.formatSize(this.currentMinHeight)
          });
        }
      }
      s.visibility = this.isResized && this.isInit ? 'visible' : 'hidden';
      return s;
    },
    containerStyle() {
      return {
        width: '100%',
        height: '100%'
      };
    },
    HTMLStyle() {
      this.scrollWidth = Math.min(this.scrollWidth, this.currentMaxWidth);
      this.scrollHeight = Math.min(this.scrollHeight, this.scrollMaxHeight - this.currentTop);
      let s = {
        maxWidth: this.isMaximized ? '100%' : this.currentMaxWidth + 'px' || null,
        maxHeight: this.isMaximized ? '100%' : this.scrollMaxHeight - this.currentTop + 'px' || null
      };
      return s;
    },
    /**
     * True if there is some content in the component.
     *
     * @computed isVisible
     * @return {Boolean}
     */
    hasContent() {
      return !!(this.content || this.component || this.filteredData.length || this.$slots.default);
    },
    /**
     * True if the component is visible.
     *
     * @computed isVisible
     * @return {Boolean}
     */
    isVisible() {
      return this.currentVisible && this.hasContent;
    },
    /**
     * True if the orientation is 'horizontal'.
     * @computed isHorizontal
     * @return {Boolean}
     */
    isHorizontal() {
      if (!!this.position && !this.position.startsWith('top') && !this.position.startsWith('bottom')) {
        return this.position === 'left' || this.position === 'right';
      }
      return this.orientation === 'horizontal';
    },
    scrollMaxHeight() {
      return this.currentMaxHeight ? this.currentMaxHeight - this.outHeight : null;
    },
    hasDimensions() {
      return !!(this.width && this.height);
    },
    hasButtons() {
      return this.currentButtons.length > 0;
    },
    anonymousComponent() {
      return this.$refs.component;
    }
  },
  methods: {
    init() {
      if (!this.ready) {
        this.ready = true;
        this.onResize(true);
        this._setMinMax();
        this.$forceUpdate().then(() => {
          if (!this.scrollable || this.definedHeight) {
            this.resizeAfterScroll();
          } else if (this.content) {
            const sc = this.getRef('scroll');
            if (sc) {
              sc.initSize();
              this.$nextTick(() => {
                this.resizeAfterScroll();
              });
            }
          }
        });
      }
    },
    /**
     * Setting up min/max width/height based on environment and properties
     */
    _setMinMax() {
      // Absolute defaults
      let minWidth = [0];
      let minHeight = [0];
      let maxWidth = [bbn.env.width];
      let maxHeight = [bbn.env.height];

      // Min properties
      let tmp = this.getDimensions(this.minWidth, this.minHeight);
      if (tmp.width) {
        minWidth.push(tmp.width);
      }
      if (tmp.height) {
        minHeight.push(tmp.height);
      }

      // Min based on element - can't be smaller than the element
      if (this.element && this.elementWidth) {
        tmp = this.element.getBoundingClientRect();
        if (tmp.width) {
          if (!this.maxWidth || this.maxWidth > tmp.width) {
            minWidth.push(tmp.width);
          }
        }
      }

      // Max properties
      tmp = this.getDimensions(this.maxWidth, this.maxHeight);
      if (tmp.width) {
        maxWidth.push(tmp.width);
      }
      if (tmp.height) {
        maxHeight.push(tmp.height);
      }

      // Max based on container - can't be bigger if container is specified
      let coord = {};
      if (this.container) {
        coord = (bbn.fn.isDom(this.container) ? this.container : this.$el.offsetParent).getBoundingClientRect();
        if (coord.width) {
          maxWidth.push(Math.round(coord.width));
        }
        if (coord.height) {
          maxHeight.push(Math.round(coord.height));
        }
      }

      // Setting container dimensions vars
      this.containerWidth = coord.width || bbn.env.width;
      this.containerHeight = coord.height || bbn.env.height;

      // Depends on an element (dropdown, context) and will position by it
      if (this.element) {
        let coord = this.element.getBoundingClientRect();
        if (this.isHorizontal) {
          maxHeight.push(Math.max(coord.y + coord.height, bbn.env.height - coord.y));
        } else {
          maxHeight.push(Math.max(coord.y, bbn.env.height - coord.y - coord.height));
        }
      }
      if (this.left !== undefined) {
        maxWidth.push(Math.max(this.left, bbn.env.width - this.left));
      }
      if (this.right !== undefined) {
        maxWidth.push(Math.max(this.right, bbn.env.width - this.right));
      }
      if (this.top !== undefined) {
        maxHeight.push(Math.max(this.top, bbn.env.height - this.top));
      }
      if (this.bottom !== undefined) {
        maxHeight.push(Math.max(this.bottom, bbn.env.height - this.bottom));
      }
      let outHeight = 0;
      if (this.title) {
        let header = this.getRef('header');
        if (header) {
          outHeight += header.offsetHeight;
        }
      }
      if (this.footer) {
        let footer = this.getRef('footer');
        if (footer) {
          outHeight += footer.offsetHeight;
        }
      } else if (this.currentButtons) {
        let footer = this.getRef('buttons');
        if (footer) {
          outHeight += footer.offsetHeight;
        }
      }
      if (outHeight !== this.outHeight) {
        this.outHeight = outHeight;
      }
      tmp = false;
      this.currentMinWidth = Math.max(...minWidth);
      this.currentMinHeight = Math.max(...minHeight);
      this.currentMaxHeight = Math.min(...maxHeight);
      this.currentMaxWidth = Math.min(...maxWidth);
      if (maxHeight < minHeight || maxHeight < minHeight) {
        throw new Error(bbn._("Wrong min/max width/height set in the properties"));
      }
      if (this.width || this.height) {
        tmp = this.getDimensions(this.width, this.height);
        if (tmp) {
          if (tmp.width && tmp.width > this.currentMaxWidth) {
            tmp.width = this.currentMaxWidth;
          }
          if (tmp.width && this.currentMaxWidth >= tmp.width && this.currentMinHeight <= tmp.width) {
            this.definedWidth = tmp.width;
          } else if (this.definedWidth) {
            this.definedWidth = null;
          }
          if (tmp.height && tmp.height > this.currentMaxHeight) {
            tmp.height = this.currentMaxHeight;
          }
          if (tmp.height && this.currentMaxHeight >= tmp.height && this.currentMinHeight <= tmp.height) {
            this.definedHeight = tmp.height;
          } else if (this.definedHeight) {
            this.definedHeight = null;
          }
        }
      }
    },
    /**
     * Defines the position of the floater.
     * @method _getCoordinates
     * @return {Object}
     */
    _getCoordinates() {
      if (this.element) {
        let coor = this.element.getBoundingClientRect();
        return {
          top: this.isHorizontal ? coor.top : coor.bottom - 1,
          bottom: this.currentMaxHeight - (this.isHorizontal ? coor.bottom : coor.top + 1),
          left: this.isHorizontal ? coor.right - 1 : coor.left,
          right: this.currentMaxWidth - (this.isHorizontal ? coor.left + 1 : coor.right)
        };
      } else {
        return {
          top: bbn.fn.isNumber(this.top) ? this.top : null,
          right: bbn.fn.isNumber(this.right) ? this.right : null,
          bottom: bbn.fn.isNumber(this.bottom) ? this.bottom : null,
          left: bbn.fn.isNumber(this.left) ? this.left : null
        };
      }
    },
    onResize(force) {
      let res = bbn.cp.mixins.resizer.methods.onResize.apply(this);
      if (this.isVisible && this.$el && (res || force)) {
        //bbn.fn.log("NORMAL RESIZE", this.lastKnownCtHeight, this.lastKnownCtWidth);

        //return this.realResize();
      }
    },
    fullResize() {
      this.isResized = false;
      this.realResize();
    },
    realResize() {
      return this.onResize(true);
    },
    /**
     * Handles the resize of the component.
     * @method onResize
     * @param {Boolean} force
     * @fires _getCoordinates
     * @fires init
     * @fires getRef
     * @fires keepCool
     * @fires setResizeMeasures
     */
    resizeAfterScroll() {
      //bbn.fn.log("RESIZEAFTERSCROLL");
      let go = this.isVisible && bbn.fn.isDom(this.$el) && (!this.isInit || this.isActiveResizer() && !this.isResized);
      if (go) {
        this._setMinMax();
      }
      return new Promise(resolve => {
        // Should be triggered by the inner scroll once mounted
        if (go) {
          if (this.definedWidth && this.definedHeight && this.definedWidth >= this.currentMinWidth && this.definedWidth <= this.currentMaxWidth && this.definedHeight >= this.currentMinHeight && this.definedHeight <= this.currentMaxHeight) {
            if (this.realWidth !== this.definedWidth || this.realHeight !== this.definedHeight) {
              this.currentWidth = this.definedWidth;
              this.realWidth = this.definedWidth;
              this.currentHeight = this.definedHeight;
              this.realHeight = this.definedHeight;
              this.updatePosition();
              resolve(1);
              return;
            }
            resolve(0);
            return;
          } else {
            let scroll = this.getRef('scroll');
            if (!scroll || !scroll.naturalWidth) {
              // We do nothing and wait that the scroll does the resize
              resolve(0);
              return;
            }
            //bbn.fn.warning("FLOATER RESIZE");
            let naturalWidth = scroll.naturalWidth;
            let naturalHeight = scroll.naturalHeight;
            let w = scroll.$el.clientWidth;
            let h = scroll.$el.clientHeight;
            //bbn.fn.log("NATURAL", naturalHeight, naturalWidth);
            let dimensions = {
              w: naturalWidth,
              h: naturalHeight
            };
            let scrollChange = false;
            if (this.scrollWidth !== dimensions.w) {
              scrollChange = true;
              this.scrollWidth = dimensions.w;
            }
            if (this.scrollHeight !== dimensions.h) {
              scrollChange = true;
              this.scrollHeight = dimensions.h;
            }
            let currentHeight = this.definedHeight || 0;
            let currentWidth = this.definedWidth || 0;
            if (!currentHeight) {
              currentHeight = this.scrollHeight + this.outHeight;
            }
            if (currentHeight > this.currentMaxHeight) {
              currentHeight = this.currentMaxHeight;
            }
            if (!currentWidth) {
              currentWidth = this.scrollWidth;
            }
            if (currentWidth > this.currentMaxWidth) {
              currentWidth = this.currentMaxWidth;
            }
            if (currentHeight < this.currentMinHeight) {
              currentHeight = this.currentMinHeight;
            }
            if (currentWidth < this.currentMinWidth) {
              currentWidth = this.currentMinWidth;
            }
            let isChanged = 0;
            if (!this.realWidth || Math.abs(this.realWidth - currentWidth) > 2) {
              isChanged = 1;
              this.realWidth = currentWidth;
            }
            if (!this.realHeight || Math.abs(this.realHeight - currentHeight) > 2) {
              isChanged = 1;
              this.realHeight = currentHeight;
            }
            resolve(isChanged);
          }
        } else {
          resolve(0);
          return;
        }
      }).then(r => {
        if (!this.isResized) {
          this.isResized = true;
        }
        if (r) {
          let wasInit = this.isInit;
          if (!this.isInit) {
            this.isInit = true;
          }
          this.isResizing = false;
          this.setResizeMeasures();
          this.updatePosition();
          //bbn.fn.log("AFTER PROMISE ++++++++++++++", this.isResized)

          this.$emit('resize');
          if (!wasInit) {
            if (this.onOpen) {
              this.onOpen(this);
            }
            this.$emit('open', this);
          }
        } else if (go && this.isInit) {
          //this.updatePosition();
          this.isResizing = false;
        }
      });
    },
    /**
     * Handles the resize of the scroller.
     * @method scrollResize
     * @fires onResize
     * @fires updateComponents
     */
    scrollResize(e, dimensions) {
      if (!this.scrollResized) {
        this.scrollResized = true;
      }
      e.preventDefault();
    },
    /**
     * Returns an object of numbers as width and height based on whatever unit given.
     *
     * @method getDimensions
     * @param {Number} width
     * @param {Number} height
     * @return {Object}
     */
    getDimensions(width, height) {
      if (bbn.fn.isNumber(width, height) && height && width) {
        return {
          width: parseInt(width),
          height: parseInt(height)
        };
      }
      let r = {
        width: 0,
        height: 0
      };
      let parent = this.container || this.$root.$el;
      if (parent && (width || height)) {
        if (!parent.insertAdjacentElement) {
          throw new Error("Impossible to insert adjacent element to calculate dimensions");
        }
        let el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.visibility = 'hidden';
        el.className = 'bbn-reset';
        el.style.width = this.formatSize(width);
        el.style.height = this.formatSize(height);
        //bbn.fn.log("getDimensions", width, height)
        try {
          parent.insertAdjacentElement('beforeend', el);
          r = {
            width: el.offsetWidth || el.clientWidth || null,
            height: el.offsetHeight || el.clientHeight || null
          };
        } catch (e) {
          bbn.fn.log("ERROR", e, this.$el);
        }
        el.remove();
      }
      return r;
    },
    /**
     * @method updatePosition
     * @fires onResize
     */
    updatePosition() {
      let r = {
        x: {
          camel: 'Width',
          posStart: 'left',
          posEnd: 'right',
          ideal: this.isHorizontal ? 'right' : 'left',
          nideal: this.isHorizontal ? 'left' : 'right',
          res: null
        },
        y: {
          camel: 'Height',
          posStart: 'top',
          posEnd: 'bottom',
          ideal: this.isHorizontal ? 'top' : 'bottom',
          nideal: this.isHorizontal ? 'bottom' : 'top',
          res: null
        }
      };
      let coor = this.element ? JSON.parse(JSON.stringify(this.element.getBoundingClientRect())) : {
        top: bbn.fn.isNumber(this.top) ? this.top : null,
        right: bbn.fn.isNumber(this.right) ? this.right : null,
        bottom: bbn.fn.isNumber(this.bottom) ? this.bottom : null,
        left: bbn.fn.isNumber(this.left) ? this.left : null
      };
      let ok = true;
      bbn.fn.iterate(r, (a, ax) => {
        let scroll = false;
        let size = this['real' + a.camel];
        if (!size) {
          ok = false;
          return false;
        }
        let min = 0;
        if (this.element) {
          // Fixed position
          if (!!this.position) {
            let isTop = this.position.startsWith('top') || this.position === 'left' || this.position === 'right',
              isLeft = this.position.endsWith('Left') || this.position === 'left' || this.position === 'top' || this.position === 'bottom',
              inverted = 0;
            if (ax === 'x') {
              if (isLeft) {
                a.res = this.isHorizontal ? coor.left - size : coor.left;
                if (a.res + size > this['container' + a.camel]) {
                  inverted = this.isHorizontal ? coor.right : coor.right - size;
                }
              } else {
                a.res = this.isHorizontal ? coor.right : coor.right - size;
                if (a.res + size > this['container' + a.camel]) {
                  inverted = this.isHorizontal ? coor.left - size : coor.left;
                }
              }
            } else {
              if (isTop) {
                a.res = this.isHorizontal ? coor.top : coor.top - size;
                if (a.res + size > this['container' + a.camel]) {
                  inverted = this.isHorizontal ? coor.bottom - size : coor.bottom;
                }
              } else {
                a.res = this.isHorizontal ? coor.bottom - size : coor.bottom;
                if (a.res + size > this['container' + a.camel]) {
                  inverted = this.isHorizontal ? coor.top : coor.top - size;
                }
              }
            }
            if (!!inverted) {
              if (inverted + size < this['container' + a.camel]) {
                a.res = inverted;
              } else {
                a.res = 0;
                size = this['container' + a.camel];
              }
            }
          }
          // If the floater is horizontal, it will ideally start at the
          // top right of the element to open downwards
          // otherwise at the bottom left
          // if the floater cannot be put after the element
          else if (coor[a.ideal] + size > this['container' + a.camel]) {
            let spaceAfter = this['container' + a.camel] - coor[a.ideal];
            let spaceBefore = coor[a.nideal];
            // Checking which of before or after is bigger
            let isBeforeBigger = spaceBefore > spaceAfter;
            if (isBeforeBigger) {
              if (spaceBefore <= size) {
                a.res = 0;
                size = spaceBefore;
              } else {
                a.res = coor[a.nideal] - size;
              }
            } else {
              a.res = coor[a.ideal];
              size = spaceAfter;
            }
          } else {
            a.res = coor[a.ideal];
          }
        } else {
          if (coor[a.posStart] !== null || coor[a.posEnd] !== null) {
            a.res = coor[a.posStart] !== null ? coor[a.posStart] : this['container' + a.camel] - coor[a.posEnd] - size;
          } else {
            // If no vertical position at all, centered (same top and bottom)
            coor[a.posStart] = Math.floor((this['container' + a.camel] - size) / 2) + (this['container' + a.camel] - size) % 2;
            if (coor[a.posStart] < 0) {
              coor[a.posStart] = 0;
            }
            if (coor[a.posStart] + size > this['container' + a.camel]) {
              if (this[a.posStart] === undefined) {
                coor[a.posStart] = this['container' + a.camel] - size;
              }
              scroll = true;
            } else if (coor[a.posEnd] + size > this['container' + a.camel]) {
              if (this[a.posEnd] !== undefined) {
                coor[a.posEnd] = this['container' + a.camel] - size;
              }
              scroll = true;
            }
            if (a.res === null) {
              if (coor[a.posStart] !== undefined) {
                a.res = coor[a.posStart];
              } else if (scroll) {
                a.res = 0;
              } else {
                a.res = this['container' + a.camel] - (coor[a.posEnd] || 0) - size;
              }
            }
            a.res = a.res ? a.res + min : min;
            if (a.res < 0) {
              a.res = 0;
            }
          }
        }
        if (size !== this['real' + a.camel]) {
          this['real' + a.camel] = size;
        }
      });
      if (ok && r.x.res !== null && r.y.res !== null) {
        // calculate offset for tooltip position
        let offset = 0;
        if (this.position == 'left') {
          offset = -this.distance;
        }
        if (this.position == 'right') {
          offset = this.distance;
        }
        this.currentLeft = Math.ceil(r.x.res + offset);
        let topPositions = ['topLeft', 'topRight', 'top'];
        let bottomPositions = ['bottomLeft', 'bottomRight', 'bottom'];
        offset = 0;
        if (topPositions.indexOf(this.position) !== -1) {
          offset = -this.distance;
        }
        if (bottomPositions.indexOf(this.position) !== -1) {
          offset = this.distance;
        }
        this.currentTop = Math.ceil(r.y.res + offset);
      }
    },
    /**
     * @method addClose
     */
    addClose(fn) {
      for (let i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === 'function') {
          this.closingFunctions.push(arguments[i]);
        }
      }
    },
    /**
     * @method removeClose
     */
    removeClose(fn) {
      if (!fn) {
        this.closingFunctions = [];
      } else {
        this.closingFunctions = bbn.fn.filter(this.closingFunctions, f => {
          return fn !== f;
        });
      }
    },
    //@todo not used
    pressKey(e) {
      switch (e.key) {
        case "Enter":
        case "Space":
          this.select(this.currentIndex);
          break;
        case "Escape":
        case "ArrowLeft":
          if (this.closable) {
            this.$emit('close');
          }
          break;
        case "ArrowDown":
          if (this.items.length) {
            if (this.currentIndex > this.items.length - 2) {
              this.currentIndex = 0;
            } else {
              this.currentIndex++;
            }
          }
          break;
        case "ArrowUp":
          if (this.items.length) {
            if (this.currentIndex > 0) {
              this.currentIndex--;
            } else {
              this.currentIndex = this.items.length - 1;
            }
          }
          break;
      }
    },
    onFloaterLeave() {
      //bbn.fn.log("ON FLOATER LEAVE")
      this.isOver = false;
    },
    /**
     * Closes the floater by hiding it.
     * @method close
     * @param {Boolean} force
     * @param {Boolean} confirm
     * @emit beforeClose
     * @emit close
     * @fires beforeClose
     * @fires hide
     * @fires afterClose
     */
    close(force) {
      var _this$$parent;
      let confirm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (force !== true) {
        if (!this.closable && !this.autoHide && !force) {
          return;
        }
        if (bbn.fn.isFunction(this.beforeClose)) {
          if (this.beforeClose(this) === false) {
            return;
          }
        } else {
          let beforeCloseEvent = new Event('beforeClose', {
            cancelable: true
          });
          this.$emit('beforeClose', beforeCloseEvent, this);
          if (beforeCloseEvent.defaultPrevented) {
            return;
          }
        }
        if (this.closingFunctions) {
          for (let i = 0; i < this.closingFunctions.length; i++) {
            if (this.closingFunctions[i](this) === false) {
              return;
            }
          }
        }
      }
      let popup = ((_this$$parent = this.$parent) === null || _this$$parent === void 0 || (_this$$parent = _this$$parent.bbnSchema) === null || _this$$parent === void 0 ? void 0 : _this$$parent.tag) === 'bbn-popup' ? this.$parent : null;
      if (this.forms.length && !confirm) {
        //bbn.fn.log("The form should have closed the floater");
        this.forms[0].closePopup(force);
      } else if (popup && this.uid) {
        //bbn.fn.log("The popup should have closed the floater");
        let idx = popup.getIndexByUID(this.uid);
        popup.close(idx, true);
      } else {
        //bbn.fn.log("The floater should have closed itself");
        this.hide();
        this.$emit('close');
      }
    },
    /**
     * Closes all levels.
     * @method closeAll
     * @fires ancestors
     */
    closeAll() {
      if (this.level) {
        let ancestors = this.ancestors('bbn-floater');
        for (let i = this.level; i >= 0; i--) {
          if (ancestors[i]) {
            //bbn.fn.log(ancestors, i, ancestors[i]);
            ancestors[i].close(true);
          }
        }
      }
      this.close(true);
    },
    /**
     * Handles the selection of the floater's items.
     * @method select
     * @param {Object} item
     * @param {Number} idx
     * @param dataIndex
     * @fires closeAll
     * @emits select
     */
    select(item, idx, dataIndex, ev) {
      if (item && !item.disabled && !item[this.children]) {
        if (!ev) {
          let ev = new Event('select', {
            cancelable: true
          });
        }
        if (this.onSelect) {
          this.onSelect(item, idx, dataIndex, ev, this);
        } else {
          this.$emit("select", item, idx, dataIndex, ev, this);
        }
        if (ev.defaultPrevented) {
          return;
        }
        if (this.mode !== 'options') {
          this.closeAll();
        }
        if (this.mode === 'options') {
          item.selected = !item.selected;
        } else if (this.mode === 'selection' && !item.selected) {
          let prev = bbn.fn.search(this.filteredData, "selected", true);
          if (prev > -1) {
            this.filteredData[prev].selected = false;
          }
          item.selected = true;
        }
        /*
        @todo bbn-list does it already
        if (item.action) {
          if (typeof (item.action) === 'string') {
            bbn.fn.log("CLICK IS STRING", this);
          }
          else if (bbn.fn.isFunction(item.action)) {
            //bbn.fn.log("CLICK IS FUNCTION", item.action, this);
            item.action(idx, item);
          }
        }
        */
      }
    },

    /**
     * @method updateData
     * @return {Promise}
     */
    updateData() {
      if (this.source === undefined) {
        return this.$nextTick();
      }
      return bbn.cp.mixins.list.methods.updateData.apply(this);
    }
  },
  /**
   * @event created
   */
  created() {
    this.componentClass.push('bbn-resize-emitter');
  },
  /**
   * @event mounted
   * @fires ancestors
   * @fires closeAll
   */
  mounted() {
    if (this.isVisible) {
      this.init();
    }

    /* Useful ?
    let ancestors = this.ancestors('bbn-floater');
    if (this.element) {
      let ct = ancestors.length ? ancestors[ancestors.length-1] : this;
      let scroll = ct.closest('bbn-scroll');
      if (scroll) {
        scroll.$once('scroll', () => {
          this.close();
        });
        this.realResize();
      }
    }
    */
  },

  beforeDestroy() {
    if (this.onClose) {
      this.onClose(this);
    }
  },
  updated() {
    /*
    let d = this.oldData;
    this.oldData = JSON.parse(JSON.stringify(this.$data));
    if (d) {
      bbn.fn.log(bbn.fn.diffObj(d, this.oldData));
    }
    */
  },
  watch: {
    /*
    lastKnownCtWidth() {
      if (this.ready && !this.isResizing) {
        this.keepCool(() => {
          bbn.fn.log("ON CHANGE CT WIDTH");
          this._setMinMax();
          this.onResize();
          this.updatePosition();
        }, 'changeDimension', 20)
      }
    },
    lastKnownCtHeight() {
      if (this.ready && !this.isResizing) {
        this.keepCool(() => {
          bbn.fn.log("ON CHANGE CT HEIGHT");
          this._setMinMax();
          this.onResize();
          this.updatePosition();
        }, 'changeDimension', 20)
      }
    },
    /**
     * @watch left
     * @fires updatePosition
     */
    left() {
      this.updatePosition();
    },
    /**
     * @watch right
     * @fires updatePosition
     */
    right() {
      this.updatePosition();
    },
    /**
     * @watch top
     * @fires updatePosition
     */
    top() {
      this.updatePosition();
    },
    /**
     * @watch bottom
     * @fires updatePosition
     */
    bottom() {
      this.updatePosition();
    },
    /**
     * @watch source
     * @fires updateData
     * @todo This can trigger a bug if source is an object at the moment of the destruction
     *
    source: {
      deep: true,
      handler() {
        if ( this.currentData.length ){
          //this.updateData();
        }
      }
    },
    */
    /**
     * @watch filteredData
     * @fires getRef
     * @fires onResize
     */
    /*
    filteredData() {
      if (this.ready) {
        this.$nextTick(() => {
          let sc = this.getRef('scroll');
          if (sc) {
            sc.initSize();
          }
          this.$nextTick(() => {
            //bbn.fn.log("CHANGE FILTERED DATA");
            this.onResize();
          });
        });
      }
    },
    */
    /**
     * @watch visible
     * @fires onResize
     */
    visible(v) {
      this.currentVisible = v;
      //bbn.fn.log("CHANGING VISIBle")
    },

    isVisible(v) {
      //bbn.fn.log("CHANGING VISIBILITY")
      if (v) {
        if (!this.ready) {
          this.init();
        } else {
          this.onResize();
        }
        if (this.onOpen) {
          this.onOpen(this);
        }
        this.$emit('open', this);
      } else if (this.onClose) {
        this.onClose(this);
      }
    },
    /**
     * @watch element
     * @param {Element} newVal
     * @fires onResize
     */
    element(newVal) {
      if (newVal && this.ready) {
        this.currentVisible = false;
        this.$forceUpdate();
        this.$nextTick(() => {
          this.currentVisible = true;
        });
      }
    },
    /**
     * @watch isOver
     */
    isOver(v) {
      this.$emit(v ? 'over' : 'out');
      if (this.autoHide && this.isResized && this.ready && !this.isResizing) {
        if (v && this.mouseLeaveTimeout) {
          clearTimeout(this.mouseLeaveTimeout);
        } else if (!v) {
          this.mouseLeaveTimeout = setTimeout(() => {
            let ev = new Event('before-hide', {
              cancelable: true
            });
            this.$emit('before-hide', ev);
            if (!ev.defaultPrevented && !this.isOver) {
              this.close();
            }
            this.mouseLeaveTimeout = false;
          }, bbn.fn.isNumber(this.autoHide) ? this.autoHide : 1500);
        }
      }
    },
    hasButtons() {
      this.lastKnownCtWidth = 0;
      this.lastKnownCtHeight = 0;
      this.realResize();
    },
    filteredData: {
      deep: true,
      handler() {
        this.realResize();
      }
    },
    filteredTotal() {
      if (this.isVisible) {
        //this.onResize(true);
      }
    }
  }
};
import cpHtml from './floater.html';
import cpStyle from './floater.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./floater.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-floater',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-form component
 *
 * @description bbn-form is a component that allows you to quickly generate and process web forms.
 * 
 * Validation and custom control can be defined before data is sent to the back-end system.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  props: {
    /**
     * @prop {Boolean} autofocus
     */
    autofocus: {
      type: Boolean,
      default() {
        return !bbn.fn.isMobile();
      }
    },
    /**
     *@tood not used
     * @ {Boolean} [false] autocomplete
     */
    autocomplete: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to enable the form's buttons without changing the form's content.
     *
     * @prop {Boolean} [false] prefilled
     */
    prefilled: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to disable the form.
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * The list of fields the form must contain.
     * @prop {} script
     */
    script: {},
    /**
     * The list of fields the form must contain.
     * @prop {} fields
     */
    fields: {},
    /**
     * Set to true to make a postOut instead of a post when the form is submitted.
     *
     * @prop {Boolean} [false] blank
     */
    blank: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to give the attribute target the value '_self'.
     * @prop {Boolean} [false] self
     */
    self: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} target
     */
    target: {
      type: String
    },
    /**
     * A confirmation popup with a costumized message shown before the form is submitted.
     *
     * @prop {String|Function} confirmMessage
     */
    confirmMessage: {
      type: [String, Function]
    },
    /**
     * A confirmation popup with a costumized message shown before leaving the form.
     *
     * @prop {String|Function} confirmLeave
     */
    confirmLeave: {
      type: [Boolean, String, Function],
      default: bbn._("Are you sure you want to discard the changes you made in this form?")
    },
    /**
     * The url contacted when submitting the form.
     *
     * @prop {String} action
     */
    action: {
      type: String
    },
    /**
     * A method called after a form is correctly submitted.
     *
     * @prop {Function} success
     */
    success: {
      type: Function
    },
    /**
     * A method called after a form submission fails.
     *
     * @prop {Function} failure
     */
    failure: {
      type: Function
    },
    /**
     * A popup with a costumized message shown after a form is correctly submitted.
     *
     * @prop {String|Function} successMessage
     */
    successMessage: {
      type: [String, Function]
    },
    /**
     * A popup with a costumized message shown after a form submission fails.
     *
     * @prop {String|Function} failureMessage
     */
    failureMessage: {
      type: [String, Function]
    },
    /**
     * The form's method of submission.
     *
     * @prop {String} [post] method
     */
    method: {
      type: String,
      default: 'post'
    },
    /**
     * Set to true to enable form scrolling.
     *
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to keep the scrollbars visible
     *
     * @prop {Boolean} [false] keepScrollVisible
     */
    keepScrollVisible: {
      type: Boolean,
      default: false
    },
    /**
     * The buttons shown on the form.
     *
     * @prop {Boolean|Array} ['cancel', 'submit'] buttons
     */
    buttons: {
      type: [Boolean, Array],
      default() {
        return ['cancel', 'submit'];
      }
    },
    /**
     * The form's text on submit button.
     *
     * @prop {String} [Submit] submitText
     */
    submitText: {
      type: String,
      default: bbn._('Submit')
    },
    /**
     * The form's text on cancel button.
     *
     * @prop {String} [Cancel] cancelText
     */
    cancelText: {
      type: String,
      default: bbn._('Cancel')
    },
    /**
     * The form's text on reset button.
     *
     * @prop {String} [Reset] resetText
     */
    resetText: {
      type: String,
      default: bbn._('Reset')
    },
    /**
     * The proper data used in the form.
     *
     * @prop {Object} source
     */
    // This is the proper data used in the form
    source: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * The additional data to be sent by the form.
     *
     * @prop {Object} data
     */
    // This is additional data to be sent by the form
    data: {
      type: Object
    },
    /**
     * Set to true to fix the form's footer.
     *
     * @prop {Boolean} [true] fixedFooter
     */
    fixedFooter: {
      type: Boolean,
      default: false
    },
    /**
     * The form's schema generating the inputs.
     *
     * @prop {Array} [[]] schema
     */
    // That will be a form schema generating the inputs
    schema: {
      type: Array,
      default: function () {
        return [];
      }
    },
    // Sets if it is the data property which must be sent, or the content of the named fields
    // (in this case names are not necessary on form inputs)
    /**
     * Set to true if the data property must be sent.
     *
     * @prop {Boolean} [true] sendModel
     */
    sendModel: {
      type: Boolean,
      default: true
    },
    /**
     * Checks the fields' data before submitting the form.
     *
     * @prop {Function} validation
     */
    validation: {
      type: Function
    },
    /**
     * If true, will consider itself as a unique element of a floater and will have its buttons incorporated in it 
     * whereas if undefined will.
     *
     * @prop {Boolean|String} windowed
     */
    windowed: {
      type: [Boolean, String],
      default: 'auto'
    },
    /**
     * If true, will use the class bbn-overlay for its container.
     *
     * @prop {Boolean} fullSize
     */
    fullSize: {
      type: Boolean,
      default: false
    },
    /**
     * If true and inside a popup the popup will close after submit
     *
     * @prop {Boolean} closeAfter
     */
    closeAfter: {
      type: Boolean,
      default: true
    },
    /**
     * @prop String mode Mode for buttons: normal or big
     */
    mode: {
      type: String
    }
  },
  data() {
    let currentSchema = [];
    this.schema.map(a => {
      currentSchema.push(bbn.fn.extend({}, a, {
        id: a.id ? a.id : bbn.fn.randomString(20, 30)
      }));
    });
    return {
      /**
       * True if the form has been modified.
       * @data {Boolean} [false] dirty
       */
      dirty: false,
      /**
       * True if the form has been modified.
       * @data {Boolean} [false] popup
       */
      popupIndex: false,
      tab: false,
      originalData: bbn.fn.clone(this.source),
      isPosted: false,
      isLoading: false,
      currentSchema: currentSchema,
      currentMode: this.mode ? this.mode : this.closest('bbn-floater') ? 'big' : 'normal',
      _isSetting: false,
      window: null,
      isInit: false,
      canSubmit: false,
      sourceTimeout: 0,
      isClosing: false
    };
  },
  computed: {
    /**
     * Returns an array containing the form's buttons.
     *
     * @computed realButtons
     * @return {Array}
     */
    realButtons() {
      let r = [];
      if (this.buttons) {
        bbn.fn.each(this.buttons, a => {
          let t = typeof a;
          let obj;
          if (t === 'string') {
            switch (a) {
              case 'cancel':
                obj = {
                  preset: 'cancel',
                  text: this.cancelText,
                  icon: 'nf nf-fa-times_circle',
                  action: () => {
                    this.cancel();
                  },
                  disabled: !this.canCancel
                };
                break;
              case 'reset':
                obj = {
                  preset: 'reset',
                  text: this.resetText,
                  icon: 'nf nf-fa-refresh',
                  action: () => {
                    this.reset();
                  },
                  disabled: !this.dirty && !this.prefilled
                };
                break;
              case 'submit':
                obj = {
                  preset: 'submit',
                  text: this.submitText,
                  icon: 'nf nf-fa-check_circle',
                  action: () => {
                    this.submit();
                  },
                  disabled: !this.canSubmit
                };
                break;
            }
          } else if (t === 'object') {
            if (typeof a.action === 'string' && bbn.fn.isFunction(this[a.action])) {
              a.action = this[a.action];
            }
            obj = a;
          }
          if (obj) {
            if (this.isLoading) {
              obj.disabled = true;
            }
            r.push(obj);
          }
        });
      }
      return r;
    },
    /**
     * Returns true if the form has a footer.
     *
     * @computed hasFooter
     * @return {Boolean}
     */
    hasFooter() {
      return this.$slots.footer && this.$slots.footer.length;
    },
    canCancel() {
      return this.window || this.isModified();
    },
    /**
     * Based on the properties 'fixedFooter' and 'fullScreen', a string is returned containing the classes for the form's template.
     *
     * @computed currentClass
     * @return {String}
     */
    currentClass() {
      let st = this.componentClass.join(' ');
      if (this.isInit) {
        if (!this.window && (this.hasFooter || this.realButtons.length || this.footer) && (this.scrollable || this.fullSize)) {
          st += ' bbn-flex-height';
        }
        if (this.scrollable || this.fullSize) {
          st += ' bbn-overlay';
        }
      }
      return st;
    },
    currentStyle() {
      return {};
      if (!this.isInit) {
        return {};
      }
      let floater = this.closest('bbn-floater');
      let ct = this.getRef('container');
      let ctn = ct ? ct.getRef('scrollContent') : false;
      if (floater && ct) {
        let width = this.scrollable && ctn ? ctn.clientWidth : ct.clientWidth;
        let height = this.scrollable && ctn ? ctn.clientHeight : ct.clientHeight;
        let ctWidth = floater.getContainerWidth();
        let ctHeight = floater.getContainerHeight() - (floater.getRef('header').clientHeight || 0);
        if (width > ctWidth) {
          width = ctWidth;
        }
        if (height > ctHeight) {
          height = ctHeight;
        }
        return {
          width: width + 'px',
          height: height + 'px'
        };
      }
    }
  },
  methods: {
    /**
     * Returns true if the form can be submitted.
     *
     * @method _canSubmit
     * @return {Boolean}
     */
    _canSubmit() {
      return (this.prefilled || this.isModified()) && !this.disabled;
    },
    /**
     * Defines the form behavior when submitted.
     *
     * @method _post
     * @fires getPopup
     * @emit failure
     * @emit success
     */
    _post() {
      this.isPosted = true;
      this.isLoading = true;
      if (this.action && !this.target) {
        let data = bbn.fn.extend(true, {}, this.data || {}, this.source || {});
        let method = this.blank || this.self || this.target ? 'postOut' : 'post';
        this[method](this.action, data, d => {
          if (d && d.success === false) {} else if (d) {
            let e = new Event('success', {
              cancelable: true
            });
            this.$emit('success', d, e);
            if (!e.defaultPrevented) {
              this.originalData = bbn.fn.clone(this.source || {});
              if (this.successMessage && p) {
                p.alert(this.successMessage);
                bbn.fn.info(this.successMessage, p);
              }

              /*
              if ( this.sendModel && this.source ){
                this.originalData = bbn.fn.extend(true, {}, this.source || {});
              }
              */

              this.dirty = false;
              this.isLoading = false;
              this.update();
              if (this.window) {
                this.$nextTick(() => {
                  this.window.close(true, true);
                });
              }
            }
          }
        }, !this.blank && !this.self && !this.target ? (xhr, textStatus, errorThrown) => {
          this.$emit('failure', xhr, textStatus, errorThrown);
          this.isLoading = false;
        } : this.self ? '_self' : this.blank ? '_blank' : this.target);
      } else {
        this.originalData = bbn.fn.clone(this.source);
        let e = new Event('success', {
          cancelable: true
        });
        this.$emit('success', this.source, e);
        if (this.sendModel) {
          this.originalData = bbn.fn.clone(this.source);
        }
        this.dirty = false;
        this.isLoading = false;
        if (!e.defaultPrevented) {
          if (this.window) {
            this.window.close(true);
          }
        }
      }
    },
    /**
     * Executes the action given to the button.
     * @method _execCommand
     */
    _execCommand(button, ev) {
      if (button.action) {
        button.action(this.source, this, ev);
      }
    },
    updateButtons() {
      if (this.window && bbn.fn.isArray(this.window.currentButtons) && this.currentMode === 'big') {
        setTimeout(() => {
          this.window.currentButtons.splice(0, this.window.currentButtons.length, ...this.realButtons);
        }, 50);
      }
    },
    /**
     * Compares the actual data with the original data of the form to identify the differences.
     *
     * @method getModifications
     * @fires getData
     * @return {Object}
     */
    getModifications() {
      let data = this.getData(this.$el) || {},
        res = {};
      for (let n in data) {
        if (this.sendModel && data[n] !== this.originalData[n] || !this.sendModel && data[n] != this.originalData[n]) {
          res[n] = data[n];
        }
      }
      return res;
    },
    /**
     * Based on the prop 'sendModel', either the source of the form or an object of data contained in the form's fields is returned.
     *
     * @method getData
     * @return {Object}
     */
    getData() {
      return this.source; //this.sendModel ? this.source : bbn.fn.formdata(this.$el);
    },

    /**
     * Returns true if the form has been modified or if the value of the property 'prefilled' is true.
     * @method isModified
     * @return {Boolean}
     */
    isModified() {
      if (!bbn.fn.isSame(this.source, this.originalData)) {
        return true;
      }
      return false;
    },
    /**
     * Closes the popup containing the form.
     * @method 
     * @param {bbnCp} window 
     * @param {Event} ev 
     * @fires isModified
     */
    closePopup(force, ev) {
      if (this.window && this.$el && !this.isClosing) {
        this.isClosing = true;
        // In case the event is sent
        if (force !== true) {
          force = false;
        }
        if (!force && !this.isPosted && this.confirmLeave && this.isModified()) {
          if (ev) {
            ev.preventDefault();
          }
          this.confirm(this.confirmLeave, () => {
            this.reset();
            this.$nextTick(() => {
              if (this.window) {
                this.window.close(true, true);
                this.isClosing = false;
              }
            });
          }, () => {
            this.isClosing = false;
          });
        } else {
          this.reinit();
          this.$nextTick(() => {
            if (this.window) {
              this.window.close(true, true);
              this.isClosing = false;
            }
          });
        }
      }
    },
    /**
     * Cancels the changes and closes the window containing the form.
     * @method cancel
     * @fires reset
     * @fires window.close
     */
    cancel() {
      let ev = new Event('cancel', {
        cancelable: true
      });
      this.$emit('beforeCancel');
      if (!ev.defaultPrevented) {
        this.$emit('cancel', ev, this);
        this.reset();
        if (this.window) {
          this.window.close();
        }
      }
    },
    /**
     * Checks if the form content is valid.
     * @method isValid
     */
    isValid(force) {
      let callValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      let onlyFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      let ok = true;
      let elems = this.findAll('.bbn-input-component');
      let firstFound = null;
      if (bbn.fn.isArray(elems)) {
        bbn.fn.each(elems, ele => {
          if (bbn.fn.isFunction(ele.isValid) && !ele.isValid(ele, callValidation) || bbn.fn.isFunction(ele.validation) && !ele.validation()) {
            bbn.fn.log("PROB", ele);
            ok = false;
            if (bbn.fn.isNull(firstFound)) {
              firstFound = ele;
            }
          }
          if (!ok && !!onlyFirst) {
            return false;
          }
        });
      }
      if (!ok && bbn.fn.isFunction(firstFound.focus)) {
        firstFound.focus();
        if (this.scrollable) {
          this.getRef('container').scrollTo(0, firstFound);
        }
      }
      if (ok && this.validation && callValidation) {
        ok = this.validation(this.source, this.originalData, force);
      }
      return !!ok;
    },
    /**
     * Submits the form.
     * @method submit
     * @param {Boolean} force 
     * @fires validation
     * @fires _post
     * @emits submit
     */
    submit(force) {
      if (!this.isValid(force)) {
        return;
      }
      if (!force) {
        if (this.disabled) {
          return;
        }
        let ev = new Event('submit', {
          cancelable: true
        });
        this.$emit('submit', ev, this);
        if (ev.defaultPrevented) {
          return;
        }
      }
      let cf = false;
      if (this.confirmMessage) {
        if (bbn.fn.isFunction(this.confirmMessage)) {
          cf = this.confirmMessage(this);
        } else {
          cf = this.confirmMessage;
        }
        if (cf && this.window) {
          this.window.confirm(cf, () => {
            this._post();
          });
        }
      }
      if (!cf) {
        this._post();
      }
    },
    /**
     * Resets the original data of the form.
     * @method reset 
     * return {Boolean}
     */
    reset() {
      this.isPosted = false;
      bbn.fn.iterate(this.originalData, (val, name) => {
        //if ( this.source[name] !== val ){
        if (!bbn.fn.isSame(this.source[name], val)) {
          if (typeof val !== typeof this.source[name]) {
            this.$set(this.source, name, bbn.fn.clone(val));
          } else if (bbn.fn.isArray(this.source[name], val)) {
            bbn.fn.each(val, (a, i) => {
              if (this.source[name].length <= i) {
                this.source[name].push(a);
              } else if (a !== this.source[name][i]) {
                let idx = this.source[name].indexOf(a);
                if (idx > i) {
                  bbn.fn.move(this.source[name], idx, i);
                } else {
                  this.source[name].splice(i, 0, a);
                }
              }
            });
            if (this.source[name].length > val.length) {
              this.source[name].splice(val.length, this.source[name].length - val.length);
            }
          } else if (bbn.fn.isObject(this.source[name], val)) {
            let k1 = Object.keys(val);
            let k2 = Object.keys(this.source[name]);
            bbn.fn.each(k2, a => {
              if (k1.indexOf(a) === -1) {
                delete this.source[name][a];
              }
            });
            bbn.fn.each(k1, a => {
              if (val[a] !== this.source[name][a]) {
                this.source[name][a] = val[a];
              }
            });
          } else {
            this.$set(this.source, name, bbn.fn.clone(val));
          }
        }
      });
      this.reinit();
      this.$forceUpdate();
      this.$nextTick(() => {
        let elems = this.findAll('.bbn-input-component');
        if (bbn.fn.isArray(elems)) {
          bbn.fn.each(elems, a => a.$emit('removevalidation'));
        }
      });
      return true;
    },
    /**
     * Reinitializes the form.
     * @method reinit
     * 
     */
    reinit() {
      this.originalData = JSON.parse(JSON.stringify(this.source));
      this.dirty = this.isModified();
    },
    focusFirst(fromLast) {
      let ele = this.getRef('container');
      if (this.scrollable) {
        ele = ele.$el;
      }
      if (ele) {
        let focusable = false;
        let all = ele.querySelectorAll('input, select, .bbn-checkbox-label, textarea, [tabindex]:not([tabindex="-1"])');
        if (fromLast) {
          bbn.fn.forir(all, a => {
            if (a.offsetHeight && a.offsetWidth && !a.disabled && !a.classList.contains('bbn-no')) {
              focusable = a;
              return false;
            }
          });
        } else {
          bbn.fn.each(all, a => {
            if (a.offsetHeight && a.offsetWidth && !a.disabled && !a.classList.contains('bbn-no')) {
              //bbn.fn.log(a);
              focusable = a;
              return false;
            }
          });
        }
        if (focusable) {
          //focusable.focus();
        }
      }
    },
    focusLast() {
      this.focusFirst(true);
    },
    /**
    * Initializes the form.
    * @method init 
    * 
    */
    init() {
      if (this.$options.propsData.script) {
        this.$el.dataset.script = this.$options.propsData.script;
      }
      //this.originalData = bbn.fn.extend(true, {}, this.getData());
      this.$nextTick(() => {
        let focusable = null;
        if (!this.window && this.windowed) {
          this.window = this.closest("bbn-floater");
          if (this.window) {
            this.window.addClose(this.closePopup);
          }
        }
        if (!this.tab) {
          this.tab = this.closest("bbn-container");
        }
        this.canSubmit = this._canSubmit();
        this.updateButtons();
        this.isInit = true;
        if (this.autofocus) {
          this.focusFirst();
        }
      });
    },
    /**
     * @method checkValidity
     * @fires $el.checkValidity
     */
    checkValidity() {
      bbn.fn.warning("checkValidity is deprecated, use isValid instead");
      return this.$el.checkValidity();
    },
    /**
     * @method reportValidity
     * @fires $el.reportValidity
     */
    reportValidity() {
      bbn.fn.warning("reportValidity is deprecated, use isValid instead");
      return this.$el.reportValidity();
    },
    update() {
      bbn.fn.warning("update");
      this.canSubmit = this._canSubmit();
      this.$forceUpdate();
    }
  },
  /**
   * Registers in each container until root.
   * 
   * @event mounted
   * @fires init
   */
  mounted() {
    let container = this;
    while (container = container.closest('bbn-container')) {
      container.forms.push(this);
    }
    container = this;
    while (container = container.closest('bbn-floater')) {
      container.forms.push(this);
    }
    if (this.storage) {
      let data = this.getStorage();
      if (data) {
        this._isSetting = true;
        bbn.fn.iterate(data, (val, name) => {
          //if ( this.source[name] !== val ){
          if (!bbn.fn.isSame(this.source[name], val)) {
            if (typeof val !== typeof this.source[name]) {
              this.$set(this.source, name, bbn.fn.clone(val));
            } else if (bbn.fn.isArray(this.source[name], val)) {
              bbn.fn.each(val, (a, i) => {
                if (this.source[name].length <= i) {
                  this.source[name].push(a);
                } else if (a !== this.source[name][i]) {
                  let idx = this.source[name].indexOf(a);
                  if (idx > i) {
                    bbn.fn.move(this.source[name], idx, i);
                  } else {
                    this.source[name].splice(i, 0, a);
                  }
                }
              });
              if (this.source[name].length > val.length) {
                this.source[name].splice(val.length, this.source[name].length - val.length);
              }
            } else if (bbn.fn.isObject(this.source[name], val)) {
              let k1 = Object.keys(val);
              let k2 = Object.keys(this.source[name]);
              bbn.fn.each(k2, a => {
                if (k1.indexOf(a) === -1) {
                  delete this.source[name][a];
                }
              });
              bbn.fn.each(k1, a => {
                if (val[a] !== this.source[name][a]) {
                  this.source[name][a] = val[a];
                }
              });
            } else {
              this.$set(this.source, name, bbn.fn.clone(val));
            }
          }
        });
        this._isSetting = false;
      }
    }
    this.init();
  },
  /**
   * Registers in each container until root.
   * 
   * @event mounted
   * @fires init
   */
  beforeDestroy() {
    let container = this;
    while (container = container.closest('bbn-container')) {
      bbn.fn.each(container.forms, (f, i) => {
        if (f === this) {
          container.forms.splice(i, 1);
          return false;
        }
      });
    }
    container = this;
    while (container = container.closest('bbn-floater')) {
      bbn.fn.each(container.forms, (f, i) => {
        if (f === this) {
          container.forms.splice(i, 1);
          return false;
        }
      });
    }
  },
  watch: {
    /**
     * @watch schema
     */
    schema() {
      let currentSchema = [];
      this.schema.map(a => {
        currentSchema.push(bbn.fn.extend({}, a, {
          id: a.id ? a.id : bbn.fn.randomString(20, 30)
        }));
      });
      this.currentSchema = currentSchema;
    },
    /**
     * @watch source
     */
    source: {
      deep: true,
      handler() {
        bbn.fn.warning('form changed');
        this.dirty = this.isModified();
        if (this.storage) {
          if (!this._isSetting) {
            this.setStorage(this.source);
          }
        }
        this.$emit('change', this.getModifications());
        this.$nextTick(() => {
          if (this.sourceTimeout) {
            clearTimeout(this.sourceTimeout);
          }
          this.sourceTimeout = setTimeout(() => {
            this.update();
          }, 200);
        });
      }
    },
    /**
     * @watch buttons
     */
    buttons: {
      deep: true,
      handler() {
        if (this.isInit) {
          this.updateButtons();
        }
      }
    },
    /**
     * @watch canSubmit
     */
    canSubmit() {
      this.updateButtons();
    },
    /**
     * @watch canCancel
     */
    canCancel() {
      this.updateButtons();
    },
    /**
     * @watch dirty
     */
    dirty(v) {
      if (this.window) {
        this.window.dirty = v;
      }
      if (this.tab) {
        this.tab.dirty = v;
      }
    },
    mode(v) {
      this.currentMode = v;
    },
    isLoading() {
      this.updateButtons();
    }
  }
};
import cpHtml from './form.html';
import cpStyle from './form.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./form.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-form',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-browser component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * @prop {} [''] sandbox
     */
    sandbox: {
      default: ''
    },
    /**
     * @prop {String} 
     */
    url: {
      type: String
    },
    /**
     * @prop {String} [''] root
     */
    root: {
      type: String,
      default: ''
    },
    /**
     * @prop {Boolean} [false] communication
     */
    communication: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      window: null
    };
  },
  computed: {
    currentSandbox() {
      if (this.sandbox === false) {
        return 'allow-forms	allow-modals' + ' allow-pointer-lock' + ' allow-orientation-lock' + ' allow-same-origin' + ' allow-popups' + ' allow-presentation' + ' allow-scripts' + ' allow-top-navigation' + ' allow-top-navigation-by-user-activation' + ' allow-popups-to-escape-sandbox';
      }
      return this.sandbox;
    }
  },
  methods: {
    sendMessage(msg) {
      this.$el.contentWindow.postMessage(msg, '*');
    },
    sendID() {
      setTimeout(() => {
        this.sendMessage(this._uid);
      }, 1000);
    },
    load() {
      if (this.communication) {
        this.sendID();
      }
      if (this.root) {
        let ev = new Event('load', {
          cancelable: true
        });
        let url = this.$bbn.fn.substr(el.contentWindow.location.href, this.root.length);
        this.$emit('load', ev, url);
        if (!ev.defaultPrevented) {
          let ct = this.closest('bbn-container');
          if (ct && ct.router && url && ct.router.currentURL !== ct.url + '/' + url) {
            bbn.fn.log(ct.router.currentURL, ct.url + '/' + url);
            ct.router.route(ct.url + '/' + url);
          }
        }
      }
    },
    listen(msg) {
      if (this.communication) {
        if (msg.data && msg.data.uid === this._uid) {
          this.$emit('message', msg.data.message);
        }
      }
    },
    route(url) {
      if (this.$el.contentWindow.location.href !== this.root + url) {
        this.$el.contentWindow.location.href = this.root + url;
      }
    }
  },
  created() {
    if (this.communication) {
      window.addEventListener('message', this.listen, false);
    }
  },
  beforeDestroy() {
    if (this.communication) {
      window.removeEventListener('message', this.listen);
    }
  }
};
import cpHtml from './frame.html';
import cpStyle from './frame.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./frame.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-frame',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
// It has a multitude of customizations to better your gallery.
/**
 * @file bbn-gallery component
 * @description bbn-gallery is a component that displays a collection of images.
 * @copyright BBN Solutions
 * @author Mirko Argentino
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.list],
  props: {
    /**
     * Set to true to allow the component to have a scroll.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * The alternative component for the toolbar.
     * @prop {bbnCp|(Object|Boolean)} toolbar
     */
    toolbar: {
      type: [bbnCp, Object, Boolean],
      default: true
    },
    /**
     * Extra buttons to add to begin of the toolbar
     * @prop {Array} [[]] toolbatButtons
     */
    toolbarButtons: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {(Boolean|String)} [false] overlay
     */
    overlay: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Set to true to allow the gallery to be magnifiable.
     * @prop {Boolean} [false] zoomable
     */
    zoomable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to show info on the gallery's footer.
     * @prop {Boolean} [false] info
     */
    info: {
      type: Boolean,
      default: false
    },
    /**
     * The gap between the columns.
     * @prop {Number} [20] columnGap
     */
    columnGap: {
      type: Number,
      default: 20
    },
    /**
     * The gap between the rows.
     * @prop {Number} [20] rowGap
     */
    rowGap: {
      type: Number,
      default: 20
    },
    /**
     * The minimum number of columns allowed.
     * @prop {Number} [1] minCol
     */
    minCol: {
      type: Number,
      default: 1
    },
    /**
     * The maximum number of columns allowed.
     * @prop {Number} maxCol
     */
    maxCol: {
      type: Number
    },
    /**
     * The width of the items.
     * @prop {(Number|String)} [150] itemWidth
     */
    itemWidth: {
      type: [Number, String],
      default: 150
    },
    /**
     * The min width of the items.
     * @prop {Number} minItemWidth
     */
    minItemWidth: {
      type: Number
    },
    /**
     * The width of the items.
     * @prop {Number} maxItemWidth
     */
    maxItemWidth: {
      type: Number
    },
    /**
     * The horizontal alignment of the column.
     * @prop {String} ['center'] align
     */
    align: {
      type: String,
      default: 'center'
    },
    /**
     * Enables the upload possibility
     * @prop {Boolean} [false] uploadable
     */
    uploadable: {
      type: Boolean,
      default: false
    },
    /**
     * Enables the download possibility
     * @prop {Boolean} [false] downloadable
     */
    downloadable: {
      type: Boolean,
      default: false
    },
    /**
     * Enables the delete possibility
     * @prop {Boolean} [false] deletable
     */
    deletable: {
      type: Boolean,
      default: false
    },
    /**
     * Sets the toolbar buttons as notext
     * @prop {Boolean} [false] buttonsNoText
     */
    buttonsNoText: {
      type: Boolean,
      default: false
    },
    /**
     * Displays a preview of items below the slideshow.
     * @prop {Boolean} [true] preview
     */
    preview: {
      type: Boolean,
      default: true
    },
    /**
     * The property that will be used for the image path.
     * @prop {String} ['content'] pathName
     */
    pathName: {
      type: String,
      default: 'content'
    },
    /**
     * The property that will be used for the image overlay.
     * @prop {String} ['verlay] overlayName
     */
    overlayName: {
      type: String,
      default: 'overlay'
    },
    /**
     * The property that will be used for the researc.
     * @prop {String} ['title'] searchName
     */
    searchName: {
      type: String,
      default: 'title'
    },
    /**
     * The item component
     * @prop {(String|Object|bbnCp)} itemComponent
     */
    itemComponent: {
      type: [String, Object, bbnCp]
    },
    /**
     * The context menu source of every image
     * @prop {(Function|Array)} buttonMenu
     */
    buttonMenu: {
      type: [Function, Array]
    },
    /**
     * The component used by the context menu items
     * @prop {(String|Object|bbnCp)} contextComponent
     */
    buttonMenuComponent: {
      type: [String, Object, bbnCp]
    },
    /**
     * Enables the resize possibility
     * @prop {Boolean} [true] resizable
     */
    resizable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to false to hide the pager.
     * @prop {Boolean} [true] pager
     */
    pager: {
      type: Boolean,
      default: true
    },
    /**
     * The data property name of an item used to sort the items
     * @prop {String} sourceOrder
     */
    sourceOrder: {
      type: String
    },
    /**
     * The data property name of an intem used to open a link
     * @prop {String} ['link'] sourceAction
     */
    sourceAction: {
      type: String,
      default: 'link'
    },
    /**
     * The property that will be used for the image info.
     * @prop {String} ['info'] sourceInfo
     */
    sourceInfo: {
      type: String,
      default: 'info'
    }
  },
  data() {
    return {
      /**
       * The width of the component.
       * @data {Number} [0] width
       */
      width: 0,
      /**
       * True if the gallery is on selection mode.
       * @data {Boolean} [false] isSelecting
       */
      isSelecting: false,
      /**
       * The selection mode.
       * @data {Boolean|String} [false] selectingMode
       */
      selectingMode: false,
      //currentSelected: this.selected,
      /**
       * @data {Boolean} [false] isLoaded
       */
      isLoaded: false,
      /**
       * The current widht of the items
       * @data {Number} currentItemWidth
       */
      currentItemWidth: this.itemWidth,
      /**
       * The current text on the search input
       * @data {String} [''] currentSearch
       */
      currentSearch: '',
      /**
       * The research timeout
       * @data {Number} [0] searchTimeout
       */
      searchTimeout: 0,
      /**
       * The data of the current selected items
       * @data {Array} [[]] currentSelectedData
       */
      currentSelectedData: [],
      /**
       * @data {Boolean} [false] showFloater
       */
      showFloater: false,
      /**
       * @data {Object} [{}] floaterSource
       */
      floaterSource: {},
      /**
       * @data {Boolean} [false] isSorting
       */
      isSorting: false,
      /**
       * @data {Number} currentLimit
       */
      currentLimit: !!this.pageable ? this.limit : 0
    };
  },
  computed: {
    /**
     * The number of columns.
     * @computed cols
     * @return {Number}
     */
    cols() {
      return parseInt(this.lastKnownWidth / (this.currentItemWidth + this.columnGap)) || 1;
    },
    /**
     * The data of the current view
     * @computed items
     * @return {Array}
     */
    items() {
      let data = this.filteredData;
      if (this.sortable && !this.serverSorting) {
        data = bbn.fn.order(data, 'data.' + this.sourceOrder, 'asc');
      }
      if (this.pageable && this.currentLimit && (!this.isAjax || !this.serverPaging)) {
        return data.slice(this.start, this.start + this.currentLimit);
      }
      return data;
    },
    /**
     * The min item width
     * @computed currentMinItemWidth
     * @return {Number}
     */
    currentMinItemWidth() {
      let mw = this.itemWidth - 200;
      return this.minItemWidth || (mw > 50 ? mw : 50);
    },
    /**
     * The max item width
     * @computed currentMaxItemWidth
     * @return {Number}
     */
    currentMaxItemWidth() {
      return this.minItemWidth || this.itemWidth + 200;
    }
  },
  methods: {
    /**
     * Alias of bbn.fn.isObject.
     * @method isObject
     * @return {Boolean}
    */
    isObject: bbn.fn.isObject,
    /**
     * Alias of bbn.cp.isComponent.
     * @method isComponent
     * @return {Boolean}
    */
    isComponent: bbn.cp.isComponent,
    /**
       * Alias of bbn.fn.correctCase.
       * @method correctCase
       * @return {string}
      */
    correctCase: bbn.fn.correctCase,
    /**
     * Sets the selectingMode data property.
     * @method setSelecting
     * @param {String} mode
     */
    setSelecting(mode) {
      if (bbn.fn.isString(mode)) {
        this.isSelecting = true;
        this.selectingMode = mode;
      } else {
        this.isSelecting = false;
        this.selectingMode = false;
        this.currentSelected.splice(0);
        this.currentSelectedData.splice(0);
      }
    },
    /**
     * Manages actions based on the data property selectingMode.
     * @method action
     * @fires setSelecting
     */
    emitAction() {
      if (this.currentSelected.length) {
        let mess = '';
        if (this.selectingMode === 'download') {
          mess = bbn._("Are you sure you want to download these photos?");
        } else if (this.selectingMode === 'delete') {
          mess = bbn._("Are you sure you want to delete these photos?");
        }
        if (mess.length) {
          this.confirm(mess, () => {
            this.$emit(this.selectingMode, this.currentSelectedData);
            this.setSelecting(false);
          });
        } else {
          this.$emit(this.selectingMode, this.currentSelectedData);
          this.setSelecting(false);
        }
      }
    },
    resetSearch() {
      this.currentSearch = '';
    }
  },
  /**
   * @event mounted
   * @fires onResize
   */
  mounted() {
    this.$nextTick(() => {
      this.ready = true;
    });
  },
  watch: {
    /**
     * @watch currentSearch
     */
    currentSearch(newVal) {
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(() => {
        let idx = bbn.fn.search(this.currentFilters.conditions, {
          field: this.searchName
        });
        bbn.fn.log("GALLERY", idx);
        if (idx > -1) {
          if (newVal) {
            this.currentFilters.conditions[idx].value == newVal;
          } else {
            this.currentFilters.conditions.splice(idx, 1);
          }
        } else if (newVal) {
          this.currentFilters.conditions.push({
            field: this.searchName,
            operator: 'contains',
            value: newVal
          });
        }
      }, 1000);
    },
    itemWidth(val) {
      this.currentItemWidth = val;
    },
    showFloater(val) {
      if (!val) {
        this.floaterSource = {};
      }
    }
  },
  components: {
    /**
     * @component gallery-col
     */
    galleryCol: {
      name: 'gallery-col',
      template: `
<div :style="colStyle">
  <component :is="gallery.itemComponent || 'gallery-item'"
             v-for="(item, idx) in source"
             :source="item"
             :key="'gallery-item-'+index+'-'+idx"/>
</div>`,
      props: {
        /**
         * The source of the component 'gallery-col'.
         * @prop {Array} [[]] source
         * @memberof gallery-col
         */
        source: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * The index of the column.
         * @prop {Number} index
         * @memberof gallery-col
         */
        index: {
          type: Number
        }
      },
      computed: {
        /**
         * The parent gallery component.
         * @computed gallery
         * @memberof gallery-col
         * @return {Object}
         */
        gallery() {
          return this.closest('bbn-gallery');
        },
        /**
         * The style object of the column.
         * @computed colStyle
         * @memberof gallery-col
         * @return {Object}
         */
        colStyle() {
          return {
            width: `${this.gallery.currentItemWidth}px`,
            margin: `0 ${this.gallery.columnGap / 2}px`,
            verticalAlign: 'top',
            display: 'inline-block'
          };
        }
      },
      components: {
        /**
         * @component galleryItem
         * @memberof gallery-col
         */
        galleryItem: {
          name: 'gallery-item',
          template: `
<a v-if="!col.gallery.isLoading"
    :class="['bbn-gallery-item', 'bbn-box', {'bbn-primary': isSelected, 'bbn-p': !!col.gallery.zoomable}]"
    @click="action"
    @contextmenu="onContext"
    :style="aStyle"
    v-draggable="!!col.gallery.isSorting && !!col.gallery.uid"
    v-droppable="!!col.gallery.isSorting && !!col.gallery.uid"
    @drop="changeOrder">
  <span :class="{
          'bbn-spadded': !loaded,
          'bbn-c': !loaded
        }"
        style="display: block">
    <img :src="imgSrc"
         @load="loaded = true"
         @error="error = true"
         :class="{
           'bbn-radius': !col.gallery.isSorting,
           'bbn-gallery-item-selected': isSelected,
           'bbn-invisible': !loaded
         }"
         :style="imgStyle"
         :alt="(source.caption ? source.caption + ' - ' : '') + (source.text ? source.text + ' - ' : '') + (source.tags || []).join(' | ')"
         :draggable="!col.gallery.isSorting">
    <bbn-loadicon class="bbn-gallery-item-loading bbn-c"
                  v-if="!loaded && !error"/>
    <i v-else-if="error && !loaded" class="bbn-red nf nf-mdi-image_off"/>
    <span v-if="showOverlay && loaded"
          class="bbn-gallery-overlay bbn-widget bbn-ellipsis bbn-radius-bottom bbn-hxspadded"
          v-text="source.data[col.gallery.overlayName]"
          :title="source.data[col.gallery.overlayName]"/>
    <i v-if="col.gallery.zoomable && loaded && !col.gallery.isSelecting && !col.gallery.isSorting"
       class="bbn-gallery-zoverlay nf nf-fa-search"/>
    <bbn-context v-if="showOverlay && !!col.gallery.buttonMenu && loaded && !col.gallery.isSelecting && !col.gallery.isSorting"
                 tag="div"
                 class="bbn-block bbn-top-left bbn-top-smargin bbn-left-smargin"
                 :source="!!col.gallery.buttonMenu
                   ? (isFunction(col.gallery.buttonMenu)
                     ? col.gallery.buttonMenu(source.data, source.index, source.key)
                     : col.gallery.buttonMenu)
                   : []"
                 :attach="buttonMenuElement"
                 :item-component="col.gallery.contextComponent"
                 @hook:mounted="buttonMenuElement = getRef('itemMenu') || undefined"
                 ref="menuButton">
        <div class="bbn-block">
          <i class="bbn-gallery-button-menu nf nf-mdi-menu"
             ref="itemMenu"/>
        </div>
    </bbn-context>
  </span>
  <div v-if="col.gallery.sortable && col.gallery.isSorting && col.gallery.sourceOrder"
        v-text="source.data[col.gallery.sourceOrder]"
        class="bbn-b bbn-gallery-item-position bbn-lg"/>
</a>
            `,
          props: {
            /**
             * The source of the compoment 'gallery-item'.
             * @prop {String|Object} source
             * @memberof gallery-item
             */
            source: {
              type: [String, Object]
            }
          },
          data() {
            return {
              /**
               * True if the gallery-item is loaded.
               * @data {Boolean} [false] loaded
               * @memberof gallery-item
               */
              loaded: false,
              /**
               * The element to which the context menu is attached
               * @data {HTMLElement} [undefined] buttonMenuElement
               * @memberof gallery-item
               */
              buttonMenuElement: undefined,
              error: false
            };
          },
          computed: {
            /**
             * The parent component 'gallery-col'.
             * @computed col
             * @memberof gallery-item
             * @return {bbnCp}
             */
            col() {
              return this.closest('gallery-col');
            },
            /**
             * The style object of the item.
             * @computed aStyle
             * @memberof gallery-item
             * @return {Object}
             */
            aStyle() {
              let style = {
                margin: `0 0 ${this.col.gallery.rowGap}px 0`,
                border: this.isSelected ? '5px dotted' : this.col.gallery.isSorting ? '5px var(--primary-border) solid' : ''
              };
              if (!this.col.gallery.zoomable && !this.hasLink) {
                style.cursor = 'default';
              }
              return style;
            },
            /**
             * The style object of the image.
             * @computed imgStyle
             * @memberof gallery-item
             * @return {Object}
             */
            imgStyle() {
              return {
                width: this.loaded ? '100%' : 0,
                height: this.loaded ? '' : 0,
                margin: 0,
                display: 'block',
                visibility: this.loaded ? 'visible' : 'hidden',
                '-webkit-user-drag': !this.col.gallery.isSorting
              };
            },
            /**
             * True if the source of the component is an object.
             * @computed isObj
             * @return {Boolean}
             * @memberof gallery-item
             */
            isObj() {
              return bbn.fn.isObject(this.source);
            },
            /**
             * If true, shows the overlay.
             * @computed showOverlay
             * @return {Boolean}
             * @memberof gallery-item
             */
            showOverlay() {
              return this.col.gallery.overlay && this.isObj && this.source.data[this.col.gallery.overlayName] !== undefined;
            },
            /**
             * True if the item is selected.
             * @computed isSelected
             * @return {Boolean}
             * @memberof gallery-item
             */
            isSelected() {
              return this.col.gallery.currentSelected.includes(!!this.col.gallery.uid ? this.source.data[this.col.gallery.uid] : this.source.index);
            },
            /**
             * The image source
             * @computed imgSrc
             * @memberof gallery-item
             * @return {String}
             */
            imgSrc() {
              let src = '';
              if (bbn.fn.isString(this.source.data)) {
                src = this.source.data;
              } else {
                let prop = this.col.gallery.pathName || 'thumb' || 'content';
                if (this.source.data[prop]) {
                  src = this.source.data[prop];
                }
              }
              if (src && bbn.fn.isString(src)) {
                return bbn.fn.escapeUrl(src, 'w=' + this.col.gallery.currentItemWidth + '&thumb=1');
              }
              return null;
            },
            floaterSource() {
              return {
                data: bbn.fn.map(this.col.gallery.currentData, d => {
                  let obj = bbn.fn.extend(true, {}, d.data);
                  obj.content = obj[this.col.gallery.pathName];
                  obj.type = 'img';
                  obj.mode = 'original';
                  if (!obj[this.col.gallery.sourceInfo]) {
                    obj[this.col.gallery.sourceInfo] = obj[this.col.gallery.overlayName];
                  }
                  return obj;
                }),
                info: this.col.gallery.info,
                sourceInfo: this.col.gallery.sourceInfo,
                slide: this.source.index,
                preview: this.col.gallery.preview
              };
            },
            hasLink() {
              return this.col.gallery.sourceAction && !!this.source.data[this.col.gallery.sourceAction];
            }
          },
          methods: {
            onContext(ev) {
              let menuButton = this.getRef('menuButton');
              if (menuButton) {
                ev.preventDefault();
                ev.stopImmediatePropagation();
                menuButton.click();
              }
            },
            /**
             * Alias of bbn.fn.isFunction method
             * @methods isFunction
             * @memberof gallery-item
             */
            isFunction: bbn.fn.isFunction,
            /**
             * Manages the actions.
             * @methods action
             * @memberof gallery-item
             * @fires getPopup
             */
            action(ev) {
              if (this.col.gallery.isSelecting) {
                let id = !!this.col.gallery.uid ? this.source.data[this.col.gallery.uid] : this.source.index;
                if (this.isSelected) {
                  this.col.gallery.currentSelected.splice(this.col.gallery.currentSelected.indexOf(id), 1);
                  if (!!this.col.gallery.uid) {
                    let idx = bbn.fn.search(this.col.gallery.currentSelectedData, this.col.gallery.uid, id);
                    if (idx > -1) {
                      this.col.gallery.currentSelectedData.splice(idx, 1);
                    }
                  }
                } else {
                  this.col.gallery.currentSelected.push(id);
                  if (!!this.col.gallery.uid) {
                    this.col.gallery.currentSelectedData.push(this.source.data);
                  }
                }
              } else if (!ev.target.classList.contains('bbn-gallery-button-menu') && !ev.target.closest('.bbn-floater-list') && this.col.gallery.zoomable) {
                this.col.gallery.floaterSource = this.floaterSource;
                this.col.gallery.showFloater = true;
              } else if (this.hasLink) {
                bbn.fn.link(this.source.data[this.col.gallery.sourceAction]);
              } else {
                this.col.gallery.$emit('clickItem', this.source);
              }
            },
            changeOrder(ev) {
              ev.preventDefault();
              let sortEvent = new Event('sort', {
                  cancelable: true
                }),
                data = ev.detail.from.originalElement.bbn.source.data,
                pos = data[this.col.gallery.sourceOrder],
                posNew = this.source.data[this.col.gallery.sourceOrder];
              this.col.gallery.$emit('sort', sortEvent, {
                [data[this.col.gallery.uid]]: posNew,
                [this.source.data[this.col.gallery.uid]]: pos
              });
              if (!sortEvent.defaultPrevented) {
                this.$set(data, this.col.gallery.sourceOrder, posNew);
                this.source.data[this.col.gallery.sourceOrder] = pos;
              }
            }
          }
        }
      }
    },
    /**
     * @component gallery-zoom
     */
    galleryZoom: {
      name: 'gallery-zoom',
      template: `
<div class="bbn-overlay bbn-gallery-zoom">
  <bbn-slideshow :source="source.data"
                :show-info="source.info"
                :source-info="source.sourceInfo"
                :arrows="true"
                :show-count="true"
                :full-slide="true"
                :initial-slide="source.slide"
                :preview="source.preview"
                :keyboard="true"/>
</div>
                `,
      props: {
        /**
         * The source of the component 'gallery-zoom'.
         * @prop {String|Object} source
         */
        source: {
          type: [String, Object]
        }
      }
    },
    /**
     * @component gallery-selected
     */
    gallerySelected: {
      name: 'gallery-selected',
      template: `
<div class="bbn-rel">
  <i class="bbn-top-right nf nf-fa-close bbn-red bbn-vxspadded bbn-hspadded bbn-lg bbn-p"
     @click="unselect"/>
  <img :src="imgSrc"
       class="bbn-radius bbn-bordered"
       :alt="altSrc">
</div>
        `,
      props: {
        /**
         * @prop {String|Number} source
         * @memberof gallery-selected
         */
        source: {
          type: [String, Number],
          required: true
        }
      },
      computed: {
        /**
         * @computed altSrc
         * @memberof gallery-selected
         * @fires bbn.fn.basename
         * @return {String}
         */
        altSrc() {
          return bbn.fn.baseName(this.imgSrc);
        },
        /**
         * @computed gallery
         * @memberof gallery-selected
         * @fires closest
         * @return {bbnCp}
         */
        gallery() {
          return this.closest('bbn-gallery');
        },
        /**
         * @computed imgSrc
         * @memberof gallery-selected
         * @return {String|null}
         */
        imgSrc() {
          if (this.gallery) {
            let data = {},
              src = '';
            if (!!this.gallery.uid) {
              data = bbn.fn.getRow(this.gallery.currentSelectedData, this.gallery.uid, this.source);
            }
            if (bbn.fn.isString(data)) {
              src = data;
            } else {
              let prop = this.gallery.pathName || 'thumb' || 'content';
              if (data[prop]) {
                src = data[prop];
              }
            }
            if (src && bbn.fn.isString(src)) {
              return bbn.fn.escapeUrl(src, 'w=70&thumb=1');
            }
          }
          return null;
        }
      },
      methods: {
        /**
         * @method unselect
         * @memberof gallery-selected
         */
        unselect() {
          if (this.gallery) {
            this.gallery.currentSelected.splice(this.gallery.currentSelected.indexOf(this.source), 1);
          }
        }
      }
    }
  }
};
import cpHtml from './gallery.html';
import cpStyle from './gallery.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./gallery.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-gallery',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-grid-configuration component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 */
const cpDef = {
  name: 'bbn-grid-configuration',
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    rows: {
      type: Number,
      default: 20
    },
    cols: {
      type: Number,
      default: 20
    },
    cellSize: {
      type: [String, Number],
      default: '1rem'
    }
  },
  data() {
    return {
      showWindow: false,
      currentRow: -1,
      currentCol: -1
    };
  },
  computed: {
    realCellSize() {
      return bbn.fn.isNumber(this.cellSize) ? this.cellSize + 'px' : this.cellSize;
    },
    numGrids() {
      return this.cols * this.rows;
    },
    buttonElement() {
      let btn = this.getRef("button");
      if (btn) {
        return btn.$el;
      }
      return null;
    }
  },
  methods: {
    mouseEnter(colidx, rowidx) {
      this.currentRow = rowidx;
      this.currentCol = colidx;
    },
    mouseLeave() {
      this.currentRow = -1;
      this.currentCol = -1;
    }
  }
};
import cpHtml from './grid-configuration.html';
import cpStyle from './grid-configuration.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./grid-configuration.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-grid-configuration',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-icon component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author Mirko Argentino
 */
const cpDef = {
  name: 'bbn-icon',
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    content: {
      type: String
    },
    loading: {
      type: Boolean,
      default: false
    },
    width: {
      type: [String, Number]
    },
    height: {
      type: [String, Number]
    }
  },
  data() {
    return {
      currentContent: this.content || '',
      isLoading: this.loading || false,
      isNotFound: false
    };
  },
  computed: {
    currentStyle() {
      let o = {
        background: 'none'
      };
      let props = ['width', 'height'];
      bbn.fn.each(props, (p, i) => {
        if (this[p]) {
          o[p] = this[p];
          if (bbn.fn.isNumber(this[p])) {
            o[p] += 'px';
          }
          if (!this[props[i === 1 ? 0 : 1]]) {
            o[props[i === 1 ? 0 : 1]] = 'auto';
            o['max' + bbn.fn.correctCase(props[i === 1 ? 0 : 1])] = '100%';
          }
        }
      });
      if (!this.width && !this.height) {
        o.width = 'auto';
        o.height = 'auto';
        o.maxHeight = '100% !important';
        o.maxWidth = '100% !important';
        o.minWidth = '4rem';
      }
      return o;
    }
  }
};
import cpHtml from './icon.html';
import cpStyle from './icon.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./icon.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-icon',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-markdown component
 *
 * @description bbn-markdown is a component that allows you to easily format the Markdown text.
 * It's an editor that enable you to create textual content, to insert lists, image management and hyperlinks.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */

import tui from 'tui-image-editor';
//Markdown editor use simpleMDe
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic 
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * @prop {String} source
     */
    source: {
      type: String
    },
    /**
     * @prop {String} name
     */
    name: {
      type: String
    }
  },
  data() {
    return {
      widget: null
    };
  },
  methods: {},
  watch: {},
  mounted() {
    this.widget = new tui.ImageEditor(this.$refs.element, {
      includeUI: {
        locale: 'fr',
        initMenu: 'filter',
        menuBarPosition: 'bottom'
      },
      cssMaxWidth: 700,
      cssMaxHeight: 500
    });
    this.widget.loadImageFromURL(this.source, this.name);
    this.ready = true;
  }
};
import cpHtml from './image-editor.html';
import cpStyle from './image-editor.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./image-editor.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-image-editor',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * Based on https://github.com/judesfernando/initial.js
 */

/**
 * @file bbn-initial component
 *
 * @description bbn-initial is a component that represents the initials of a name as an avatar for a profile.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 28/03/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * The user id whose initials will be represented.
     * @prop {(String|Number)} userId
     */
    userId: {
      type: [String, Number]
    },
    /**
     * The username whose initials will be represented.
     * @prop {String} userName
     */
    userName: {
      type: String
    },
    /**
     * The width of the rectangle containing the initials.
     * @prop {(String|Number)} width
     */
    width: {
      type: [String, Number]
    },
    /**
     * The height of the rectangle containing the initials.
     * @prop {(String|Number)} height
     */
    height: {
      type: [String, Number]
    },
    /**
     * The dimensions given to the component as width and height.
     * @prop {Number} [36] defaultSize
     */
    defaultSize: {
      type: Number,
      default: 36
    },
    /**
     * The number of characters shown if the property 'letter' is not specified.
     * @prop {Number} [2] charCount
     */
    charCount: {
      type: Number,
      default: 2
    },
    /**
     * The color of the text.
     * @prop {String} ['#FFF'] textColor
     */
    textColor: {
      type: [String],
      default: '#FFF'
    },
    /**
     * The text's font family.
     * @prop {String} fontFamily
     */
    fontFamily: {
      type: String
    },
    /**
     * The rectangle's background color.
     * @prop {String} color
     */
    color: {
      type: String
    },
    /**
     * The font-size of the initials.
     * @prop {(Number|String)} fontSize
     */
    fontSize: {
      type: [Number, String]
    },
    /**
     * The font-weight of the initials.
     * @prop {(String|Number)} [400] fontWeight
     */
    fontWeight: {
      type: [Number, String],
      default: 400
    },
    /**
     * The letters shown in the component if neither the userName or the userId are given.
     * @prop {String} letters
     */
    letters: {
      type: String
    },
    /**
     * The border-radius of the main container.
     * @prop {(Number|String)} [3] radius
     */
    radius: {
      type: [Number, String],
      default: 3
    },
    /**
     * The array of users.
     * @prop {Array} source
     */
    source: {
      type: Array,
      default() {
        return window.appui && appui.app && appui.app.users ? appui.app.users : [];
      }
    },
    /**
     * The name of the property containing the user's name in the array source.
     * @prop {String} nameField
     */
    nameField: {
      type: String,
      default() {
        return window.appui && appui.app && appui.app.users ? 'text' : 'name';
      }
    },
    /**
     * The name of the property containing the user's id in the array source.
     * @prop {String} idField
     */
    idField: {
      type: String,
      default() {
        return window.appui && appui.app && appui.app.users ? 'value' : 'id';
      }
    },
    /**
     * The background colors palette
     * @prop {Array} [['#1abc9c', '#16a085', '#f1c40f', '#f39c12', '#2ecc71', '#27ae60', '#e67e22', '#d35400', '#3498db', '#2980b9', '#e74c3c', '#c0392b', '#9b59b6', '#8e44ad', '#bdc3c7', '#34495e', '#2c3e50', '#95a5a6', '#7f8c8d', '#ec87bf', '#d870ad', '#f69785', '#9ba37e', '#b49255', '#b49255', '#a94136']] colors
     */
    colors: {
      type: Array,
      default() {
        return ['#1abc9c', '#16a085', '#f1c40f', '#f39c12', '#2ecc71', '#27ae60', '#e67e22', '#d35400', '#3498db', '#2980b9', '#e74c3c', '#c0392b', '#9b59b6', '#8e44ad', '#bdc3c7', '#34495e', '#2c3e50', '#95a5a6', '#7f8c8d', '#ec87bf', '#d870ad', '#f69785', '#9ba37e', '#b49255', '#b49255', '#a94136'];
      }
    }
  },
  computed: {
    currentStyle() {
      const res = {
        width: this.currentWidth,
        height: this.currentHeight,
        borderRadius: this.currentRadius
      };
      if (this.currentColor) {
        res.backgroundColor = this.currentColor;
      }
      return res;
    },
    /**
     * Defines the style of the text based on the properties 'textColor', 'fontWeight', 'fontSize' and 'fontFamily'.
     * @computed fontStyle
     * @return {Object}
     */
    fontStyle() {
      let o = {
        color: this.textColor,
        'font-weight': this.fontWeight,
        'font-size': this.currentFontSize
      };
      if (this.fontFamily) {
        o['font-family'] = this.fontFamily;
      }
      return o;
    },
    /**
     * The current name
     * @computed currentName
     * @return {String}
     */
    currentName() {
      let name = this.userName;
      if (!name && this.userId && this.source) {
        name = bbn.fn.getField(this.source, this.nameField, this.idField, this.userId);
      }
      return name;
    },
    /**
     * The letters that will be shown in the component.
     * @computed currentLetters
     * @return {String}
     */
    currentLetters() {
      let currentLetters = '';
      if (this.letters) {
        currentLetters = this.letters;
      }
      if (!this.letters && this.currentName) {
        let tmp = bbn.fn.removeEmpty(this.currentName.split(' '));
        while (tmp.length > this.charCount && tmp[0].length <= 3) {
          tmp.shift();
        }
        for (let i = 0; i < tmp.length; i++) {
          if (!this.charCount || currentLetters.length <= this.charCount) {
            currentLetters += bbn.fn.substr(tmp[i], 0, 1);
          }
        }
      }
      return this.charCount && !this.letters ? bbn.fn.substr(currentLetters, 0, this.charCount) : currentLetters;
    },
    /**
     * The color of the text.
     * @computed currentColor
     * @return {String}
     */
    currentColor() {
      let name = this.userName,
        col = this.color;
      if (!col) {
        let sum = 0;
        this.currentLetters.split('').forEach(a => {
          sum += a.charCodeAt();
        });
        sum += name ? bbn.fn.substr(this.userName, -1).charCodeAt() : bbn.fn.substr(this.currentLetters, 0, 1).charCodeAt();
        let colorIndex = Math.floor(sum % this.colors.length);
        col = this.colors[colorIndex];
      }
      return col ? col : null;
    },
    /**
     * The font-size.
     * @computed currentFontSize
     * @return string
     */
    currentFontSize() {
      let currentFontSize = this.fontSize;
      if (!this.fontSize) {
        let baseSize = parseInt(this.height) / this.charCount;
        currentFontSize = Math.round(baseSize + bbn.fn.percent(15 * this.charCount, baseSize));
      }
      return bbn.fn.isNumber(currentFontSize) ? currentFontSize + 'px' : currentFontSize;
    },
    /**
     * The final width of the component.
     * @computed currentWidth
     * @return {String}
     */
    currentWidth() {
      let w = this.width || this.height || this.defaultSize;
      return bbn.fn.isNumber(w) ? w + 'px' : w;
    },
    /**
     * The final height of the component.
     * @computed currentHeight
     * @return {String}
     */
    currentHeight() {
      let h = this.height || this.width || this.defaultSize;
      return bbn.fn.isNumber(h) ? h + 'px' : h;
    },
    /**
     * The final border-radius that will be applied to the component.
     * @computed currentRadius
     * @return {String}
     */
    currentRadius() {
      return bbn.fn.isNumber(this.radius) ? this.radius + 'px' : this.radius;
    }
  }
};
import cpHtml from './initial.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./initial.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-initial',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-cms-block component
 * @description bbn-cms-block 
 * @copyright BBN Solutions
 * @author Loredana Bruno
 * @created 09/11/2020.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input],
  props: {
    /**
     * @prop {String} value
     */
    value: {
      type: String
    }
  },
  data() {
    return {};
  },
  computed: {},
  methods: {
    onInlineInput(ev) {
      this.emitInput(ev.target.innerText);
    },
    updateEditor() {
      this.getRef('divEditor').innerText = this.value;
    }
  },
  mounted() {
    this.updateEditor();
  },
  watch: {
    currentValue(v) {
      this.emitInput(v);
      this.updateEditor();
    },
    value(v) {
      if (v !== this.currentValue) {
        this.currentValue = v;
      }
    }
  }
};
import cpHtml from './inline-editor.html';
import cpStyle from './inline-editor.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./inline-editor.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-inline-editor',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-input component
 *
 * @description bbn-input is a simple text field.
 *
 * @author BBN Solutions
 * 
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input],
  props: {
    /**
     * Specifies whether a loading icon isshown inside the input field.
     * @prop {Boolean} [false] loading
     */
    loading: {
      type: [Boolean],
      default: false
    },
    /**
     * Specifies whether or not the input field should have autocomplete enabled. Accepts boolean or the strings 'on' or 'off'.
     * @prop {Boolean|String} [true] autocomplete
     */
    autocomplete: {
      type: [Boolean, String],
      default: true
    },
    /**
     * The type of the input.
     * @prop {String} type
     */
    type: {
      type: String,
      default: 'text'
    },
    /**
     * The button's icon on the left of the input.
     * @prop {String} buttonLeft
     */
    buttonLeft: {
      type: String
    },
    /**
     * The button's icon on the right of the input.
     * @prop {String} buttonRight
     */
    buttonRight: {
      type: String
    },
    /**
     * Hides the left button. 
     * @prop {Boolean} [false] autoHideLeft
     */
    autoHideLeft: {
      type: Boolean,
      default: false
    },
    /**
     * Hides the right button.
     * @prop {Boolean} [false] autoHideRight
     */
    autoHideRight: {
      type: Boolean,
      default: false
    },
    /**
     * Called when click the left button. 
     * @prop {Function} actionLeft
     */
    actionLeft: {
      type: Function
    },
    /**
     * Called when click the right button. 
     * @prop {Function} actionRight
     */
    actionRight: {
      type: Function
    },
    /**
     * Sets the left button disabled.
     * @prop {Boolean} [false] buttonLeftDisabled
     */
    buttonLeftDisabled: {
      type: Boolean,
      default: false
    },
    /**
     * Sets the left button disabled.
     * @prop {Boolean} [false] buttonRightDisabled
     */
    buttonRightDisabled: {
      type: Boolean,
      default: false
    },
    /**
     * The title of the left button.
     * @prop {String} buttonLeftTitle
     */
    buttonLeftTitle: {
      type: String
    },
    /**
     * The title of the right button.
     * @prop {String} buttonRightTitle
     */
    buttonRightTitle: {
      type: String
    },
    /**
     * The input's attribute 'pattern'.
     * @prop {String} pattern
     */
    pattern: {
      type: String
    },
    /**
     * The size of the input.
     * @prop {(String|Number)} size
     */
    size: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} min
     */
    min: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} max
     */
    max: {
      type: [String, Number]
    },
    /**
     * @prop {String} prefix
     */
    prefix: {
      type: String
    },
    /**
     * Forces the input to show the nullable icon even if it is in the read-only state
     * @prop {Boolean} [false] forceNullable
     */
    forceNullable: {
      type: Boolean,
      default: false
    }
  },
  data() {
    let currentAutocomplete = 'off';
    if (this.autocomplete === true) {
      currentAutocomplete = 'on';
    } else if (this.autocomplete && bbn.fn.isString(this.autocomplete)) {
      currentAutocomplete = this.autocomplete;
    }
    let currentValue = this.value || '';
    if (this.prefix && this.value.indexOf(this.prefix) === 0) {
      currentValue = bbn.fn.substr(currentValue, this.prefix.length);
    }
    return {
      /**
       * @todo not used
       */
      currentValue,
      /**
       * The property 'autocomplete' normalized.
       * @data {String} [''] currentAutocomplete
       */
      currentAutocomplete: currentAutocomplete,
      /**
       * The property 'size' normalized.
       * @data {String} [''] currentSize
       */
      currentSize: this.size || '',
      /**
       * The action performed by the left button.
       * @data {Function} currentActionLeft
       */
      currentActionLeft: bbn.fn.isFunction(this.actionLeft) ? this.actionLeft : () => {
        this.$emit('clickLeftButton');
      },
      /**
       * The action performed by the right button.
       * @data {Function} currentActionRight
       */
      currentActionRight: bbn.fn.isFunction(this.actionRight) ? this.actionRight : () => {
        this.$emit('clickRightButton');
      },
      currentPattern: null,
      currentType: null
    };
  },
  computed: {
    /**
     * The current input width in characters if the 'autosize' is enabled
     * @computed currentInputSize
     * @returns {Number}
     */
    currentInputSize() {
      return this.autosize ? this.value ? this.value.toString().length : 1 : 0;
    }
  },
  methods: {
    clear() {
      this.emitInput(this.prefix || '');
      this.currentValue = '';
    },
    init() {
      if (this.pattern) {
        let types = ['text', 'date', 'search', 'url', 'tel', 'email', 'password'];
        this.currentPattern = this.pattern;
        this.currentType = types.includes(this.type) ? this.type : 'text';
      } else if (this.type === 'hostname') {
        this.currentPattern = bbn.var.regexp.hostname.source;
        this.currentType = 'text';
      } else if (this.type === 'ip') {
        this.currentPattern = bbn.var.regexp.ip.source;
        this.currentType = 'text';
      } else {
        this.currentPattern = this.pattern;
        this.currentType = this.type;
      }
    },
    emitValue(v) {
      if (this.prefix && v.indexOf(this.prefix) !== 0) {
        v = this.prefix + v;
      }
      this.emitInput(v);
    }
  },
  created() {
    this.init();
  },
  mounted() {
    if (this.required) {
      this.getRef('element').setAttribute('required', '');
    }
    this.ready = true;
  },
  watch: {
    value(v) {
      if (this.prefix && v.indexOf(this.prefix) === 0) {
        v = bbn.fn.substr(v, this.prefix.length);
      }
      if (this.currentValue !== v) {
        this.currentValue = v;
      }
    },
    currentValue(v) {
      if (this.value !== (this.prefix || '') + this.currentValue) {
        this.getRef('element').value = v;
        this.emitValue(v);
      }
    },
    required(v) {
      if (v) {
        this.getRef('element').setAttribute('required', '');
      } else {
        this.getRef('element').removeAttribute('required');
      }
    },
    type(newVal) {
      this.init();
    }
  }
};
import cpHtml from './input.html';
import cpStyle from './input.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./input.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-input',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-json-editor component
 *
 * @description bbn-json-editor is a component that allows the schematic visualization of data in JSON format using different types of structures, such as: 'tree', 'text', 'object' and 'code'.
 * It also allows the modification or insertion of content.
 *
 * @author BBN Solutions
 * 
 * @copyright BBN Solutions
 *
 * @created 20/02/17
 */

import 'jsoneditor/dist/jsoneditor.css';
import JSONEditor from 'jsoneditor';

//Markdown editor use simpleMDe
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  statics() {
    return {
      lang: {
        array: bbn._('Array'),
        auto: bbn._('Auto'),
        appendText: bbn._('Append'),
        appendTitle: bbn._('Append a new field with type \'auto\' after this field (Ctrl+Shift+Ins)'),
        appendSubmenuTitle: bbn._('Select the type of the field to be appended'),
        appendTitleAuto: bbn._('Append a new field with type \'auto\' (Ctrl+Shift+Ins)'),
        ascending: bbn._('Ascending'),
        ascendingTitle: bbn._('Sort the childs of this ${type} in ascending order'),
        actionsMenu: bbn._('Click to open the actions menu (Ctrl+M)'),
        collapseAll: bbn._('Collapse all fields'),
        descending: bbn._('Descending'),
        descendingTitle: bbn._('Sort the childs of this ${type} in descending order'),
        drag: bbn._('Drag to move this field (Alt+Shift+Arrows)'),
        duplicateKey: bbn._('duplicate key'),
        duplicateText: bbn._('Duplicate'),
        duplicateTitle: bbn._('Duplicate selected fields (Ctrl+D)'),
        duplicateField: bbn._('Duplicate this field (Ctrl+D)'),
        duplicateFieldError: bbn._('Duplicate field name'),
        cannotParseFieldError: bbn._('Cannot parse field into JSON'),
        cannotParseValueError: bbn._('Cannot parse value into JSON'),
        empty: bbn._('empty'),
        expandAll: bbn._('Expand all fields'),
        expandTitle: bbn._('Click to expand/collapse this field (Ctrl+E). \n' + 'Ctrl+Click to expand/collapse including all childs.'),
        insert: bbn._('Insert'),
        insertTitle: bbn._('Insert a new field with type \'auto\' before this field (Ctrl+Ins)'),
        insertSub: bbn._('Select the type of the field to be inserted'),
        object: bbn._('Object'),
        ok: bbn._('Ok'),
        redo: bbn._('Redo (Ctrl+Shift+Z)'),
        removeText: bbn._('Remove'),
        removeTitle: bbn._('Remove selected fields (Ctrl+Del)'),
        removeField: bbn._('Remove this field (Ctrl+Del)'),
        selectNode: bbn._('Select a node...'),
        showAll: bbn._('show all'),
        showMore: bbn._('show more'),
        showMoreStatus: bbn._('displaying ${visibleChilds} of ${totalChilds} items.'),
        sort: bbn._('Sort'),
        sortTitle: bbn._('Sort the childs of this ${type}'),
        sortTitleShort: bbn._('Sort contents'),
        sortFieldLabel: bbn._('Field:'),
        sortDirectionLabel: bbn._('Direction:'),
        sortFieldTitle: bbn._('Select the nested field by which to sort the array or object'),
        sortAscending: bbn._('Ascending'),
        sortAscendingTitle: bbn._('Sort the selected field in ascending order'),
        sortDescending: bbn._('Descending'),
        sortDescendingTitle: bbn._('Sort the selected field in descending order'),
        string: bbn._('String'),
        transform: bbn._('Transform'),
        transformTitle: bbn._('Filter, sort, or transform the childs of this ${type}'),
        transformTitleShort: bbn._('Filter, sort, or transform contents'),
        extract: bbn._('Extract'),
        extractTitle: bbn._('Extract this ${type}'),
        transformQueryTitle: bbn._('Enter a JMESPath query'),
        transformWizardLabel: bbn._('Wizard'),
        transformWizardFilter: bbn._('Filter'),
        transformWizardSortBy: bbn._('Sort by'),
        transformWizardSelectFields: bbn._('Select fields'),
        transformQueryLabel: bbn._('Query'),
        transformPreviewLabel: bbn._('Preview'),
        type: bbn._('Type'),
        typeTitle: bbn._('Change the type of this field'),
        openUrl: bbn._('Ctrl+Click or Ctrl+Enter to open url in new window'),
        undo: bbn._('Undo last action (Ctrl+Z)'),
        validationCannotMove: bbn._('Cannot move a field into a child of itself'),
        autoType: bbn._('Field type "auto". ' + 'The field type is automatically determined from the value ' + 'and can be a string, number, boolean, or null.'),
        objectType: bbn._('Field type "object". ' + 'An object contains an unordered set of key/value pairs.'),
        arrayType: bbn._('Field type "array". ' + 'An array contains an ordered collection of values.'),
        stringType: bbn._('Field type "string". ' + 'Field type is not determined from the value, ' + 'but always returned as string.'),
        modeCodeText: bbn._('Code'),
        modeCodeTitle: bbn._('Switch to code highlighter'),
        modeFormText: bbn._('Form'),
        modeFormTitle: bbn._('Switch to form editor'),
        modeTextText: bbn._('Text'),
        modeTextTitle: bbn._('Switch to plain text editor'),
        modeTreeText: bbn._('Tree'),
        modeTreeTitle: bbn._('Switch to tree editor'),
        modeViewText: bbn._('View'),
        modeViewTitle: bbn._('Switch to tree view'),
        modePreviewText: bbn._('Preview'),
        modePreviewTitle: bbn._('Switch to preview mode'),
        examples: bbn._('Examples'),
        default: bbn._('Default')
      }
    };
  },
  props: {
    /**
     * The value of the json editor.
     * @prop {String} ['{}'] value
     */
    value: {
      default: '{}'
    },
    /**
     * Defines the mode of the json editor. Allowed values are 'tree', 'view', 'form', 'code' and 'text'.
     * @prop {String} ['tree'] mode
     */
    mode: {
      type: String,
      default: 'tree'
    },
    expanded: {
      type: [Number, Boolean]
    },
    /**
     * The object of configuration.
     * @prop {Object} [{}] cfg
     */
    cfg: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    let isParsed = this.value && (bbn.fn.isObject(this.value) || bbn.fn.isArray(this.value));
    let v = this.value || '';
    if (isParsed) {
      try {
        v = JSON.stringify(this.value);
      } catch (e) {
        bbn.fn.log("Impossible to parse");
      }
    }
    return {
      isParsed: isParsed,
      currentValue: v
    };
  },
  computed: {
    /**
      * The mode of the component.
      * @data {String} mode
      */
    currentMode() {
      return this.readonly ? 'view' : this.mode || "tree";
    }
  },
  methods: {
    /**
     * Gets the initial configuration of the component.
     * @method getCfg
     * @emit change
     * @emit input
     * @return {Object}
     */
    getCfg() {
      let cfg = {
        /**
         * @data onEditable
         */
        onEditable: this.cfg.onEditable || null,
        /**
         * @data onError
         */
        onError: this.cfg.onError || null,
        /**
         * @data onModeChange 
         */
        onModeChange: this.cfg.onModeChange || null,
        /**
         * @data escapeUnicode 
         */
        escapeUnicode: this.cfg.escapeUnicode || false,
        /**
         * @data sortObjectKeys 
         */
        sortObjectKeys: this.cfg.sortObjectKeys || false,
        /**
         * @data history
         */
        history: this.cfg.history || true,
        /**
         * The mode of the component.
         * @data {String} mode
         */
        mode: this.readonly ? 'view' : this.currentMode,
        /**
         * @data {Array} modes
         */
        modes: this.readonly ? ['view'] : ["tree", "view", "form", "code", "text"],
        /**
         * @data schema
         */
        schema: this.cfg.schema || null,
        /**
         * @data schemaRefs
         */
        schemaRefs: this.cfg.schemaRefs || null,
        /**
         * @data search
         */
        search: this.cfg.search !== undefined ? this.cfg.search : true,
        /**
         * @data {Number} indentation
         */
        indentation: this.cfg.indentation || 2,
        /**
         * @data theme
         */
        theme: this.cfg.theme || null,
        /**
         * @data {Array} templates
         */
        templates: this.cfg.templates || [],
        /**
         * @data autocomplete
         */
        autocomplete: this.cfg.autocomplete || null,
        /**
         * The code of the language used in the component.
         * @data {String} ['en'] language
         */
        language: bbn.env.lang || 'en',
        languages: {}
      };
      if (bbn.env.lang) {
        cfg.languages[bbn.env.lang || 'en'] = bbnJsonEditorCp.lang;
      }
      if (!this.readonly) {
        let cp = this;
        cfg.onChange = () => {
          let v = this.widget.getText();
          if (this.isParsed) {
            try {
              v = JSON.parse(v);
            } catch (e) {
              bbn.fn.log('Impossible to read the JSON');
              v = '';
            }
          }
          if (this.value !== v) {
            bbn.fn.log("REAL CHANGE", v);
            this.emitInput(v);
          }
        };
      }
      return cfg;
    },
    /**
     * Initializes the component.
     * @fires getCfg
     * @fires widget.setText
     */
    init() {
      let cfg = this.getCfg();
      bbn.fn.log("VALUE", this.value);
      this.widget = new window.JSONEditor(this.$refs.element, cfg);
      if (this.currentValue) {
        this.widget.setText(this.currentValue);
      }
      if (this.expanded) {
        if (bbn.fn.isNumber(this.expanded)) {
          expand(this.widget.node.childs, this.expanded);
        } else {
          this.widget.expandAll();
        }
      }
      this.ready = true;
    },
    /**
     * Destroys and reinitializes the component.
     * @fires widget.destroy
     * @fires init
     */
    reinit() {
      this.widget.destroy();
      this.init();
    }
  },
  /**
   * @event mounted@fires init
   */
  mounted() {
    this.init();
  },
  watch: {
    /**
     * @watch value
     * @param {String} newVal 
     * @fires widget.getText
     * @fires widget.setText
     */
    currentValue(v) {
      if (this.ready && this.widget.getText() != v) {
        this.widget.setText(v);
      }
    },
    value(v) {
      let tmp = v;
      if (v && typeof v === 'object') {
        tmp = JSON.stringify(v);
      } else if (!bbn.fn.isString(v)) {
        tmp = '';
      }
      if (tmp !== this.currentValue) {
        this.currentValue = tmp;
      }
    }
  }
};
import cpHtml from './json-editor.html';
import cpStyle from './json-editor.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./json-editor.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
const def = {
  name: 'bbn-json-editor',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
export { def as default, JSONEditor };
/**
 * @file bbn-context component
 *
 * @description bbn-context is a menu that can be activated with a right click.
 * The source of the menu can have a tree structure.
 * 
 * @copyright BBN Solutions
 *
 * @created 15/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  statics() {
    const DIRECTIONS = ['left', 'right', 'up', 'down'];
  },
  props: {
    /**
     * The content of the context menu.
     * @prop {String} content
     */
    content: {
      type: String
    }
  },
  data() {
    return {
      /**
       * True if the floating element of the menu is opened.
       * @data {Boolean} [false] showFloater 
       */
      showFloater: false
    };
  },
  computed: {
    k() {
      return this.content.toLowerCase();
    },
    isReturn() {
      return ['return', 'enter'].includes(this.k);
    },
    isDelete() {
      return ['del', 'delete', 'backspace'].includes(this.k);
    },
    isSpace() {
      return this.content === ' ' || this.k === 'space';
    },
    isDouble() {
      return ['shift', 'tab', 'return', 'enter', 'backspace', 'caps lock'].includes(this.k);
    },
    isEscape() {
      return ['esc', 'escape'].includes(this.k);
    },
    isSpecial() {
      return this.k.length > 1;
    },
    isTop() {
      return this.isEscape || this.isFunction || ['print screen', 'prt', 'prt sc', 'prt sc.', 'screen lock', 'screen', 'scr lk', 'pause'].includes(this.k);
    },
    isFunction() {
      return this.isSpecial && bbn.fn.substr(this.k, 0, 1) === 'f';
    },
    isArrow() {
      return this.k.indexOf('arrow') === 0 || bbnKeyCp.DIRECTIONS.includes(this.k);
    },
    rendered() {
      let st = bbn.fn.correctCase(this.k);
      if (st === 'Escape') {
        st = 'Esc';
      }
      if (st === 'Space') {
        st = ' ';
      }
      if (st === 'Prt sc' || st === 'Prt sc.' || st === 'Print screen') {
        st = 'Prt<br>Sc';
      }
      if (st === 'Scr lk' || st === 'Screen lock' || st === 'Screen') {
        st = 'Src<br>Lk';
      }
      return st;
    },
    arrowClass() {
      let cls = '';
      if (this.isArrow) {
        bbn.fn.each(bbnKeyCp.DIRECTIONS, a => {
          if (this.k.indexOf(a) > -1) {
            cls = 'nf nf-fa-long_arrow_' + a;
            return false;
          }
        });
      }
      return cls;
    }
  }
};
import cpHtml from './key.html';
import cpStyle from './key.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./key.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-key',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-code component
 *
 * @description bbn-code is a text editor.
 * It specializes in editing the code of a supported language. 
 * Various tools are provided to the users, which can be configured to their liking.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {},
  data() {
    return {
      /**
       * @todo not used
       */
      widget: null,
      /**
       * True if the editor is fullscreen.
       * @data {Boolan} [false] isFullScreen
       */
      isVisible: false
    };
  },
  computed: {
    /**
     * If the property theme is not defined, the default theme is returned.
     *
     * @computed currentTheme
     * @return {String}
     */
    currentTheme() {
      return this.theme ? this.theme : this.defaultTheme;
    }
  },
  methods: {
    onChange(input) {
      bbn.fn.log("CHANGE", input);
    },
    onKeyPress(button) {
      if (button === "{shift}" || button === "{lock}") {
        this.handleShift();
      }
      if (button === "{numbers}" || button === "{abc}") {
        this.handleNumbers();
      }
      bbn.fn.log("KEYPRESS", button);
    },
    handleNumbers() {
      let currentLayout = this.widget.options.layoutName;
      let numbersToggle = currentLayout !== "numbers" ? "numbers" : "default";
      this.widget.setOptions({
        layoutName: numbersToggle
      });
    },
    handleShift() {
      let currentLayout = this.widget.options.layoutName;
      let shiftToggle = currentLayout === "default" ? "shift" : "default";
      this.widget.setOptions({
        layoutName: shiftToggle
      });
    }
  },
  /**
   * @event mounted
   * @fires initTern
   * @fires getRef
   * @emit  input
   */
  mounted() {
    this.widget = new window.SimpleKeyboard.default({
      onChange: input => this.onChange(input),
      onKeyPress: button => this.onKeyPress(button),
      mergeDisplay: true,
      layoutName: "default",
      layout: {
        default: ["q w e r t y u i o p", "a s d f g h j k l", "{shift} z x c v b n m {backspace}", "{numbers} {space} {ent}"],
        shift: ["Q W E R T Y U I O P", "A S D F G H J K L", "{shift} Z X C V B N M {backspace}", "{numbers} {space} {ent}"],
        numbers: ["1 2 3", "4 5 6", "7 8 9", "{abc} 0 {backspace}"]
      },
      display: {
        "{numbers}": "123",
        "{ent}": "return",
        "{escape}": "esc ",
        "{tab}": "tab ",
        "{backspace}": "",
        "{capslock}": "caps lock ",
        "{shift}": "",
        "{controlleft}": "ctrl ",
        "{controlright}": "ctrl ",
        "{altleft}": "alt ",
        "{altright}": "alt ",
        "{metaleft}": "cmd ",
        "{metaright}": "cmd ",
        "{abc}": "ABC"
      }
    });
    //bbn.fn.log(this.getOptions());
  },

  watch: {}
};
import cpHtml from './keyboard.html';
import cpStyle from './keyboard.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./keyboard.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-keyboard',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-context component
 *
 * @description bbn-keyvalue is a dynamic list of keys and values
 * The source of the menu can have a tree structure.
 * 
 * @copyright BBN Solutions
 *
 * @created 15/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input],
  props: {
    /**
     * @prop {Number} max
     */
    max: {
      type: Number
    },
    /**
     * @prop {Number} min
     */
    min: {
      type: Number
    }
  },
  data() {
    let isJSON = bbn.fn.isString(this.value);
    return {
      isJSON: isJSON,
      obj: isJSON ? JSON.parse(this.value) : this.value,
      currentKey: '',
      currentValue: '',
      items: []
    };
  },
  methods: {
    setItems() {
      this.items.splice(0, this.items.length);
      bbn.fn.iterate(this.obj, (o, n) => {
        this.items.push({
          key: n,
          value: o
        });
      });
    },
    update() {
      this.setItems();
      this.$forceUpdate();
    },
    remove(key) {
      delete this.obj[key];
      if (this.isJSON) {
        this.emitInput(JSON.stringify(this.obj) || '{}');
      } else {
        /** @see https://www.drewtown.dev/post/using-vues-v-model-with-objects/ */
        this.$emit('input', {
          ...this.obj
        });
      }
      this.update();
    },
    add() {
      if (this.currentKey && this.currentValue) {
        if (this.isJSON) {
          this.obj[this.currentKey] = this.currentValue;
          this.emitInput(JSON.stringify(this.obj) || '{}');
        } else {
          /** @see https://www.drewtown.dev/post/using-vues-v-model-with-objects/ */
          this.$emit('input', {
            ...this.obj,
            [this.currentKey]: this.currentValue
          });
          this.obj[this.currentKey] = this.currentValue;
        }
        this.update();
        this.currentKey = '';
        this.currentValue = '';
        this.getRef('key').focus();
      }
    }
  },
  created() {
    this.setItems();
  }
};
import cpHtml from './keyvalue.html';
import cpStyle from './keyvalue.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./keyvalue.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-keyvalue',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-list component
 *
 * @description A fully customizable selectable list.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.position
   * @mixin bbn.cp.mixins.keepCool
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.componentInside
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.position, bbn.cp.mixins.keepCool, bbn.cp.mixins.resizer, bbn.cp.mixins.events, bbn.cp.mixins.componentInside],
  statics() {
    return {
      isClicked: false
    };
  },
  props: {
    /**
     * @prop {} origin
     */
    origin: {},
    /**
     * The maximum width of the floater.
     * @prop {Number|String} maxWidth
     */
    maxWidth: {
      type: [Number, String]
    },
    /**
     * The maximum height of the floater.
     * @prop {Number|String} maxHeight
     */
    maxHeight: {
      type: [Number, String]
    },
    /**
     * The minimum width of the floater.
     * @prop {Number|String} minWidth
     */
    minWidth: {
      type: [Number, String]
    },
    /**
     * The minimum height of the floater.
     * @prop {Number|String} minHeight
     */
    minHeight: {
      type: [Number, String]
    },
    /**
     * The width of the floater.
     * @prop {(String|Number|Boolean)} width
     */
    width: {
      type: [String, Number, Boolean]
    },
    /**
     * The height of the floater.
     * @prop {(String|Number|Boolean)} height
     */
    height: {
      type: [String, Number, Boolean]
    },
    /**
     * The source of the floater.
     * @prop {(Function|Array|String|Object)} source
     */
    source: {
      type: [Function, Array, String, Object]
    },
    /**
     * Only one selection at a time if "true"
     * @prop {Boolean} [true] unique
     */
    unique: {
      type: Boolean,
      default: true
    },
    /**
     * The hierarchical level, root is 0, and for each generation 1 is added to the level.
     * @prop {Number} [0] level
     */
    level: {
      type: Number,
      default: 0
    },
    /**
     * The array containings the tree's children.
     * @prop {String} ['items'] children
     */
    children: {
      type: String,
      default: 'items'
    },
    /**
     * @prop {(Boolean|Number)} [false] suggest
     */
    suggest: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Alternates the background color on the list
     * @prop {Boolean} [false] alternateBackground
     */
    alternateBackground: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] groupable
     */
    groupable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} ['group'] sourceGroup
     */
    sourceGroup: {
      type: String,
      default: 'group'
    },
    /**
     * @prop {(String|Object|bbnCp)} groupComponent
     */
    groupComponent: {
      type: [String, Object, bbnCp]
    },
    /**
     * @prop {String} groupStyle
     */
    groupStyle: {
      type: String
    },
    /**
     * Whatever will be given as arguments to the function action.
     * @prop {Array} actionArguments
     */
    actionArguments: {
      type: Array
    },
    /**
     * The name of the property to be used as icon.
     * @prop {String} sourceIcon
     * @memberof listComponent
     */
    sourceIcon: {
      type: String,
      default: 'icon'
    },
    /**
     * The name of the property to be used as action to execute when selected.
     * @prop {String} sourceAction
     * @memberof listComponent
     */
    sourceAction: {
      type: [String, Function],
      default: 'action'
    },
    /**
     * The name of the property to be used as URL to go to when selected.
     * @prop {String} sourceUrl
     * @memberof listComponent
     */
    sourceUrl: {
      type: [String, Function],
      default: 'url'
    },
    scrollHidden: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {Number} [0] currentIndex
       */
      currentIndex: 0,
      /**
       * @data [null] currentTop
       */
      currentTop: null,
      /**
       * @data [null] currentLeft
       */
      currentLeft: null,
      /**
       * @data [null] currentHeight
       */
      currentHeight: null,
      /**
       * @data [null] currentWidth
       */
      currentWidth: null,
      /**
       * @data {Boolean} [false] currentScroll
       */
      currentScroll: false,
      /**
       * @data {Number} [0] currentWidth
       */
      containerWidth: 0,
      /**
       * @data {Number} [0] currentHeight
       */
      containerHeight: 0,
      /**
       * @data {Boolean} focused
       */
      focused: bbn.env.focused || null,
      /**
       * @data {Number} [0] floaterHeight
       */
      floaterHeight: 0,
      /**
       * @data {Number} [0] floaterWidth
       */
      floaterWidth: 0,
      /**
       * @data {Boolean} [false] hasIcon
       */
      hasIcons: false,
      /**
       * @data {Number} [-1] currentSelected
       */
      currentSelected: -1,
      /**
       * @data {Boolean} [false] isMaximized
       */
      isMaximized: false,
      /**
       * @data {Boolean} [false] isOver
       */
      isOver: false,
      /**
       * The index (on filteredData) on which is the mouse cursor or the keyboard navigation
       * @data {Number} [-1] overItem
       * @memberof listComponent
       */
      overIdx: -1,
      /**
       * @data {Boolean} [true] isOpened
       */
      isOpened: true,
      /**
       * @data [null] scroll
       */
      scroll: null,
      /**
       * @data {Boolean} [false] hasScroll
       */
      hasScroll: false,
      /**
       * @data [null] currentComponent
       */
      currentComponent: null,
      /**
       * @data {Boolean} [false] tmpDisabled
       */
      tmpDisabled: false,
      /**
       * The main list in a hierarchical system
       * @data {Boolean|bbnCp} [false] rootList
       */
      rootList: false,
      /**
       * The current list with the mouse over
       * @data {Boolean|bbnCp} [false] overList
       */
      overList: false
    };
  },
  computed: {
    /**
     * Normalizes the property 'width'.
     * @computed formattedWidth
     * @return {String}
     */
    formattedWidth() {
      if (this.isMaximized) {
        return '100%';
      }
      if (this.width) {
        return this.width + (bbn.fn.isNumber(this.width) ? 'px' : '');
      }
      return this.currentWidth ? this.currentWidth + 'px' : '100%';
    },
    /**
     * Normalizes the property 'height'.
     * @computed formattedHeight
     * @return {String}
     */
    formattedHeight() {
      if (this.isMaximized) {
        return '100%';
      }
      if (this.height) {
        return this.height + (bbn.fn.isNumber(this.height) ? 'px' : '');
      }
      return this.currentHeight ? this.currentHeight + 'px' : 'auto';
    },
    /**
     * An object of css property to apply to the floater.
     * @computed currentStyle
     * @return {Object}
     */
    currentStyle() {
      let s = {
        width: this.formattedWidth,
        height: this.formattedHeight,
        overflow: 'hidden'
      };
      if (this.maxWidth) {
        s.maxWidth = this.maxWidth + (bbn.fn.isNumber(this.maxWidth) ? 'px' : '');
      }
      if (this.maxHeight) {
        s.maxHeight = this.maxHeight + (bbn.fn.isNumber(this.maxHeight) ? 'px' : '');
      }
      if (this.minWidth) {
        s.minWidth = this.minWidth + (bbn.fn.isNumber(this.minWidth) ? 'px' : '');
      }
      if (this.minHeight) {
        s.minHeight = this.minHeight + (bbn.fn.isNumber(this.minHeight) ? 'px' : '');
      }
      return s;
    },
    /**
     * The parent list in a hierarchical system
     * @computed parentList
     * @fires closest
     * @returns {bbnCp|Boolean}
     */
    parentList() {
      let list = this.closest('bbn-list');
      return list ? list.level < this.level ? list : false : false;
    }
  },
  methods: {
    /**
     * @method _setFilteredData
     * @fires _checkConditionsOnItem
     * @returns {Array}
     */
    _setFilteredData() {
      let data = this.currentData;
      if (this.currentData.length && this.currentFilters && this.currentFilters.conditions && this.currentFilters.conditions.length && (!this.serverFiltering || !this.isAjax)) {
        data = bbn.fn.filter(data, a => {
          return this._checkConditionsOnItem(this.currentFilters, a.data);
        });
      }
      if (this.groupable && this.sourceGroup) {
        let grouped = {},
          ungrouped = [];
        bbn.fn.each(data, d => {
          if (d.data[this.sourceGroup] !== undefined) {
            if (grouped[d.data[this.sourceGroup]] === undefined) {
              grouped[d.data[this.sourceGroup]] = [];
            }
            grouped[d.data[this.sourceGroup]].push(d);
          } else {
            ungrouped.push(d);
          }
        });
        data = [];
        bbn.fn.each(Object.values(grouped), g => data.push(...g));
        data.push(...ungrouped);
      }
      this.filteredData = data;
    },
    /**
     * Manages the icon of the items.
     * @method _updateIconSituation
     */
    _updateIconSituation() {
      let hasIcons = false;
      if (this.sourceIcon) {
        bbn.fn.each(this.filteredData, a => {
          if (a.data && a.data.icon) {
            hasIcons = true;
            return false;
          }
        });
      }
      if (hasIcons !== this.hasIcons) {
        this.hasIcons = hasIcons;
      }
    },
    /**
     * The method called on the mouseenter event
     * @method mouseenter
     * @param {Event} e
     * @param {Number} idx
     */
    mouseenter(e, idx) {
      let list = e.target.closest('.bbn-list');
      if ((list === null || list === void 0 ? void 0 : list.bbn) === this) {
        this.overIdx = idx;
        this.isOver = true;
        this.rootList.overList = this;
        this.filteredData[idx].opened = true;
      }
    },
    /**
     * @method resetOverIdx
     */
    resetOverIdx() {
      if (this.suggest === false) {
        this.overIdx = -1;
      } else if (this.suggest === true) {
        this.overIdx = 0;
      } else if (this.filteredData[this.suggest]) {
        this.overIdx = this.suggest;
      }
    },
    /**
     * The method called on mouseleave event
     * @method mouseleave
     * @fires resetOverIdx
     */
    mouseleave() {
      this.isOver = false;
      this.rootList.overList = false;
      this.resetOverIdx();
    },
    /**
     * @method isSelected
     * @param {Number} idx
     * @returns {Boolean}
     */
    isSelected(idx) {
      let r = false;
      if (this.filteredData[idx]) {
        if (this.selection) {
          if (this.filteredData[idx].selected && this.mode !== 'options') {
            r = true;
          }
        } else if (this.selected.length && this.sourceValue) {
          r = this.selected.includes(this.filteredData[idx].data[this.sourceValue]);
        }
      }
      return r;
    },
    /**
     * @method remove
     * @param {Number} idx
     * @fires realDelete
     */
    remove(idx) {
      //bbn.fn.log(this.currentData, idx);
      this.realDelete(idx);
    },
    /**
     * Handles the selection of the floater's items.
     * @method select
     * @param {Number} idx
     * @emits select
     */
    select(idx) {
      let item = this.filteredData[idx] || null;
      if (item && item.data && !item.data.disabled) {
        let ev = new Event('select', {
          cancelable: true
        });
        this.currentIndex = idx;
        if (item.data[this.children] && item.data[this.children].length) {
          this.isOpened = !this.isOpened;
        } else {
          let v = item.data[this.sourceValue];
          this.$emit(this.isSelected(idx) ? "unselect" : "select", item.data, idx, item.index, ev);
          bbn.fn.log("SELECT " + idx, ev.defaultPrevented, this.mode, item.data, idx, item.index, this.isSelected(idx));
          if (!ev.defaultPrevented) {
            if (this.mode === 'selection' && !item.selected) {
              let prev = bbn.fn.getRow(this.filteredData, "selected", true);
              if (prev) {
                this.currentData[prev.index].selected = false;
              }
              item.selected = true;
            } else {
              item.selected = !this.isSelected(idx);
            }
            if (v !== undefined) {
              if (item.selected) {
                if (this.unique) {
                  this.selected.splice(0, this.selected.length);
                }
                if (!this.selected.includes(v)) {
                  this.selected.push(v);
                }
              } else if (this.selected.includes(v)) {
                this.selected.splice(this.selected.indexOf(v), 1);
              }
            }
            if (item.data[this.sourceAction]) {
              if (typeof item.data[this.sourceAction] === 'string') {
                if (bbn.fn.isFunction(this[item.data[this.sourceAction]])) {
                  this[item.data[this.sourceAction]]();
                }
              } else if (bbn.fn.isFunction(item.data[this.sourceAction])) {
                if (this.actionArguments) {
                  item.data[this.sourceAction](...this.actionArguments);
                } else {
                  item.data[this.sourceAction](idx, item.data);
                }
              }
            } else if (item.data[this.sourceUrl]) {
              bbn.fn.link(item.data[this.sourceUrl]);
            }
          }
        }
      }
    },
    /**
     * @method unselect
     */
    unselect() {
      bbn.fn.each(bbn.fn.filter(this.currentData, a => {
        return this.selected.includes(a.data[this.sourceValue]);
      }), a => {
        if (a.selected) {
          a.selected = false;
        }
      });
      this.selected.splice(0, this.selected.length);
    },
    overByString(st) {
      let idx = bbn.fn.search(this.filteredData, 'data.' + this.sourceText, st, 'startswith');
      bbn.fn.log("overByString", st, idx);
      this.overIdx = idx;
    }
  },
  /**
   * @event created
   * @fires _updateIconSituation
   * @fires closest
   */
  created() {
    this.$on('dataloaded', () => {
      this._updateIconSituation();
    });
    this.$once('dataloaded', () => {
      if (this.selected && this.selected.length && this.uid) {
        this.$nextTick(() => {
          if (this.hasScroll) {
            let overIdx = bbn.fn.search(this.filteredData, 'data.' + this.uid, this.selected[0]),
              scroll = this.closest('bbn-scroll');
            if (scroll.ready) {
              this.isOver = false;
              this.overIdx = overIdx;
            } else {
              scroll.$once('ready', () => {
                this.$nextTick(() => {
                  setTimeout(() => {
                    this.isOver = false;
                    this.overIdx = overIdx;
                  }, 50);
                });
              });
            }
          }
        });
      }
    });
    if (!this.level) {
      this.rootList = this;
    } else {
      let cp = this.closest('bbn-list');
      if (!cp) {
        this.rootList = this;
      } else {
        while (cp && cp.level) {
          cp = cp.closest('bbn-list');
        }
        if (cp && !cp.level) {
          this.rootList = cp;
        }
      }
    }
  },
  /**
   * @event mounted
   * @fires $nextTick
   * @fires resetOverIdx
   */
  mounted() {
    this.$nextTick(() => {
      if (this.$parent.$options && this.$parent.$options._componentTag === 'bbn-scroll') {
        this.hasScroll = true;
      }
      this.ready = true;
      setTimeout(() => {
        this.resetOverIdx();
      }, 50);
    });
  },
  watch: {
    /**
     * @watch overIdx
     * @param {Number} newVal
     * @fires keepCool
     * @fires closest
     */
    overIdx(newVal) {
      this.keepCool(() => {
        if (this.hasScroll && newVal !== -1 && !this.isOver) {
          let sc = this.closest('bbn-scroll');
          if (sc) {
            sc.scrollTo(null, this.getRef('li' + newVal));
          }
        }
      }, 'overIdx', 50);
    },
    /**
     * @watch source
     * @fires updateData
     */
    source: {
      deep: true,
      handler() {
        if (this.isAutobind) {
          this.updateData();
        }
      }
    },
    filteredTotal(v, ov) {
      if (!ov) {
        this.$nextTick(() => {
          this.resetOverIdx();
        });
      }
      if (v < ov) {
        let fl = this.closest('bbn-scroll');
        if (fl) {
          fl.isResized = false;
          fl.onResize(true);
        }
      }
    }
    /*
    selected(){
      this.updateData();
    }
    */
  }
};

import cpHtml from './list.html';
import cpStyle from './list.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./list.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-list',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-list component
 *
 * @description A fully customizable selectable list.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.input],
  statics() {
    return {
      isClicked: false
    };
  },
  props: {
    //@todo not used.
    unique: {
      type: Boolean,
      default: true
    },
    /**
     * The mode of the component.
     * @prop {String} ['free'] mode
     */
    mode: {
      type: String,
      default: "free"
    },
    /**
     * @prop {Boolean} [false] suggest
     */
    suggest: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {};
  },
  computed: {},
  methods: {},
  /**
   * @event mounted
   */
  mounted() {}
};
import cpHtml from './list-input.html';
import cpStyle from './list-input.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./list-input.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-list-input',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-loadbar component
 *
 * @description bbn-loadbar component is a simple implementation component, it represents a bar with a display of wait state of a user-defined file.
 * Next to the loading icon, you'll find the path of the file from which the response is expected.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 15/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic 
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    //@todo not used
    encoded: {
      type: Boolean,
      default: true
    },
    //@todo not used
    position: {
      type: Object,
      default() {
        return {
          position: {
            bottom: 5,
            right: 5
          }
        };
      }
    },
    /**
     * The source of the component
     * @prop {Array} source
     */
    source: {
      type: Array
    },
    //@todo not used
    history: {
      type: Number,
      default: 100
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} isLoading
       */
      isLoading: false,
      //@todo not used
      isSuccess: false,
      //@todo not used
      isError: false,
      /**
       * @data {String} [''] text
       */
      text: '',
      //@todo not used
      id: false,
      //@todo not used
      selected: 0,
      //@todo not used
      numLoaded: 0,
      /**
       * @data {Boolean} [false] info
       */
      info: false,
      /**
      * @data {Boolean} [false] interval
      */
      interval: false,
      /**
      * @data {Boolean} [false] timeNow
      */
      timeNow: false,
      link: ''
    };
  },
  computed: {
    /**
     * @computed loadingItems 
     * @return {Array}
     */
    loadingItems() {
      return bbn.fn.filter(this.source, {
        loading: true
      });
    },
    /**
    * @computed loadedItems 
    * @return {Array}
    */
    loadedItems() {
      return bbn.fn.filter(this.source, {
        loading: false
      });
    },
    /**
     * @computed items
     * @return {Array}
     */
    items() {
      let items = [];
      bbn.fn.each(this.loadingItems, a => {
        let b = bbn.fn.clone(a);
        b.duration = this.timeNow - b.start;
        items.push(b);
      });
      return items.concat(this.loadedItems);
    },
    /** 
     * @computed currentItem
     * @return {Object|Boolean}
    */
    currentItem() {
      return this.loadingItems.length ? this.loadingItems[0] : this.loadedItems.length ? this.loadedItems[0] : false;
    }
  },
  methods: {
    contextMenu(item) {
      let res = [{
        text: bbn._("Copy URL"),
        icon: 'nf nf-mdi-content_copy',
        action() {
          bbn.fn.copy(item.url);
          appui.success(bbn._("Copied"));
        }
      }];
      if (item.loading) {
        res.push({
          text: bbn._("abort"),
          icon: 'nf nf-mdi-cancel',
          action: () => {
            this.cancel(item);
          }
        });
      }
      return res;
    },
    /**
     * Return the duration in seconds or milliseconds of a request
     * @method renderDuration
     * @param {Number} d
     * @return {Number}
     */
    renderDuration(d) {
      let tmp = d / 1000;
      if (tmp < 10) {
        return tmp.toFixed(3) + ' s';
      } else {
        return parseInt(tmp) + ' s';
      }
    },
    /**
     * Aborts the selected request
     * @method cancel
     * @param {Object} item 
     */
    cancel(item) {
      if (item.loading) {
        this.confirm(bbn._("Are you sure you want to abort this request?"), d => {
          bbn.fn.abort(item.key);
        });
      }
    },
    //@todo not used
    deleteHistory() {
      let tmp = [];
      bbn.fn.each(this.data, a => {
        if (a.isLoading) {
          tmp.push(a);
        }
      });
      this.data = tmp;
    },
    /**
     * Opens the given link
     * @method go
     */
    go() {
      if (this.link) {
        bbn.fn.link(this.link);
        this.hide();
      }
    },
    /**
     * Shows the information panel
     * @method show
     */
    show() {
      this.info = true;
    },
    /**
     * Hides the information panel
     * @method hide
     */
    hide() {
      this.info = false;
    }
  },
  watch: {
    source: {
      deep: true,
      handler(v, ov) {
        //bbn.fn.log(["WATCHING LOADBAR SOURCE", v, ov, v === ov])
        this.$forceUpdate();
      }
    },
    /*
    async currentItem(v) {
      await this.$forceUpdate();
    },
    */
    info(v) {
      if (this.interval) {
        clearInterval(this.interval);
      }
      if (v) {
        this.timeNow = bbn.fn.timestamp();
        this.interval = setInterval(() => {
          if (this.info) {
            this.timeNow = bbn.fn.timestamp();
          }
        }, 300);
      }
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    if (this.info) {
      this.interval = setInterval(() => {
        if (this.info) {
          this.timeNow = bbn.fn.timestamp();
        }
      }, 300);
    }
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    if (this.info) {
      clearInterval(this.interval);
    }
  }
};
import cpHtml from './loadbar.html';
import cpStyle from './loadbar.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./loadbar.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-loadbar',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-loader component
 *
 * @description The bbn-loader component has the purpose of graphically displaying a wait for the user with a simple implementation, asking to wait while something ends before being able to proceed.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 15/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer 
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],
  props: {
    //@todo not used
    source: {
      type: [Object, Array],
      default: function () {
        return {};
      }
    },
    /**
     * The text below the loader icon
     * @prop {String} ['Loading'] loadingText
     */
    text: {
      type: String,
      default: bbn._('Loading')
    },
    /**
     * The background color
     * @prop {String} [''] bgColor
     */
    bgColor: {
      type: String,
      default: ''
    },
    /**
     * The size of the font. Allowed values are 's', 'm', 'l', 'xl'
     * @prop {String} ['s'] fontSize
     */
    fontSize: {
      type: String,
      default: 's'
    },
    type: {
      type: String,
      default: 'cube_grid',
      validator(v) {
        return ['plane', 'chase', 'bounce', 'wave', 'pulse', 'flow', 'swing', 'circle', 'circle_fade', 'grid', 'fold', 'wander', 'cube_grid'].includes(v);
      }
    }
  },
  data() {
    return {
      //@todo not used
      minHeight: true,
      //@todo not used
      height: false,
      currentType: this.type
    };
  },
  mounted() {
    if (this.bgColor) {
      this.$el.style.backgroundColor = this.bgColor;
    }
  },
  methods: {
    //@todo not used
    /*onResize(){
      this.height = $(this.$el).height();
      //bbn.fn.log("HEIGHT", this.height);
      let currentFont = this.fontClass,
          currentMinHeight = this.minHeight;
      if( this.height >= 500 ){
        this.minHeight = true;
        this.fontClass = 'bbn-xxl';
      }
      else if (  this.height > 250 && this.height < 500 ){
        this.minHeight = true;
        this.fontClass = 'bbn-medium'
      }
      else if ( this.height <= 250 ){
        this.minHeight = false;
        this.fontClass = 'bbn-small'
      }
      if ( (currentFont !== this.fontClass) || (currentMinHeight !== this.minHeight) ){
        this.$forceUpdate();
      }
    }*/
  },
  computed: {
    /**
     * The css class corresponding to the prop fontSize
     * @computed fontClass
     * @return {String}
     */
    fontClass() {
      if (this.fontSize === 's') {
        return 'bbn-small';
      } else if (this.fontSize === 'm') {
        return 'bbn-medium';
      } else if (this.fontSize === 'l') {
        return 'bbn-large';
      } else if (this.fontSize === 'xl') {
        return 'bbn-xl';
      }
    }
  },
  watch: {
    type(v) {
      this.currentType = v;
    }
  }
};
import cpHtml from './loader.html';
import cpStyle from './loader.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./loader.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-loader',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-loadicon component
 *
 * @description bbn-loadicon is a simple implementation component, which represents an icon displaying a waiting state.
 *
 * @copyright BBN Solutions
 *
 * @author  BBN Solutions
 * 
 * @created 07/01/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic 
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * The size of the icon container
     * @prop {Number|String} [16] size
     */
    size: {
      type: [Number, String],
      default: 16
    }
  },
  data() {
    return {
      currentSize: bbn.fn.formatSize(this.size)
    };
  },
  watch: {
    size(v) {
      this.currentSize = bbn.fn.formatSize(v);
    }
  }
};
import cpHtml from './loadicon.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./loadicon.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-loadicon',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-login component
 * @description The bbn-login component
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 31/05/2021
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.popup
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.popup],
  props: {
    /**
     * The background color
     * @prop {String} [''] bgColor
     */
    bgColor: {
      type: String,
      default: 'transparent'
    },
    /**
     * The size of the font. Allowed values are 'xs', 's', 'm', 'l', 'xl'
     * @prop {String} ['xs'] fontSize
     */
    fontSize: {
      type: String,
      default: 'xs'
    },
    /**
     * @prop {String} logo
     */
    logo: {
      type: String
    },
    /**
     * @prop {String} [''] url
     */
    url: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} loginUrl
     */
    loginUrl: {
      type: String
    },
    /**
     * @prop {String} lostUrl
     */
    lostUrl: {
      type: String
    },
    /**
     * @prop {String} changeUrl
     */
    changeUrl: {
      type: String
    },
    /**
     * @prop {String} mode
     */
    mode: {
      type: String,
      required: true,
      validator: m => ['login', 'lost', 'change', 'invalid'].includes(m)
    },
    /**
     * @prop {Number} [1200000] expires
     */
    expires: {
      type: Number,
      default: 1200000
    },
    /**
     * @prop {String} [''] salt
     */
    salt: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} [''] secureId
     */
    secureId: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} [''] secureKey
     */
    secureKey: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} ['appui_action'] actionName
     */
    actionName: {
      type: String,
      default: 'appui_action'
    },
    /**
     * @prop {String} ['appui_salt'] saltName
     */
    saltName: {
      type: String,
      default: 'appui_salt'
    },
    /**
     * @prop {(Boolean|String)} ['Password forgotten?'] passwordLink
     */
    passwordLink: {
      type: [Boolean, String],
      default: bbn._("Password forgotten?")
    },
    /**
     * @prop {String} ['Login name'] loginFieldPlaceholder
     */
    loginFieldPlaceholder: {
      type: String,
      default: bbn._('Login name')
    },
    /**
     * @prop {String} ['Password'] passwordFieldPlaceholder
     */
    passwordFieldPlaceholder: {
      type: String,
      default: bbn._('Password')
    },
    /**
     * @prop {String} note
     */
    note: {
      type: String
    },
    /**
     * A custom HTML block to insert before the form
     * @prop {String} custom
     */
    custom: {
      type: String
    }
  },
  data() {
    const formData = {
      login: {
        [this.saltName]: this.salt,
        user: '',
        pass: ''
      },
      lost: {
        email: ''
      },
      change: {
        [this.actionName]: 'init_password',
        id: this.secureId,
        key: this.secureKey,
        pass1: '',
        pass2: ''
      }
    };
    return {
      isInit: false,
      /**
       * @data {String} currentMode
       */
      currentMode: this.mode,
      /**
       * @data {Object} [{}] formData
       */
      formData,
      currentFormData: bbn.fn.clone(formData[this.mode]),
      /**
       * @data {Boolean} [false] passwordVisible
       */
      passwordVisible: false,
      /**
       * @data {Boolean} [false] hasExpired
       */
      hasExpired: false,
      /**
       * @data {Number} clientHeight
       */
      clientHeight: document.documentElement.clientHeight
    };
  },
  computed: {
    /**
     * @computed isLogoTag
     * @return {Boolean}
     */
    isLogoTag() {
      return this.logo && this.logo.trim().substr(0, 1) === '<';
    },
    /**
     * @computed currentUrl
     * @return {String}
     */
    currentUrl() {
      return this[this.currentMode + 'Url'] || this.url;
    },
    /**
     * @computed currentFontSizeClass
     * @return {String}
     */
    currentFontSizeClass() {
      return `bbn-${this.fontSize === 'l' ? 'lg' : this.fontSize}`;
    }
  },
  methods: {
    /**
     * @method onSubmit
     * @param {Event} ev
     * @param {bbnCp} form
     * @emit submit
     */
    onSubmit(ev, form) {
      this.$emit('submit', ev, form);
    },
    /**
     * @method onAfterSubmit
     * @param d
     * @fires alert
     * @emit aftersubmit
     */
    onAfterSubmit(d) {
      let ev = new Event('aftersubmit', {
        cancelable: true
      });
      this.$emit('aftersubmit', ev, d, this.currentMode, this);
      if (ev.defaultPrevented) {
        return;
      }
      if (d == 1) {
        window.document.location.href = bbn.env.path;
      } else if (d.success) {
        if (this.currentMode === 'lost') {
          this.alert(bbn._('An email has been sent to %s', this.currentFormData.email), false);
          this.currentMode = 'login';
        } else if (this.currentMode === 'change') {
          //this.alert(bbn._('Your password has been changed'), false);
          //this.currentMode = 'login';
          this.alert(bbn._('Your password has been changed'), false, () => {}, () => {
            window.document.location.href = bbn.env.root;
          });
        }
      } else {
        this.alert(d.errorMessage, false);
      }
    },
    /**
     * @method setHeight
     */
    setHeight() {
      this.clientHeight = document.documentElement.clientHeight;
    },
    /**
     * @method resetForm
     * @fires $set
     */
    resetForm() {
      this.currentFormData = bbn.fn.clone(this.formData[this.currentMode]);
    },
    /**
     * @method validation
     * @fires alert
     * @return {Boolean}
     */
    validation() {
      if (!this.currentUrl || !this.currentUrl.length) {
        return false;
      }
      switch (this.currentMode) {
        case 'change':
          if (!this.currentFormData.pass1.length || !this.currentFormData.pass2.length || this.currentFormData.pass1 !== this.currentFormData.pass2) {
            this.alert(bbn._('Passwords must match!'), false);
            return false;
          }
        default:
          return true;
      }
    },
    /**
     * @method reload
     */
    reload() {
      window.location.reload();
    }
  },
  /**
   * @event mounted
   * @fires resetForm
   * @fires $nextTick
   * @fires alert
   */
  mounted() {
    this.resetForm();
    this.$nextTick(() => {
      setTimeout(() => {
        if (this.$el && this.$el.style) {
          this.isInit = true;
          bbn.fn.each(this.$el.querySelectorAll("input"), (element, i) => {
            if (element.style.visibility === 'visible') {
              element.focus();
              return false;
            }
          });
        }
      }, 1000);
      if (this.expires) {
        if (this.expires > 300000) {
          setTimeout(() => {
            this.alert(bbn._("This login form will expire in 5 minutes"));
          }, this.expires - 300000);
        }
        setTimeout(() => {
          if (this.$el && this.$el.innerHTML) {
            this.hasExpired = true;
          }
        }, this.expires);
      }
    });
    window.addEventListener('resize', this.setHeight);
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    window.removeEventListener('resize', this.setHeight);
  },
  watch: {
    /**
     * @watch mode
     * @param {String} val
     */
    mode(val) {
      this.currentMode = val;
    },
    /**
     * @watch currentMode
     * @fires resetForm
     */
    currentMode() {
      this.resetForm();
    }
  }
};
import cpHtml from './login.html';
import cpStyle from './login.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./login.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-login',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-code component
 *
 * @description bbn-code is a text editor.
 * It specializes in editing the code of a supported language. 
 * Various tools are provided to the users, which can be configured to their liking.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {},
  data() {
    return {
      /**
       * @todo not used
       */
      widget: null,
      /**
       * True if the editor is fullscreen.
       * @data {Boolan} [false] isFullScreen
       */
      isVisible: false
    };
  },
  computed: {},
  methods: {},
  /**
   * @event mounted
   * @fires initTern
   * @fires getRef
   * @emit  input
   */
  mounted() {},
  watch: {}
};
import cpHtml from './map.html';
import cpStyle from './map.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./map.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-map',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-markdown component
 *
 * @description bbn-markdown is a component that allows you to easily format the Markdown text.
 * It's an editor that enable you to create textual content, to insert lists, image management and hyperlinks.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */

import EasyMDE from 'easymde';
import { marked } from 'marked';
//Markdown editor use simpleMDe
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic 
   * @mixin bbn.cp.mixins.input 
   * @mixin bbn.cp.mixins.events 
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  statics() {
    const toolbar = [{
      name: "bold",
      className: "nf nf-fa-bold",
      title: bbn._("Bold"),
      action: window.EasyMDE.toggleBold
    }, {
      name: "italic",
      className: "nf nf-fa-italic",
      title: bbn._("Italic"),
      action: window.EasyMDE.toggleItalic
    }, {
      name: "heading",
      className: "nf nf-fa-header",
      title: bbn._("Heading"),
      children: [{
        name: "heading-1",
        className: "nf nf-md-format_header_1",
        title: bbn._("Heading") + " 1",
        action: window.EasyMDE.toggleHeading1
      }, {
        name: "heading-2",
        className: "nf nf-md-format_header_2",
        title: bbn._("Heading") + " 2",
        action: window.EasyMDE.toggleHeading2
      }, {
        name: "heading-3",
        className: "nf nf-md-format_header_3",
        title: bbn._("Heading") + " 3",
        action: window.EasyMDE.toggleHeading3
      }, {
        name: "heading-4",
        className: "nf nf-md-format_header_4",
        title: bbn._("Heading") + " 4",
        action: window.EasyMDE.toggleHeading4
      }, {
        name: "heading-5",
        className: "nf nf-md-format_header_5",
        title: bbn._("Heading") + " 5",
        action: window.EasyMDE.toggleHeading5
      }, {
        name: "heading-6",
        className: "nf nf-md-format_header_6",
        title: bbn._("Heading") + " 6",
        action: window.EasyMDE.toggleHeading6
      }]
    }, "|", {
      name: "quote",
      className: "nf nf-fa-quote_left",
      title: bbn._("Quote"),
      action: window.EasyMDE.toggleBlockquote
    }, {
      name: "unordered-list",
      className: "nf nf-fa-list_ul",
      title: bbn._("Generic List"),
      action: window.EasyMDE.toggleUnorderedList
    }, {
      name: "ordered-list",
      className: "nf nf-fa-list_ol",
      title: bbn._("Numbered List"),
      action: window.EasyMDE.toggleOrderedList
    }, "|", {
      name: "link",
      className: "nf nf-fa-link",
      title: bbn._("Create Link"),
      action: window.EasyMDE.drawLink
    }, {
      name: "image",
      className: "nf nf-fa-image",
      title: bbn._("Insert Image"),
      action: window.EasyMDE.drawImage
    }, "|", {
      name: "preview",
      className: "nf nf-fa-eye no-disable",
      title: bbn._("Toggle Preview"),
      action: window.EasyMDE.togglePreview
    }, {
      name: "side-by-side",
      className: "nf nf-fa-columns no-disable no-mobile",
      title: bbn._("Toggle Side by Side"),
      action: window.EasyMDE.toggleSideBySide,
      default: true
    }, {
      name: "fullscreen",
      className: "nf nf-fa-arrows_alt no-disable no-mobile",
      title: bbn._("Toggle Fullscreen"),
      action: window.EasyMDE.toggleFullScreen
    }, "|", {
      name: "guide",
      action: () => bbn.fn.link("https://simplemde.com/markdown-guide"),
      className: "nf nf-fa-question-circle",
      title: bbn._("Markdown Guide")
    }];
    return {
      toolbar
    };
  },
  props: {
    /**
     * The object of configuration
     * @prop {Object} cfg
     */
    cfg: {
      type: Object,
      default() {
        return {};
      }
    },
    //@todo not used
    toolBar: {
      type: Array
    },
    //@todo not used
    hideIcons: {
      type: Array
    }
  },
  data() {
    return {
      widgetName: "EasyMDE",
      sideBySideFullscreen: false,
      nativeSpellcheck: this.cfg.nativeSpellCheck || false,
      spellChecker: this.cfg.spellChecker || false,
      indentWithTabs: this.cfg.indentWithTabs === undefined ? true : this.cfg.indentWithTabs,
      initialValue: this.value,
      insertTexts: {
        horizontalRule: ["", "\n\n-----\n\n"],
        image: ["![](https://", ")"],
        link: ["[", "](https://)"],
        table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text      | Text     |\n\n"]
      },
      autoDownloadFontAwesome: false,
      renderingConfig: {
        singleLineBreaks: true,
        codeSyntaxHighlighting: true
      },
      minHeight: "100px",
      status: false,
      tabSize: this.cfg.tabSize || 2,
      toolbarTips: true,
      shortcuts: {
        drawTable: "Cmd-Alt-T"
      }
    };
  },
  computed: {
    compiled() {
      return this.value ? window.marked.parse(this.value) : '';
    },
    toolbar() {
      if (this.readonly) {
        return false;
      }
      return this.toolBar || bbnMarkdownCp.toolbar;
    }
  },
  methods: {
    disableWidget(v) {
      this.widget.codemirror.setOption('disableInput', !!v);
      if (!v && !this.readonly) {
        this.widget.codemirror.setOption('readOnly', false);
        this.$el.querySelector(".editor-toolbar").display = 'block';
      } else {
        this.widget.codemirror.setOption('readOnly', true);
        this.$el.querySelector(".editor-toolbar").display = 'none';
      }
    },
    readonlyWidget(v) {
      this.widget.codemirror.setOption('readOnly', !!v);
      if (!v && !this.isDisabled) {
        this.$el.querySelector(".editor-toolbar").display = 'block';
      } else {
        this.$el.querySelector(".editor-toolbar").display = 'none';
      }
    }
  },
  watch: {
    isDisabled(newVal) {
      this.disableWidget(newVal);
    },
    readonly(newVal) {
      this.readonlyWidget(newVal);
    }
  },
  mounted() {
    const vm = this;
    /*let cfg = bbn.fn.extend(vm.getOptions(), {
      change: function(e){
        vm.emitInput(vm.widget.value());
        return true
      }
    });*/
    this.widget = new window.EasyMDE(bbn.fn.extend({
      element: this.$refs.element,
      value: this.value
    }, this.$data, toolbar));
    this.widget.codemirror.on("change", () => {
      this.emitInput(this.widget.value());
    });
    if (this.isDisabled) {
      this.disableWidget(true);
    }
    if (this.readonly) {
      this.readonlyWidget(true);
    }
    this.ready = true;
  }
};
import cpHtml from './markdown.html';
import cpStyle from './markdown.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./markdown.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
const def = {
  name: 'bbn-markdown',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
export { def as default, EasyMDE, marked };
/**
 * @file bbn-masked component
 * @description bbn-masked is a component that allows the full control of data to be processed.
 * It represents an input box that allows the user to insert values in a given format.
 * @copyright BBN Solutions
 * @author Mirko Argentino
 */
const cpDef = {
  /**
      * @mixin bbn.cp.mixins.basic
      * @mixin bbn.cp.mixins.input
      * @mixin bbn.cp.mixins.events
      */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /** 
     * The required mask pattern.
     * 
     * @prop {String} mask
     * @required true
    */
    mask: {
      type: String,
      required: true,
      validator: val => !!val.length
    },
    /** 
     * The character used for the prompt.
     * 
     * @prop {String} ['_'] promptChar
    */
    promptChar: {
      type: String,
      default: '_'
    },
    /**
       * Defines the pattern of this elemenet
       * @prop {String} pattern
       */
    pattern: {
      type: String
    }
  },
  data() {
    return {
      /** 
       * The escape symbol.
       * 
       * @data {String} ['\'] escape
      */
      escape: '\\',
      /** 
       * The patterns list.
       * 
       * @data {Object} patterns
      */
      patterns: {
        // Digit. Accepts any digit between 0 and 9.
        0: {
          pattern: '[0-9]'
        },
        // Digit or space. Accepts any digit between 0 and 9, plus space.
        9: {
          pattern: '[0-9\\s]'
        },
        // Digit or space. Like 9 rule, but allows also (+) and (-) signs.
        '#': {
          pattern: '[0-9\\s\\+\\-]'
        },
        // Letter. Restricts the input to letters a-z and A-Z. This rule is equivalent to [a-zA-Z] in regular expressions.
        'L': {
          pattern: '[a-zA-Z]'
        },
        // Letter or space. Restricts the input to letters a-z and A-Z. This rule is equivalent to [a-zA-Z] in regular expressions.
        '?': {
          pattern: '[a-zA-Z\\s]'
        },
        // Character. Accepts any character. The rule is equivalent to \S in regular expressions.
        // in this case, promptChar can't be special character. eg: It can't be "_"
        '&': {
          pattern: '[0-9a-zA-Z\\S]'
        },
        // Character or space. Accepts any character. The rule is equivalent to . in regular expressions.
        // in this case, promptChar can't be special character. eg: It can't be "_"
        'C': {
          pattern: '.'
        },
        // Alphanumeric. Accepts letters and digits only.
        'A': {
          pattern: '[0-9a-zA-Z]'
        },
        // Alphanumeric or space. Accepts letters, digits and spaces only.
        'a': {
          pattern: '[0-9a-zA-Z\\s]'
        },
        // Decimal placeholder. The decimal separator will be generated from the bbn.env.money property.
        '.': {
          static: bbn.env && bbn.env.money && bbn.env.money.decimal ? bbn.env.money.decimal : '.'
        },
        // Thousands placeholder. The display character will be generated from the bbn.env.money property.
        ',': {
          static: bbn.env && bbn.env.money && bbn.env.money.thousands ? bbn.env.money.thousands : ','
        },
        // Currency symbol. The display character will be generated from the bbn.env.money property.
        '$': {
          static: bbn.env && bbn.env.money && bbn.env.money.currency ? bbn.env.money.currency : ''
        }
      },
      /** 
       * The current input value.
       * 
       * @data inputValue {String} inoutValue
      */
      inputValue: ''
    };
  },
  computed: {
    /** 
     * The list of escape positions in the mask.
     * 
     * @computed escapePos
     * @returns {Array}
    */
    escapePos() {
      if (!this.mask) {
        return [];
      }
      let exp = Object.keys(this.patterns).map(p => {
          return this.escape.repeat(p === '?' ? 4 : 2) + p;
        }).join('|'),
        reg = new RegExp(exp, 'gu'),
        res = [],
        match;
      while (match = reg.exec(this.mask)) {
        res.push(match.index);
      }
      return res;
    },
    /** 
     * The list of banned positions in the mask.
     * The position indexes are created without considering the positions with the escape symbol.
     * 
     * @computed bannedPos
     * @returns {Array}
    */
    bannedPos() {
      let pos = [],
        idx = 0;
      bbn.fn.each([...this.mask], (c, i) => {
        if (!this.escapePos.includes(i) && (!this.patterns[c] || this.patterns[c].static || this.escapePos.includes(i - 1))) {
          if (this.escapePos.includes(i - 1)) {
            idx--;
          }
          pos.push(idx);
        }
        idx++;
      });
      return pos;
    },
    /** 
     * The list of banned positions in the mask.
     * The position indexes are created by considering the positions with the escape symbol.
     * 
     * @computed bannedPosRaw
     * @returns {Array}
    */
    bannedPosRaw() {
      let pos = [];
      bbn.fn.each([...this.mask], (c, i) => {
        if (!this.escapePos.includes(i) && (!this.patterns[c] || this.patterns[c].static || this.escapePos.includes(i - 1))) {
          pos.push(i);
        }
      });
      return pos;
    },
    /** 
     * A list of relations between positions in the mask.
     * 
     * @computed posLink
     * @returns {Array}
    */
    posLink() {
      let pos = {},
        idx = 0;
      bbn.fn.each([...this.mask], (c, i) => {
        //if ( c !== this.escape ){
        if (!this.escapePos.includes(i)) {
          if (this.escapePos.includes(i - 1)) {
            idx--;
          }
          pos[idx] = i;
        }
        idx++;
      });
      return pos;
    },
    /**
     * The maximum value length calculated from the mask.
     * 
     * @computed maxLeng
     * @returns {Number}
     */
    maxLen() {
      return [...this.mask].filter((c, i) => {
        return !!(!this.escapePos.includes(i - 1) && !this.bannedPosRaw.includes(i) && this.patterns[c] && this.patterns[c].pattern);
      }).length;
    },
    /**
     * The maximum position.
     *
     * @computed maxPos
     * @returns {Number}
     */
    maxPos() {
      return this.mask.length - this.escapePos.length;
    },
    /**
       * The current input width in characters if the 'autosize' is enabled
       * @computed currentInputSize
       * @returns {Number}
       */
    currentInputSize() {
      if (this.autosize) {
        let val = this.getInputValue();
        return val.length || 1;
      }
      return 0;
    }
  },
  methods: {
    /**
     * Checks if the given character is valid, based on the mask's pattern.
     *
     * @method isValidChar
     * @param {String} char
     * @param {Number} pos
     * @returns {Boolean}
     */
    isValidChar(char, pos) {
      let k = this.mask.charAt(this.posLink[pos]);
      return !!(this.patterns[k] && this.patterns[k].pattern && char.match(this.patterns[k].pattern) && char !== this.promptChar);
    },
    /**
     * Checks if the pressed key is a special key.
     * 
     * @method isSpecialKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isSpecialKey(keyCode) {
      switch (keyCode) {
        case 8: //Backspace
        case 9: //Tab
        case 16: //Shift
        case 18: //AltGraph
        case 35: //End
        case 36: //Home
        case 37: //ArrowLeft
        case 39: //ArrowRight
        case 46:
          //Canc
          return true;
        default:
          return false;
      }
    },
    /**
     * Cheks if the pressed key is an arrow key.
     *
     * @method isArrowKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isArrowKey(keyCode) {
      switch (keyCode) {
        case 35: //End
        case 36: //Home
        case 37: //ArrowLeft
        case 39:
          //ArrowRight
          return true;
        default:
          return false;
      }
    },
    /**
     * Checks if the pressed key is the "shift" key.
     *
     * @method isShiftKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isShiftKey(keyCode) {
      return keyCode === 16;
    },
    /**
     * Checks if the pressed key is the "control" key.
     *
     * @method isControlKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isControlKey(keyCode) {
      return keyCode === 17;
    },
    /**
     * Checks if the pressed key is the "backspace" key.
     *
     * @method isBackspaceKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isBackspaceKey(keyCode) {
      return keyCode === 8;
    },
    /**
     * Checks if the pressed key is the "canc" key.
     *
     * @method isCancKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isCancKey(keyCode) {
      return keyCode === 46;
    },
    /**
     * Checks if the pressed key is the "tab" key.
     *
     * @method isTabKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isTabKey(keyCode) {
      return keyCode === 9;
    },
    /**
     * Checks if the pressed key is the "enter" key.
     *
     * @method isEnterKey
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    isEnterKey(keyCode) {
      return keyCode === 13;
    },
    /**
     * Sets the data property 'inputValue'.
     *
     * @method setInputValue
     * @fires getInputValue
     * @fires $forceUpdate
     */
    setInputValue() {
      this.inputValue = '';
      this.inputValue = this.getInputValue();
      this.$forceUpdate();
    },
    /**
     * Gets the input value.
     *
     * @method getInputValue
     * @param {String} value
     * @returns {String}
     */
    getInputValue(value) {
      let ret = '',
        idxValue = 0;
      value = (value === undefined ? !!this.value ? this.value : '' : value).toString();
      bbn.fn.each([...this.mask], (c, i) => {
        if (!this.escapePos.includes(i) && !this.bannedPosRaw.includes(i) && this.patterns[c] && this.patterns[c].pattern) {
          if (value && value.charAt(idxValue) && value.charAt(idxValue).match(this.patterns[c].pattern)) {
            ret += value.charAt(idxValue);
          } else if (this.escapePos.includes(i - 1)) {
            ret += c;
          } else {
            ret += this.promptChar;
          }
          idxValue++;
        } else if (!this.escapePos.includes(i)) {
          ret += this.patterns[c] && this.patterns[c].static ? this.patterns[c].static : c;
        }
      });
      return ret;
    },
    /** 
     * Gets the correct cursor position.
     * 
     * @method getPos
     * @param {Number} pos The original position
     * @param {Event} event The key event
     * @fires isBackspaceKey
     * @returns {Number}
    */
    getPos(pos, event) {
      let originalPos = pos;
      if (pos < 0) {
        pos = 0;
      } else if (pos > this.maxPos) {
        pos = this.maxPos;
      }
      if (event && (this.isBackspaceKey(event.keyCode) || event.keyCode === 37)) {
        while (pos > 0 && this.bannedPos.includes(event.type === 'keydown' ? pos - 1 : pos)) {
          pos--;
        }
      } else {
        while (pos < this.maxPos && this.bannedPos.includes(pos)) {
          pos++;
        }
      }
      return pos < 0 || pos > this.maxPos ? originalPos : pos;
    },
    /**
     * Finds and returns the start and the end position of the value by two points of the inputValue.
     * 
     * @method getIdxRange
     * @param {Number} start
     * @param {Number} end
     * @returns {String}
     */
    getIdxRange(start, end) {
      let val = !!this.value ? this.value.toString() : '',
        idxStart = -1,
        idxEnd = -1;
      for (let i = 0; i <= end; i++) {
        if (!this.bannedPos.includes(i)) {
          if (i <= start) {
            idxStart++;
          }
          if (i <= end) {
            idxEnd++;
          }
        }
      }
      return {
        start: idxStart < 0 ? 0 : idxStart,
        end: idxEnd
      };
    },
    /** 
     * The method called on every key pressed (keydown event).
     * 
     * @method keydownEvent
     * @param {Event} event
     * @fires isShiftKey
     * @fires isControlKey
     * @fires isArrowKey
     * @fires isCancKey
     * @fires isBackspaceKey
     * @fires getPos
     * @fires isSpecialKey
     * @fires isValidChar
     * @fires emitInput
     * @fires raw
     * @fires setInputValue
     * @fires keydown
     * @fires getIdxRange
     * @emits input
    */
    keydownEvent(event) {
      if (!this.isDisabled && !this.readonly) {
        if (!this.isShiftKey(event.keyCode) && !this.isControlKey(event.keyCode) && !this.isArrowKey(event.keyCode) && !this.isTabKey(event.keyCode) && !event.ctrlKey && !this.isEnterKey(event.keyCode)) {
          let isSelection = this.$refs.element.selectionStart !== this.$refs.element.selectionEnd,
            value = this.value ? this.value.toString() : '';
          // Check max length
          if (!this.isCancKey(event.keyCode) && !this.isBackspaceKey(event.keyCode) && !isSelection && (bbn.fn.isNumber(this.maxLen) && value.length >= parseInt(this.maxLen) || this.size !== undefined && bbn.fn.isNumber(this.size) && value.length >= this.size || this.maxlength !== undefined && bbn.fn.isNumber(this.maxlength) && value.length >= parseInt(this.maxlength))) {
            event.preventDefault();
            return;
          }
          // Get the correct cursor position
          let pos = this.getPos(this.$refs.element.selectionStart, event);
          // Not special key and not valid char
          if (!this.isSpecialKey(event.keyCode) && !this.isValidChar(event.key, pos)) {
            event.preventDefault();
          }
          // Input
          else if (!this.isSpecialKey(event.keyCode) && (this.inputValue.charAt(pos) !== this.promptChar || isSelection)) {
            let p = this.getIdxRange(isSelection ? this.$refs.element.selectionStart : pos, isSelection ? this.$refs.element.selectionEnd - 1 : pos);
            p.end = isSelection ? p.end + 1 : p.start;
            value = value.slice(0, p.start) + event.key + value.slice(p.end);
            this.emitInput(value);
            this.$nextTick(() => {
              this.setInputValue();
              this.$nextTick(() => {
                this.$refs.element.setSelectionRange(pos + 1, pos + 1);
              });
            });
            event.preventDefault();
          }
          // Canc and Backspace
          else if (this.isCancKey(event.keyCode) || this.isBackspaceKey(event.keyCode)) {
            event.preventDefault();
            // Delete from a selection
            if (isSelection) {
              let pos = this.$refs.element.selectionStart,
                p = this.getIdxRange(this.$refs.element.selectionStart, this.$refs.element.selectionEnd - 1);
              this.emitInput(value.slice(0, p.start) + value.slice(p.end + 1));
              this.$nextTick(() => {
                this.setInputValue();
                this.$nextTick(() => {
                  this.$refs.element.setSelectionRange(pos, pos);
                });
              });
            }
            // Normal backspace and canc
            else {
              if (this.isBackspaceKey(event.keyCode) && pos > 0) {
                this.inputValue = this.inputValue.slice(0, pos - 1) + this.promptChar + this.inputValue.slice(pos);
                pos--;
              } else if (this.isCancKey(event.keyCode) && pos < this.maxPos) {
                this.inputValue = this.inputValue.slice(0, pos) + this.promptChar + this.inputValue.slice(pos + 1);
              }
              this.$nextTick(() => {
                this.emitInput(this.raw());
                this.$nextTick(() => {
                  this.setInputValue();
                  this.$nextTick(() => {
                    this.$refs.element.setSelectionRange(pos, pos);
                  });
                });
              });
            }
          } else if (event.shiftKey && this.isArrowKey(event.keyCode)) {
            this.$refs.element.selectionStart = pos;
          } else {
            this.$refs.element.setSelectionRange(pos, pos);
          }
        }
        this.keydown(event);
      }
    },
    /** 
     * The method called on every key pressed (keyup event).
     * 
     * @method keyupEvent
     * @param {Event} event
     * @fires isShiftKey
     * @fires isControlKey
     * @fires getPos
     * @fires isArrowKey
     * @fires keyup
    */
    keyupEvent(event) {
      if (!this.isDisabled && !this.readonly) {
        if (!this.isShiftKey(event.keyCode) && !this.isControlKey(event.keyCode) && !this.isTabKey(event.keyCode) && !event.ctrlKey) {
          let pos = this.$refs.element.selectionStart;
          this.$nextTick(() => {
            pos = this.getPos(pos, event);
            if (event.shiftKey && this.isArrowKey(event.keyCode)) {
              this.$refs.element.selectionStart = pos;
            } else {
              this.$refs.element.setSelectionRange(pos, pos);
            }
          });
        }
        this.keyup(event);
      }
    },
    /**
     * The method called on input event.
     * 
     * @method inputEvent
     * @param {Event} event
     * @fires isValidChar
     * @fires emitInput
     * @fires raw
     * @emits input
     */
    inputEvent(event) {
      let pos = this.$refs.element.selectionStart;
      //bbn.fn.log('input', event, pos, this.maxPos)
      if (pos <= this.maxPos && !bbn.fn.isNull(event.data) && this.isValidChar(event.data, pos - 1) && this.inputValue.charAt(pos - 1) === this.promptChar && pos === this.$refs.element.selectionEnd) {
        this.inputValue = this.inputValue.slice(0, pos - 1) + event.data + this.inputValue.slice(pos);
        this.$nextTick(() => {
          this.emitInput(this.raw());
          this.$refs.element.setSelectionRange(pos, pos);
        });
      }
    },
    /**
     * The method called on blur event.
     * 
     * @method blurEvent
     * @param {Event} event
     * @fires blur
     */
    blurEvent(event) {
      if (!this.isDisabled && !this.readonly) {
        if (!this.value) {
          this.inputValue = '';
        }
        this.blur(event);
      }
    },
    /**
     * The method called on focus event.
     *
     * @method focusEvent
     * @param {Event} event
     * @fires setInputValue
     * @fires focus
     */
    focusEvent(event) {
      if (!this.isDisabled && !this.readonly) {
        this.setInputValue();
        this.$nextTick(() => {
          this.$refs.element.setSelectionRange(0, 0);
        });
        this.focus(event);
      }
    },
    /** 
     * The method called on paste event.
     * 
     * @method pasteEvent
     * @param {Event} event
     * @fires getPos
     * @fires getIdxRange
     * @fires clearText
     * @fires emitInput
    */
    pasteEvent(event) {
      if (!this.isDisabled && !this.readonly) {
        let text = event.clipboardData ? event.clipboardData.getData('text') : '',
          pos = this.getPos(this.$refs.element.selectionStart),
          p = this.getIdxRange(0, pos),
          val = this.value.toString();
        event.preventDefault();
        text = this.clearText(text, pos);
        val = val.slice(p.start, p.end) + text + val.slice(p.end);
        pos = p.end + text.length + 1;
        this.emitInput(val.slice(0, this.maxLen));
        this.$nextTick(() => {
          this.$refs.element.setSelectionRange(pos, pos);
        });
      }
    },
    /**
     * The method called on cut event.
     * 
     * @method cutEvent
     * @param {Event} event 
     * @fires getPos
     * @fires getIdxRange
     * @fires clearText
     * @fires emitInput
     */
    cutEvent(event) {
      if (!this.isDisabled && !this.readonly) {
        let sel = document.getSelection(),
          text = sel.toString(),
          oriPos = this.$refs.element.selectionStart,
          pos = this.getPos(oriPos),
          p = this.getIdxRange(0, pos),
          val = this.value.toString();
        event.preventDefault();
        document.execCommand('copy');
        text = this.clearText(text, pos);
        val = val.slice(p.start, p.end) + val.slice(p.end + text.length);
        this.emitInput(val.slice(0, this.maxLen));
        this.$nextTick(() => {
          this.$refs.element.setSelectionRange(oriPos, oriPos);
        });
      }
    },
    /**
     * Removes the invalid characters from a string.
     * 
     * @method clearText
     * @param {String} text
     * @param {Number} pos
     * @fires isValidChar
     * @fires getPos
     * @returns {String}
     */
    clearText(text, pos) {
      let ret = '';
      if (text) {
        bbn.fn.each([...text], (c, i) => {
          if (this.isValidChar(c, pos)) {
            ret += c;
            pos = this.getPos(pos);
          }
        });
      }
      return ret;
    },
    /**
     * Gets the raw value.
     *
     * @method raw
     * @returns {String}
     */
    raw(value) {
      let ret = '';
      value = (value !== undefined ? value : this.$refs.element.value || '').toString();
      if (value) {
        bbn.fn.each([...value], (c, i) => {
          if (!this.bannedPos.includes(i) && this.patterns[this.mask[this.posLink[i]]] && this.patterns[this.mask[this.posLink[i]]].pattern) {
            if (c.match(this.patterns[this.mask[this.posLink[i]]].pattern) && c !== this.promptChar) {
              ret += c;
            }
          }
        });
      }
      return ret;
    }
  },
  /**
   * @event mounted
   * @fires setInputValue
   */
  mounted() {
    if (this.value) {
      this.setInputValue();
    }
    this.ready = true;
  },
  watch: {
    value(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.setInputValue();
      }
    },
    mask() {
      this.$nextTick(() => {
        let pos = this.value.length;
        this.getRef('element').setSelectionRange(pos, pos);
      });
    }
  }
};
import cpHtml from './masked.html';
import cpStyle from './masked.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./masked.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-masked',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-masonry component
 * @description bbn-masonry
 * @copyright BBN Solutions
 * @author Mirko Argentino
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.list],
  props: {
    /**
     * Set to true to allow the component to have a scroll.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * The gap between the columns.
     * @prop {Number} [20] columnGap
     */
    columnGap: {
      type: Number,
      default: 20
    },
    /**
     * The gap between the rows.
     * @prop {Number} [20] rowGap
     */
    rowGap: {
      type: Number,
      default: 20
    },
    /**
     * The minimum number of columns allowed.
     * @prop {Number} [1] minCol
     */
    minCol: {
      type: Number,
      default: 1
    },
    /**
     * The maximum number of columns allowed.
     * @prop {Number} maxCol
     */
    maxCol: {
      type: Number
    },
    /**
     * The width of the items.
     * @prop {Number} [350] itemWidth
     */
    itemWidth: {
      type: Number,
      default: 350
    }
  },
  data() {
    return {
      fromSlot: []
    };
  },
  computed: {
    /**
     * The number of columns.
     * @computed cols
     * @return {Number}
     */
    cols() {
      return parseInt(this.lastKnownWidth / (this.itemWidth + this.columnGap)) || 1;
    },
    /**
     * @computed containerStyle
     * @return {Object}
     */
    containerStyle() {
      return {
        gridTemplateColumns: `repeat(${this.cols}, 1fr)`,
        gridGap: `${this.columnGap}px`
      };
    },
    items() {
      let d = [...this.currentData];
      if (this.fromSlot.length) {
        let idx = this.currentData.length;
        bbn.fn.each(this.fromSlot, s => {
          d.push({
            index: idx,
            slot: true,
            content: s.content
          });
          idx++;
        });
      }
      return d;
    }
  },
  /**
   * @event mounted
   * @fires $nextTick
   */
  mounted() {
    this.$nextTick(() => {
      /*
      if (this.$slots.default) {
        let toData = [];
        for (let node of this.$slots.default) {
          if (!!node.componentOptions
            && (node.componentOptions.tag === 'bbns-masonry')
            ) {
            toData.push({
              content: node.elm.innerHTML.trim()
            });
          }
        }
        this.fromSlot.push(...toData);
      }
      */
      this.ready = true;
    });
  },
  components: {
    slotItem: {
      name: 'bbns-masonry'
    },
    masonryCol: {
      name: 'masonry-col',
      props: {
        /**
         * The source of the component 'masonry-col'.
         * @prop {Array} [[]] source
         * @memberof masonry-col
         */
        source: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * The index of the column.
         * @prop {Number} index
         * @memberof masonry-col
         */
        index: {
          type: Number
        }
      },
      computed: {
        /**
         * The parent masonry component.
         * @computed masonry
         * @memberof masonry-col
         * @return {Object}
         */
        masonry() {
          return this.closest('bbn-masonry');
        },
        /**
         * The style object of the column.
         * @computed colStyle
         * @memberof masonry-col
         * @return {Object}
         */
        colStyle() {
          return {
            width: '100%',
            margin: `0 ${this.index + 1 < this.masonry.cols ? this.masonry.columnGap : 0}px 0 0`,
            verticalAlign: 'top',
            display: 'inline-block'
          };
        }
      },
      components: {
        /**
         * @component masonryItem
         * @memberof masonry-col
         */
        masonryItem: {
          name: 'masonry-item',
          props: {
            /**
             * The source of the compoment 'masonry-item'.
             * @prop {String|Object} source
             * @memberof masonry-item
             */
            source: {
              type: [String, Object]
            }
          },
          computed: {
            /**
             * The parent component 'masonry-col'.
             * @computed col
             * @memberof masonry-item
             * @return {bbnCp}
             */
            col() {
              return this.closest('masonry-col');
            },
            itemStyle() {
              return {
                marginBottom: this.col.index < this.col.masonry.cols ? this.col.masonry.rowGap + 'px' : 0
              };
            }
          }
        }
      }
    }
  }
};
import cpHtml from './masonry.html';
import cpStyle from './masonry.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./masonry.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-masonry',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-menu component
 * @description The bbn menu with a simple implementation shows a hierarchical list of elements grouped in boxes that when clicked perform an action defined by the user .
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 10/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list],
  props: {
    /**
     * @prop {} orientation
     */
    orientation: {},
    /**
     * @prop {} direction
     */
    direction: {},
    /**
     * @prop {} opened
     */
    opened: {},
    /**
     * @prop {Number} [-1] selectedIndex
     */
    selectedIndex: {
      type: Number,
      default: -1
    },
    /**
     * @prop {} ['text'] sourceValue
     */
    sourceValue: {
      default: 'text'
    },
    /**
     * @prop {} ['url'] sourceUrl
     */
    sourceUrl: {
      default: 'url'
    },
    /**
     * @prop {String} ['items'] children
     */
    children: {
      type: String,
      default: 'items'
    }
  },
  data() {
    return {
      currentSelectedIndex: this.selectedIndex,
      overIdx: -1,
      isChanging: false
    };
  },
  methods: {
    _enterLi(idx) {
      //bbn.fn.log("ENTER LI");
      if (idx > -1 && this.overIdx !== idx) {
        this.overIdx = idx;
        this.getRef('li' + idx).focus();
      }
    },
    clickLi(idx, ev) {
      //bbn.fn.log("clickLi", idx, this.overIdx);
      if (this.filteredData[idx]) {
        if (this.filteredData[idx].data[this.children] && this.filteredData[idx].data[this.children].length) {
          this.overIdx = this.overIdx === idx ? -1 : idx;
        } else {
          this.select(this.filteredData[idx].data, idx, idx, ev);
        }
        this.currentSelectedIndex = idx;
      }
    },
    onKeyDown(idx, ev) {
      //bbn.fn.log(ev);
      let floater = this.getRef('floater');
      if (floater) {
        let list = floater.getRef('list');
        if (list) {
          list.keynav(ev);
        }
      } else if (ev.key === ' ' || ev.key === 'Enter') {
        this.clickLi(idx, ev);
      }
    },
    onFocus(idx) {
      if (this.filteredData[this.overIdx] && this.filteredData[idx]) {
        this.overIdx = idx;
      }
    },
    onClose() {
      //getRef('li' + selectedElement).blur(); selectedElement = -1;
    },
    select(item, idx, idx2, ev) {
      if (this.selection) {
        let selected = this.currentSelected.includes(this.filteredData[idx].index);
        if (!this.multiple) {
          this.currentSelected.splice(0);
        }
        if (!selected) {
          this.currentSelected.push(this.filteredData[idx].index);
        } else if (!!this.multiple) {
          this.currentSelected.splice(this.currentSelected.indexOf(this.filteredData[idx].index), 1);
        }
      }
      if (this.sourceUrl && item[this.sourceUrl]) {
        bbn.fn.link(item[this.sourceUrl]);
      }
      this.$emit('select', item, idx, idx2, ev);
    }
    /*onDataLoaded(){         
      this.$emit('onDataLoaded', this);
    }*/
  },

  watch: {
    filteredData: {
      deep: true,
      handler() {
        this.isChanging = true;
        this.$forceUpdate().then(() => {
          setTimeout(() => {
            this.isChanging = false;
            this.$forceUpdate().then(() => {
              const floater = this.getRef('floater');
              if (floater) {
                floater.updateData();
                floater.onResize(true);
              }
            }, 50);
          });
        });
      }
    },
    overIdx(nv, ov) {
      if (nv > -1) {
        this.isChanging = true;
        this.$forceUpdate().then(() => {
          setTimeout(() => {
            this.isChanging = false;
            this.$forceUpdate().then(() => {
              const floater = this.getRef('floater');
              if (floater) {
                floater.updateData();
                floater.onResize(true);
              }
            }, 50);
          });
        });
      }
    }
  },
  mounted() {
    this.ready = true;
  }
};
import cpHtml from './menu.html';
import cpStyle from './menu.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./menu.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-menu',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-message component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/01/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    position: {},
    cfg: {
      type: Object,
      default() {
        return {
          position: "tr"
        };
      }
    }
  },
  data() {
    return {
      todo: {},
      isShown: false,
      num: 0
    };
  },
  methods: {
    _getCfg(obj, type, timeout) {
      var group = type ? type : 'info',
        cfg = {
          time: new Date(),
          type: group,
          widget: {
            cssClass: group
          }
        };
      if (typeof obj !== 'object') {
        obj = {
          text: obj.toString()
        };
      } else if (obj.widget) {
        return obj;
      }
      if (timeout === false) {
        cfg.close = true;
      } else if (timeout) {
        cfg.timeout = timeout;
      }
      if (obj.html) {
        cfg.html = obj.html;
      } else if (obj.text) {
        cfg.html = '<div>' + obj.text + '</div>';
      }
      cfg.title = obj.title ? obj.title : 'misc';
      cfg.cat = bbn.fn.md5(cfg.title);
      cfg.data = obj.data ? obj.data : false;
      cfg.url = obj.url ? obj.url : false;
      return cfg;
    },
    _getClass(cfg) {
      return 'bbn-notification-section-' + cfg.cat;
    },
    _getTitleHTML(cfg) {
      return '<h5 class="ui dividing header">' + cfg.title + '</h5>';
    },
    _getItemHTML(cfg) {
      if (cfg.time && cfg.html) {
        var m = dayjs(cfg.time);
        return '<div class="bbn-form-label" style="width: 130px">' + '<div class="metadata"><span class="date">' + m.calendar() + '</span></div>' + '</div><div class="ui reset bbn-form-field">' + cfg.html + '</div>';
      }
      return '';
    },
    _getHTML(cfg) {
      return '<div class="bbn-form-full ' + this._getClass(cfg) + '">' + this._getTitleHTML(cfg) + this._getItemHTML(cfg) + '</div>';
    },
    _addHTML(cfg) {
      var $cont = $(".bbn-notification:visible"),
        $ele = $("." + this._getClass(cfg), $cont[0]);
      if (!$cont.length) {
        return;
      }
      if (!$ele.length) {
        $cont.prepend(this._getHTML(cfg));
      } else {
        $ele.prependTo($cont).find(".ui.header:first").after(this._getItemHTML(cfg));
      }
      if (cfg.data) {
        var d = $cont.data("bbn-data");
        if (d) {
          d.push(cfg.data);
          $cont.data("bbn-data", d);
        } else {
          $cont.data("bbn-data", [cfg.data]);
        }
      }
      $cont.bbn("analyzeContent", true);
    },
    _callWidget(cfg) {
      const vm = this;
      var uncertain = {};
      vm.isShown = cfg.type;
      if (cfg.close) {
        uncertain.close = cfg.close;
      }
      if (cfg.timeout) {
        uncertain.delay = cfg.timeout;
      }
      $.notifyBar(bbn.fn.extend({
        html: '<div class="bbn-notification">' + vm._getHTML(cfg) + '</div>',
        cssClass: cfg.type,
        closeOnClick: false,
        onBeforeHide() {
          vm.isShown = false;
          //bbn.fn.log($(".bbn-notification:visible").length, $(".bbn-notification:visible").data("bbn-data"));
          if (cfg.onClose) {
            cfg.onClose(cfg.data ? cfg.data : []);
          }
        },
        onShow() {
          var $n = $(".bbn-notification:visible").redraw();
          if (cfg.data) {
            $n.data("bbn-data", [cfg.data]);
          }
        }
      }, uncertain));
    },
    success(obj, timeout) {
      return this.show(obj, "success", timeout);
    },
    info(obj, timeout) {
      return this.show(obj, "info", timeout ? timeout : false);
    },
    warning(obj, timeout) {
      return this.show(obj, "warning", timeout ? timeout : false);
    },
    error(obj, timeout) {
      return this.show(obj, "error", timeout === undefined ? 2000 : timeout);
    },
    show(obj, type, timeout) {
      const vm = this;
      if (!$.notifyBar) {
        alert("The library notifyBar is needed for bbn.app.messages");
        return false;
      }
      var cfg = vm._getCfg(obj, type, timeout);
      if (vm.isShown) {
        if (vm.isShown === cfg.type) {
          if (cfg.close) {
            addHTML(cfg);
          }
        } else {
          if (!todo[cfg.type]) {
            todo[cfg.type] = {
              items: []
            };
            todo._num++;
          }
          todo[cfg.type].last = cfg.time.getTime();
          todo[cfg.type].items.push(cfg);
        }
      } else {
        callWidget(cfg);
      }
    },
    setID(id) {
      if (!id) {
        id = new Date().getMilliseconds();
      }
      widget.getNotifications().last().data("bbn-id", id);
      return id;
    },
    getFromID(id) {
      return widget.getNotifications().filter(function () {
        return $(this).data("bbn-id") === id;
      }).first();
    },
    deleteFromID(id) {
      var ele = this.getFromID(id),
        close = ele.find(".bbn-notification-close");
      if (close.length) {
        close.click();
      } else {
        ele.parent().fadeOut("fast", function () {
          $(this).remove();
        });
      }
    },
    deleteAll() {
      widget.hide();
    }
  },
  mounted() {
    const vm = this;
    /*
    setInterval(function(){
      if ( vm.num && !vm.isShown ){
        for ( var n in vm.todo ){
          if ( vm.todo[n].items.length ){
            bbn.fn.each(vm.todo[n].items, function(v, i){
              vm.show(v, v.type);
            });
            delete vm.todo[n];
            vm.num--;
            break;
          }
        }
      }
    }, 1000);
    */
    return this;
  }
};
import cpHtml from './message.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./message.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-message',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-mini-search component
 *
 * @description
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017.
 */

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
   * @mixin bbn.cp.mixins.dropdown
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input, bbn.cp.mixins.resizer, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.url, bbn.cp.mixins.dropdown],
  props: {
    /**
     * @prop {Boolean} [false] filterselection
     */
    filterselection: {
      default: false
    },
    /**
     * Defines if the search is filterable.
     * @prop {Boolean} [true] filterable
     */
    filterable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true will automatically update the data before mount.
     * @prop {Boolean} [false] autobind
     */
    autobind: {
      default: true
    },
    /**
     * Defines if the search can have a null value.
     * @prop {Boolean} [true] nullable
     */
    nullable: {
      default: true
    },
    /**
     * Defines the min length of the filter string.
     * @prop {Number} [1] minLength
     */
    minLength: {
      type: Number,
      default: 1
    },
    /**
     * Defines the left icon of the search.
     * @prop {Boolean|String} [false] leftIcon
     */
    leftIcon: {
      default: false
    },
    /**
     * Defines the right icon of the search.
     * @prop {Boolean|String} ['nf nf-fa-search'] rightIcon
     */
    rightIcon: {
      default: 'nf nf-fa-search'
    },
    /**
     * Defines the min width of the input.
     * @prop {String} ['4,2rem'] minWidth
     */
    minWidth: {
      default: '4.2rem'
    },
    /**
     * Defines the max width of the input.
     * @prop {String} ['100%'] maxWidth
     */
    maxWidth: {
      default: '100%'
    },
    /**
     * Defines the delay before the component starts to search.
     * @prop {Number} [500] delay
     */
    delay: {
      type: Number,
      default: 20
    },
    /**
     * @prop {String} ['?'] shortPlaceholder
     */
    shortPlaceholder: {
      type: String,
      default: '?'
    },
    /**
     * Delay to auto-hide the results when mouse out (or false to not auto-hide).
     * @prop {Boolean|Number} [1500] autohide
     */
    autohide: {
      type: [Boolean, Number],
      default: 1500
    },
    /**
     * The name of the property to be used as action to execute when selected.
     * @prop {String} sourceAction
     */
    sourceAction: {
      type: [String, Function],
      default: 'action'
    },
    /**
     * The name of the property to be used as URL to go to when selected.
     * @prop {String} sourceUrl
     */
    sourceUrl: {
      type: [String, Function],
      default: 'url'
    },
    /**
     * The URL where to send the selected result.
     * @prop {String} selectUrl
     */
    selectUrl: {
      type: String
    },
    /**
     * An array of javascript search functions
     * @prop {Array} searchFunctions
     */
    searchFunctions: {
      type: Array,
      default() {
        return [];
      },
      validator(a) {
        let ok = true;
        bbn.fn.each(a, f => {
          if (!bbn.fn.isFunction(f)) {
            ok = false;
            return false;
          }
        });
        return ok;
      }
    }
  },
  data() {
    return {
      isOpened: true,
      /**
       * The current min width.
       * @data {String} ['4.2rem'] specialWidth
       */
      specialWidth: this.minWidth,
      /**
       * The placeholder.
       * @data {String} ['?'] currentPlaceholder
       */
      currentPlaceholder: this.shortPlaceholder,
      /**
       * The timeout.
       * @data {Number|null} [null] timeout
       */
      timeout: null,
      /**
       * @data {Number|null} [null] mouseTimeout
       */
      mouseTimeout: null,
      /**
       * @data {Array} [null] registeredFunctions
       */
      registeredFunctions: this.searchFunctions.slice()
    };
  },
  computed: {
    isNullable() {
      return this.nullable && this.isActive;
    },
    isDisabled() {
      return !!this.disabled;
    },
    /**
     * Returns the component object.
     * @computed realComponent
     * @memberof listComponent
     */
    searchComponent() {
      let cp = bbn.fn.isString(this.component) || bbn.fn.isObject(this.component) && Object.keys(this.component).length ? this.component : null;
      if (!cp) {
        cp = {
          props: ['source'],
          data() {
            return this.source;
          },
          template: `<component :is="myCp" :source="source"></component>`,
          computed: {
            myCp() {
              return this.source.component || 'div';
            }
          }
        };
      }
      bbn.fn.log("MINISEARCH", cp, this.source);
      return cp;
    },
    currentIcon() {
      return '';
    }
  },
  methods: {
    /**
     * Register a new search function
     * @method registerFunction
     * @param {Function} fn
     */
    registerFunction(fn) {
      if (!bbn.fn.isFunction(fn)) {
        throw new Error(bbn._("%s takes a function as argument", "registerFunction"));
      }
      let signature = bbn.fn.md5(fn.toString());
      if (!bbn.fn.getRow(this.registeredFunctions, {
        signature: signature
      })) {
        this.registeredFunctions.push({
          signature: signature,
          fn: fn
        });
      }
    },
    /**
     * Unregister a search function
     * @method registerFunction
     * @param {Function} fn
     */
    unregisterFunction(fn) {
      let idx = this.registeredFunctions.indexOf(fn);
      if (idx > -1) {
        this.registeredFunctions.splice(idx, 1);
      }
    },
    /**
     * Emits the event 'select'
     * @method select
     * @param {Object} item
     * @param {Number} idx
     * @param {Number} dataIndex
     * @emit change
     */
    select(item, idx, dataIndex, ev) {
      if (!this.isDisabled) {
        if (!ev) {
          let ev = new Event('select', {
            cancelable: true
          });
        }
        this.$emit('select', ev, item, idx, dataIndex);
        if (!ev.defaultPrevented) {
          if (this.sourceAction && item[this.sourceAction]) {
            if (typeof item[this.sourceAction] === 'string') {
              if (bbn.fn.isFunction(this[item[this.sourceAction]])) {
                this[item[this.sourceAction]]();
              }
            } else if (bbn.fn.isFunction(item[this.sourceAction])) {
              if (this.actionArguments) {
                item[this.sourceAction](...this.actionArguments);
              } else {
                item[this.sourceAction](idx, item.data);
              }
            }
          } else if (this.sourceUrl && item[this.sourceUrl]) {
            let url = bbn.fn.isFunction(this.sourceUrl) ? this.sourceUrl(item, idx, dataIndex) : item[this.sourceUrl];
            if (url) {
              bbn.fn.link(url);
            }
          }
          if (this.selectUrl) {
            bbn.fn.post(this.selectUrl, {
              data: item,
              id: this.searchId
            }, d => {
              bbn.fn.log("RESULT OF SELECT URL", d);
            });
          }
          this.isOpened = false;
          this.filterString = '';
        }
      }
    },
    /**
     * States the role of the enter key on the dropdown menu.
     *
     * @method _pressEnter
     * @fires resetDropdown
     * @fires keynav
     *
     */
    keydown(e) {
      if (e.key === 'Enter') {
        let list = this.getRef('list');
        if (!!list) {
          list = list.getRef('list');
        }
        if (list && bbn.fn.isNumber(list.overIdx)) {
          list.select(list.overIdx);
        }
      }
      if (e.key === ' ' || this.commonKeydown(e)) {
        return;
      }
      if (e.key === 'Escape') {
        this.isOpened = false;
        this.filterString = '';
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      }
    },
    async updateData() {
      if (this.beforeUpdate() !== false) {
        this._dataPromise = new Promise(resolve => {
          let loadingRequestID;
          if (this.loadingRequestID) {
            bbn.fn.abort(this.loadingRequestID);
            setTimeout(() => {
              this.loadingRequestID = false;
              this.updateData().then(() => {
                resolve();
              });
            }, 50);
            return;
          }
          this.isLoading = true;
          this.$emit('startloading');
          let data = this.getData();
          loadingRequestID = bbn.fn.getRequestId(this.source, data);
          this.loadingRequestID = loadingRequestID;
          this.post(this.source, data).then(d => {
            if (!this.loadingRequestID || this.loadingRequestID !== loadingRequestID) {
              this.isLoading = false;
              this.loadingRequestID = false;
              throw new Error("No loading request");
            }
            this.isLoading = false;
            this.loadingRequestID = false;
            if (!d) {
              return;
            }
            if (d.status !== 200) {
              d.data = undefined;
            } else {
              d = d.data;
            }
            this.$emit('datareceived', d);
            if (bbn.fn.isArray(d.data)) {
              this.appendData(d.data);
            }
            this.afterUpdate();
            this.isOpened = true;
            resolve(this.currentData);
            if (!this.isLoaded) {
              this.isLoaded = true;
            }
            this.$emit('dataloaded', d);
            if (this.isAjax && d && d.next_step) {
              if (d.id && d.data !== undefined) {
                this.searchId = d.id;
              }
              this.getMoreData(d.next_step);
            }
          });
        }).catch(e => {
          this.isLoading = false;
          this.loadingRequestID = false;
          bbn.fn.log("ERROR", e);
        });
        return this._dataPromise;
      }
    },
    appendData(data) {
      bbn.fn.each(this.treatData(data), a => {
        let todo = true;
        if (a.data.hash) {
          let row = bbn.fn.filter(this.currentData, r => r.data.hash === a.data.hash);
          if (row.length && row[0].data.score && a.data.score) {
            todo = false;
            row[0].data.score += a.data.score;
          }
        }
        if (todo) {
          this.currentData.push(a);
        }
      });
      bbn.fn.order(this.currentData, 'data.score', 'desc');
      this.updateIndexes();
    },
    getMoreData() {
      let step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (this.isAjax) {
        this.isLoading = true;
        this.$emit('startloading');
        let data = this.getData();
        data.step = step;
        this.loadingRequestID = bbn.fn.getRequestId(this.source, data);
        this.isLoading = true;
        this.post(this.source, data, d => {
          this.isLoading = false;
          this.loadingRequestID = false;
          if (d && d.data) {
            if (d.data.length) {
              this.appendData(d.data);
            }
            if (d.next_step) {
              if (this.isOpened !== undefined) {
                if (this.isOpened) {
                  bbn.fn.log("APPEING DATA");
                  this.getMoreData(d.next_step);
                }
              } else {
                this.getMoreData(d.next_step);
              }
            }
          }
        });
      }
    },
    launchRegisteredFunctions(search) {
      bbn.fn.each(this.registeredFunctions, o => {
        let res = o.fn(search);
        if (bbn.fn.isArray(res) && res.length) {
          bbn.fn.each(res, r => {
            let d = bbn.fn.extend({}, r);
            delete d.score;
            if (!r.hash) {
              r.hash = bbn.fn.md5(JSON.stringify(d));
            }
            r.signature = o.signature;
          });
          this.appendData(res);
        }
      });
    }
  },
  watch: {
    isOpened(v) {
      bbn.fn.log("isOpened", this.isOpened);
      if (!v) {
        this.$emit('close');
      }
    },
    /**
     * @watch filterString
     * @param {String} v 
     */
    filterString(v) {
      if (!this.ready) {
        this.ready = true;
      }
      clearTimeout(this.filterTimeout);
      if (!v.length) {
        this.isOpened = false;
      }
      if (v !== this.currentText) {
        this.emitInput(v);
        this.$emit('change', v);
        if (this.currentData.length) {
          this.currentData.splice(0);
        }
        this.launchRegisteredFunctions(v);
        this.$nextTick(() => {
          this.filterTimeout = setTimeout(() => {
            this.filterTimeout = false;
            // We don't relaunch the source if the component has been left
            if (v && v.length >= this.minLength) {
              this.$once('dataloaded', () => {
                this.$nextTick(() => {
                  let list = this.getRef('list');
                  if (list) {
                    list = this.find('bbn-scroll');
                    if (list) {
                      list.onResize();
                    }
                  }
                });
              });
              this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
                field: this.sourceText,
                operator: 'startswith',
                value: v
              });
            } else {
              this.unfilter();
            }
          }, this.delay);
        });
      }
    }
  },
  mounted() {
    this.ready = true;
  }
};
import cpHtml from './mini-search.html';
import cpStyle from './mini-search.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./mini-search.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-mini-search',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-input component
 *
 * @description bbn-input is a simple text field.
 *
 * @author BBN Solutions
 * 
 * @copyright BBN Solutions
 */

/**
 * Classic input with normalized appearance
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input],
  props: {
    /**
     * Specifies whether a loading icon isshown inside the input field.
     * @prop {Boolean} [false] loading
     */
    loading: {
      type: [Boolean],
      default: false
    },
    /**
     * Specifies whether or not the input field should have autocomplete enabled. Accepts boolean or the strings 'on' or 'off'.
     * @prop {(Boolean|String)} [true] autocomplete
     */
    autocomplete: {
      type: [Boolean, String],
      default: true
    },
    /**
     * The type of the input.
     * @prop {String} type
     */
    type: {
      type: String,
      default: 'text'
    },
    /**
     * The button's icon on the left of the input.
     * @prop {String} buttonLeft
     */
    buttonLeft: {
      type: String
    },
    /**
     * The button's icon on the right of the input.
     * @prop {String} buttonRight
     */
    buttonRight: {
      type: String
    },
    /**
     * Hides the left button. 
     * @prop {Boolean} [false] autoHideLeft
     */
    autoHideLeft: {
      type: Boolean,
      default: false
    },
    /**
     * Hides the right button.
     * @prop {Boolean} [false] autoHideRight
     */
    autoHideRight: {
      type: Boolean,
      default: false
    },
    /**
     * Called when click the left button. 
     * @prop {Function} actionLeft
     */
    actionLeft: {
      type: Function
    },
    /**
     * Called when click the right button. 
     * @prop {Function} actionRight
     */
    actionRight: {
      type: Function
    },
    /**
     * The input's attribute 'pattern'. 
     * @prop {String} pattern
     */
    pattern: {
      type: String
    },
    /**
     * The size of the input.
     * @prop {(String|Number)} size
     */
    size: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} min
     */
    min: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} max
     */
    max: {
      type: [String, Number]
    }
  },
  data() {
    let currentAutocomplete = 'off';
    if (this.autocomplete === true) {
      currentAutocomplete = 'on';
    } else if (this.autocomplete && bbn.fn.isString(this.autocomplete)) {
      currentAutocomplete = this.autocomplete;
    }
    return {
      /**
       * @todo not used
       */
      currentValue: this.value,
      /**
       * The property 'autocomplete' normalized.
       * @data {String} [''] currentAutocomplete
       */
      currentAutocomplete: currentAutocomplete,
      /**
       * The property 'size' normalized.
       * @data {String} [''] currentSize
       */
      currentSize: this.size || '',
      /**
       * The action performed by the left button.
       * @data {Function} currentActionLeft
       */
      currentActionLeft: bbn.fn.isFunction(this.actionLeft) ? this.actionLeft : () => {},
      /**
       * The action performed by the right button.
       * @data {Function} currentActionRight
       */
      currentActionRight: bbn.fn.isFunction(this.actionRight) ? this.actionRight : () => {},
      currentPattern: null,
      currentType: null
    };
  },
  computed: {
    /**
     * The current input width in characters if the 'autosize' is enabled
     * @computed currentInputSize
     * @returns {Number}
     */
    currentInputSize() {
      return this.autosize ? this.value ? this.value.toString().length : 1 : 0;
    }
  },
  methods: {
    clear() {
      this.emitInput('');
    },
    init() {
      if (this.pattern) {
        let types = ['text', 'date', 'search', 'url', 'tel', 'email', 'password'];
        this.currentPattern = this.pattern;
        this.currentType = types.includes(this.type) ? this.type : 'text';
      } else if (this.type === 'hostname') {
        this.currentPattern = bbn.var.regexp.hostname.source;
        this.currentType = 'text';
      } else if (this.type === 'ip') {
        this.currentPattern = bbn.var.regexp.ip.source;
        this.currentType = 'text';
      } else {
        this.currentPattern = this.pattern;
        this.currentType = this.type;
      }
    }
  },
  created() {
    this.init();
  },
  mounted() {
    if (this.required) {
      this.getRef('element').setAttribute('required', '');
    }
  },
  watch: {
    required(v) {
      if (v) {
        this.getRef('element').setAttribute('required', '');
      } else {
        this.getRef('element').removeAttribute('required');
      }
    },
    type(newVal) {
      this.init();
    }
  }
};
import cpHtml from './multi-input.html';
import cpStyle from './multi-input.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./multi-input.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-multi-input',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-form component
 *
 * @description bbn-form is a component that allows you to quickly generate and process web forms.
 * 
 * Validation and custom control can be defined before data is sent to the back-end system.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  props: {
    /**
     * @todo not used
     * @prop {Boolean} [false] autocomplete
     */
    autocomplete: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to enable the form's buttons without changing the form's content.
     *
     * @prop {Boolean} [false] prefilled
     */
    prefilled: {
      type: Boolean,
      default: false
    },
    /**
     * A confirmation popup with a costumized message shown before leaving the form.
     *
     * @prop {String|Function} confirmLeave
     */
    confirmLeave: {
      type: [Boolean, String, Function],
      default: bbn._("Are you sure you want to leave?")
    },
    /**
     * Set to true to disable the form.
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {} script
     */
    script: {},
    /**
     * @prop {} scrollable
     */
    scrollable: {},
    /**
     * The list of fields the form must contain.
     * @prop {} fields
     */
    fields: {},
    /**
     * Set to true to make a postOut instead of a post when the form is submitted.
     *
     * @prop {Boolean} [false] blank
     */
    blank: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to give the attribute target the value '_self'.
     * @prop {Boolean} [false] self
     */
    self: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} target
     */
    target: {
      type: String
    },
    /**
     * A confirmation popup with a costumized message shown before the form is submitted.
     *
     * @prop {(String|Function)} confirmMessage
     */
    confirmMessage: {
      type: [String, Function]
    },
    /**
     * A confirmation popup with a costumized message shown before leaving the form.
     *
     * @prop {(String|Function)} confirmLeave
     */
    confirmLeave: {
      type: [Boolean, String, Function],
      default: bbn._("Are you sure you want to discard the changes you made in this form?")
    },
    /**
     * The url contacted when submitting the form.
     *
     * @prop {String} action
     */
    action: {
      type: String
    },
    /**
     * A method called after a form is correctly submitted.
     *
     * @prop {Function} success
     */
    success: {
      type: Function
    },
    /**
     * A method called after a form submission fails.
     *
     * @prop {Function} failure
     */
    failure: {
      type: Function
    },
    /**
     * A popup with a costumized message shown after a form is correctly submitted.
     *
     * @prop {(String|Function)} successMessage
     */
    successMessage: {
      type: [String, Function]
    },
    /**
     * A popup with a costumized message shown after a form submission fails.
     *
     * @prop {(String|Function)} failureMessage
     */
    failureMessage: {
      type: [String, Function]
    },
    /**
     * The form's method of submission.
     *
     * @prop {String} [post] method
     */
    method: {
      type: String,
      default: 'post'
    },
    /**
     * The buttons shown on the form.
     *
     * @prop {(Boolean|Array)} ['cancel', 'submit'] buttons
     */
    buttons: {
      type: [Boolean, Array],
      default() {
        return ['cancel', 'submit'];
      }
    },
    /**
     * The proper data used in the form.
     *
     * @prop {Object} source
     */
    // This is the proper data used in the form
    source: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * The additional data to be sent by the form.
     *
     * @prop {Object} data
     */
    // This is additional data to be sent by the form
    data: {
      type: Object
    },
    /**
     * Set to true to fix the form's footer.
     *
     * @prop {Boolean} [true] fixedFooter
     */
    fixedFooter: {
      type: Boolean,
      default: false
    },
    /**
     * The form's schema generating the inputs.
     *
     * @prop {Array} [[]] schema
     */
    // That will be a form schema generating the inputs
    schema: {
      type: Array,
      default: function () {
        return [];
      }
    },
    // Sets if it is the data property which must be sent, or the content of the named fields
    // (in this case names are not necessary on form inputs)
    /**
     * Set to true if the data property must be sent.
     *
     * @prop {Boolean} [true] sendModel
     */
    sendModel: {
      type: Boolean,
      default: true
    },
    /**
     * Checks the fields' data before submitting the form.
     *
     * @prop {Function} validation
     */
    validation: {
      type: Function
    },
    /**
     * If true, will consider itself as a unique element of a floater and will have its buttons incorporated in it 
     * whereas if undefined will.
     *
     * @prop {(Boolean|String)} windowed
     */
    windowed: {
      type: [Boolean, String],
      default: 'auto'
    },
    /**
     * If true, will use the class bbn-overlay for its container.
     *
     * @prop {Boolean} fullSize
     */
    fullSize: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} [''] def
     */
    def: {
      type: String,
      default: ''
    }
  },
  data() {
    return {
      router: null,
      form: null,
      hasNext: false,
      hasPrev: false,
      isFocusing: false
    };
  },
  methods: {
    prev() {
      if (this.router) {
        this.router.prev();
      }
    },
    next() {
      if (this.router) {
        this.router.next();
      }
    },
    init() {
      this.router = this.getRef('router');
      this.form = this.getRef('form');
      this.update();
      setTimeout(() => {
        this.router.route(this.router.getDefaultURL(), true);
      }, 100);
    },
    focusout(e) {
      bbn.fn.log("FOCUSING OUT");
    },
    leaveBefore(e) {
      if (this.hasPrev) {
        this.router.prev();
        this.isFocusing = true;
        setTimeout(() => {
          this.form.focusLast();
          this.isFocusing = false;
        }, 100);
      }
    },
    leaveAfter(e) {
      if (this.hasNext) {
        this.router.next();
        this.isFocusing = true;
        setTimeout(() => {
          this.form.focusFirst();
          this.isFocusing = false;
        }, 100);
      }
    },
    update() {
      this.$nextTick(() => {
        if (this.router) {
          this.hasPrev = this.router.views[this.router.selected - 1] !== undefined;
          this.hasNext = this.router.views[this.router.selected + 1] !== undefined;
        }
      });
    },
    onRoute() {
      this.update();
      if (!this.isFocusing) {
        this.form.focusFirst();
      }
    }
  }
};
import cpHtml from './multipart.html';
import cpStyle from './multipart.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./multipart.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-multipart',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-search component
 *
 * @description bbn-serach is a  component used for a search, filtering the tree-structured data
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.list
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events, bbn.cp.mixins.keynav, bbn.cp.mixins.list],
  props: {
    source: {},
    /**
     * @prop {String} [''] textValue
     */
    textValue: {
      type: String,
      default: ''
    },
    /**
     * @prop {Number} [1] minLength
     */
    minLength: {
      type: Number,
      default: 1
    },
    /**
     * A component for each element of the list.
     *
     * @prop component
     */
    component: {},
    /**
     * The template to costumize the dropdown menu.
     *
     * @prop template
     */
    template: {},
    /**
     * @todo description
     *
     * @prop valueTemplate
     */
    valueTemplate: {},
    /**
     * Defines the groups for the dropdown menu.
     * @prop {String} group
     */
    group: {
      type: String
    },
    /**
     * If set to true the dropdown is not autofilled if empty
     * @prop {Boolean} nullable
     */
    nullable: {
      default: null
    },
    /**
     * The placeholder of the dropdown.
     *
     * @prop {String} placeholder
     */
    placeholder: {
      type: String
    },
    /**
     * @prop {Boolean} [false] autocomplete
     */
    autocomplete: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Number} [500] delay
     */
    delay: {
      type: Number,
      default: 500
    },
    /**
     * @prop {} [false] leftIcon
     */
    leftIcon: {
      default: false
    },
    /**
     * @prop ['nf nf-fa-search'] rightIcon
     */
    rightIcon: {
      default: 'nf nf-fa-search'
    },
    /**
     * @prop {} ['4rem'] minWidth
     */
    minWidth: {
      default: '4rem'
    },
    /**
     * @prop {} ['100%'] maxWidth
     */
    maxWidth: {
      default: '100%'
    },
    /**
     * @prop {Array} [[]] value
     */
    value: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  data() {
    return {
      isFocused: false,
      style: this.source && this.source.style ? this.source.style : {},
      isOpened: true,
      currentWidth: this.minWidth,
      currentPlaceholder: '?',
      hasSelection: true
    };
  },
  computed: {
    /*
    ui(){
      return this.closest('bbn-appui');
    },
    cfg(){
      if ( this.source && Object.keys(this.source).length ){
        let cfg = bbn.fn.extend(true, {}, this.source);
        if ( cfg.focus !== undefined ){
          delete cfg.focus;
        }
        if ( cfg.blur !== undefined ){
          delete cfg.blur;
        }
        if ( cfg.change !== undefined ){
          delete cfg.change;
        }
        if ( cfg.style !== undefined ){
          delete cfg.style;
        }
        return cfg;
      }
      return {
        delay: 500,
        sourceText: 'text',
        sourceValue: 'value',
        clearButton: false,
        suggest: true,
        source: [],
        placeholder: '?',
        placeholderFocused: bbn._("Search.."),
        icon: 'nf nf-fa-search',
        minLength: 1,
        height: bbn.env.height - 100,
        template(d){
          return `
            <div class="bbn-hpadded bbn-nl">
              <div class="bbn-block-left">
                <h3>${d.text}</em></h3>
              </div>
              <div class="bbn-block-right bbn-h-100 bbn-r" style="display: table">
                <span style="display: table-cell; vertical-align: middle">${d.value}</span>
              </div>
            </div>`;
        }
      };
    },
    eventsCfg(){
      let def = {
        focus: e => {
          if ( !this.isExpanded ){
            let pane = this.closest('bbn-pane'),
                w = pane.$children[0].$el.clientWidth + pane.$children[1].$el.clientWidth - 40;
            this.$refs.search.$refs.element.placeholder = this.cfg.placeholderFocused;
            this.$set(this.style, 'width', w + 'px');
            this.isExpanded = true;
          }
        },
        blur: e => {
          if ( this.isExpanded ){
            this.$set(this.style, 'width', this.source.style && this.source.style.width ? this.source.style.width : '30px');
            this.isExpanded = false;
            this.$refs.search.$refs.element.placeholder = this.cfg.placeholder;
            this.search = '';
          }
        },
        change: id => {
          if (id && !(id instanceof Event)) {
            setTimeout(() => {
              document.activeElement.blur();
            }, 15);
          }
        }
      };
      return {
        focus: this.source.focus || def.focus,
        blur: this.source.blur || def.blur,
        change: this.source.change || def.change
      };
    },
    currentStyle(){
      return bbn.fn.extend({
        'z-index': 10,
        transition: 'width 400ms',
        width: '30px'
      }, (this.source.style || {}), this.style);
    }
    */
  },
  methods: {
    /**
     * States the role of the enter button on the dropdown menu.
     *
     * @method keynav
     * @fires widget.select
     * @fires widget.open
     *
     */
    keydown(e) {
      let list = this.getRef('list');
      if (!list || !this.filteredData.length || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }
      if (e.key === ' ') {
        if (list.overIdx > -1) {
          list.select(list.overIdx);
        }
      } else if (bbn.var.keys.confirm.indexOf(e.which) > -1) {
        e.preventDefault();
        if (list.overIdx > -1) {
          list.select(list.overIdx);
        }
      } else if (bbn.var.keys.upDown.indexOf(e.keyCode) > -1) {
        this.keynav(e);
      }
    },
    select(item) {
      if (item[this.sourceValue] !== undefined) {
        let v = this.value.slice();
        let idx = v.indexOf(item[this.sourceValue]);
        if (idx > -1) {
          v.splice(idx, 1);
        } else {
          v.push(item[this.sourceValue]);
        }
        this.emitInput(v);
      }
    }
  },
  mounted() {
    this.ready = true;
  }
};
import cpHtml from './multiselect.html';
import cpStyle from './multiselect.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./multiselect.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-multiselect',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-notification component
 * @description bbn-notification is a component that allows the display of a brief information message, for example to confirm the success of an action that has taken place.
 * @author BBN Solutions
 * @copyright BBN Solutions
 * @created 11/01/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * @prop {Number}, [5000] delay
     */
    delay: {
      type: Number,
      default: 5000
    },
    /**
     * @prop {String}, ['bottom-left'] position
     */
    position: {
      type: String,
      default: 'bottom-right'
    },
    /**
     * @prop {String|Function}, ['Success'] successMessage
     */
    successMessage: {
      type: [String, Function],
      default: bbn._('Success')
    },
    /**
     * @prop {String|Function}, ['Warning'] warningMessage
     */
    warningMessage: {
      type: [String, Function],
      default: bbn._('Warning')
    },
    /**
     * @prop {String|Function}, ['Error'] errorMessage
     */
    errorMessage: {
      type: [String, Function],
      default: bbn._('Error')
    },
    /**
     * @prop {String|Function}, ['Info'] infoMessage
     */
    infoMessage: {
      type: [String, Function],
      default: bbn._('Info')
    },
    /**
     * @prop {String|Boolean}, ['nf nf-fa-check_square'] successIcon
     */
    successIcon: {
      type: [String, Boolean],
      default: 'nf nf-fa-check_square'
    },
    /**
     * @prop {String|Boolean}, ['nf nf-fa-warning'] warningIcon
     */
    warningIcon: {
      type: [String, Boolean],
      default: 'nf nf-fa-warning'
    },
    /**
     * @prop {String|Boolean}, ['nf nf-fa-exclamation_circle'] errorIcon
     */
    errorIcon: {
      type: [String, Boolean],
      default: 'nf nf-fa-exclamation_circle'
    },
    /**
     * @prop {String|Boolean}, ['nf nf-mdi-information'] infoIcon
     */
    infoIcon: {
      type: [String, Boolean],
      default: 'nf nf-mdi-information'
    },
    /**
     * The source of the component.
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {Number} [10] zIndex
     */
    zIndex: {
      type: Number,
      default: 10
    }
  },
  data() {
    let bits = this.position.split('-');
    let pos = {
      v: {
        top: false,
        bottom: true
      },
      h: {
        left: false,
        right: true
      }
    };
    bbn.fn.each(bits, bit => {
      bbn.fn.iterate(pos, (o, dir) => {
        if (o[bit.toLowerCase()] !== undefined) {
          bbn.fn.iterate(o, (b, k) => {
            if (bit === k) {
              pos[dir][k] = true;
            } else {
              pos[dir][k] = false;
            }
          });
        }
      });
    });
    return {
      /**
       * @data {Array} [[]] items
       */
      items: this.source,
      /**
       * @data {Boolean} isTop
       */
      isTop: pos.v.top,
      /**
       * @data {Boolean} isLeft
       */
      isLeft: pos.h.left,
      /**
       * @data {Object} [{}] positions
       */
      positions: {}
    };
  },
  methods: {
    /**
     * @method _sanitize
     * @param {Object} obj
     * @param {String} type
     * @param {Number} timeout
     * @return {Object}
     */
    _sanitize(obj, type, timeout) {
      if (!bbn.fn.isObject(obj) || !obj.id) {
        if (typeof obj === 'string') {
          obj = {
            content: obj
          };
        } else if (!obj) {
          obj = {};
        }
        if (!obj.type) {
          if (type) {
            obj.type = type;
          } else {
            //obj.type = 'info';
          }
        }
        let id = new Date().getTime() + bbn.fn.randomString(10);
        obj.id = id;
        obj.num = 1;
        if (!obj.content && this[type + 'Message']) {
          obj.content = bbn.fn.isFunction(this[type + 'Message']) ? this[type + 'Message'](obj) : this[type + 'Message'];
        }
        if (!obj.content) {
          obj.content = '';
        }
        if (timeout && !obj.delay) {
          obj.delay = timeout > 500 ? timeout : timeout * 1000;
        } else {
          obj.pinned = true;
        }
        if (obj.icon !== false) {
          if (obj.icon === undefined && obj.type && this[obj.type + 'Icon']) {
            obj.icon = this[obj.type + 'Icon'];
          }
        }
      }
      return obj;
    },
    /**
     * @method add
     * 
     * @param {Object} o
     */
    add(o) {
      o = this._sanitize(o);
      let idx = bbn.fn.search(this.items, {
        content: o.content,
        type: o.type,
        icon: o.icon
      });
      if (idx > -1) {
        o.num += this.items[idx].num;
        this.items.splice(idx, 1);
      }
      this.items.push(o);
      this._updatePositions();
      if (o.delay) {
        setTimeout(() => {
          this.close(o.id);
        }, o.delay);
      }
    },
    /**
     * @method _updatePositions
     * @fires getRef
     */
    _updatePositions() {
      let p = {};
      let pos = 0;
      let ids = [];
      bbn.fn.each(this.items, a => {
        let cp = this.getRef('it' + a.id);
        let s;
        if (cp) {
          s = cp.$el.getBoundingClientRect().height;
        }
        if (a.closing) {
          p[a.id] = this.positions[a.id];
        } else {
          p[a.id] = pos;
          if (s) {
            pos += s;
          }
        }
        ids.push(a.id);
      });
      bbn.fn.iterate(bbn.fn.diffObj(this.positions, p), (a, k) => {
        if (a.type === 'updated') {
          this.positions[k] = a.newData;
        } else if (a.type === 'created') {
          this.positions[k] = a.data;
        } else if (a.type === 'deleted') {
          delete this.positions[k];
        }
      });
      this.$forceUpdate();
    },
    /**
     * @method close
     * @param {Number} id
     */
    close(id, callCallback) {
      let idx = bbn.fn.search(this.items, {
        id: id
      });
      if (idx > -1) {
        if (callCallback && this.items[idx].onClose && bbn.fn.isFunction(this.items[idx].onClose)) {
          this.items[idx].onClose(this.items[idx]);
        }
        this.items.splice(idx, 1);
        this._updatePositions();
      }
    },
    /**
     * @method success
     * @param {Object} o
     * @param {Number} timeout
     * @fires _sanitize
     * @fires add
     */
    success(o, timeout) {
      if (!timeout) {
        timeout = this.delay;
      }
      o = this._sanitize(o, 'success', timeout);
      this.add(o);
    },
    /**
     * @method error
     * @param {Object} o
     * @param {Number} timeout
     * @fires _sanitize
     * @fires add
     */
    error(o, timeout) {
      o = this._sanitize(o, 'error', timeout);
      this.add(o);
    },
    /**
     * @method warning
     * @param {Object} o
     * @param {Number} timeout
     * @fires _sanitize
     * @fires add
     */
    warning(o, timeout) {
      o = this._sanitize(o, 'warning', timeout);
      this.add(o);
    },
    /**
     * @method show
     * @param {Object} o
     * @param {String} type
     * @param {Number} timeout
     * @fires _sanitize
     * @fires add
     */
    show(o, type, timeout) {
      o = this._sanitize(o, type, timeout);
      this.add(o);
    },
    /**
     * @method info
     * @param {Object} o
     * @param {Number} timeout
     * @fires _sanitize
     * @fires add
     */
    info(o, timeout) {
      o = this._sanitize(o, 'info', timeout);
      this.add(o);
    }
  },
  /**
   * @event beforeMount
   * @fires _updatePositions
   */
  beforeMount() {
    this._updatePositions();
  }
};
import cpHtml from './notification.html';
import cpStyle from './notification.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./notification.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-notification',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-numeric component
 *
 * @description bbn - numeric allows to enter and modify numeric values by typing it, using arrow buttons or keyboard shortcuts.
 * By configuring the component it is possible to define its range and its step.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input],
  props: {
    /**
     * Specify the number of decimals to be shown in the input, it doesn't affect the value of 
     * the component.
     * @prop {(String|Number)} [0] decimals
     */
    decimals: {
      type: [Number, String],
      default: 0
    },
    /**
     * The unit of measure of the value.
     * @prop {String} [''] unit
     */
    unit: {
      type: String,
      default: ''
    },
    /**
     * The max value of the component.
     * @prop {Number|String} max
     */
    max: {
      type: [Number, String]
    },
    /**
     * The min value of the component.
     * @prop {Number|String} min
     */
    min: {
      type: [Number, String]
    },
    /**
     * The step at which the value of the component change.
     * @prop {Number} [1] step
     */
    step: {
      type: Number,
      default: 1
    },
    /**
     * Set to true shows the arrow buttons of the component.
     * @prop {Boolean} [true] spinners
     */
    spinners: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] onlySpinners
     */
    onlySpinners: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the input mode of this elemenet
     * @prop {String} ['decimal'] inputmode
     */
    inputmode: {
      type: String,
      default: 'decimal'
    },
    /**
     * A suffix to display inside of the input
     * @prop {String} suffix
     */
    suffix: {
      type: String
    }
  },
  data() {
    let isPercentage = this.unit === '%',
      decimals = isPercentage ? parseInt(this.decimals) + 2 : this.decimals,
      value = this.value;
    if (!this.decimals && this.step && this.step < 1) {
      let step = this.step;
      while (step < 1) {
        step *= 10;
        decimals++;
      }
    }
    if (value === null || value === '') {
      value = '';
    } else if (value == 0) {
      value = this.getFormatted(parseFloat(0).toFixed(decimals) * (isPercentage ? 100 : 1), decimals);
    } else {
      value = this.getFormatted(this.value * (isPercentage ? 100 : 1), isPercentage ? this.decimals : decimals);
    }
    return {
      /**
       * True if the inpunt is the edit mode
       * @data {Boolean} [false] editMode
       */
      editMode: false,
      /**
       * The value of the input (view mode)
       * @data {String|Number} inputValue
       */
      inputValue: value,
      /**
       * The value of the input (edit mode)
       * @data {String|Number} currentValue
       */
      currentValue: this.value === null ? '' : bbn.fn.isNumber(this.value) ? parseFloat(this.value).toFixed(this.decimals) : this.value,
      /**
       * The current decimals.
       * @data currentDecimals
       */
      currentDecimals: decimals
    };
  },
  computed: {
    /**
     * True if the decrease functionality must to disabled.
     * @computed disableDecrease
     * @returns {Boolean}
     */
    disableDecrease() {
      return bbn.fn.isNumber(this.min) && parseFloat(this.currentValue) <= this.min || !!this.readonly || this.isDisabled;
    },
    /**
     * True if the increase functionality must to disabled.
     * @computed disableIncrease
     * @returns {Boolean}
     */
    disableIncrease() {
      return bbn.fn.isNumber(this.max) && parseFloat(this.currentValue) >= this.max || !!this.readonly || this.isDisabled;
    },
    /**
     * The pattern of the input.  ^\-?[0-9]+\.0*[1-9]{0}$
     * @computed pattern
     * @returns {RegExp}
     */
    pattern() {
      let p = '^';
      if (!bbn.fn.isNumber(this.min) || this.min < 0) {
        p += '\\-?';
      }
      p += '[0-9]+';
      if (this.currentDecimals) {
        p += '(\\.[0-9]{1,' + this.currentDecimals + '}){0,1}';
      }
      p += '$';
      return new RegExp(p);
    },
    /**
     * True if the unit is "%".
     * @computed isPercentage
     * @returns {Boolean}
     */
    isPercentage() {
      return this.unit === '%';
    },
    /**
     * The current input width in characters if the 'autosize' is enabled
     * @computed currentInputSize
     * @returns {Number}
     */
    currentInputSize() {
      if (this.autosize) {
        let val = this.inputValue;
        return val.length || 1;
      }
      return 0;
    }
  },
  methods: {
    /**
     * Called at keydown, defines some shortcuts for the component.
     * @method _keydown
     * @param {Event} e
     * @fires increment
     * @fires decrement
     * @fires changeValue
     * @fires keydown
     * @emit input
     */
    _keydown(e) {
      const keys = [].concat(bbn.var.keys.numbers, bbn.var.keys.upDown, bbn.var.keys.leftRight, bbn.var.keys.dels, bbn.var.keys.confirm, bbn.var.keys.numsigns);
      if (bbn.fn.isNumber(this.min) && this.min >= 0 && e.keyCode === 189 || !this.decimals && !this.unit && (e.keyCode === 110 || e.keyCode === 190) || !keys.includes(e.keyCode) && e.keyCode !== 17) {
        e.preventDefault();
        return;
      }
      if (this.spinners) {
        //arrow up
        if (e.keyCode === 38) {
          this.increment();
        }
        //arrow down
        if (e.keyCode === 40) {
          this.decrement();
        }
        //page up - increase the step of 10 unit
        if (e.keyCode === 33) {
          let step = 10 * this.step,
            tmp = parseFloat(this.value) + (this.isPercentage ? step / 100 : step);
          this.changeValue(tmp);
        }
        //page down - decrease the step of 10 unit
        if (e.keyCode === 34) {
          let step = 10 * this.step,
            tmp = parseFloat(this.value) - (this.isPercentage ? step / 100 : step);
          this.changeValue(tmp);
        }
      }
      this.keydown(e);
    },
    /**
     * @method _focus
     * @param {Event} e
     * @fires focus
     */
    _focus(e) {
      if (!this.isDisabled && !this.readonly && !this.onlySpinners) {
        //this.currentValue = this.value;
        this.currentValue = this.value === null ? '' : bbn.fn.isNumber(this.value) ? parseFloat(this.value).toFixed(this.decimals) : this.value;
        this.editMode = true;
        this.$nextTick(() => {
          this.focus(e);
          this.selectText();
        });
      }
    },
    /**
     * @method _blur
     * @fires blur
     * @fires checkMinMax
     * @fires checkDecimals
     * @param {Event} e
     */
    _blur(e) {
      this.checkMinMax();
      this.checkDecimals();
      this.editMode = false;
      this.$nextTick(() => {
        this.blur(e);
      });
    },
    /**
     * @method _change
     * @fires change
     * @fires checkMinMax
     * @fires checkDecimals
     * @param {Event} e
     */
    _change(e) {
      this.checkMinMax();
      this.checkDecimals();
      this.editMode = false;
      this.$nextTick(() => {
        this.change(e);
      });
    },
    /**
     * @method checkDecimals
     */
    checkDecimals() {
      if (this.currentDecimals && this.currentValue && parseFloat(this.currentValue).toString().match('^\-?[0-9]+\.0{0,' + this.currentDecimals + '}[1-9]{0}$')) {
        this.currentValue = parseFloat(this.currentValue).toFixed(0);
      }
    },
    /**
     * @method checkMinMax
     * @fires setInputValue
     * @fires emitInput
     * @returns Boolean
     */
    checkMinMax() {
      let w = false;
      if (bbn.fn.isNumber(this.max) && this.currentValue !== '' && this.currentValue !== null && parseFloat(this.currentValue) > parseFloat(this.max)) {
        this.currentValue = parseFloat(this.max).toFixed(this.currentDecimals);
        w = true;
      } else if (bbn.fn.isNumber(this.min) && this.currentValue !== '' && this.currentValue !== null && parseFloat(this.currentValue) < parseFloat(this.min)) {
        this.currentValue = parseFloat(this.min).toFixed(this.currentDecimals);
        w = true;
      }
      if (w) {
        this.setInputValue(this.currentValue);
        if (this.value !== this.currentValue) {
          this.emitInput(this.currentValue);
        }
      }
      return w;
    },
    /**
     * Increase the value of the component of 1 step.
     * @method increment
     * @fires checkMinMax
     * @emits beforeIncrement
     * @emits increment
     * @emits change
     */
    increment(event, negative) {
      if (!this.readonly && !this.isDisabled && (negative ? !this.disableDecrease : !this.disableIncrease)) {
        let evName = negative ? 'decrement' : 'increment',
          beforeEvName = 'before' + bbn.fn.correctCase(evName),
          ev = new Event(beforeEvName, {
            cancelable: true
          }),
          modifier = negative ? -1 : 1,
          ratio = this.currentDecimals ? Math.pow(10, this.currentDecimals) : 1,
          value = this.value ? Math.round(this.value * ratio) : 0;
        value += this.step * ratio * modifier;
        value /= ratio;
        this.$emit(beforeEvName, value, ev);
        if (!ev.defaultPrevented) {
          this.currentValue = value;
          this.checkMinMax();
          this.$emit(evName, this.currentValue);
        }
      }
    },
    /**
     * Decrease the value of the component of 1 step.
     * @method decrement
     * @fires checkMinMax
     * @emits beforeDecrement
     * @emits decrement
     * @emits change
     */
    decrement() {
      this.increment(null, true);
    },
    /**
     * Change the value of the component.
     * @method changeValue
     * @param {Number|String} newVal
     * @fires setInputValue
     * @fires emitInput
     */
    changeValue(newVal, oldVal) {
      if (newVal === '' || newVal === null) {
        this.currentValue = '';
        this.setInputValue('');
        this.emitInput(this.nullable ? null : '');
      } else {
        if (this.pattern.exec(newVal) || this.currentDecimals && bbn.fn.isString(newVal) && newVal.match(/^\-?[0-9]+\.$/)) {
          let v = newVal ? parseFloat(parseFloat(newVal).toFixed(this.currentDecimals)) : 0;
          if (this.value !== v) {
            this.emitInput(v);
          }
          this.setInputValue(v);
        } else if ((!this.currentDecimals || bbn.fn.isString(newVal) && !newVal.match(/^\-?[0-9]+\.$/)) && oldVal !== undefined) {
          this.currentValue = oldVal;
        }
      }
    },
    /**
     * Sets the value to the input (view mode)
     * @method setInputValue
     * @param {Number|String} val
     * @fires getFormatted
     */
    setInputValue(val) {
      if (val === undefined) {
        val = this.currentValue;
      }
      if (val === '' || val === null) {
        this.inputValue = '';
        return;
      }
      if (this.isPercentage) {
        val = val * 100;
      }
      this.inputValue = this.getFormatted(val, this.decimals);
    },
    /**
     * Gets the formatted value
     * @method getFormatted
     * @param {String|Number} val
     * @param {Number|String} decimals
     * @returns {String}
     */
    getFormatted(val, decimals) {
      return bbn.fn.money(val, bbn.env.money !== undefined && bbn.env.money.kilo !== undefined ? bbn.env.money.kilo : undefined, this.unit + (!!this.suffix ? (!!this.unit ? ' ' : '') + this.suffix : ''), '', bbn.env.money !== undefined && bbn.env.money.decimal !== undefined ? bbn.env.money.decimal : undefined, bbn.env.money !== undefined && bbn.env.money.thousands !== undefined ? bbn.env.money.thousands : undefined, decimals);
    }
  },
  watch: {
    /**
     * @watch value
     */
    value(newVal) {
      if (newVal !== this.currentValue && !this.editMode) {
        this.currentValue = newVal;
      }
    },
    /**
     * @watch currentValue
     * @fires changeValue
     */
    currentValue(newVal, oldVal) {
      //bbn.fn.log("CHANGE OF CURRENT VALUE - " + newVal + ' - ' + oldVal);
      if (newVal !== oldVal) {
        this.changeValue(newVal, oldVal);
      }
    },
    /**
     * @watch suffix
     * @fires setInputValue
     */
    suffix() {
      this.setInputValue();
    }
  }
};
import cpHtml from './numeric.html';
import cpStyle from './numeric.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./numeric.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-numeric',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-pager component
 * @description bbn-pager is a component to manage the pagination of a pageable component.
 * @author BBN Solutions
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * The element to bond with
     * @props {bbnCp} element
     */
    element: {
      type: [Object, bbnCp],
      default() {
        return this.$parent;
      }
    },
    /**
     * False if you wanto to see the arrows instead of the buttons
     * @prop {Boolean} [true] buttons
     */
    buttons: {
      type: Boolean,
      default: true
    },
    /**
     * Force to render as mobile
     * @prop {Boolean} [false] forceMobile
     */
    forceMobile: {
      type: Boolean,
      default: false
    },
    /**
     * Force to render as tablet
     * @prop {Boolean} [false] forceTablet
     */
    forceTablet: {
      type: Boolean,
      default: false
    },
    /**
     * The name of the `page` word as used in the pager interface.
     * @prop {String} ['Page'] pageName
     */
    pageName: {
      type: String,
      default: bbn._("page")
    },
    /**
     * The name of the `record` word as used in the pager interface.
     * @prop {String} ['Record(s)'] itemName
     */
    itemName: {
      type: String,
      default: bbn._("records")
    },
    /**
     * The extra controls part on the right.
     * @prop {Boolean} [true] extraControls
     */
    extraControls: {
      type: Boolean,
      default: true
    },
    /**
     * False if you wanto to hide the limit selector
     * @prop {Boolean} [true] limit
     */
    limit: {
      type: Boolean,
      default: true
    },
    /**
     * Shows the bbn-numeric field for selecting the page
     * @prop {Boolean} [true] numericSelector
     */
    numericSelector: {
      type: Boolean,
      default: true
    }
  },
  data() {
    var _this$element;
    return {
      numericTimeout: false,
      currentNumericPage: (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.currentPage
    };
  },
  computed: {
    currentPage: {
      get() {
        var _this$element2;
        return (_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.currentPage;
      },
      set(v) {
        if (this.element) {
          this.element.currentPage = v;
        }
      }
    },
    numPages: {
      get() {
        var _this$element3;
        return (_this$element3 = this.element) === null || _this$element3 === void 0 ? void 0 : _this$element3.numPages;
      },
      set(v) {
        if (this.element) {
          this.element.numPages = v;
        }
      }
    }
  },
  methods: {
    updatePager() {
      bbn.fn.log("UPDATE PAGER");
    },
    /**
     * @method firstPage
     */
    firstPage() {
      if (this.element && 'currentPage' in this.element && this.element.currentPage !== 1) {
        this.element.currentPage = 1;
      }
    },
    /**
     * @method nextPage
     */
    nextPage() {
      if (this.element && 'currentPage' in this.element && 'numPages' in this.element && this.element.currentPage < this.element.numPages) {
        this.element.currentPage++;
      }
    },
    /**
     * @method prevPage
     */
    prevPage() {
      if (this.element && 'currentPage' in this.element && this.element.currentPage > 1) {
        this.element.currentPage--;
      }
    },
    /**
     * @method lastPage
     */
    lastPage() {
      if (this.element && 'currentPage' in this.element && 'numPages' in this.element && this.element.currentPage !== this.element.numPages) {
        this.element.currentPage = this.element.numPages;
      }
    }
  },
  /**
   * @event created
   */
  created() {
    if (this.forceMobile) {
      this.isMobile = true;
    }
    if (this.forceTablet) {
      this.isTablet = true;
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    if (this.element && this.element instanceof bbnCp) {
      if (this.element.ready && !this.ready) {
        this.ready = true;
      } else {
        this.element.$on('ready', () => {
          this.ready = true;
        });
      }
      this.element.$on('dataloaded', this.updatePager);
    }
  },
  beforeDestroy() {
    if (this.element) {
      this.element.$off('dataloaded', this.updatePager);
    }
  },
  watch: {
    element(v, oldV) {
      if (v && v instanceof bbnCp) {
        this.ready = true;
      }
    },
    currentPage(v) {
      //bbn.fn.log("CURRENT PAGE", v);
      if (this.currentNumericPage !== v) {
        this.currentNumericPage = parseInt(v);
      }
    },
    currentNumericPage(v) {
      //bbn.fn.log("CURRENT NUM PAGE", v);
      if (this.numericTimeout) {
        clearTimeout(this.numericTimeout);
      }
      this.numericTimeout = setTimeout(() => {
        if (this.currentPage != v) {
          this.currentPage = v;
        }
      }, 250);
    }
  }
};
import cpHtml from './pager.html';
import cpStyle from './pager.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./pager.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-pager',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file the bbn-pane component
 *
 * @description the bbn-pane is a component created to be operated by "bbn-splitter".
 * It represents the portion of the single area of the splitter that will contain what the user desires.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 *
 * @created 15/02/2017
 */

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],
  props: {
    /**
     * @prop {String} ['hidden'] overflow
     */
    overflow: {
      type: String,
      default: 'hidden'
    },
    /**
     * @prop {String} title
     */
    title: {
      type: String
    },
    /**
     * @prop {(String|Number)} [''] size
     */
    size: {
      type: [String, Number],
      default: ''
    },
    /**
     * @prop {Boolean} resizable
     */
    resizable: {
      type: Boolean
    },
    /**
     * @prop {Boolean} collapsible
     */
    collapsible: {
      type: Boolean
    },
    /**
     * @prop {Boolean} [false] collapsed
     */
    collapsed: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] hidden
     */
    hidden: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Number} [20] min
     */
    min: {
      type: Number,
      default: 20
    },
    /**
     * @prop {Number} [10000] min
     */
    max: {
      type: Number,
      default: 10000
    }
  },
  data() {
    return {
      /**
       * The current collapsed state.
       * @data {Boolean} isCollapsed
       */
      isCollapsed: this.collapsed,
      /**
       * The current resizable state.
       * @data {Boolean} isResizable
       */
      isResizable: this.resizable,
      /**
       * The splitter to which the pane belongs.
       * @data {bbnCp} splitter
       */
      splitter: null
    };
  },
  computed: {
    isHorizontal() {
      return this.splitter && this.splitter.isHorizontal;
    }
  },
  watch: {
    collapsed(val) {
      this.currentHidden = val;
      this.isCollapsed = val;
    }
  },
  created() {
    this.componentClass.push('bbn-resize-emitter');
  },
  mounted() {
    this.splitter = this.closest('bbn-splitter');
    if (this.splitter) {
      if (this.resizable === undefined) {
        this.isResizable = this.splitter.resizable;
      }
      this.selfEmit(true);
      this.splitter.init();
      setTimeout(() => {
        this.ready = true;
      }, 40);
    }
  }
};
import cpHtml from './pane.html';
import cpStyle from './pane.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./pane.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-pane',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-panelbar component
 * @description bbn-panelbar is a component that configures itself easily, it allows to visualize the data in a hierarchical way expandable to levels.
 * It can contain texts, html elements and even Vue components, the latter can be inserted both on its content but also as a header.
 * Those who use this component have the possibility to see schematically their data with the maximum simplicity of interpretation.
 * @copyright BBN Solutions
 * @author Loredana Bruno
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage, bbn.cp.mixins.resizer],
  props: {
    /**
     * @prop {Boolean} [false] multiple
     */
    multiple: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] flex
     */
    flex: {
      type: Boolean,
      default: false
    },
    /**
     * The source of the component. The object item has property:
     * - header // the title on the header
     * - headerComponent // a component on the header
     * - headerOptions // options relative to the component on the header
     * - content // the content html or text to show when the item is selected
     * - component // a component to show when the item is selected
     * - height // the height of the item's slot, it will overwrite the props itemsHeight for the item
     * - options // options of configuration of the component shown in the slot of the item
     * @prop {Array} items
     */
    source: {
      type: Array
    },
    /**
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} ['center'] align
     */
    align: {
      type: String,
      default: 'center'
    },
    /**
     * Specifies whether or not an index will be expanded
     * @prop {Number} opened
     */
    opened: {
      type: Number
    },
    /**
     * The component to be rendered on each header if not specified for the single item in the source
     * @prop {String} headerComponent
     */
    headerComponent: {
      type: String
    },
    /**
     * The object of properties to bind with the headerComponent
     * @prop {Object} headerOptions
     */
    headerOptions: {
      type: Object
    },
    /**
     * The component to be rendered in each content slot if not specified for the single item in the source
     * @prop {String} component
     */
    component: {
      type: String
    },
    /**
     * The object of properties to bind with the component in the content slot
     * @prop {Object} componentOptions
     */
    componentOptions: {
      type: Object
    }
  },
  data() {
    return {
      selectedValues: [],
      /**
       * @data {Number} [null] size
       */
      size: null,
      /**
       * The index of the selected item
       * @data {Number} [null] selected
       */
      selected: null,
      /**
       * @data {Number} [null] preselected
       */
      preselected: null,
      /**
       * @data {Number} [0] childHeight
       */
      childHeight: 0
    };
  },
  computed: {
    /**
     * @computed headers
     */
    headers() {
      return this.$refs['header'];
    }
  },
  methods: {
    isSelected(idx) {
      if (!this.multiple) {
        return this.selected === idx;
      } else {
        return this.selectedValues.includes(idx);
      }
    },
    /**
     * @method onResize
     */
    onResize() {
      this.size = this.$el.clientHeight;
    },
    multiselect(idx) {
      if (!this.selectedValues.includes(idx)) {
        this.selectedValues.push(idx);
      } else {
        this.selectedValues.splice(this.selectedValues.indexOf(idx), 1);
      }
    },
    /**
      * Shows the content of selected items and emits the event select
      * @method select
      * @param {Number} idx
      * @emits select
      * @fires getStyle
      */
    select(idx) {
      if (this.selected !== idx) {
        this.preselected = idx;
        if (this.selected === null) {
          setTimeout(() => {
            this.selected = idx;
          }, 300);
        } else {
          this.selected = idx;
        }
        this.$emit('select', idx, this.source[idx]);
        if (!this.flex) {
          this.$nextTick(() => {
            this.getStyle(idx);
          });
        }
      } else {
        this.preselected = null;
        this.selected = null;
      }
    },
    /**
     * @method getStyle
     * @param {Number} idx
     * @fires getRef
     * @return {Object}
     */
    getStyle(idx) {
      if (!this.multiple) {
        if (idx !== null && idx === this.preselected && (this.flex || this.source[idx] !== undefined && this.source[idx].flex === true)) {
          return this.size ? {
            height: this.size + 'px',
            overflow: 'hidden'
          } : {};
        }
        //if this.flex === false, case of panelbar containing a table or other content that has an height
        else if (idx !== null && idx === this.preselected && (!this.flex || this.source[idx] !== undefined && this.source[idx].flex === false)) {
          let children = this.getRef('container').children,
            res = [],
            childHeight = 0;
          bbn.fn.each(children, a => {
            if (a.classList.contains('bbn-border-box')) {
              res.push(a);
            }
          });
          this.$nextTick(() => {
            if (res[idx] && res[idx].firstElementChild.clientHeight) {
              this.childHeight = res[idx].firstElementChild.clientHeight;
            }
            return this.size ? {
              height: this.childHeight + 'px',
              overflow: 'hidden'
            } : {};
          });
        } else {
          return {
            height: '0px',
            overflow: 'hidden'
          };
        }
      } else {
        if (this.selectedValues.includes(idx) && idx !== null && (this.flex || this.source[idx] !== undefined && this.source[idx].flex === true)) {
          return this.size ? {
            height: this.size + 'px',
            overflow: 'hidden'
          } : {};
        }
        //if this.flex === false, case of panelbar containing a table or other content that has an height
        else if (this.selectedValues.includes(idx) && idx !== null && (!this.flex || this.source[idx] !== undefined && this.source[idx].flex === false)) {
          let children = this.getRef('container').children,
            res = [],
            childHeight = 0;
          bbn.fn.each(children, a => {
            if (a.classList.contains('bbn-border-box')) {
              res.push(a);
            }
          });
          this.$nextTick(() => {
            if (res[idx] && res[idx].firstElementChild.clientHeight) {
              this.childHeight = res[idx].firstElementChild.clientHeight;
            }
            return this.size ? {
              height: this.childHeight + 'px',
              overflow: 'hidden'
            } : {};
          });
        } else {
          return {
            height: '0px',
            overflow: 'hidden'
          };
        }
      }
    }
  },
  /**
    * Select the index of item defined by the prop opened
    * @event mounted
    * @fires select
    */
  mounted() {
    if (this.opened !== undefined) {
      this.$nextTick(() => {
        this.select(this.opened);
      });
    }
  },
  watch: {
    /**
     * @watch selected
     */
    selected(v, o) {
      if (v !== null) {
        setTimeout(() => {
          this.headers[v].style.overflow = null;
        }, 300);
      }
    }
  }
};
import cpHtml from './panelbar.html';
import cpStyle from './panelbar.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./panelbar.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-panelbar',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-popup component
 * @description bbn-popup is a component very similar to a desktop window of an operating system.
 * Inside you can show what you wish, even the components with its information.
 * Its potential lies in the fact that it emphasizes with a particular attention that portion of information that we want to see, enclosed in a window that can be opened or closed upon request.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 15/02/2017
 */

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.position
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.position],
  props: {
    /**
     * @prop {String} ['United'] united
     */
    untitled: {
      type: String,
      default: bbn._("Untitled")
    },
    /**
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default: function () {
        return [];
      }
    },
    /**
     * @prop {Number} [10] zIndex
     */
    zIndex: {
      type: Number,
      default: 10
    },
    /**
     * @prop {String} ['There was a problem...'] alertMessage
     */
    alertMessage: {
      type: String,
      default: bbn._("There was a problem") + '...'
    },
    /**
     * @prop {String} ['Confirmation request] confirmTitle
     */
    confirmTitle: {
      type: String,
      default: bbn._("Confirmation request")
    },
    /**
     * @prop {String} ['Are you sure?'] confirmMessage
     */
    confirmMessage: {
      type: String,
      default: bbn._("Are you sure?")
    },
    /**
     * @prop {String} ['OK'] okText
     */
    okText: {
      type: String,
      default: bbn._("OK")
    },
    /**
     * @prop {String} ['Yes'] yesText
     */
    yesText: {
      type: String,
      default: bbn._("Yes")
    },
    /**
     * @prop {String} ['No'] noText
     */
    noText: {
      type: String,
      default: bbn._("No")
    }
  },
  data() {
    return {
      /**
       * @data [false] type
       */
      type: false,
      /**
       * @data [[]] items
       */
      items: this.source
    };
  },
  computed: {
    /**
     * @computed numPopups
     * @return {Number}
     */
    numPopups() {
      return this.items.length;
    },
    /**
     * @computed popus
     * @fires getObject
     * @return {Array}
     */
    popups() {
      let r = [];
      bbn.fn.each(this.items, (a, i) => {
        //r.push(this.getObject(bbn.fn.extendOut(a, {index: i})));
        r.push(this.getObject(bbn.fn.extend({}, a, {
          index: i,
          maxWidth: a.maxWidth || this.lastKnownWidth || this.lastKnownCtWidth || null,
          maxHeight: a.maxHeight || this.lastKnownHeight || this.lastKnownCtHeight || null
        })));
      });
      return r;
    },
    /**
     * @computed showPopup
     * @return {Boolean}
     */
    showPopup() {
      return this.items.length > 0;
    }
  },
  methods: {
    /**
     * Alias of bbn.fn.randomString
     * @method randomString
    */
    randomString: bbn.fn.randomString,
    /**
     * @method open
     * @param {Object} obj
     * @return {String|Boolean}
     */
    open(obj) {
      let d = {};
      if (typeof obj !== 'object') {
        for (let i = 0; i < arguments.length; i++) {
          if (!d.content && typeof arguments[i] === 'string') {
            d.content = arguments[i];
          } else if (bbn.fn.isDimension(arguments[i])) {
            if (!d.width) {
              d.width = arguments[i];
            } else if (!d.height) {
              d.height = arguments[i];
            }
          } else if (!d.title && typeof arguments[i] === 'string') {
            d.title = arguments[i];
          } else if (!d.title && arguments[i] === false) {
            d.title = false;
          } else if (bbn.fn.isFunction(arguments[i])) {
            if (!d.onOpen) {
              d.onOpen = arguments[i];
            } else if (!d.onClose) {
              d.onClose = arguments[i];
            }
          } else if (typeof arguments[i] === 'object') {
            d.options = arguments[i];
          }
        }
        if (!d.height) {
          d.height = false;
        }
      } else {
        d = obj;
      }
      if (d) {
        if (d.url) {
          return this.load(d);
        }
        if (!d.uid) {
          d.uid = 'bbn-popup-' + bbn.fn.timestamp().toString() + '-' + bbn.fn.randomString(4, 6);
        }
        d.index = this.items.length;
        this.setResizeMeasures();
        this.setContainerMeasures();
        this.items.push(d);
        //this.makeWindows();
        return d.uid;
      } else {
        new Error("You must give a title and either a content or a component to a popup");
      }
      return false;
    },
    /**
     * @method load
     * @param {Object} obj
     * @fires post
     * @fires makeWindows
     */
    load(obj) {
      let d = {};
      if (typeof obj !== 'object') {
        for (let i = 0; i < arguments.length; i++) {
          if (!d.url && typeof arguments[i] === 'string') {
            d.url = arguments[i];
          } else if (bbn.fn.isDimension(arguments[i]) || arguments[i] === 'auto') {
            if (!d.width) {
              d.width = arguments[i];
            } else if (!d.height) {
              d.height = arguments[i];
            }
          } else if (bbn.fn.isFunction(arguments[i])) {
            if (!d.onOpen) {
              d.onOpen = arguments[i];
            } else if (!d.close) {
              d.onClose = arguments[i];
            }
          } else if (typeof arguments[i] === 'object') {
            if (!d.data) {
              d.data = arguments[i];
            } else if (!d.options) {
              d.options = arguments[i];
            }
          }
        }
        if (!d.height) {
          d.height = false;
        }
      } else {
        d = obj;
      }
      if (d.url) {
        return this.post(d.url, d.data || {}, r => {
          if (r.content || r.title) {
            if (r.script) {
              let tmp = eval(r.script);
              delete r.script;
              if (bbn.fn.isFunction(tmp)) {
                d.open = tmp;
              }
              // anon vuejs component initialization
              else if (typeof tmp === 'object') {
                bbn.fn.extendOut(tmp, {
                  name: bbn.fn.randomString(20, 15).toLowerCase(),
                  template: '<div class="bbn-overlay">' + (r.content || '') + '</div>',
                  props: ['source']
                });
                this.$options.components[tmp.name] = tmp;
                d.component = this.$options.components[tmp.name];
                d.source = r.data || [];
              }
            }
            bbn.fn.extend(d, r);
            delete d.url;
            delete d.data;
            if (!d.uid) {
              d.uid = 'bbn-popup-' + bbn.fn.timestamp().toString();
            }
            d.index = this.items.length;
            this.setResizeMeasures();
            this.setContainerMeasures();
            this.items.push(d);
            this.makeWindows();
          }
        });
      } else {
        new Error("You must give a URL in order to load a popup");
      }
    },
    /**
     * @method onClose
     * @param {Number} index
     */
    onClose(index) {
      this.items.splice(index, 1);
    },
    /**
     * @method getObject
     * @param {Object} a
     * @return {Object}
     */
    getObject(a) {
      if (!a.uid) {
        a.uid = 'bbn-popup-' + bbn.fn.timestamp().toString();
      }
      if (a.closable === undefined) {
        a.closable = true;
      }
      if (a.title === undefined && this.untitled) {
        a.title = this.untitled;
      }
      if (a.draggable === undefined) {
        a.draggable = true;
      }
      return a;
    },
    /**
     * @method loading
     * @fires open
     * @return {String|Boolean}
     */
    loading() {
      return this.open({
        title: false,
        content: `
<div class="bbn-middle" style="width: 500px; height: 250px">
<div class="bbn-block bbn-c bbn-b bbn-xl">` + bbn._('Loading') + `...</div>
</div>`,
        width: 500,
        height: 250,
        scrollable: false
      });
    },
    /**
     * @method close
     * @param {Number} idx
     * @param {Boolean} force
     * @fires getWindows
     */
    close(idx, force) {
      if (idx === undefined) {
        idx = this.items.length - 1;
      }
      let win = this.getWindow(idx);
      if (win && !force) {
        return win.close(idx);
      }
      if (this.items[idx]) {
        this.items.splice(idx, 1);
        this.$forceUpdate();
      }
    },
    /**
     * @method getIndexByUID
     * @param {String} uid
     * @return {Number}
     */
    getIndexByUID(uid) {
      return bbn.fn.search(this.items, {
        uid: uid
      });
    },
    /**
     * @method alert
     * @fires open
     */
    alert() {
      let has_msg = false;
      let has_title = false;
      let has_width = false;
      let has_callback = false;
      let okText;
      let onOpen;
      let onClose;
      let o = {};
      for (let i = 0; i < arguments.length; i++) {
        if (!has_msg && typeof arguments[i] === 'string') {
          o.content = arguments[i];
          has_msg = 1;
        } else if (bbn.fn.isDimension(arguments[i]) || arguments[i] === 'auto') {
          if (has_width) {
            o.height = arguments[i];
          } else {
            o.width = arguments[i];
            has_width = 1;
          }
        } else if (!has_title && typeof arguments[i] === 'string') {
          o.title = arguments[i];
          has_title = true;
        } else if (typeof arguments[i] === 'string') {
          okText = arguments[i];
        } else if (bbn.fn.isFunction(arguments[i])) {
          if (has_callback) {
            onClose = arguments[i];
          } else {
            onOpen = arguments[i];
            has_callback = 1;
          }
        } else if (bbn.cp.isComponent(arguments[i])) {
          o.opener = arguments[i];
        } else if (bbn.fn.isObject(arguments[i])) {
          bbn.fn.extend(o, arguments[i]);
        }
      }
      if (typeof o === 'object') {
        if (o.closable === undefined) {
          o.closable = true;
        }
        if (!o.content) {
          o.content = this.alertMessage;
        }
        if (!o.title) {
          o.title = false;
        }
        if (!okText) {
          okText = this.okText;
        }
        o.content = '<div class="' + (this.isMobile || this.isTablet ? 'bbn-padded' : 'bbn-lpadded') + ' bbn-large bbn-c" style="min-width: ' + (this.isMobile || this.isTablet ? '15' : '30') + 'em">' + o.content + '</div>';
        o.buttons = [{
          text: okText,
          cls: 'bbn-primary',
          icon: 'nf nf-fa-check_circle',
          focused: true,
          action($ev, btn) {
            if (onClose) {
              onClose($ev, btn);
            }
            btn.closest('bbn-floater').close(true);
          }
        }];
        /*
        mounted(){
          this.window = this.closest('bbn-floater');
          setTimeout(() => {
            let ele = this.getRef('click');
            if ( ele ){
              ele.$el.focus();
            }
          }, 50)
        }
        */
        this.open(bbn.fn.extend(o, {
          maximizable: false,
          scrollable: true,
          resizable: false
        }));
      }
    },
    /**
     * @method confirm
     * @fires open
     */
    confirm() {
      let onYes = false;
      let onNo = false;
      let yesText = bbn._('Yes');
      let noText = bbn._('No');
      let o = {};
      let options = {};
      let has_msg = false;
      let has_yes = false;
      let has_width = false;
      let i;
      if (bbn.fn.isObject(arguments[0])) {
        o = arguments[0];
      } else {
        for (i = 0; i < arguments.length; i++) {
          if (!has_msg && typeof arguments[i] === 'string') {
            o.content = arguments[i];
            has_msg = 1;
          } else if (bbn.fn.isDimension(arguments[i]) || arguments[i] === 'auto') {
            if (has_width) {
              o.height = arguments[i];
            } else {
              o.width = arguments[i];
              has_width = 1;
            }
          } else if (typeof arguments[i] === 'string') {
            if (!has_yes) {
              yesText = arguments[i];
              has_yes = true;
            } else {
              noText = arguments[i];
            }
          } else if (bbn.fn.isFunction(arguments[i])) {
            if (onYes) {
              onNo = arguments[i];
            } else {
              onYes = arguments[i];
            }
          } else if (bbn.cp.isComponent(arguments[i])) {
            o.opener = arguments[i];
          } else if (typeof arguments[i] === 'object') {
            options = arguments[i];
          }
        }
      }
      if (typeof o === 'object' && onYes) {
        if (!o.content) {
          o.content = this.confirmMessage;
        }
        if (!o.title) {
          o.title = false;
        }
        o.content = '<div class="' + (this.isMobile || this.isTablet ? 'bbn-padded' : 'bbn-lpadded') + ' bbn-large bbn-c" style="min-width: ' + (this.isMobile || this.isTablet ? '15' : '30') + 'em">' + o.content + '</div>';
        o.buttons = [{
          text: noText,
          icon: 'nf nf-fa-times_circle',
          focused: true,
          action($ev, btn) {
            btn.closest('bbn-floater').close(true);
            bbn.fn.log("ON NO", btn);
            if (onNo) {
              onNo($ev, btn);
            }
          }
        }, {
          text: yesText,
          cls: 'bbn-primary',
          icon: 'nf nf-fa-check_circle',
          action: ($ev, btn) => {
            bbn.fn.log("ON YES", btn);
            btn.closest('bbn-floater').close(true);
            onYes($ev, btn);
          }
        }];
        this.open(bbn.fn.extend(o, options, {
          resizable: false,
          maximizable: false,
          scrollable: true
        }));
      }
    },
    /**
     * @method makeWindows
     */
    makeWindows() {
      this.$forceUpdate();
    },
    /**
     * @method getWindow
     * @param {Number} idx
     * @return {Object|Boolean}
     */
    getWindow(idx) {
      if (this.popups.length) {
        if (idx === undefined) {
          idx = this.popups.length - 1;
        }
        if (this.popups[idx]) {
          return this.getChildByKey(this.popups[idx].uid);
        }
      }
      return false;
    }
  },
  /**
   * @event created
   */
  created() {
    this.componentClass.push('bbn-resize-emitter');
  },
  /**
   * @event mounted
   */
  mounted() {
    this.onResize();
    bbn.fn.each(this.popups, a => this.open(a));
    this.ready = true;
  },
  watch: {
    /**
     * @watch items
     * @fires makeWindows
     */
    items() {
      this.makeWindows();
    },
    /**
     * @watch numPopups
     */
    numPopups(v) {
      if (v && !this.ready) {
        this.ready = true;
      }
    }
  }
};
import cpHtml from './popup.html';
import cpStyle from './popup.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./popup.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-popup',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file The bbn-progessbar component is a bar that indicates the progress status, it can be customized as the user desires: vertical bar, horizontal, reverse mode or chunk type.
 *
 * @copyright BBN Solutions
 *
 * @created 10/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * The value to be represented by the bar
     * @prop {Number|String} value
     */
    value: {
      type: [Number, String]
    },
    /**
     * The maximum value of the bar
     * @prop {Number} [100] max
     */
    max: {
      type: Number,
      default: 100
    },
    /**
     * The minimum value of the bar
     * @prop {Number} [0] min
     */
    min: {
      type: Number,
      default: 0
    },
    /**
     * In case of type 'chunk' defines the step of the chunk
     * @prop {Number} [10] step
     */
    step: {
      type: Number,
      default: 10
    },
    /**
     * The orientation of the bar
     * @prop {String} ['horizontal'] orientation
     */
    orientation: {
      type: String,
      default: 'horizontal',
      validator: o => ['horizontal', 'vertical'].includes(o)
    },
    /**
     * Set to true flip the bar.
     * @prop {Boolean} [false] reverse
     */
    reverse: {
      type: Boolean,
      default: false
    },
    /**
     * The type the bar. Allowed 'value', 'percent', 'chunk' ('chunk' divides the bar into boxes to show the progress)
     * @prop {String} ['value'] type
     */
    type: {
      type: String,
      default: 'value',
      validator: t => ['value', 'percent', 'chunk'].includes(t)
    },
    /**
     * The primary color of the bar (hex, rgb, rgba)
     * @prop {String} [''] barColor
     */
    barColor: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} ['bbn-background-effect-primary'] barClass
     */
    barClass: {
      type: String,
      default: 'bbn-background-effect-primary'
    },
    /**
     * Defines the color of the text on the bar
     * @prop textColor {String} [''] textColor
     */
    textColor: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} [''] text
     */
    text: {
      type: String,
      default: ''
    },
    /**
     * Defines the height of the bar if the prop orientation is set to 'vertical'
     * @prop {Number|String} [500] height
     */
    height: {
      type: [Number, String],
      default: 500
    },
    /**
     * Defines the width of the bar if the bar if the prop orientation is set to 'horizontal'
     * @prop {Number|String} width
     */
    width: {
      type: [Number, String]
      //default: 500
    },

    /**
     * Set to true shows the value on the bar
     * @prop showValue {Boolean} [true] showValue
     */
    showValue: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true shows the unit
     * @prop {Boolean} [true] showUnit
     */
    showUnit: {
      type: Boolean,
      default: true
    },
    /**
     * Defines of how many degrees the progressbar has to be rotated
     * @prop {Number} [0] rotate
     */
    rotate: {
      type: Number,
      default: 0
    },
    /**
     * @prop {String} ['default'] valuePosition
     */
    valuePosition: {
      type: String,
      default: 'right',
      validator: p => ['left', 'center', 'right', 'top', 'bottom'].includes(p)
    }
  },
  data() {
    return {
      /**
       * The string that defines the main style of the bar basing on the orientation
       * @data {String} [''] orientationStyle
       */
      orientationStyle: '',
      /**
       * If the type is set to 'percent' the unit will be '%'
       * @data {String} [''] unit
       */
      unit: '',
      /**
       * If the type is set to 'chunk' represents the number of total chunks in the bar
       * @data {Number} [0] chunknumber
       */
      chunknumber: 0,
      /**
       * If the type is set to 'chunk' represents the number of selected chunks in the bar
       * @data {Number} [0] selectedChunks
       */
      selectedChunks: 0,
      /**
       * Defines the style of the bar when type is set to 'chunk'
       * @data {String} [''] chunkStyle
       */
      chunkStyle: '',
      /**
       * Defines the class for the alignment of the value in the bar depending on the orientation and on the prop valuePosition
       * @data {String} [''] realValuePosition
       */
      realValuePosition: '',
      percent: 0
    };
  },
  computed: {
    /**
     * @computed stepTotal
     * @return {Number}
     */
    stepTotal() {
      return Math.round(this.max / this.step * 100) / 100;
    },
    /**
     * @computed stepTotalRounded
     * @return {Number}
     */
    stepTotalRounded() {
      return Math.round(this.max / this.step);
    },
    /**
     * Defines the style of the bar
     * @computed {String} style
     * @return {String}
     */
    style() {
      let st = '';
      if (this.orientation === 'horizontal') {
        st += 'width:' + this.percent + '%;';
      } else if (this.orientation === 'vertical') {
        st += 'height:' + this.percent + '%;';
      }
      if (this.barColor) {
        st += 'background-color: ' + this.barColor + '!important;border-color: ' + this.barColor + '!important;';
      }
      if (this.reverse) {
        st += 'margin-left: auto;';
      }
      return st;
    }
  },
  methods: {
    /**
     * Init the component by the type
     * @method init
     * @fires emitInput
     */
    init() {
      if (this.type === 'percent') {
        this.unit = '%';
        this.percent = this.value;
      }
      if (this.type === 'value') {
        this.percent = (this.value - this.min) / (this.max - this.min) * 100;
      }
      if (this.value) {
        if (bbn.fn.isString(this.value)) {
          this.value = parseInt(this.value);
        }
      }
      if (this.type === 'chunk') {
        this.chunknumber = (this.max - this.min) / this.step, this.selectedChunks = this.value / 100 * this.chunknumber;
      }
      if (this.max && this.value > this.max) {
        this.emitInput(this.max);
      }
      if (this.min && this.value < this.min) {
        this.emitInput(this.min);
      }
    }
  },
  /**
   * @event beforeMount
   * @fires init
   */
  beforeMount() {
    this.init();
    let st = 'margin: auto;';
    if (this.orientation === 'vertical') {
      st += 'width: 1.9rem; min-height: ' + (bbn.fn.isNumber(this.height) ? this.height + 'px' : this.height);
      if (this.valuePosition === 'right') {
        this.realValuePosition = 'top';
      } else {
        this.realValuePosition = this.valuePosition;
      }
    } else if (this.orientation === 'horizontal') {
      this.realValuePosition = this.valuePosition;
    }
    if (this.orientation === 'horizontal' && this.width) {
      st += 'height: 1.9rem; min-width: ' + (bbn.fn.isNumber(this.width) ? this.width + 'px' : this.width);
    }
    this.orientationStyle = st += ';';
    if (this.rotate && bbn.fn.isNumber(this.rotate)) {
      this.orientationStyle += 'transform: rotate(' + this.rotate + 'deg)';
    }
  },
  watch: {
    /**
     * @watch chunknumber
     */
    chunknumber(val) {
      if (this.orientation === 'horizontal') {
        this.chunkStyle += 'grid-template-columns:repeat(' + this.chunknumber + ', 1fr);grid-template-rows: 1fr';
      } else {
        this.chunkStyle += 'grid-template-rows:repeat(' + this.chunknumber + ',1fr);grid-template-columns: 1fr; min-height: ' + this.height + 'px';
      }
    },
    /**
     * @watch value
     * @fires init
     */
    value() {
      this.init();
    }
  }
};
import cpHtml from './progressbar.html';
import cpStyle from './progressbar.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./progressbar.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-progressbar',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-radio component
 * @description bbn-radio is a component that can be used to select a particular choice from a range of options.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 13/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.events
   *
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.localStorage, bbn.cp.mixins.events],
  props: {
    /**
     * The separator that can be inserted between the radio buttons.
     * @prop {String} separator
     */
    separator: {
      type: String
    },
    /**
     * Set to true to arrange the radio buttons vertically.
     * @prop {Boolean} [false] vertical
     */
    vertical: {
      type: Boolean,
      default: false
    },
    /**
     * If the property vertical is set to false, defines the number of columns used to render the component.
     * @prop {Number} step
     */
    step: {
      type: Number
    },
    /**
     * The id of the radio input.
     * @prop {String} [bbn.fn.randomString(10, 25)]  id
     */
    id: {
      type: String,
      default() {
        return bbn.fn.randomString(10, 25);
      }
    },
    /**
     * A function rendering each radio label.
     * @prop {Function} render
     */
    render: {
      type: Function
    },
    /**
     * The name of the property in the item object used as a text.
     * @prop {String} ['text'] sourceText
     */
    sourceText: {
      type: String,
      default: 'text'
    },
    /**
     * The name of the property in the item object used as a value
     * @prop {String} ['text'] sourceValue
     */
    sourceValue: {
      type: String,
      default: 'value'
    },
    /**
     * The source of the component.
     * @prop {Array} [[{text:'Yes', value:1},{text:'No', value:0}]] source
     */
    source: {
      type: Array,
      default() {
        return [{
          text: bbn._("Yes"),
          value: 1
        }, {
          text: bbn._("No"),
          value: 0
        }];
      }
    },
    /**
     * The real value used in the input emit.
     * @prop {String|Boolean|Number} [undefined] modelValue
     */
    modelValue: {
      type: [String, Boolean, Number],
      default: undefined
    }
  },
  model: {
    prop: 'modelValue',
    event: 'input'
  },
  methods: {
    /**
     * @method changed
     * @param val
     * @param {Event} e
     * @emits input
     * @emits change
     */
    changed(val, d, e) {
      bbn.fn.log("CHANGED", val, d, e);
      this.$emit('input', val);
      this.$emit('change', val, d, e);
    },
    /**
     * Returns the component's style based on the property 'step'.
     * @method getStyle
     */
    getStyle() {
      if (this.step && !this.vertical) {
        return 'display: grid; grid-template-columns: ' + 'auto '.repeat(this.step) + ';';
      } else {
        return '';
      }
    }
  },
  beforeMount() {
    if (this.hasStorage) {
      let v = this.getStorage();
      if (v && v !== this.modelValue) {
        this.changed(v);
      }
    }
  },
  watch: {
    /**
     * @watch value
     * @param {Mixed} v
     */
    modelValue(v) {
      if (this.storage) {
        if (v) {
          this.setStorage(v);
        } else {
          this.unsetStorage();
        }
      }
    }
  }
};
import cpHtml from './radio.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./radio.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-radio',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-radio component
 * @description bbn-radio is a component that can be used to select a particular choice from a range of options.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 13/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.events
   *
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.localStorage, bbn.cp.mixins.events],
  props: {
    /**
     * Set to true to arrange the radio buttons vertically.
     * @prop {Boolean} [false] vertical
     */
    vertical: {
      type: Boolean,
      default: false
    },
    /**
     * The name of the property in the item object used as a text.
     * @prop {String} ['text'] sourceText
     */
    sourceText: {
      type: String,
      default: 'text'
    },
    /**
     * The name of the property in the item object used as a text.
     * @prop {String} ['text'] sourceText
     */
    sourceIcon: {
      type: String,
      default: 'icon'
    },
    /**
     * The name of the property in the item object used as a value
     * @prop {String} ['text'] sourceValue
     */
    sourceValue: {
      type: String,
      default: 'value'
    },
    /**
     * The source of the component.
     * @prop {Array} [[{text:'Yes', value:1},{text:'No', value:0}]] source
     */
    source: {
      type: Array
    },
    /**
     * The real value used in the input emit.
     * @prop {String|Boolean|Number} [undefined] modelValue
     */
    modelValue: {
      type: [String, Boolean, Number],
      default: undefined
    },
    /**
     * @prop {Boolean} [false] notext
     */
    notext: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    currentData() {
      if (this.source.length && !bbn.fn.isObject(this.source[0])) {
        return bbn.fn.map(this.source, a => {
          return {
            [this.sourceText]: a,
            [this.sourceValue]: a
          };
        });
      }
      return this.source;
    }
  },
  beforeMount() {
    if (this.hasStorage) {
      let v = this.getStorage();
      if (v && v !== this.modelValue) {
        this.changed(v);
      }
    }
  },
  watch: {
    /**
     * @watch value
     * @param {Mixed} v
     */
    value(v) {
      if (this.storage) {
        if (v) {
          this.setStorage(v);
        } else {
          this.unsetStorage();
        }
      }
    }
  }
};
import cpHtml from './radiobuttons.html';
import cpStyle from './radiobuttons.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./radiobuttons.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-radiobuttons',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-range component
 * @description bbn-range is a 'range' input type
 * @copyright BBN Solutions
 * @author BBN Solutions
 */
const cpDef = {
  name: 'bbn-range',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input],
  props: {
    /**
     * The min value
     * @prop {Number} [1] min
     */
    min: {
      type: Number
    },
    /**
     * The max value
     * @prop {Number} [100] max
     */
    max: {
      type: Number
    },
    /**
     * The step value
     * @prop {Number} [1] step
     */
    step: {
      type: Number
    },
    /**
     * The unit used for the value
     * @prop {String} [''] unit
     */
    unit: {
      type: String,
      default: ''
    },
    /**
     * @prop {Array} [[{text: '%', value: '%'}, {text: 'px', value: 'px'}, {text: 'em', value: 'em'}]] units
     */
    units: {
      type: Array,
      default() {
        return [{
          text: '%',
          value: '%',
          min: 1,
          max: 100,
          step: 1,
          decimals: 0
        }, {
          text: 'px',
          value: 'px',
          min: 1,
          max: 2000,
          step: 1,
          decimals: 0
        }, {
          text: 'em',
          value: 'em',
          min: 0.1,
          max: 200,
          step: 0.1,
          decimals: 1
        }, {
          text: 'vh',
          value: 'vh',
          min: 1,
          max: 100,
          step: 1,
          decimals: 0
        }, {
          text: 'vw',
          value: 'vw',
          min: 1,
          max: 100,
          step: 1,
          decimals: 0
        }];
      }
    },
    /**
     * @prop {Boolean} [false] showLabel
     */
    showLabel: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [true] showReset
     */
    showReset: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] showUnits
     */
    showUnits: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] showNumeric
     */
    showNumeric: {
      type: Boolean,
      default: false
    }
  },
  data() {
    let currentUnit = this.unit;
    if (!!this.value) {
      let match = this.value.toString().match(/(?!^\-{0,1}\d+)\D+/);
      if (!!match) {
        currentUnit = match[0];
      }
    }
    if (!!this.showUnits && !currentUnit) {
      currentUnit = 'px';
    }
    return {
      /**
       * The property 'size' normalized.
       * @data {String} [''] currentSize
       */
      currentSize: this.size || '',
      /**
       * The original value
       * @data {Number} originalValue
       */
      originalValue: this.value,
      /**
       * The current unit
       * @data {String} [''] currentUnit
       */
      currentUnit: currentUnit,
      /**
       * The current value of the numeric input
       * @data {String} numericValue
       */
      numericValue: Number(this.value.toString().replace(currentUnit, ''))
    };
  },
  computed: {
    /**
     * The current input width in characters if the 'autosize' is enabled
     * @computed currentInputSize
     * @returns {Number}
     */
    currentInputSize() {
      return this.autosize ? this.value ? this.value.toString().length : 1 : 0;
    },
    currentMin() {
      if (this.min !== undefined) {
        return this.min;
      }
      if (this.currentUnit) {
        return bbn.fn.getField(this.units, 'min', 'value', this.currentUnit);
      }
      return 1;
    },
    currentMax() {
      if (this.max !== undefined) {
        return this.max;
      }
      if (this.currentUnit) {
        return bbn.fn.getField(this.units, 'max', 'value', this.currentUnit);
      }
      return 100;
    },
    currentStep() {
      if (this.step) {
        return this.step;
      }
      if (this.currentUnit) {
        let step = bbn.fn.getField(this.units, 'step', 'value', this.currentUnit);
        if (step) {
          return step;
        }
      }
      return 1;
    },
    currentDecimals() {
      if (this.currentUnit) {
        return bbn.fn.getField(this.units, 'decimals', 'value', this.currentUnit) || 0;
      }
      return 0;
    }
  },
  methods: {
    /**
     * Resets the value to the original one
     * @method reset
     * @fires emitInput
     */
    reset() {
      if (!this.isDisabled && !this.readonly) {
        this.emitInput(this.originalValue);
      }
    },
    /**
     * Emits the new value
     * @method _changeValue
     * @fires emitInput
     */
    _changeValue() {
      let val = Number(this.getRef('element').value);
      this.numericValue = val;
      if (this.currentUnit) {
        val += this.currentUnit;
      }
      this.emitInput(val);
    }
  },
  /**
   * @event mounted
   */
  mounted() {
    this.ready = true;
  },
  watch: {
    /**
     * @watch currentUnit
     * @fires _changeValue
     */
    currentUnit() {
      this._changeValue();
    },
    /**
     * @watch unit
     */
    unit(val) {
      this.currentUnit = val;
    },
    /**
     * @watch numericValue
     */
    numericValue(val) {
      if (val !== this.value) {
        if (this.currentUnit) {
          val += this.currentUnit;
        }
        this.emitInput(val);
      }
    }
  }
};
import cpHtml from './range.html';
import cpStyle from './range.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./range.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-range',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-router component
 * @description bbn-router is a component that allows and manages the navigation (url) between the various containers of an application
 * @copyright BBN Solutions
 * @author BBN Solutions
 */
const cpDef = {
  name: 'bbn-router',
  statics() {
    // IndexedDb access for storing thumbnails in visual mode
    let db = false;
    if (bbn.db && bbn.db.ok && window.html2canvas) {
      db = true;
      if (!bbn.db._structures.bbn || !bbn.db._structures.bbn.containers) {
        bbn.db.add('bbn', 'containers', {
          keys: {
            PRIMARY: {
              columns: ['url'],
              unique: true
            }
          },
          fields: {
            url: {},
            image: {}
          }
        });
      }
    }
    return {
      db,
      possibleOrientations: [{
        name: 'auto',
        text: bbn._("Position automatically")
      }, {
        name: 'left',
        text: bbn._("Position on the left side")
      }, {
        name: 'top',
        text: bbn._("Position on the top side")
      }, {
        name: 'bottom',
        text: bbn._("Position on the bottom side")
      }, {
        name: 'right',
        text: bbn._("Position on the right side")
      }]
    };
  },
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.close
   * @mixin bbn.cp.mixins.observer
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage, bbn.cp.mixins.close, bbn.cp.mixins.observer, bbn.cp.mixins.resizer, bbn.cp.mixins.keepCool],
  props: {
    /**
     * Routes automatically after mount.
     * @prop {Boolean} [true] auto
     */
    auto: {
      type: Boolean,
      default: true
    },
    /**
     * The URL on which the router will be initialized.
     * @prop {String} ['] url
     */
    url: {
      type: String,
      default: ''
    },
    /**
     * Defines if the container will be automatically loaded based on URLs.
     * @prop {Boolean} [true] autoload
     */
    autoload: {
      type: Boolean,
      default: true
    },
    /**
     * The root URL of the router, will be only taken into account for the top parents' router, will be automatically calculated for the children.
     * @prop {String} ['] root
     */
    root: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} def
     */
    def: {
      type: String
    },
    /**
     * The views shown at init.
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {Boolean} [false] single
     */
    single: {
      type: Boolean,
      default: false
    },
    maxTotal: {
      type: Number,
      default: 25
    },
    /**
     * Set it to true if you want to see the navigation bar (tabs or breadcrumb).
     * @prop {Boolean} [false] nav
     */
    nav: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if you want to see the visual navigation bar
     * @prop {Boolean} [false] visual
     */
    visual: {
      type: Boolean,
      default: false
    },
    /**
     * Sets if the views' titles will be scrollable in case they have a greater width than the page (true), or if they will be shown multilines (false, default).
     * @prop {Boolean} [false] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * Sets if the router and the ocntainers inside it should be themselves scrollable or part of the global scroll.
     * @prop {Boolean} [false] scrollContent
     */
    scrollContent: {
      type: Boolean,
      default: true
    },
    /**
     * The name used for the storage.
     * @prop {String} ['__ROOT__'] storageName
     */
    storageName: {
      type: String,
      default: '__ROOT__'
    },
    /**
     * The confirm message when you close an unsaved container.
     * @prop {(Boolean|String|Function)} ['Are you sure you want to discard the changes you made in this tab?'] confirmLeave
     */
    confirmLeave: {
      type: [Boolean, String, Function],
      default: bbn._("Are you sure you want to discard the changes you made in this page?")
    },
    /**
     * The max length of the history.
     * @prop {Number} [10] historyMaxLength
     */
    historyMaxLength: {
      type: Number,
      default: 10
    },
    /**
     * @todo Integrates Boolean to have a default with no menu
     * @prop {Array|Function} [[]] menu
     */
    menu: {
      type: [Array, Function],
      default: function () {
        return [];
      }
    },
    /**
     * Set it to true if you want to show the breadcrumb instead of the tabs.
     * @prop {Boolean} [false] breadcrumb
     */
    breadcrumb: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if you want to set this nav as a master.
     * @prop {Boolean} [false] master
     */
    master: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if you want to send the variable _baseUrl.
     * @prop {Boolean} [true] postBaseUrl
     */
    postBaseUrl: {
      type: Boolean,
      default: true
    },
    /**
     * If this is set, along with componentSource and componentUrl a single container with this component will be created.
     * @prop {(String|Object)} component
     */
    component: {
      type: [String, Object]
    },
    /**
     * The source for the component.
     * @prop {Object} componentSource
     */
    componentSource: {
      type: Object
    },
    /**
     * The property to get from the componentSource to use for setting the URL.
     * @prop {String} componentUrl
     */
    componentUrl: {
      type: String
    },
    /**
     * The max length for the titles
     * @prop {Number} [20] maxTitleLength
     */
    maxTitleLength: {
      type: Number,
      default: 20
    },
    /**
     * @prop {Boolean} [true] urlNavigation
     */
    urlNavigation: {
      type: Boolean,
      default: true
    },
    /**
     * Will be passed to router in order to ignore the dirty parameter.
     * @prop {Boolean} ignoreDirty
     */
    ignoreDirty: {
      type: Boolean,
      default: false
    },
    /**
     * The size of every grid cell on which is based the visual view
     * @prop {Number} [180] visualSize
     */
    visualSize: {
      type: Number,
      default() {
        return Math.max(60, Math.min(120, Math.round(Math.min(bbn.env.width, bbn.env.height) / 7)));
      }
    },
    /**
     * The position of the visual mini containers
     * @prop {Number} [180] visualSize
     */
    orientation: {
      type: String,
      default() {
        return 'auto';
      },
      validator(v) {
        return !!bbn.fn.getRow(bbnRouterCp.possibleOrientations, {
          name: v
        });
      }
    },
    /**
     * The default background color for the title bar
     * @prop {String} [#666] bcolor
     */
    bcolor: {
      type: String,
      default: '#666'
    },
    /**
     * The default text color for the title bar
     * @prop {String} [#EEE] fcolor
     */
    fcolor: {
      type: String,
      default: '#EEE'
    },
    /**
     * A list of panes used by default if splittable is true
     * @prop {Array} [[]] panes
     */
    panes: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Decides if real bbn-container are shown before or after the ones in the config or fake container 9bbns-container)
     * @prop {String} ['real] first
     */
    first: {
      type: String,
      default: 'real'
    },
    /**
     * If true another tab can be opened aside
     * @prop {Boolean} [false] splittable
     */
    splittable: {
      type: Boolean,
      default: false
    },
    /**
     * If true when splittable the extra panes can be collapsed
     * @prop {Boolean} [false] collapsible
     */
    collapsible: {
      type: Boolean,
      default: true
    },
    /**
     * If true when splittable the extra panes can be resized
     * @prop {Boolean} [false] resizable
     */
    resizable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * IndexedDb connection
       * @return {Object} 
       */
      db: null,
      /**
      * Number of conatainers registered - as they say it.
      * @data {Number} [0] numRegistered
      */
      numRegistered: 0,
      /**
       * Real containers are the bbn-container in the slot.
       * @data {Boolean} [false] hasRealContainers
       */
      hasRealContainers: false,
      /**
       * Fake containers are the bbns-container in the slot.
       * @data {Boolean} [false] hasFakeContainers
       */
      hasFakeContainers: false,
      /**
       * True if one of the initial containers' URL is an empty string.
       * @data {Boolean} [false] hasEmptyURL
       */
      hasEmptyURL: false,
      /**
       * The array of containers defined in the source.
       * @data {Array} cfgViews
       */
      cfgViews: [].concat(this.source),
      /**
       * The views from the slot.
       * @data {Array} [[]] slotViews
       */
      slotViews: [],
      /**
       * All the views.
       * @data {Array} [[]] views
      */
      views: [],
      /**
       * All the URLS of the views.
       * @data {Object} [{}] urls
       */
      urls: {},
      /**
       * Current URL of the router.
       * @data {String} currentURL
       */
      currentTitle: '',
      /**
       * Current URL of the router.
       * @data {String} currentURL
       */
      currentURL: this.url || '',
      /**
       * Relative root of the router (set by user or by parent router).
       * @data {String} baseURL
       */
      baseURL: this.formatBaseURL(this.root),
      /**
      * An array of the parents router.
      * @data {Array} [[]] parents
      */
      parents: [],
      /**
      * An object with each mounted children router.
      * @data {Object} [{}] routers
      */
      routers: {},
      /**
      * The direct parent router if there is one.
      * @data {bbnCp} [null] parent
      */
      parent: null,
      /**
       * The root router or the current one it's the same.
       * @data {bbnCp} [null] router
       */
      router: null,
      /**
       * The container having the router in if there is one.
       * @data {bbnCp} [null] parentContainer
       */
      parentContainer: null,
      /**
       * ????
       * @data {Boolean} [ture] visible
       */
      visible: true,
      /**
       * The currently visible container.
       * @data {bbnCp} [null] activeContainer
       */
      activeContainer: null,
      /**
       * Set to true each time the router is loading (can only load once at a time).
       * @data {Boolean} [false] isLoading
       */
      isLoading: false,
      /**
       * This will remain false until the first routing.
       * @data {Boolean} [false] routed
       */
      routed: false,
      /**
       * True while the component is in the action of routing.
       * @data {Boolean} [false] isRouting
       */
      isRouting: false,
      /**
       * False until the first routing.
       * @data {Boolean} [false] isInit
       */
      isInit: false,
      /**
       * The index of the currently selected view.
       * @data {Number} [null] selected
       */
      selected: null,
      /**
       * The list of the dirty containers.
       * @data {Array} [[]] dirtyContainers
       */
      dirtyContainers: [],
      /**
       * The navigation history.
       * @data {Array} [[]] history
       */
      history: [],
      /**
       * @data {Boolean} [false] iconsReady
       */
      iconsReady: false,
      /**
       * Shows if the navigation mode is set to breacrumb.
       * @data {Boolean} isBreadcrumb
       */
      isBreadcrumb: !!this.breadcrumb,
      /**
       * itsMaster.isBreadcrumb watcher.
       * @data {Boolean} breadcrumbWatcher
       */
      breadcrumbWatcher: false,
      /**
       * List of breadcrumbs
       * @data {Array} breadcrumbsList
       */
      breadcrumbsList: [],
      /**
       * If true and visual will show all the containers as icons.
       * Starts at true for better updating when displays changes
       * @data {Boolean} visualShowAll
       */
      visualShowAll: false,
      /**
       * In visual mode the side on which the thumbnails are shown.
       * If auto (default) the bar will be top if H > W, left otherwise
       * @data {String} ['auto'] visualOrientation
       */
      visualOrientation: this.orientation !== 'auto' ? this.orientation : null,
      /**
       * If true the auto orientation won't be taken into account.
       * @data {Boolean} lockedOrientation
       */
      lockedOrientation: false,
      /**
       * If true visual mode is used for nav (instead of tabs or breadcrumbs)
       * @data {Boolean} visual
       */
      isVisual: this.visual,
      /**
       * The panes for when splittable is true
       * @data {Array} currentPanes
       */
      currentPanes: this.panes.slice(),
      /**
       * If true the configuration will be shown
       * @data {Boolean} visual
       */
      showRouterCfg: false,
      /**
       * Becomes true once the pane splitter is mounted
       * @data {Boolean} visual
       */
      splitterMounted: false,
      visualStyleContainer: bbn.fn.createObject()
    };
  },
  computed: {
    selectedTab: {
      get() {
        return bbn.fn.search(this.tabsList, {
          idx: this.selected
        });
      },
      set(v) {
        bbn.fn.log("SETING SELECTED TAB");
        let done = false;
        let i = v;
        while (i > -1) {
          if (this.tabsList[i]) {
            this.selected = this.tabsList[i].idx;
            done = true;
            break;
          }
          i--;
        }
        if (!done) {
          i = v;
          while (i < this.tabsList.length) {
            if (this.tabsList[i]) {
              this.selected = this.tabsList[i].idx;
              done = true;
              break;
            }
            i++;
          }
        }
        if (!done) {
          this.selected = null;
        }
      }
    },
    isSplittable() {
      return this.splittable && !this.single;
    },
    visualContainerStyle() {
      if (!this.isVisual) {
        return {};
      }
      let coord = [1, this.numVisualCols + 1, 1, this.numVisualRows + 1];
      if (this.views.length > 1) {
        switch (this.visualOrientation) {
          case 'top':
            coord[2] = 2;
            break;
          case 'bottom':
            coord[3] = coord[3] - 1;
            break;
          case 'left':
            coord[0] = 2;
            break;
          case 'right':
            coord[1] = coord[1] - 1;
            break;
        }
      }
      return {
        position: 'relative',
        top: null,
        left: null,
        right: null,
        bottom: null,
        gridColumnStart: coord[0],
        gridColumnEnd: coord[1],
        gridRowStart: coord[2],
        gridRowEnd: coord[3],
        zoom: 1
      };
    },
    /**
     * Not only the baseURL but a combination of all the parent's baseURLs.
     * @computed fullBaseURL
     * @return {String}
     */
    fullBaseURL() {
      let vm = this,
        base = '',
        tmp;
      while (tmp = vm.baseURL) {
        base = tmp + base;
        if (!vm.parents.length) {
          break;
        }
        vm = vm.parents[0];
      }
      return base;
    },
    /**
     * Returns true if there are any unsaved views.
     * @computed isDirty
     * @return {Boolean}
     */
    isDirty() {
      return !!this.dirtyContainers.length;
    },
    /**
     * The master bbn-router of this one.
     * @computed itsMaster
     * @return {bbnCp}
     */
    itsMaster() {
      let r = this;
      if (this.master) {
        return r;
      }
      if (this.parents.length) {
        let i = 0;
        while (this.parents[i] && this.parents[i].isBreadcrumb) {
          r = this.parents[i];
          i++;
          if (r.master) {
            break;
          }
        }
      }
      return r;
    },
    isBreadcrumbMaster() {
      if (this.isBreadcrumb) {
        return this.itsMaster === this;
      }
      return false;
    },
    /**
     * Returns the bbn-tabs component of this router.
     * @todo Kill this function, there is no anymore tabs component
     * @computed itsTabs
     * @fires getRef
     * @return {Vue|Boolean}
     */
    itsTabs() {
      if (!this.isBreadcrumb) {
        return this.getRef('tabs');
      }
      return false;
    },
    /**
     * The final Vue object for the active container (if it has sub-router).
     * @computed activeRealContainer
     * @fires getFinalContainer
     * @return {Vue|Boolean}
     */
    activeRealContainer() {
      return this.getFinalContainer();
    },
    /**
     * The last router i.e. the deepest in the current active container - or this one if none
     * @computed activeRouter
     * @fires getSubRouter
     * @return {bbnCp}
     */
    activeRouter() {
      if (this.activeContainer) {
        let sub = this.getSubRouter(this.selected);
        if (bbn.cp.isComponent(sub)) {
          return sub.activeRouter;
        }
      }
      return this;
    },
    /**
     * Returns the breadcrumbs array
     * @computed breadcrumbs
     * @return {Array}
     */
    breadcrumbs() {
      let res = [];
      if (this.isBreadcrumb) {
        res.push(this);
      }
      if (this.breadcrumbsList.length) {
        res.push(...this.getBreadcrumbs(this.selected));
      }
      return res;
    },
    /**
     * The grid style for showing the router in visual mode
     * @computed visualStyle
     * @return {Object} 
     */
    visualStyle() {
      if (!this.isVisual) {
        return {};
      }
      return {
        minHeight: '100%',
        display: 'grid',
        gridColumnGap: '0.5rem',
        gridRowGap: '0.5rem',
        gridTemplateRows: 'repeat(' + this.numVisualRows + ', 1fr)',
        gridTemplateColumns: 'repeat(' + this.numVisualCols + ', 1fr)'
      };
    },
    /**
     * Returns true if the visual blocks are on top or bottom of the selected container
     * @computed visualIsOnHeight
     * @return {Boolean} 
     */
    visualIsOnHeight() {
      if (this.isVisual) {
        return ['top', 'bottom'].includes(this.visualOrientation);
      }
      return false;
    },
    /**
     * The ratio between height and width for each block
     * @computed visualRatio
     * @return {Object} 
     */
    visualRatio() {
      if (!this.isVisual) {
        return 1;
      }
      let diffW = this.visualIsOnHeight ? 0 : this.visualSize;
      let diffH = this.visualIsOnHeight ? this.visualSize : 0;
      let ratio = (this.lastKnownWidth - diffW) / (this.lastKnownHeight - diffH);
      if (ratio > 2) {
        return 2;
      }
      return Math.max(0.5, ratio);
    },
    /**
     * The number of columns (width) for the visual mode
     * @computed numVisualCols
     * @return {Number} 
     */
    numVisualCols() {
      if (this.isVisual && this.ready) {
        // Width greater or equal to height
        let w = this.lastKnownWidth - (this.visualIsOnHeight ? 0 : this.visualSize);
        if (this.splitterMounted) {
          let splitter = this.getRef('splitter');
          if (splitter.$el.clientWidth < w) {
            w -= splitter.$el.clientWidth;
          }
        }
        if (this.visualRatio >= 1) {
          return Math.floor(w / this.visualSize);
        } else {
          return Math.floor(w / (this.visualSize * 1));
        }
      }
      return 1;
    },
    /**
     * The number of rows (height) for the visual mode
     * @computed numVisualRows
     * @return {Number} 
     */
    numVisualRows() {
      if (this.isVisual && this.ready) {
        let h = this.lastKnownHeight - (this.visualIsOnHeight ? this.visualSize : 0);
        if (this.splitterMounted) {
          let splitter = this.getRef('splitter');
          if (splitter.$el.clientHeight < h) {
            h -= splitter.$el.clientHeight;
          }
        }
        if (this.visualRatio > 1) {
          return Math.floor(h / this.visualSize * 1);
        } else {
          return Math.floor(h / this.visualSize);
        }
      }
      return 1;
    },
    /**
     * The number of cells on the side where the thumbnails are shown in the visual mode
     * @computed numVisuals
     * @return {Number} 
     */
    numVisuals() {
      if (this.isVisual) {
        if (['left', 'right'].includes(this.visualOrientation)) {
          return this.numVisualRows;
        } else {
          return this.numVisualCols;
        }
      }
      return 0;
    },
    /**
     * The number of cells on the side where the thumbnails are shown in the visual mode
     * @computed numVisualReals
     * @return {Number} 
     */
    numVisualReals() {
      if (this.isVisual) {
        return bbn.fn.filter(this.visualList, a => a.view.idx !== this.selected && !a.view.pane).length;
      }
      return 0;
    },
    /**
     * The views to show, in a specific different order, for the visual mode
     * @computed visualList
     * @return {Array} 
     */
    visualList() {
      if (!this.isVisual) {
        return [];
      }
      let moreViewsThanSlots = this.numVisuals < bbn.fn.filter(this.views, {
        pane: false
      }).length;
      let numAvailableSlots = this.numVisuals - (moreViewsThanSlots ? 1 : 0);
      let order = this.visualShowAll ? {
        selected: 'asc',
        fixed: 'desc',
        pinned: 'desc',
        last: 'desc',
        idx: 'asc'
      } : {
        selected: 'desc',
        last: 'desc',
        fixed: 'desc',
        pinned: 'desc',
        idx: 'asc'
      };
      let idx = 0;
      return bbn.fn.map(bbn.fn.multiorder(this.views, order), a => {
        let visible = false;
        if (this.visualShowAll || idx <= numAvailableSlots || this.selected === a.idx) {
          visible = true;
          if (!a.pane) {
            idx++;
          }
        } else if (a.pane) {
          visible = true;
        }
        return {
          view: a,
          visible: visible
        };
      });
    },
    /**
     * The number of tabs which are not in a pane
     * 
     * @returns {Number}
     */
    numOutOfPane() {
      return bbn.fn.filter(this.views, {
        pane: false
      }).length;
    },
    /**
     * The number of panes displayed
     * @computed numPanes
     * @return {Number} 
     */
    numPanes() {
      return this.currentPanes.length;
    },
    /**
     * The views to show in the tabs, without the ones in the pane if splittable
     * @computed tabsList
     * @return {Array} 
     */
    tabsList() {
      return bbn.fn.multiorder(this.splittable ? bbn.fn.filter(this.views, a => !a.pane) : this.views, {
        fixed: 'desc',
        pinned: 'desc',
        idx: 'asc'
      });
    },
    hasVerticalTabs() {
      return !this.isVisual && !this.isBreadcrumb && (this.orientation === 'left' || this.orientation === 'right');
    }
  },
  methods: {
    /**
     * @method updateVisualStyleContainer
     * @return {Object}
     */
    updateVisualStyleContainer() {
      if (!this.visualStyleContainer) {
        this.visualStyleContainer = bbn.fn.createObject();
      } else if (!this.isVisual) {
        this.visualStyleContainer = bbn.fn.createObject();
      }
      if (!this.isVisual) {
        return;
      }

      //bbn.fn.warning("updateVisualStyleContainer");
      bbn.fn.iterate(this.views, view => {
        if (view.view) {
          view = view.view;
        }
        if (!this.visualStyleContainer[view.url]) {
          this.visualStyleContainer[view.url] = {};
        }
        if (!this.urls[view.url]) {
          return;
        }
        const ct = this.urls[view.url];
        if (!(ct !== null && ct !== void 0 && ct.isVisible) || this.visualShowAll) {
          if (this.visualStyleContainer[view.url].zoom != 0.5) {
            this.visualStyleContainer[view.url] = {
              zoom: 0.1
            };
          }
          return;
        }
        let num = this.numVisuals + 1;
        let coord = [1, num, 1, num];
        switch (this.visualOrientation) {
          case 'up':
            coord[2] = 2;
            break;
          case 'down':
            coord[3] = num - 1;
            break;
          case 'left':
            coord[0] = 2;
            break;
          case 'right':
            coord[1] = num - 1;
            break;
        }
        if (this.visualStyleContainer[view.url].zoom != 1 || this.visualStyleContainer[view.url].gridColumnStart != coord[0] || this.visualStyleContainer[view.url].gridColumnEnd != coord[1] || this.visualStyleContainer[view.url].gridRowStart != coord[2] || this.visualStyleContainer[view.url].gridRowEnd != coord[3]) {
          this.visualStyleContainer[view.url] = {
            gridColumnStart: coord[0],
            gridColumnEnd: coord[1],
            gridRowStart: coord[2],
            gridRowEnd: coord[3],
            zoom: 1
          };
        }
      });
      return this.visualStyleContainer;
    },
    /**
     * Alias of bbn.fn.isNumber
     * @method isNumber
     * @return {Boolean}
     */
    isNumber: bbn.fn.isNumber,
    /**
     * Alias of bbn.fn.numProperties
     * @method numProperties
     * @return {Number|Boolean}
     */
    numProperties: bbn.fn.numProperties,
    getPortalSelector(view) {
      if (!this.disabled && this.panes.length) {
        let pane = this.getPane(view);
        if (pane) {
          return '#' + pane + slashToHyphen(this.isVisual ? view.view.url : view.url);
        }
      }
      return undefined;
    },
    /**
     * Removes an element from the views
     * 
     * @method remove
     * @param {*} misc Index, URL or element
     * @param {Boolean} noCfg If set to true will not trigger the storage saving
     * @fires getIndex
     * @fires remove
     * @emit close
     * @return {Boolean}
     */
    remove(misc, force) {
      let idx = this.getIndex(misc);
      if (idx > -1) {
        /** @var {Event} onBeforeClose beforeClose event, cancelable only if not force */
        let onBeforeClose = new Event('beforeClose', {
          cancelable: !force
        });
        /** @var {Event} onClose close event, cancelable only if not force */
        let onClose = new Event('close');
        this.$emit('beforeClose', idx, onBeforeClose);
        bbn.fn.log("REMOVING " + this.views[idx].url);
        if (force || !onBeforeClose.defaultPrevented) {
          if (!force && !this.ignoreDirty && this.isDirty && this.views[idx].dirty) {
            this.confirm(this.confirmLeave, () => {
              // Looking for dirty ones in registered forms of each container
              let forms = this.urls[this.views[idx].url].forms;
              if (Array.isArray(forms) && forms.length) {
                bbn.fn.each(forms, (f, k) => {
                  f.reset();
                });
              }
              return this.close(idx, true);
            });
          } else if (this.views[idx] && !this.views[idx].real) {
            bbn.fn.log("ERMOVE FROM ROUTER " + idx);
            this.$emit('close', idx, onClose);
            let url = this.views[idx].url;
            this.views.splice(idx, 1);
            if (this.urls[url]) {
              this.$removeDOM(this.urls[url].$el);
            }
            this.$delete(this.urls, url);
            this.fixIndexes();
            this.$forceUpdate();
            return true;
          }
        }
      }
      return false;
    },
    getPane(obj) {
      if (!obj) {
        return false;
      }
      if (this.isVisual) {
        return obj.view.pane || false;
      }
      return obj.pane || false;
    },
    selectClosest(idx) {
      if (idx === this.selected && this.views[idx] && !this.views[idx].pane) {
        return;
      }
      if (this.selected === idx) {
        if (this.views.length) {
          let newIdx = false;
          bbn.fn.each(this.history, a => {
            let tmp = this.getIndex(a);
            if (tmp !== false && !this.views[tmp].pane) {
              newIdx = tmp;
              return false;
            }
          });
          if (newIdx === false) {
            let tmp = idx;
            while (tmp >= 0) {
              if (this.views[tmp] && !this.views[tmp].pane) {
                newIdx = tmp;
                break;
              }
              tmp--;
            }
            if (newIdx === false) {
              tmp = idx;
              while (tmp < this.views.length) {
                if (this.views[tmp] && !this.views[tmp].pane) {
                  newIdx = tmp;
                  break;
                }
                tmp++;
              }
            }
          }
          if (this.views[newIdx]) {
            this.activateIndex(newIdx);
          }
        } else {
          this.selected = false;
        }
      }
    },
    /**
     * @method close
     * @param {Number}  idx   The index of the container to close
     * @param {Boolean} force Will close the container without prevention
     * @param {Boolean} noCfg If set to true will not trigger the storage saving
     * @fires remove
     * @fires getIndex
     * @fires activateIndex
     * @fires setConfig
     * @return {Boolean}
     */
    close(idx, force, noCfg) {
      bbn.fn.log("CLOSING CT");
      let res = this.remove(idx, force);
      if (res) {
        if (this.selected > idx) {
          this.selected--;
        } else if (idx === this.selected) {
          this.selectClosest(idx);
        }
        if (!noCfg) {
          this.setConfig();
        }
      }
      return res;
    },
    /**
     * Adds an object with a valid url to the views.
     * @method add
     * @param {Object} obj
     * @param {Number} idx
     * @fires getFullBaseURL
     * @fires search
     * @fires isValidIndex
     * @fires getDefaultView
     */
    add(obj, idx) {
      let index;
      if (this.single && this.views.length) {
        this.remove(0, true);
        this.$forceUpdate();
      }
      //obj must be an object with property url
      if (bbn.fn.isObject(obj) && bbn.fn.isString(obj.url)) {
        // This is a component
        if (obj.$options) {
          if (!obj.current && !obj.currentURL) {
            if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj.url ? obj.url + '/' : '')) === 0) {
              obj.currentURL = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);
            } else {
              obj.currentURL = obj.url;
            }
          } else {
            if (obj.currentURL) {
              obj.currentURL = bbn.fn.replaceAll(obj.currentURL);
            }
          }
          let obj2 = bbn.fn.extend(true, {}, obj.$options.propsData),
            props = obj.$options.props;
          bbn.fn.iterate(props, (v, i) => {
            if (!(i in obj2) && 'default' in v) {
              obj2[i] = v.default;
            }
          });
          bbn.fn.iterate(this.getDefaultView(), (a, n) => {
            if (obj2[n] === undefined) {
              obj2[n] = a;
            }
          });
          obj2.real = true;

          // ---- ADDED 16/12/20 (Mirko) ----
          if (!obj2.current) {
            if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj2.url ? obj2.url + '/' : '')) === 0) {
              obj2.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);
            } else {
              obj2.current = obj2.url;
            }
          } else if (obj2.current !== obj2.url && obj2.current.indexOf(obj2.url + '/') !== 0) {
            obj2.current = obj2.url;
          }
          if (!obj2.current) {
            obj2.current = obj2.url;
          }
          if (obj2.content) {
            obj2.loaded = true;
          }
          // ---- END ----

          if (obj2.real && !this.hasRealContainers) {
            this.hasRealContainers = true;
          }
          if (obj2.url === '') {
            this.hasEmptyURL = true;
          }
          if (this.search(obj2.url) === false) {
            if (this.isValidIndex(idx)) {
              this.views.splice(idx, 0, obj2);
            } else if (this.hasRealContainers && this.first !== 'real' && !obj2.real) {
              idx = bbn.fn.search(this.views, {
                real: true
              });
              this.views.splice(idx, 0, obj2);
            } else {
              this.views.push(obj2);
            }
          }
        } else {
          if (!obj.current) {
            if (bbn.env.path.indexOf(this.getFullBaseURL() + (obj.url ? obj.url + '/' : '')) === 0) {
              obj.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);
            } else {
              obj.current = obj.url;
            }
          } else if (obj.current !== obj.url && obj.current.indexOf(obj.url + '/') !== 0) {
            obj.current = obj.url;
          }
          if (!obj.current) {
            obj.current = obj.url;
          }
          if (obj.content) {
            obj.loaded = true;
          }
          obj.events = {};
          if (obj.menu === undefined) {
            obj.menu = [];
          }
          index = this.search(obj.url);
          if (index !== false) {
            let o = this.views[index],
              cn = this.urls[this.views[index].url];
            if (idx === undefined) {
              idx = index;
            }
            if (cn && this.isValidIndex(idx)) {
              cn.currentIndex = idx;
            }
            if (obj.real) {
              return;
            }
            bbn.fn.iterate(obj, (a, n) => {
              if (o[n] !== a) {
                // Each new property must be set with $set
                this.$set(o, n, a);
              }
            });
          } else {
            let isValid = this.isValidIndex(idx);
            obj.selected = false;
            obj.idx = isValid ? idx : this.views.length;
            bbn.fn.iterate(this.getDefaultView(), (a, n) => {
              if (obj[n] === undefined) {
                // Each new property must be set with $set
                this.$set(obj, n, a);
              }
            });
            obj.uid = obj.url + '-' + bbn.fn.randomString();
            if (isValid) {
              this.views.splice(obj.idx, 0, obj);
            } else if (this.hasRealContainers && this.first !== 'real' && !obj.real) {
              idx = bbn.fn.search(this.views, {
                real: true
              });
              this.views.splice(idx, 0, obj);
            } else {
              this.views.push(obj);
            }
          }
        }
        this.fixIndexes();
        this.$forceUpdate();
      }
    },
    init(url) {
      if (!this.isInit) {
        if (this.numRegistered) {
          this.isInit = true;
        }
        setTimeout(() => {
          if (this.auto) {
            this.route(url, true);
          }
        }, 50);
      }
    },
    /**
     * Function used by container to make themselves known when they are mounted.
     * @method register
     * @param {bbnCp} cp
     * @param {Boolean} fake
     * @fires add
     * @fires search
     * @fires route
     * @fires getDefaultURL
     */
    register(cp, fake) {
      if (fake) {
        bbn.fn.log("ADDING FAKE", cp);
        this.add(cp);
        return;
      }
      if (!bbn.fn.isString(cp.url)) {
        bbn.fn.log(cp);
        throw Error(bbn._('The component bbn-container must have a URL defined'));
      }
      //bbn.fn.log("REGISRTE", cp.$el.bbnId, cp.url, this.urls[cp.url] ? this.urls[cp.url].$el.bbnId : "NO")
      if (this.urls[cp.url]) {
        bbn.fn.log("It exists", this.urls[cp.url].$numBuild, this.numRegistered, this.views[0].real);
        if (cp !== this.urls[cp.url]) {
          throw Error(bbn._('Two containers cannot have the same URL defined (' + cp.url + ')'));
        }
        return;
      }
      this.numRegistered++;
      this.urls[cp.url] = cp;
      if (this.isVisual) {
        //bbn.fn.log("VIEW ON VISUAL")
        cp.$on('view', () => {
          this.visualShowAll = false;
        });
      }
      let idx = this.search(cp.url);
      if (idx === false) {
        //bbn.fn.log("ADDING BECAUSE CAN'T FIND", cp.url, this.views.map(a => a.url));
        this.add(cp);
      } else {
        cp.currentIndex = idx;
      }

      //bbn.fn.log(this.numRegistered + " OUT OF " + this.numOutOfPane, cp.currentView.pane)
      if (this.numRegistered === this.numOutOfPane) {
        this.init(this.getDefaultURL());
      }
      this.$emit('registered', cp.url);
    },
    /**
     * Function used by container to make themselves known when they are destroyed
     * @method unregister
     * @fires search
     * @fires remove
     * @param {bbnCp} cp
     */
    unregister(cp) {
      //bbn.fn.log("UNREGISTERING " + cp.url);
      if (!bbn.fn.isString(cp.url)) {
        throw Error(bbn._('The component bbn-container must have a URL defined'));
      }
      this.numRegistered--;
      let idx = this.search(cp.url),
        dataObj = this.postBaseUrl ? {
          _bbn_baseURL: this.fullBaseURL
        } : {},
        requestID = bbn.fn.getRequestId(cp.url, dataObj);
      if (bbn.fn.getLoader(requestID)) {
        bbn.fn.abort(requestID);
      }
      if (this.urls[cp.url] !== undefined) {
        delete this.urls[cp.url];
      }
      if (idx !== false) {
        //this.remove(idx);
      }
    },
    /**
     * Given a URL returns the existing path of a corresponding view or false, or the default view if forced.
     * @method getRoute
     * @param {String} url
     * @param {Boolean} force
     * @fires parseURL
     * @returns {String|false}
     */
    getRoute(url, force) {
      if (!bbn.fn.isString(url)) {
        throw Error(bbn._('The bbn-container must have a valid URL defined'));
      }
      if (!url && this.hasEmptyURL) {
        return '';
      }
      if (!url && !this.parent) {
        url = this.parseURL(bbn.env.path);
      }
      if (!url && force && this.parent) {
        url = this.parseURL(this.router.getFullCurrentURL());
      }
      if (url) {
        let bits = url.split('/');
        while (bits.length) {
          let st = bits.join('/');
          if (this.urls[st]) {
            return this.urls[st].disabled ? '' : st;
          }
          bits.pop();
        }
      }
      if (this.def && force) {
        return this.def;
      }
      if (this.views.length && force) {
        return this.views[0].current;
      }
      return false;
    },
    /**
     * Formats a baseURL correctly (without 1st slash and with end slash.
     * @method formatBaseURL
     * @param {String} baseURL
     * @returns {String}
     */
    formatBaseURL(baseURL) {
      while (bbn.fn.substr(baseURL, -1) === '/') {
        baseURL = bbn.fn.substr(baseURL, 0, baseURL.length - 1);
      }
      while (bbn.fn.substr(baseURL, 0, 1) === '/') {
        baseURL = bbn.fn.substr(baseURL, 1);
      }
      return baseURL ? baseURL + '/' : '';
    },
    /**
     * Returns the default object for the view.
     * @method getDefaultView
     * @return {Object}
     */
    getDefaultView() {
      return {
        source: null,
        title: bbn._("Untitled"),
        options: null,
        cached: !this.single && this.nav,
        scrollable: true,
        component: null,
        icon: '',
        notext: false,
        content: null,
        menu: [],
        loaded: null,
        fcolor: null,
        bcolor: null,
        load: false,
        pane: false,
        selected: null,
        css: '',
        advert: null,
        dirty: false,
        help: null,
        imessages: [],
        script: null,
        fixed: false,
        pinned: false,
        url: null,
        current: null,
        real: false,
        cfg: {},
        events: {},
        real: false,
        last: 0
      };
    },
    /**
     * Sends event beforeRoute (cancellable) and launch real routing.
     * @method route
     * @param {String} url
     * @param {Boolean} force
     * @fires realRoute
     * @fires getRoute
     * @fires load
     * @emit beforeRoute
     * @returns {void}
     */
    route(url, force) {
      //bbn.fn.log("ROUTING ON " + url);
      if (!bbn.fn.isString(url)) {
        throw Error(bbn._('The component bbn-container must have a valid URL defined (URL is not a string)'));
      }
      url = bbn.fn.replaceAll('//', '/', url);
      /** @var {Boolean} ok Will prevent the route to happen if false */
      let ok = true;

      // Looking first in the opened panes if splittable
      if (this.splittable) {
        bbn.fn.each(this.currentPanes, a => {
          bbn.fn.each(a.tabs, (v, i) => {
            if (url.indexOf(v.url) === 0) {
              /** @var {bbnCp} container The bbn-container component for the given URL if it's in a pane] */
              let container = this.urls[v.url];
              if (!container) {
                ok = false;
              }
              if (a.selected !== i) {
                a.selected = i;
                ok = false;
              }
              if (v.current !== url) {
                v.current = url;
                if (container) {
                  container.setCurrent(url);
                }
              }
              return false;
            }
          });
          if (!ok) {
            return false;
          }
        });
      }
      if (ok && this.ready && (force || !this.activeContainer || url !== this.currentURL)) {
        let event = new CustomEvent("beforeroute", {
          bubbles: false,
          cancelable: true
        });
        this.$emit("beforeroute", event, url);
        if (!event.defaultPrevented) {
          let bits = url.split('#');
          url = bits[0];
          if (url === '' && this.hasEmptyURL) {
            this.urls[''].setCurrent(url);
            this.realRoute('', '', force);
            return;
          }
          // Checks weather the container is already there
          if (!url) {
            let idx = this.getRoute('', true);
            if (idx && this.urls[idx]) {
              url = this.urls[idx].currentURL;
            }
          }
          let st = url ? this.getRoute(url) : '';
          /** @todo There is asomething to do here */
          //bbn.fn.log("ROUTING FUNCTION EXECUTING FOR " + url + " (CORRESPONDING TO " + st + ")");
          if (!url || !force && this.currentURL === url) {
            if (bits[1]) {}
            //bbn.fn.log("SAME URL END ROUTING");
            return;
          } else if (url && (!st && this.autoload || this.urls[st] && this.urls[st].load && !this.urls[st].isLoaded)) {
            this.load(url);
          }
          // Otherwise the container is activated ie made visible
          else {
            //bbn.fn.log("LOADED " + url);
            if (!st && this.def && (!url || force)) {
              st = this.getRoute(this.def);
              if (st) {
                url = this.def;
              }
            }
            if (!st && force && this.views.length) {
              st = this.views[0].url;
              if (st) {
                url = this.urls[st] ? this.urls[st].currentURL : st;
              }
            }
            if (st) {
              if (this.urls[st]) {
                this.urls[st].setCurrent(url);
              }
              this.realRoute(url, st, force, bits[1]);
            }
          }
        }
      }
    },
    /**
     * Routes the router.
     * @method realRoute
     * @param {String} url The URL to route to
     * @param {String} st The URL/key of the container on which we will route
     * @param {Boolean} force
     * @fires activate
     * @emit route1
     */
    realRoute(url, st, force, anchor) {
      if (!bbn.fn.isString(url) && !bbn.fn.isNumber(url)) {
        throw Error(bbn._('The component bbn-container must have a valid URL defined (URL given to route is not a string)'));
      }
      if (this.urls[st]) {
        //bbn.fn.log("REAL ROUTING GOING ON FOR " + url);
        if (!this.urls[st].isPane && url !== this.currentURL) {
          //bbn.fn.log("THE URL IS DIFFERENT FROM THE ORIGINAL " + this.currentURL);
          this.currentURL = url;
        }
        // First routing, triggered only once
        if (this.urls[st].currentView.pane) {
          let pane = bbn.fn.getRow(this.currentPanes, {
            id: this.urls[st].currentView.pane
          });
          if (pane && pane.tabs) {
            let idx = bbn.fn.search(pane.tabs, {
              url: st
            });
            /*
            if (pane.tabs[idx] && (pane.selected === idx)) {
              this.activate(url, this.urls[st]);
            }
            */
            if (pane.tabs[idx]) {
              this.activate(url, this.urls[st]);
            }
          }
        } else {
          if (!this.routed) {
            this.routed = true;
            this.$emit("route1", this);
            this.$nextTick(this.onResize);
          }
          this.activate(url, this.urls[st]);
        }
        if (this.urls[st] && this.urls[st].isLoaded) {
          this.urls[st].currentURL = url;
          this.$nextTick(() => {
            let child = this.urls[st].find('bbn-router');
            //bbn.fn.log("LOOKING FOR CHILD", child);
            if (child) {
              child.route(bbn.fn.substr(url, st.length + 1), force);
            } else {
              let ifr = this.urls[st].find('bbn-frame');
              if (ifr) {
                ifr.route(bbn.fn.substr(url, st.length + 1));
              }
            }
          });
        }
      }
    },
    /**
     * Routes to the next view if any.
     * @method next
     * @fires activateIndex
     */
    next(force) {
      let next = this.selected + 1;
      if (!this.views[next] && force) {
        next = 0;
      }
      if (this.views[next]) {
        this.activateIndex(next);
      }
    },
    /**
     * Routes to the previous view if any.
     * @method prev
     * @fires activateIndex
     */
    prev(force) {
      let prev = this.selected - 1;
      if (!this.views[prev] && force) {
        prev = this.views.length - 1;
      }
      if (this.views[prev]) {
        this.activateIndex(prev);
      }
    },
    /**
     * Shows the container with the corresponding URL and hide all others.
     * @method activate
     * @param url
     * @param container
     */
    activate(url, container) {
      if (!bbn.fn.isString(url)) {
        throw Error(bbn._('The component bbn-container must have a valid URL defined (activate)'));
      }
      if (!container) {
        let row = bbn.fn.getRow(this.views, {
          current: url
        });
        if (!row) {
          row = bbn.fn.getRow(this.views, {
            url: url
          });
        }
        if (!row) {
          throw new Error(bbn._("Impossible to find a container for the URL %s", url));
        }
        if (!this.urls[row.url]) {
          throw new Error(bbn._("The container for the URL %s is not registered", row.url));
        }
        container = this.urls[row.url];
      }

      //bbn.fn.log("ACTIVATING " + url + " AND SENDING FOLLOWING CONTAINER:", container);
      if (this.selected !== container.currentIndex) {
        this.$emit('activate', url);
        container.setCurrent(url);
        if (!container.isPane) {
          this.activeContainer = container;
        }
        container.show();
        // Scrolling tabs
        if (this.scrollable && this.nav && !this.breadcrumb && !this.isVisual) {
          let scroll = this.getRef('horizontal-scroll');
          let tab = this.getRef('tab-' + container.currentIndex);
          if (scroll !== null && scroll !== void 0 && scroll.ready) {
            scroll.scrollTo(tab);
          } else if (scroll) {
            scroll.$on('ready', sc => {
              setTimeout(() => {
                sc.scrollTo(this.getRef('tab-' + container.currentIndex));
              }, 100);
            });
          }
        }
      } else if (url !== container.currentURL) {
        if (container.routers) {
          let rt;
          bbn.fn.iterate(container.routers, (r, n) => {
            if (!rt) {
              rt = r;
            }
            if (url.indexOf(r.baseURL) === 0) {
              rt = r;
              return false;
            }
          });
          if (rt) {
            rt.route(url.indexOf(rt.baseURL) === 0 ? bbn.fn.substr(url, rt.baseURL.length) : '');
          }
        } else {
          this.activeContainer.setCurrent(url);
        }
      }
      //bbn.fn.log("ACTIVATED " + url + " AND ACTIVATED CONTAINER BELOW:", this.activeContainer);
    },

    /**
     * @method changeURL
     * @param {String} url
     * @param {String} title
     * @param {Boolean} replace
     * @fires getFullBaseURL
     */
    changeURL(url, title, replace) {
      if (!bbn.fn.isString(url)) {
        throw Error(bbn._('The component bbn-container must have a valid URL defined (change URL)'));
      }
      if (!bbn.env.isInit) {
        return;
      }
      if (title && title !== this.currentTitle) {
        this.currentTitle = title;
      }
      if (url !== this.currentURL) {
        this.currentURL = url;
        // Will fire again
        return;
      }

      /*
      bbn.fn.log([
        "changeURL",
        url,
        title,
        this,
        this.parentContainer ? 
          ["FROM PQARENT", this.parentContainer.currentTitle, this.parentContainer.title]
          : this.currentTitle
      ]);
      */
      // Changing the current property of the view cascades on the container's currentURL
      if (this.views[this.selected] && (url.indexOf(this.views[this.selected].url + '/') === 0 || url === this.views[this.selected].url)) {
        this.$set(this.views[this.selected], 'current', url);
      }
      if (this.urlNavigation) {
        if (this.parentContainer) {
          //this.parentContainer.currentTitle = title + ' < ' + this.parentContainer.title;
          if (!this.parentContainer.isPane) {
            this.parent.currentURL = this.baseURL + url;
          } else {
            this.parentContainer.currentView.current = this.baseURL + url;
          }
        } else if (replace || url !== bbn.env.path) {
          if (!replace) {
            //bbn.fn.log("NO REPLAACE", this.getFullBaseURL() + url, bbn.env.path);
          }
          if (!replace && (this.getFullBaseURL() + url).indexOf(bbn.env.path) === 0) {
            //bbn.fn.log("REPLACING");
            replace = true;
          }
          bbn.fn.setNavigationVars(this.getFullBaseURL() + url, this.currentTitle, {}, replace);
        }
      }
    },
    /**
     * Returns the baseURL property.
     * @method getBaseURL
     * @returns {String}
     */
    getBaseURL() {
      return this.baseURL;
    },
    /**
     * Returns a string of all the baseURL properties till root.
     * @method getFullBaseURL
     * @returns {String}
     */
    getFullBaseURL() {
      return this.fullBaseURL;
    },
    /**
     * Returns the full URL from the root router (without the hostname).
     * @method getFullURL
     * @fires getFullBaseURL
     * @returns {String}
     */
    getFullURL() {
      let url = this.getURL();
      if (url !== false) {
        return this.getFullBaseURL() + url;
      }
      return '';
    },
    /**
     * Returns the current URL of the current router.
     * @method getCurrentURL
     * @returns {String}
     */
    getCurrentURL() {
      return this.currentURL;
    },
    /**
     * Returns the full current URL from the root router (without the hostname).
     * @method getFullCurrentURL
     * @fires getCurrentURL
     * @fires getFullBaseURL
     * @returns {String|Boolean}
     */
    getFullCurrentURL() {
      let url = this.getCurrentURL();
      if (url !== false) {
        return this.getFullBaseURL() + url;
      }
      return false;
    },
    /**
     * Returns the url relative to the current tabNav from the given url.
     * @method parseURL
     * @param fullURL
     * @returns {String}
     */
    parseURL(fullURL) {
      if (fullURL === undefined) {
        return '';
      }
      if (!bbn.fn.isString(fullURL)) {
        fullURL = fullURL.toString();
      }
      if (fullURL.indexOf(bbn.env.root) === 0) {
        fullURL = bbn.fn.substr(fullURL, bbn.env.root.length);
      }
      fullURL = bbn.fn.removeTrailingChars(fullURL, '/');
      if (this.fullBaseURL === fullURL + '/') {
        return '';
      }
      if (this.fullBaseURL) {
        if (fullURL.indexOf(this.fullBaseURL) === 0) {
          fullURL = bbn.fn.substr(fullURL, this.fullBaseURL.length);
        } else {
          fullURL = '';
        }
      }
      return fullURL;
    },
    /**
     * @method isValidIndex
     * @return {Boolean}
     */
    isValidIndex(idx) {
      return typeof idx === 'number' && this.views[idx] !== undefined;
    },
    /**
     * Activates the default view, or the first one if no default.
     * @method activateDefault
     * @fires getIndex
     * @fires isValidIndex
     * @fires activate
     */
    activateDefault() {
      let idx = this.getIndex('', true);
      if (this.isValidIndex(idx)) {
        this.activate(this.views[idx].current ? this.views[idx].current : this.views[idx].url);
      }
    },
    /**
     * @method activateIndex
     * @param {Number} idx
     * @fires isValidIndex
     * @fires route
     */
    activateIndex(idx) {
      if (this.isValidIndex(idx)) {
        this.route(this.urls[this.views[idx].url] ? this.urls[this.views[idx].url].currentURL : this.views[idx].current);
      }
    },
    /**
     * @method getVue
     * @fires isValidIndex
     * @return {Vue|Boolean}
     */
    getVue(idx) {
      return this.getContainer(idx);
    },
    /**
     * Returns the corresponding container's component's DOM element.
     * @method getContainer
     * @param {Number} idx
     * @return {bbnCp}
     */
    getContainer(idx) {
      var _this$views$idx;
      if (idx === undefined) {
        idx = this.selected;
      }
      return this.urls[(_this$views$idx = this.views[idx]) === null || _this$views$idx === void 0 ? void 0 : _this$views$idx.url];
    },
    /**
     * Returns the corresponding container's component's DOM element.
     * @method getDOMContainer
     * @param {Number} idx
     * @fires getContainer
     * @return {HTMLElement|Boolean}
     */
    getDOMContainer(idx) {
      if (idx === undefined) {
        idx = this.selected;
      }
      let c = this.getContainer(idx);
      return c ? c.$el : false;
    },
    /**
     * Returns the next router in the corresponding container if there's any.
     * @method getSubRouter
     * @param misc
     * @fires getIndex
     * @fires getvue
     * @return {Vue|null}
     */
    getSubRouter(misc) {
      let idx = this.getIndex(misc);
      if (idx === undefined) {
        idx = this.selected;
      }
      let container = this.getContainer(idx);
      if (container) {
        return container.find('bbn-router') || null;
      }
      return null;
    },
    /**
     * @method getFinalContainer
     * @param misc
     * @fires getIndex
     * @fires getSubRouter
     * @fires getContainer
     * @return {bbnCp}
     */
    getFinalContainer(misc) {
      let idx = this.getIndex(misc);
      if (idx === undefined) {
        idx = this.selected;
      }
      let router = this.getSubRouter(idx);
      if (router) {
        return router.getFinalContainer();
      }
      return this.getContainer(idx);
    },
    /**
     * @method getRealVue
     * @param misc
     * @fires getFinalContainer
     * @return {bbnCp}
     */
    getRealVue(misc) {
      return this.getFinalContainer(misc);
    },
    /**
     * @method getIndex
     * @fires isValidIndex
     * @fires search
     * @return {Number|Boolean}
     */
    getIndex(misc) {
      if (!this.views.length) {
        return false;
      }
      if ([undefined, null].includes(misc)) {
        return this.selected;
      }
      if (!this.isValidIndex(misc)) {
        if (typeof misc === 'string') {
          misc = this.search(misc);
        } else if (typeof misc === 'object') {
          // Vue
          if (misc.$el) {
            misc = misc.$el;
          }
          if (misc.tagName) {
            bbn.fn.each(this.$children, ct => {
              if (ct.$vnode && ct.$vnode.componentOptions && ct.$vnode.componentOptions.tag === 'bbn-container' && (ct.$el === misc || ct.$el.contains(misc))) {
                misc = ct.currentIndex;
                return false;
              }
            });
          }
        }
      }
      return this.isValidIndex(misc) ? misc : false;
    },
    fixIndexes() {
      bbn.fn.each(this.views, (v, i) => {
        if (v.idx !== i) {
          v.idx = i;
          if (this.urls[v.url]) {
            this.urls[v.url].currentIndex = i;
          }
        }
      });
    },
    /**
     * Moves a container within the router, changes its idx.
     * 
     * @method move
     * @param {Number} from The index of the container to move
     * @param {Number} to   The index to which the container must go
     * @returns 
     */
    move(from, to) {
      if (!bbn.fn.isNumber(from, to) || from === to || !this.views[from] || !this.views[to]) {
        return;
      }
      bbn.fn.move(this.views, from, to);
      let selectedOk = false;
      if (from === this.selected) {
        this.selected = to;
        selectedOk = true;
      }
      for (let i = Math.min(from, to); i <= Math.max(from, to); i++) {
        if (this.views[i].idx !== i) {
          if (!selectedOk && this.selected === this.views[i].idx) {
            this.selected = i;
          }
          this.views[i].idx = i;
        }
      }
      this.setConfig();
    },
    /**
     * @method search
     * @param {String} url
     * @return {Number|Boolean}
     */
    search(url) {
      if (!bbn.fn.isString(url)) {
        throw Error(bbn._('The component bbn-container must have a valid URL defined (Search)'));
      }
      let r = bbn.fn.search(this.views, "url", url);
      if (r === -1) {
        bbn.fn.each(this.views, (tab, index) => {
          if (url.indexOf(tab.url + '/') === 0) {
            r = index;
            return false;
          }
        });
      }
      return r > -1 ? r : false;
    },
    searchForString(needle) {
      let res = [];
      let st = needle.toLowerCase().trim();
      bbn.fn.each(this.views, a => {
        let found = false;
        bbn.fn.iterate(this.routers, router => {
          let tmp = router.searchForString(needle);
          if (tmp.length) {
            bbn.fn.each(tmp, t => {
              t.url = this.getBaseURL() + t.url;
              if (!bbn.fn.getRow(res, {
                url: t.url
              })) {
                found = true;
                res.push(t);
              }
            });
          }
        });
        if (!found) {
          let match = false;
          let idx = -1;
          let obj = {
            url: a.current || a.url,
            title: this.getFullTitle(a)
          };
          if ((idx = obj.url.toLowerCase().indexOf(st)) > -1) {
            match = "url";
          } else if ((idx = obj.title.toLowerCase().indexOf(st)) > -1) {
            match = "title";
          }
          if (match) {
            let url = this.getBaseURL() + obj.url;
            res.push({
              url: url,
              title: obj.title,
              score: match === 'url' ? 10 : 20,
              icon: a.icon || null,
              hash: url,
              bcolor: a.bcolor || null,
              fcolor: a.fcolor || null,
              component: this.$options.components.searchResult,
              match: bbn.fn.substr(obj[match], 0, idx) + '<strong><em>' + bbn.fn.substr(obj[match], idx, st.length) + '</em></strong>' + bbn.fn.substr(obj[match], idx + st.length)
            });
          }
        }
      });
      return res;
    },
    /**
     * @method callRouter
     * @param {String} url
     * @param st
     * @fires getFullBaseURL
     * @fires realRoute
     */
    callRouter(url, st) {
      if (!bbn.fn.isString(url)) {
        throw Error(bbn._('The component bbn-container must have a valid URL defined (from callRouter)'));
      }
      if (this.parent) {
        let containers = this.ancestors('bbn-container');
        url = bbn.fn.substr(this.getFullBaseURL(), this.router.baseURL.length) + url;
        //bbn.fn.log("CALL ROOT ROUTER WITH URL " + url);
        // The URL of the last bbn-container as index of the root router
        this.router.realRoute(url, containers[containers.length - 1].url, true);
      } else {
        this.realRoute(url, st, true);
      }
    },
    /**
     * @method searchContainer
     * @param {String} url
     * @param {Boolean} deep
     * @fires search
     * @fires getContainer
     * @return {Vue|Boolean}
     */
    searchContainer(url, deep) {
      let container = false,
        idx = this.search(url);
      if (idx !== false) {
        container = this.getContainer(idx);
        if (deep && container) {
          let router = container.find('bbn-router');
          if (router) {
            let real = router.searchContainer(bbn.fn.substr(url, router.baseURL.length), true);
            if (real) {
              return real;
            }
          }
        }
      }
      return container;
    },
    /**
     * @method load
     * @param {String} url
     * @param {Boolean} force
     * @fires search
     * @fires add
     * @fires parseURL
     * @fires callRouter
     * @fires navigate
     * @fires activate
     * @emit update
    */
    load(url, force, index) {
      if (url) {
        this.isLoading = true;
        let finalURL = this.fullBaseURL + url;
        let idx = this.search(url);
        let toAdd = false;
        let view;
        if (idx !== false) {
          //bbn.fn.log("INDEX RETRIEVED BEFORE LOAD: " + idx.toString(), JSON.stringify(this.views[idx], null, 2));
          if (this.views[idx].loading || !force && !this.views[idx].load) {
            return;
          }
          view = this.views[idx];
          //bbn.fn.log(finalURL, idx, JSON.stringify(view, null, 2), force, index);
          //alert("STOP");
          if (force) {
            let kept = {
              loading: true,
              loaded: false,
              load: true,
              url: view.url,
              current: url,
              selected: true,
              cached: view.cached !== undefined ? view.cached : this.single || !this.nav ? false : true,
              pane: view.pane,
              title: view.title,
              fixed: view.fixed,
              pinned: view.pinned,
              index: idx,
              real: view.real || false,
              last: bbn.fn.timestamp()
            };
            if (view.icon) {
              kept.icon = view.icon;
            }
            if (view.bcolor) {
              kept.bcolor = view.bcolor;
            }
            if (view.fcolor) {
              kept.fcolor = view.fcolor;
            }
            bbn.fn.iterate(bbn.fn.extend(this.getDefaultView(), kept), (a, n) => {
              if (view[n] !== a) {
                this.$set(view, n, a);
              }
            });
            if (this.urls[url]) {
              this.urls[url].isLoaded = false;
              this.urls[url].dirty = false;
            }
          }
          if (index !== undefined && idx !== index) {
            this.move(idx, index);
            idx = index;
          }
        } else {
          toAdd = true;
          idx = index === undefined ? this.views.length : index;
        }
        if (this.single) {
          idx = 0;
        }
        if (toAdd) {
          var _view, _view2;
          bbn.fn.log("ADDING ON LOAD");
          this.add({
            url: url,
            title: (_view = view) !== null && _view !== void 0 && _view.title ? view.title : bbn._('Loading'),
            load: true,
            loading: true,
            real: ((_view2 = view) === null || _view2 === void 0 ? void 0 : _view2.real) || false,
            pane: false,
            scrollable: !this.single,
            current: url,
            error: false,
            loaded: false,
            hidden: false,
            last: bbn.fn.timestamp()
          }, idx);
          view = this.views[this.search(url)];
        } else if (!this.views[idx].loading) {
          this.views[idx].loading = true;
        }
        if (!this.views[idx].pane) {
          this.currentURL = this.parseURL(url);
        }
        this.$forceUpdate();
        let portal = this.getRef('portal-' + url);
        if (portal) {
          portal.$forceUpdate();
        }
        this.$emit('update', this.views);
        this.$emit("load", finalURL);
        let dataObj = this.postBaseUrl ? {
          _bbn_baseURL: this.fullBaseURL
        } : {};
        return this.$nextTick(() => {
          this.post(finalURL, dataObj, d => {
            let callRealInit = true;
            this.isLoading = false;
            //this.remove(url);
            if (d.url) {
              d.url = this.parseURL(d.url);
            }
            if (!d.url) {
              d.url = url;
            }
            //bbn.fn.warning("URLS", url, d.url);
            if (url.indexOf(d.url) === 0) {
              d.current = url;
              //bbn.fn.warning("CURRENT DEFINED AS " + d.current);
            } else {
              bbn.fn.warning(url + ' != ' + d.url);
              let searchIdx = this.search(url);
              if (searchIdx !== false) {
                idx = searchIdx;
                bbn.fn.log("REMOVED");
                this.remove(searchIdx, true);
              }
            }
            if (d.data && bbn.fn.numProperties(d.data)) {
              d.source = d.data;
              delete d.data;
            }
            if (!d.title || d.title === bbn._('Loading')) {
              if (view && view.title) {
                d.title = view.title;
              } else {
                let title = bbn._('Untitled');
                let num = 0;
                while (bbn.fn.search(this.views, {
                  title: title
                }) > -1) {
                  num++;
                  title = bbn._('Untitled') + ' ' + num;
                }
                d.title = title;
              }
            }
            if (!d.current && d.url) {
              d.current = d.url;
            }
            if (d.url !== d.current && this.urls[d.current]) {
              let currentIndex = this.urls[d.current].currentIndex;
              //bbn.fn.warning("DELETING VIEW CASE.... " + d.url + ' / ' + d.current + ' ' + currentIndex);
              //bbn.fn.log([d.url, this.urls[d.current], this.urls[d.url], Object.keys(this.urls), bbn.fn.search(this.views, {idx: this.urls[d.current].idx})]);
              this.remove(currentIndex, true);
              this.$forceUpdate().then(() => {
                var _view3;
                const onRegister = url => {
                  //bbn.fn.log(["REGISTERED", url]);
                  if (url === d.url) {
                    this.$off('registered', onRegister);
                    let view = bbn.fn.getRow(this.views, {
                      url: url
                    });
                    if (this.selected === view.idx || view.pane) {
                      this.realInit(url);
                    }
                  }
                };
                this.$on('registered', onRegister);
                let o = bbn.fn.extend(view || bbn.fn.createObject(), d, {
                  loading: false,
                  load: true,
                  real: ((_view3 = view) === null || _view3 === void 0 ? void 0 : _view3.real) || false,
                  loaded: true
                });
                //bbn.fn.log(["BEFORE", this.views.length, Object.keys(this.urls)]);
                this.add(o, currentIndex);
                //bbn.fn.log(["AFTER", this.views.length, Object.keys(this.urls)]);
                this.$forceUpdate().then(() => {
                  //bbn.fn.log(this.search(o.url), o);
                  let searchIndex = this.search(o.url);
                  //bbn.fn.log("Looking for " + o.url);
                  if (searchIndex !== false) {
                    //this.activateIndex(searchIndex);
                    this.selected = searchIndex;
                  }
                });
              });
              //callRealInit = false;
              /*
              */
            } else {
              this.$forceUpdate().then(() => {
                var _view4;
                let o = bbn.fn.extend(view || bbn.fn.createObject(), d, {
                  loading: false,
                  load: true,
                  real: ((_view4 = view) === null || _view4 === void 0 ? void 0 : _view4.real) || false,
                  loaded: true
                });
                let searchIndex = this.search(o.url);
                //bbn.fn.log("Looking for " + o.url);
                if (searchIndex !== false && this.urls[this.views[searchIndex].url]) {
                  //this.remove(searchIndex);
                  //bbn.fn.warning("FOUND AND NOT REMOVED " + searchIndex);
                  this.urls[this.views[searchIndex].url].isLoaded = true;
                  this.urls[this.views[searchIndex].url].dirty = false;
                  this.urls[this.views[searchIndex].url].ready = false;
                  this.urls[this.views[searchIndex].url].init();
                } else {
                  //bbn.fn.warning("ADDEDD " + idx);
                  //bbn.fn.log("ADDING AFTER LOAD");
                  this.add(o, idx);
                }
                if (o.title && !o.pane) {
                  this.currentTitle = o.title;
                }
                //this.$forceUpdate();
                this.$nextTick(() => {
                  if (callRealInit) {
                    this.realInit(d.url);
                  }
                });
              });
            }
          }, xhr => {
            this.isLoading = false;
            let idx = this.search(this.parseURL(finalURL));
            if (idx !== false) {
              let url = this.views[idx].url;
              if (this.urls[url]) {
                this.urls[url].errorStatus = xhr;
                this.urls[url].setTitle(bbn._("Error"));
                this.urls[url].setIcon("nf nf-fa-warning");
                if (this.selected === idx) {
                  this.callRouter(finalURL, url);
                }
              }
            }
          }, () => {
            this.isLoading = false;
            let idx = this.search(this.parseURL(finalURL));
            if (idx !== false) {
              let url = this.views[idx].url;
              if (this.urls[url]) {
                this.callRouter(finalURL, url);
                this.$nextTick(() => {
                  this.close(idx);
                });
              }
            }
          });
        });
      }
    },
    realInit(url) {
      //bbn.fn.log("REAL INIT", url, this.urls, this.views)
      if (this.urls[url]) {
        this.urls[url].setLoaded(true);
        // Otherwise the changes we just did on the props wont be taken into account at container level
        this.urls[url].init();
        //bbn.fn.log("callRouter", this.urls[url], this.urls[url].currentView);
        this.callRouter(this.urls[url].currentURL || url, url);
        this.$emit('update', this.views);
      } else {
        //bbn.fn.log(url, this.views[0].loading, this.views[0].url, JSON.stringify(Object.keys(this.urls), null, 2));
        //throw new Error(bbn._("Impossible to find the container for URL") + ' ' + url);
      }
    },
    checkLoaded(idx) {
      return this.views[idx] &&
      //!this.views[idx].real &&
      this.views[idx].load && this.urls[this.views[idx].url] && this.urls[this.views[idx].url].isLoaded;
    },
    /**
     * @method reload
     * @param {Number} idx
     * @fires route
     */
    reload(idx, force) {
      if (this.checkLoaded(idx)) {
        let url = this.views[idx].current;
        if (!force && !this.ignoreDirty && this.isDirty && this.views[idx].dirty) {
          this.confirm(this.confirmLeave, () => {
            if (this.checkLoaded(idx)) {
              // Looking for dirty ones in registered forms of each container
              let forms = this.urls[this.views[idx].url].forms;
              if (Array.isArray(forms) && forms.length) {
                bbn.fn.each(forms, (f, k) => {
                  f.reset();
                });
              }
              if (this.urls[this.views[idx].url] && this.urls[this.views[idx].url].popups && this.urls[this.views[idx].url].popups.length) {
                this.urls[this.views[idx].url].popups.splice(0);
              }
              this.load(url, true, idx);
            }
          });
        } else {
          this.$nextTick(() => {
            if (this.urls[this.views[idx].url] && this.urls[this.views[idx].url].popups && this.urls[this.views[idx].url].popups.length) {
              this.urls[this.views[idx].url].popups.splice(0);
            }
            this.load(url, true, idx);
          });
        }
      }
    },
    /**
     * @method getDefaultURL
     * @fires parseURL
     * @return {String}
     */
    getDefaultURL() {
      let url = this.parseURL(bbn.env.path);
      if (!url && this.url) {
        url = this.url;
      }

      // If there is a parent router we automatically give the proper baseURL
      if (!url && this.parentContainer && this.parentContainer.currentURL !== this.parentContainer.url) {
        url = bbn.fn.substr(this.parentContainer.currentURL, this.parentContainer.url.length + 1);
      }
      if (!url && this.def) {
        url = this.def;
      }
      return url;
    },
    /**
     * @method getTitle
     * @param {Number} idx
     * @return {String}
     */
    getTitle(idx) {
      let cp = this,
        res = '';
      if (idx === undefined) {
        idx = this.selected;
      }
      if (cp.views[idx]) {
        res += cp.views[idx].title || bbn._('Untitled');
        if (cp.parentTab) {
          idx = cp.parentTab.currentIndex;
          cp = cp.parentTab.router;
          while (cp) {
            res += ' < ' + (cp.views[idx].title || bbn._('Untitled'));
            if (cp.parentTab) {
              idx = cp.parentTab.currentIndex;
              cp = cp.parentTab.router;
            } else {
              cp = false;
            }
          }
        }
        res += ' - ';
      }
      res += bbn.env.siteTitle || bbn._("Untitled site");
      return res;
    },
    /**
     * Sets the 'dirtyContainers' property with the list of unsaved views
     * @method retrieveDirtyContainers
     */
    retrieveDirtyContainers() {
      this.dirtyContainers.splice(0, this.dirtyContainers.length);
      bbn.fn.iterate(this.urls, v => {
        if (v.dirty) {
          this.dirtyContainers.push({
            idx: v.currentIndex,
            url: v.url
          });
        }
      });
    },
    /**
     * @method onEscape
     * @param {Event} e
     */
    onEscape(e) {
      if (this.isVisual && this.visualShowAll) {
        this.visualShowAll = false;
        e.stopPropagation();
        e.preventDefault();
      }
    },
    /**
     * @method getMenuFn
     * @param {Number} idx
     * @fires getSubRouter
     * @fires getContainer
     * @fires reload
     * @return {Array|Boolean}
     */
    getMenuFn(idx) {
      if (!this.nav || !this.views[idx] || this.views[idx].menu === false) {
        return [];
      }
      let items = [];
      let tmp = ((bbn.fn.isFunction(this.views[idx].menu) ? this.views[idx].menu() : this.views[idx].menu) || []).slice();
      let others = false;
      let container = this.getContainer(idx);
      bbn.fn.each(this.views, (a, i) => {
        if (i !== idx && !a.fixed) {
          others = true;
          return false;
        }
      });
      if (!this.views[idx].help) {
        let sub = this.getSubRouter(idx);
        if (sub && sub.views && sub.views.length) {
          let helps = [];
          sub.views.forEach(a => {
            if (a.help) {
              helps.push({
                url: sub.fullBaseURL + a.url,
                content: a.help,
                title: a.title || a.url,
                anchor: bbn.fn.randomString(15, 20).toLowerCase()
              });
            }
          });
          if (helps.length === 1) {
            this.views[idx].help = helps[0].content;
          } else if (helps.length) {
            this.views[idx].help = '';
            let slide1 = '';
            helps.forEach(a => {
              slide1 += '<h1><a href="#' + a.anchor + '">' + a.title + '</a></h1>\n';
              this.views[idx].help += '---slide---' + '\n<a name="' + a.anchor + '">\n' + a.content;
            });
            this.views[idx].help = slide1 + this.views[idx].help;
          }
        }
      }
      if (this.views[idx].help) {
        items.push({
          text: bbn._("Help"),
          key: "help",
          icon: "nf nf-mdi-help_circle_outline",
          action: () => {
            let view = this.getContainer(idx),
              span = document.createElement('span');
            span.innerHTML = this.views[idx].title;
            let title = span.innerText;
            if (!title && span.querySelector("[title]").length) {
              title = span.querySelector("[title]").getAttribute("title");
            }
            view.getPopup({
              scrollable: false,
              component: {
                props: ['source'],
                template: `
                  <bbn-slideshow :source="source.content"
                                class="bbn-bg-webblue bbn-white"
                                :full-slide="true"
                                separator="---slide---"></bbn-slideshow>`
              },
              source: {
                content: this.views[idx].help
              },
              title: '<i class="bbn-large nf nf-mdi-help_circle_outline"> </i> <span class="bbn-iblock">' + title + '</span>',
              width: '90%',
              height: '90%'
            });
          }
        });
      }
      if (this.views[idx].load && !this.views[idx].component) {
        items.push({
          text: bbn._("Reload"),
          key: "reload",
          icon: "nf nf-mdi-sync",
          action: () => {
            this.reload(idx);
          }
        });
      }
      if (container && container.fullScreen) {
        items.push({
          text: bbn._("Exit full screen"),
          key: "reduce",
          icon: "nf nf-mdi-arrow_collapse",
          action: () => {
            container.fullScreen = false;
          }
        });
      } else if (container && !container.isPane) {
        items.push({
          text: bbn._("Enlarge"),
          key: "enlarge",
          icon: "nf nf-mdi-arrow_expand_all",
          action: () => {
            container.fullScreen = true;
          }
        });
      }
      if (tmp && tmp.length) {
        bbn.fn.each(tmp, (a, i) => {
          items.push(a);
        });
      }
      if (this.views[idx].icon && this.views[idx].title && !this.isBreadcrumb && !this.isVisual) {
        items.push({
          text: this.views[idx].notext ? bbn._("Show text") : bbn._("Show only icon"),
          key: "notext",
          icon: this.views[idx].notext ? "nf nf-fa-font" : "nf nf-fa-font_awesome",
          action: () => {
            this.$set(this.views[idx], 'notext', !this.views[idx].notext);
          }
        });
      }

      // Adding a shortcut
      if (window.appui) {
        items.push({
          text: bbn._("Create a shortcut"),
          key: "shortcut",
          icon: "nf nf-fa-link",
          action: () => {
            this.$emit('shortcut', {
              text: this.views[idx].title,
              icon: this.views[idx].icon || 'nf nf-fa-link',
              url: this.getFullBaseURL() + this.views[idx].url
            });
          }
        });
      }
      if (container) {
        items.push({
          text: bbn._("Copy content text"),
          icon: "nf nf-fa-copy",
          key: "text_copy",
          action: () => {
            let scroll = container.getRef('scroll');
            let ok = false;
            if (scroll) {
              let scrollContent = scroll.getRef('scrollContent');
              if (scrollContent) {
                bbn.fn.copy(scrollContent.innerText);
                ok = true;
              }
            }
            if (ok) {
              appui.success(bbn._("Copied!"));
            } else {
              appui.error(bbn._("Not copied!"));
            }
          }
        });
        items.push({
          text: bbn._("Copy content HTML"),
          icon: "nf nf-fa-html5",
          key: "html_copy",
          action: () => {
            let scroll = container.getRef('scroll');
            let ok = false;
            if (scroll) {
              let scrollContent = scroll.getRef('scrollContent');
              if (scrollContent) {
                bbn.fn.copy(scrollContent.innerHTML);
                ok = true;
              }
            }
            if (ok) {
              appui.success(bbn._("Copied!"));
            } else {
              appui.error(bbn._("Not copied!"));
            }
          }
        });
        items.push({
          text: bbn._("Screenshot"),
          icon: "nf nf-mdi-image_album",
          key: "screenshot",
          items: [{
            text: bbn._("Download"),
            key: "screenshot_dl",
            icon: "nf nf-mdi-arrow_expand_all",
            action: () => {
              container.takeScreenshot().then(canvas => {
                if (canvas) {
                  bbn.fn.downloadContent(bbn.fn.replaceAll('/', '-', container.getFullCurrentURL() + '_' + bbn.fn.dateSQL(undefined, true) + '.png'), canvas);
                }
              });
            }
          }, {
            text: bbn._("Copy"),
            key: "screenshot_copy",
            icon: "nf nf-mdi-image_multiple",
            action: () => {
              container.takeScreenshot(0.5).then(canvas => {
                if (canvas) {
                  canvas.toBlob(blob => {
                    bbn.fn.copy(blob).then(() => {
                      appui.success();
                    });
                  });
                }
              });
            }
          }, {
            text: bbn._("Copy full size"),
            key: "screenshot_copy",
            icon: "nf nf-mdi-image_multiple",
            action: () => {
              container.takeScreenshot(1).then(canvas => {
                if (canvas) {
                  canvas.toBlob(blob => {
                    bbn.fn.copy(blob).then(() => {
                      appui.success();
                    });
                  });
                }
              });
            }
          }]
        });
      }
      if (!this.views[idx].fixed && !this.views[idx].pane) {
        if (this.isBreadcrumb) {
          items.push({
            text: bbn._("Close"),
            key: "close",
            icon: "nf nf-mdi-close",
            action: () => {
              this.close(idx);
            }
          });
        } else {
          if (!this.views[idx].pinned) {
            items.push({
              text: bbn._("Pin"),
              key: "pin",
              icon: "nf nf-mdi-pin",
              action: () => {
                this.pin(idx);
              }
            });
            items.push({
              text: bbn._("Close"),
              key: "close",
              icon: "nf nf-mdi-close",
              action: () => {
                this.close(idx);
              }
            });
          } else {
            items.push({
              text: bbn._("Unpin"),
              key: "pin",
              icon: "nf nf-mdi-pin_off",
              action: () => {
                this.unpin(idx);
              }
            });
          }
        }
      }
      if (others && !this.views[idx].pane) {
        items.push({
          text: bbn._("Close Others"),
          key: "close_others",
          icon: "nf nf-mdi-close_circle_outline",
          action: () => {
            this.closeAllBut(idx);
          }
        });
        if (!this.isVisual) {
          let directions = [];
          if (idx) {
            if (idx > 1) {
              directions.push({
                text: bbn._("First"),
                key: "move_first",
                icon: "nf nf-mdi-close_circle_outline",
                action: () => {
                  this.move(idx, 0);
                }
              });
            }
            directions.push({
              text: bbn._("Before"),
              key: "move_before",
              icon: "nf nf-mdi-close_circle_outline",
              action: () => {
                this.move(idx, idx - 1);
              }
            });
          }
          if (idx < this.views.length - 1) {
            directions.push({
              text: bbn._("After"),
              key: "move_after",
              icon: "nf nf-mdi-close_circle_outline",
              action: () => {
                this.move(idx, idx + 1);
              }
            });
            if (idx < this.views.length - 2) {
              directions.push({
                text: bbn._("Last"),
                key: "move_last",
                icon: "nf nf-mdi-close_circle_outline",
                action: () => {
                  this.move(idx, this.views.length - 1);
                }
              });
            }
          }
          if (directions.length) {
            if (directions.length === 1) {
              directions[0].text = bbn._("Switch position");
              items.push(directions[0]);
            } else {
              items.push({
                text: bbn._("Move"),
                key: "move",
                icon: "nf nf-mdi-close_circle_outline",
                items: directions
              });
            }
          }
        }
      }
      if (container && this.splittable) {
        if (container.isPane) {
          items.push({
            text: bbn._("Remove from pane"),
            key: "unpane",
            icon: "nf nf-mdi-window_restore",
            action: () => {
              this.removeFromPane(idx);
            }
          });
        } else {
          items.push({
            text: bbn._("Show in a new pane"),
            key: "split",
            icon: "nf nf-mdi-format_horizontal_align_right",
            action: () => {
              this.addToPane(idx);
            }
          });
          if (this.currentPanes.length) {
            let tmp = {
              text: bbn._("Show in pane"),
              key: "panes",
              icon: "nf nf-mdi-checkbox_multiple_blank_outline",
              items: []
            };
            bbn.fn.each(this.currentPanes, (a, i) => {
              tmp.items.push({
                text: 'Pane <div class="bbn-badge">' + (i + 1) + '</div>',
                key: "pane" + (i + 1),
                action: () => {
                  this.addToPane(idx, a.id);
                }
              });
            });
            items.push(tmp);
          }
        }
      }
      if (others && !this.views[idx].fixed && !this.views[idx].pane) {
        items.push({
          text: bbn._("Close All"),
          key: "close_all",
          icon: "nf nf-mdi-close_circle",
          action: () => {
            this.closeAll();
          }
        });
      }
      if (!this.views[idx].pane) {
        items.push({
          text: bbn._("Configuration"),
          key: "config",
          icon: "nf nf-fa-cogs",
          action: () => {
            this.showRouterCfg = true;
          }
        });
      }
      let menu = bbn.fn.isArray(this.menu) ? this.menu : this.menu(this.views[idx], this);
      if (menu.length) {
        bbn.fn.each(menu, a => {
          items.push(a);
        });
      }
      return items;
    },
    /**
     * @method setconfig
     * @fires setStorage
     * @fires getConfig
     */
    setConfig() {
      if (this.autoload && this.isInit) {
        this.setStorage(this.getConfig(), this.parentContainer ? this.parentContainer.getFullURL() : this.storageName);
        //this.$forceUpdate();
      }
    },

    /**
     * @method getConfig
     * @return {Object}
     */
    getConfig() {
      let cfg = {
        baseURL: this.parentContainer ? this.parentContainer.getFullURL() : this.storageName,
        views: [],
        breadcrumb: this.isBreadcrumb,
        visual: this.isVisual,
        orientation: this.lockedOrientation ? this.visualOrientation : null,
        panes: this.currentPanes.map(a => {
          return {
            id: a.id,
            tabs: a.tabs.map(b => b.url),
            selected: a.selected
          };
        })
      };
      bbn.fn.each(this.views, (obj, i) => {
        if (obj.url && obj.load) {
          let res = {
            url: obj.url,
            icon: obj.icon || false,
            notext: obj.notext || false,
            load: true,
            loaded: false,
            title: obj.title ? obj.title : bbn._('Untitled'),
            fixed: !!obj.fixed,
            pinned: !!obj.pinned,
            pane: obj.pane || false,
            current: obj.current ? obj.current : obj.url,
            cfg: {},
            real: obj.real,
            last: obj.last
          };
          if (obj.bcolor) {
            res.bcolor = obj.bcolor;
          }
          if (obj.fcolor) {
            res.fcolor = obj.fcolor;
          }
          cfg.views.push(res);
        }
      });
      return cfg;
    },
    /**
     * @method unsetConfig
     * @fires unsetStorage
     */
    unsetConfig() {
      if (this.autoload) {
        this.unsetStorage(this.parentContainer ? this.parentContainer.getFullURL() : this.storageName);
      }
    },
    /*
    observerEmit(newVal, obs){
      bbn.fn.log("OBS EMIT", newVal, obs);
      let ele = $(".bbn-observer-" + obs.element, this.$el);
      if ( ele.length ){
        let idx = this.getIndex(ele);
        if ( idx !== false ){
          let i = bbn.fn.search(this.observers, {id: obs.id, element: obs.element});
          if ( (i > -1) && (this.observers[i].value !== newVal) ){
            if ( idx === this.selected ){
              this.$emit('bbnObs' + obs.element + obs.id, newVal);
              this.observers[i].value = newVal;
            }
            else{
              this.observers[i].value = newVal;
              this.$set(this.views[idx].events, 'bbnObs' + obs.element + obs.id, newVal);
            }
          }
        }
      }
    },
    */
    /**
     * @method observerEmit
     * @param newVal
     * @param obs
     * @fires getIndex
     */
    observerEmit(newVal, obs) {
      if (bbn.cp.mixins.observer.methods.observerEmit.apply(this, [newVal, obs])) {
        let ele = this.$el.querySelector(".bbn-observer-" + obs.element);
        if (ele) {
          let idx = this.getIndex(ele);
          if (idx !== false) {
            this.$set(this.views[idx].events, 'bbnObs' + obs.element + obs.id, newVal);
            this.$nextTick(() => {
              //this.$forceUpdate();
            });
          }
        }
      }
    },
    /**
     * The called method on the switching to false of the "observer Dirty" property value
     * @method observerClear
     * @param {Object} obs
     * @fires getIndex
     * @fires $delete
     * @fires $nextTick
     * @fires $forceUpdate
     * @fires observationTower.observerClear
     */
    observerClear(obs) {
      let ele = this.$el.querySelector(".bbn-observer-" + obs.element);
      if (ele) {
        let idx = this.getIndex(ele);
        if (idx !== false && this.views[idx].events['bbnObs' + obs.element + obs.id] !== undefined) {
          this.$delete(this.views[idx].events, 'bbnObs' + obs.element + obs.id);
          this.$nextTick(() => {
            //this.$forceUpdate();
          });
        }
      } else if (this.observationTower) {
        this.observationTower.observerClear(obs);
      }
    },
    /**
     * Function triggered every time a container is shown (at the start of the animation) to change the URL if needed.
     * @method enter
     * @param container
     */
    enter(container) {
      //bbn.fn.log("THE CONTAINER WILL BE SHOWN: ", container);
    },
    //Tabs
    /**
     * Cuts the given string by 'maxTitleLength' property value
     * @method cutTitle
     * @param {String} title
     * @return {String}
     */
    cutTitle(title) {
      return bbn.fn.shorten(title, this.maxTitleLength);
    },
    /**
     * Returns the full title (combination of title and ftitle if any)
     * 
     * @method getFullTitle
     * @param {Object} obj
     * @return {String|null}
     */
    getFullTitle(obj) {
      let t = '';
      if (obj.title) {
        t += obj.title;
      }
      if (obj.ftitle) {
        t += (t.length ? ' - ' : '') + obj.ftitle;
      }
      return t;
    },
    /**
     * @method getFontColor
     * @param {Number} idx
     * @fires getRef
     * @return {String}
     */
    getFontColor(idx) {
      return this.views[idx].fcolor || '';
      //this.views[idx].fcolor = window.getComputedStyle(el.$el ? el.$el : el).color;
    },

    /**s
     * @method getBackgroundColor
     * @param {Number} idx
     * @fires getRef
     * @return {String}
     */
    getBackgroundColor(idx) {
      return this.views[idx].bcolor || '';
      /*
      if (this.$isMounted && this.views[idx]) {
        if (!this.views[idx].bcolor) {
          let el = this.getRef('title-' + idx);
          if (el) {
            this.views[idx].bcolor = window.getComputedStyle(el.$el ? el.$el : el).backgroundColor;
            bbn.fn.log(["GETTING BCOLOR", idx, this.views[idx].bcolor]);
          }
        }
          return this.views[idx].bcolor;
      }
        return '';
      */
    },

    /**
     * @method getTab
     * @param {Number} idx
     * @fires getRef
     * @return {HTMLElement}
     */
    getTab(idx) {
      if (idx === undefined) {
        idx = this.selected;
      }
      return this.getRef('tabs').getRef('tab-' + idx);
    },
    /**
     * @method closeAll
     * @fires close
     */
    closeAll(force) {
      for (let i = this.views.length - 1; i >= 0; i--) {
        if (!this.views[i].fixed && !this.views[i].pinned) {
          this.close(i, force, true);
        }
      }
      this.setConfig();
    },
    /**
     * @method closeallBut
     * @param {Number} idx
     * @fires close
     */
    closeAllBut(idx, force) {
      for (let i = this.views.length - 1; i >= 0; i--) {
        if (!this.views[i].fixed && !this.views[i].pinned && i !== idx) {
          this.close(i, force, true);
        }
      }
      this.setConfig();
    },
    /**
     * @method pin
     * @param {Number} idx
     * @fires isValidIndex
     * @fires setConfig
     * @emit beforePin
     * @emit pin
     */
    pin(idx) {
      if (this.isValidIndex(idx)) {
        let ev = new CustomEvent('beforePin', {
          cancelable: true
        });
        this.$emit('beforePin', idx, ev);
        if (!ev.defaultPrevented) {
          this.views[idx].pinned = true;
          this.setConfig();
          this.$emit('pin', idx);
        }
      }
    },
    /**
     * @method unpin
     * @param {Number} idx
     * @fires isValidIndex
     * @fires setConfig
     * @emit beforeUnpin
     * @emit unpin
     */
    unpin(idx) {
      if (this.isValidIndex(idx)) {
        let ev = new CustomEvent('beforeUnpin', {
          cancelable: true
        });
        this.$emit('beforeUnpin', idx, ev);
        if (!ev.defaultPrevented) {
          this.views[idx].pinned = false;
          this.setConfig();
          this.$emit('unpin', idx);
        }
      }
    },
    /**
     * @method registerRouter
     * @param {bbnCp} bc
     * @param {String} url
     */
    registerRouter(router) {
      this.routers[bbn.fn.substr(router.getBaseURL(), 0, -1)] = router;
    },
    /**
     * @method unregisterRouter
     * @param {bbnCp} bc
     * @param {String} url
     */
    unregisterRouter(router) {
      delete this.routers[bbn.fn.substr(router.getBaseURL(), 0, -1)];
    },
    //Breadcrumb
    /**
     * @method registerBreadcrumb
     * @param {bbnCp} bc
     * @param {String} url
     */
    registerBreadcrumb(bc) {
      let url = bbn.fn.substr(bc.baseURL, 0, bc.baseURL.length - 1);
      this.breadcrumbsList.push(bc);
      if (this.itsMaster && !this.master) {
        this.itsMaster.breadcrumbsList.push(bc);
      }
    },
    /**
     * @method unregisterBreadcrumb
     * @param {bbnCp} bc
     * @param {String} url
     */
    unregisterBreadcrumb(bc) {
      if (this.breadcrumbsList) {
        let idx = bbn.fn.search(this.breadcrumbsList, {
          baseURL: bc.baseURL
        });
        if (idx !== -1) {
          this.breadcrumbsList.splice(idx, 1);
        }
        if (this.itsMaster && !this.master) {
          idx = bbn.fn.search(this.itsMaster.breadcrumbsList, {
            baseURL: bc.baseURL
          });
          if (idx !== -1) {
            this.itsMaster.breadcrumbsList.splice(idx, 1);
          }
        }
      }
    },
    getBreadcrumbs(idx) {
      let ret = [];
      if (bbn.fn.isNumber(idx) && this.views[idx]) {
        let url = this.views[idx].url,
          bc = bbn.fn.getRow(this.breadcrumbsList, {
            baseURL: url + '/'
          });
        if (this.urls[url] && bc) {
          ret.push(...bc.breadcrumbs);
        }
      }
      return ret;
    },
    /**
     * Returns the breadcrumb's source list.
     * @method getList
     * @param {bbnCp} bc
     * @fires close
     * @return {Array}
     */
    getList(idx) {
      let list = [],
        parents = bbn.fn.map(idx && this.itsMaster && this.baseURL !== this.itsMaster.baseURL ? this.getParents() : [], p => {
          return {
            view: p.views[p.selected],
            maxTitleLength: p.maxTitleLength
          };
        });
      if (parents.length > idx) {
        parents.splice(0, parents.length - idx);
      }
      bbn.fn.each(this.views, (t, i) => {
        if (!t.hidden && t.idx !== this.selected && !t.pane) {
          list.push({
            view: t,
            key: t.url,
            parents: parents,
            children: bbn.fn.map(this.getBreadcrumbs(i), c => {
              return {
                view: c.views[c.selected],
                maxTitleLength: c.maxTitleLength
              };
            }),
            maxTitleLength: this.maxTitleLength,
            action: () => {
              this.activateIndex(t.idx);
            },
            closeAction: () => {
              return this.close(t.idx);
            }
          });
        }
      });
      return list;
    },
    /**
     * @method getParents
     * @return {Array}
     */
    getParents() {
      return this.parent ? [...this.parent.getParents(), this.parent] : [];
    },
    /**
     * @method onResize
     * @return {Promise}
     */
    onResize() {
      this.keepCool(() => {
        let m = this.setResizeMeasures();
        let c = this.setContainerMeasures();
        if (m || c) {
          this.$emit('resize');
        }
        if (this.isVisual && this.orientation === 'auto' && !this.lockedOrientation) {
          this.visualOrientation = this.lastKnownWidth > this.lastKnownHeight ? 'left' : 'top';
        }
      }, 'resize', 50);
    },
    /**
     * @method getView
     * @return {Object|null}
     */
    getView(url) {
      return bbn.fn.getRow(this.views, {
        url: url
      });
    },
    addPane(paneId) {
      if (this.splittable) {
        if (!paneId) {
          paneId = bbn.fn.randomString().toLowerCase();
        }
        if (!bbn.fn.getRow(this.currentPanes, {
          id: paneId
        })) {
          this.currentPanes.push({
            id: paneId,
            tabs: [],
            selected: -1
          });
        }
      }
      return paneId;
    },
    selectPaneTab(pane) {
      let view = pane.tabs[pane.selected];
      if (view) {
        view.last = bbn.fn.timestamp();
      }
    },
    closeTab(idx) {
      this.close(this.tabsList[idx].idx);
    },
    removePane(paneId) {
      if (this.splittable && this.currentPanes) {
        let paneIndex = bbn.fn.search(this.currentPanes, {
          id: paneId
        });
        let pane = this.currentPanes[paneIndex];
        if (!pane) {
          throw new Error(bbn._("Impossible to find the pane with ID %s", paneId));
        }
        if (pane.tabs.length) {
          throw new Error(bbn._("Impossible to remove the pane with ID %s as it has still containers inside", paneId));
        }
        this.currentPanes.splice(paneIndex, 1);
        if (this.routed) {
          this.$nextTick(() => {
            this.currentPanes.length ? this.getRef('splitter').init() : this.getRef('topSplitter').init();
          });
        }
      }
    },
    addToPane(containerIdx, paneId) {
      let view = this.views[containerIdx];
      if (!view) {
        throw new Error(bbn._("Impossible to find the view with index") + ' ' + containerIdx);
      }
      if (view.dirty) {
        this.alert(bbn._("Save your changes or discard them before moving the container"));
        return;
      }
      let pane = bbn.fn.getRow(this.currentPanes, {
        id: paneId
      });
      if (!pane) {
        paneId = this.addPane(paneId);
        pane = bbn.fn.getRow(this.currentPanes, {
          id: paneId
        });
      }
      this.$set(this.views[containerIdx], "pane", paneId);
      pane.tabs.push(view);
      //this.$forceUpdate();
      if (containerIdx === this.selected) {
        this.selectClosest(containerIdx);
      }
      pane.selected = pane.tabs.length - 1;
    },
    removeFromPane(containerIdx) {
      let view = this.views[containerIdx];
      if (view) {
        if (view.dirty) {
          this.alert(bbn._("Save your changes or discard them before moving the container"));
          return;
        }
        let paneId = view.pane;
        if (paneId) {
          let pane = bbn.fn.getRow(this.currentPanes, {
            id: paneId
          });
          if (pane && pane.tabs) {
            let idx = bbn.fn.search(pane.tabs, {
              idx: containerIdx
            });
            if (idx > -1) {
              this.selected = containerIdx;
              view.pane = false;
              this.$nextTick(() => {
                pane.tabs.splice(idx, 1);
                if (!pane.tabs.length) {
                  this.removePane(paneId);
                } else if (pane.selected >= idx) {
                  pane.selected--;
                  this.getRef('pane' + pane.id).onResize(true);
                }
              });
            }
          }
        }
      }
    },
    slashToHyphen(str) {
      return bbn.fn.replaceAll('/', '-', str);
    }
  },
  /**
   * @event created
   */
  created() {
    this.componentClass.push('bbn-resize-emitter');
    /**
    * @event route
    * @fires setconfig
    */
    this.$on('route', url => {
      if (this.nav) {
        this.setConfig();
        let i = this.history.indexOf(url);
        if (i > -1) {
          this.history.splice(i, 1);
        }
        this.history.unshift(url);
        while (this.history.length > this.historyMaxLength) {
          this.history.pop();
        }
      }
    });
    let storage = !this.single && this.getStorage(this.parentContainer ? this.parentContainer.getFullURL() : this.storageName);
    if (storage && storage.panes) {
      bbn.fn.each(storage.panes, a => {
        this.addPane(a.id);
      });
    }
  },
  /**
   * @event mounted
   * @fires getStorage
   * @fires getDefaultURL
   * @fires add
   */
  beforeMount() {
    // All routers above (which constitute the fullBaseURL)
    this.parents = this.ancestors('bbn-router');
    // The closest
    this.parent = this.parents.length ? this.parents[0] : false;
    // The root
    this.router = this.parents.length ? this.parents[this.parents.length - 1] : this;
    // Case where the rooter is not at the root level

    if (this.parent) {
      this.parentContainer = this.closest('bbn-container');
      let uri = this.parentContainer.url;
      if (this.root && uri !== this.root && this.root.indexOf(uri) === 0) {
        uri = this.root;
      }
      this.baseURL = this.formatBaseURL(uri);
    }
    // Case where the rooter is at root level
    else {
      // Opening the database for the visual mode multiview
      if (!this.single && bbnRouterCp.db) {
        bbn.db.open('bbn').then(r => {
          this.db = r;
        }, err => {
          bbn.fn.log("Connection error in router", err);
        });
      }
      window.addEventListener("beforeunload", e => {
        e = e || window.event;
        //if ( $(".bbn-tabnav-unsaved").length ){
        if (this.isDirty) {
          // doesn't use that string but a default string...
          let st = bbn._('You have unsaved data, are you sure you want to leave?');
          // For IE and Firefox prior to version 4
          if (e) {
            e.returnValue = st;
          }
          // For Safari
          return st;
        }
      });
    }
    let tmp = [];

    //bbn.fn.warning("BEFORE MOUNT ROUTER")

    //Get config from the storage
    let storage = !this.single && this.getStorage(this.parentContainer ? this.parentContainer.getFullURL() : this.storageName);
    if (storage) {
      if (storage.breadcrumb !== undefined) {
        this.isBreadcrumb = storage.breadcrumb;
      }
      if (storage.visual !== undefined) {
        this.isVisual = storage.visual;
      }
      if (storage.orientation) {
        this.visualOrientation = storage.orientation;
        this.lockedOrientation = true;
      }
    }

    // ---- ADDED 16/12/20 (Mirko) ----
    // Adding bbns-container from the slot
    if (this.$slots.default) {
      for (let item of this.$slots.default) {
        let node = item.bbnSchema;
        //bbn.fn.log("ROUTER SLOT", node, '-------------');

        if (['bbn-container', 'bbns-container'].includes(node === null || node === void 0 ? void 0 : node.tag)) {
          if (node.props.url === undefined) {
            throw new Error(bbn._("You cannot use containers in router without defining a URL property"));
          }
          if (!this.hasRealContainers) {
            this.hasRealContainers = true;
          }
          if (node.props.url === '') {
            this.hasEmptyURL = true;
          }
          const obj = bbn.fn.createObject(bbn.fn.extend(true, {}, node.props));
          bbn.fn.iterate(this.getDefaultView(), (a, n) => {
            if (obj[n] === undefined) {
              obj[n] = a;
            }
          });
          if (node.tag === 'bbn-container') {
            obj.real = true;
          }
          //let o = {real: true, load: false, loaded: true};
          //tmp.push(bbn.fn.extend({}, node.componentOptions.propsData, o));
          tmp.push(obj);
        }
      }
    }
    // ---- END ----

    bbn.fn.each(this.source, (a, i) => {
      if (a.url === '') {
        if (a.load) {
          throw new Error(bbn._("You cannot use containers with empty URL for loading"));
        }
        this.hasEmptyURL = true;
      }
      tmp.push(bbn.fn.extendOut(a, {
        real: false
      }));
    });

    //Get config from the storage
    if (storage && storage.views && tmp) {
      bbn.fn.each(storage.views, a => {
        let idx = bbn.fn.search(tmp, {
          url: a.url
        });
        if (idx > -1) {
          // Static comes only from configuration
          let isFixed = tmp[idx].fixed;
          bbn.fn.extend(tmp[idx], a, {
            fixed: isFixed
          });
        } else {
          tmp.push(a);
        }
      });
    }

    // Getting the default URL
    let url = this.getDefaultURL();
    if (this.first !== 'real') {
      tmp = bbn.fn.multiorder(tmp, {
        real: 'desc'
      });
    }

    // Adding to the views
    //bbn.fn.warning("ROUTER BEFORE MOUNT");
    bbn.fn.each(tmp, a => {
      if (!bbn.fn.isString(a.url)) {
        throw new Error(bbn._("The container must have a valid URL"));
      }

      // Setting current if URL starts with default URL
      if (url && url.indexOf(a.url) === 0) {
        a.current = url;
      }

      //bbn.fn.warning("ADDING BEFORE MOUNT");
      //bbn.fn.log(a);
      this.add(a);
    });
    if (this.splittable) {
      if (storage && storage.panes) {
        bbn.fn.each(storage.panes, pane => {
          bbn.fn.each(pane.tabs, tab => {
            let view = bbn.fn.getRow(this.views, {
              url: tab
            });
            let realPane = bbn.fn.getRow(this.currentPanes, {
              id: pane.id
            });
            if (view && realPane) {
              if (!view.pane) {
                view.pane = pane.id;
              }
              realPane.tabs.push(view);
            }
          });
        });
      }
      bbn.fn.each(this.views, a => {
        if (a.pane) {
          let pane = bbn.fn.getRow(this.currentPanes, {
            id: a.pane
          });
          if (pane && !bbn.fn.getRow(pane.tabs, {
            url: a.url
          })) {
            pane.tabs.push(a);
          }
        }
      });
      bbn.fn.each(this.currentPanes, pane => {
        let done = false;
        if (storage && storage.panes) {
          let p = bbn.fn.getRow(storage.panes, {
            id: pane.id
          });
          if (p && pane.tabs[p.selected]) {
            pane.selected = p.selected;
            done = true;
          }
        }
        if (!done) {
          pane.selected = pane.tabs.length ? 0 : -1;
        }
      });
    }

    //Breadcrumb
    if (!this.master && this.parent && this.parentContainer) {
      this.parent.registerBreadcrumb(this);
      bbn.fn.log("VIEW ON BREADCUMB");
      this.parentContainer.$on('view', () => {
        this.parent.registerBreadcrumb(this);
      }, true);
      this.parentContainer.$on('unview', () => {
        this.parent.unregisterBreadcrumb(this);
      }, true);
      if (this.parentContainer.isVisible) {
        this.parent.registerBreadcrumb(this);
      }
    }
    if (this.parentContainer) {
      this.parentContainer.registerRouter(this);
    }
    this.updateVisualStyleContainer();
    this.ready = true;
    this.$forceUpdate();
    this.$nextTick(() => {
      if (this.$slots.default) {
        for (let item of this.$slots.default) {
          var _item$bbnSchema;
          if (((_item$bbnSchema = item.bbnSchema) === null || _item$bbnSchema === void 0 ? void 0 : _item$bbnSchema.tag) === 'bbn-container') {
            let el = this.$refsElements['ct-' + item.bbnSchema.props.url];
            if (el) {
              el.parentNode.replaceChild(item, el);
            }
          }
        }
      }
      if (!this.views.length) {
        this.init(url);
      }
    });
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    if (!this.master && this.parent) {
      this.parent.unregisterBreadcrumb(this);
    }
    if (this.parentContainer) {
      this.parentContainer.unregisterRouter(this);
    }
  },
  watch: {
    numVisuals() {
      this.onResize();
    },
    numPanes() {
      this.onResize();
    },
    visualShowAll(v) {
      if (v && this.isVisual) {
        this.getRef('visualRouter').focus();
      }
    },
    selected(idx) {
      if (this.views[idx]) {
        //bbn.fn.log("In selected watcher " + idx, bbn.fn.filter(this.views, {selected: true}));
        bbn.fn.map(bbn.fn.filter(this.views, {
          selected: true
        }), a => {
          if (a.idx !== idx) {
            a.selected = false;
            if (this.urls[a.url]) {
              this.urls[a.url].$tick();
            }
          }
        });
        if (!this.views[idx].selected && !this.views[idx].pane) {
          this.views[idx].selected = true;
        }
        this.views[idx].last = bbn.fn.timestamp();
        if (this.currentURL !== this.views[idx].current) {
          bbn.fn.log("CHANGING URL " + this.currentURL + " TO " + this.views[idx].current);
          this.route(this.views[idx].current);
        }
      } else {
        throw new Error("The view with index " + idx + " doesn't exist");
      }
    },
    currentTitle(v) {
      if (!this.parent) {
        document.title = v + ' - ' + bbn.env.siteTitle;
      }
    },
    /**
     * @watch currentURL
     * @fires changeURL
     * @fires search
     * @emit change
     * @emit route
     */
    currentURL(newVal, oldVal) {
      if (this.ready) {
        let idx = this.search(newVal);
        if (idx !== false) {
          let v = this.views[idx];
          let ct = this.urls[v.url];
          if (!v.pane) {
            this.selected = idx;
            if (ct) {
              this.changeURL(newVal, ct.title);
            } else if (this.isLoading) {
              this.changeURL(newVal, bbn._("Loading"));
            }
          }
        }
        this.$emit('change', newVal);
        this.$emit('route', newVal);
      }
    },
    /**
     * @watch url
     * @fires route
     */
    url(newVal) {
      if (this.ready && newVal && newVal !== this.currentURL) {
        //bbn.fn.log("URL CHANGED FROM WATCHER TO " + newVal);
        this.route(newVal);
      }
    },
    /**
     * @watch dirty
     */
    isDirty(v) {
      if (this.parentContainer) {
        this.parentContainer.dirty = v;
      }
    },
    /**
     * @watch itsMaster
     * @fires breadcrumbWatcher
     */
    itsMaster(newVal, oldVal) {
      if (this.nav && newVal !== oldVal) {
        this.isBreadcrumb = newVal ? newVal.isBreadcrumb : this.breadcrumb;
        if (this.breadcrumbWatcher) {
          this.breadcrumbWatcher();
        }
        if (newVal) {
          /**
           * @watch itsMaster.isBreadcrumb
           */
          this.breadcrumbWatcher = this.$watch('itsMaster.isBreadcrumb', isB => {
            this.isBreadcrumb = isB;
          });
        }
      }
    },
    currentPanes: {
      deep: true,
      handler() {
        if (this.ready) {
          this.setConfig();
        }
      }
    },
    breadcrumb(v) {
      this.isBreadcrumb = v;
    },
    /**
     * @watch isBreadcrumb
     * @fires setConfig
     */
    isBreadcrumb(newVal) {
      this.$nextTick(() => {
        if (this.ready) {
          this.setConfig();
          this.onResize();
        }
      });
    },
    /**
     * @watch isVisual
     * @fires setConfig
     */
    isVisual(v) {
      this.$nextTick(() => {
        if (this.ready) {
          this.setConfig();
          this.onResize();
        }
      });
    },
    source(v, ov) {
      //bbn.fn.log("ROUTER SOURCE WATCHER", v, ov);
      bbn.fn.each(v, a => {
        if (!bbn.fn.isString(a.url)) {
          throw new Error(bbn._("The container must have a valid URL"));
        }

        // Setting current if URL starts with default URL
        if (this.currentURL && this.currentURL.indexOf(a.url) === 0) {
          a.current = this.currentURL;
        }

        //bbn.fn.warning(bbn._("ADDING %s ON WATCH", a.url));
        this.add(a);
      });
    },
    views() {
      this.updateVisualStyleContainer();
    }
  },
  components: {
    /**
     * @component listItem
     */
    listItem: {
      template: `
<div class="bbn-w-100 bbn-vmiddle bbn-bordered-bottom"
     style="height: 2.5rem"
     @mouseenter="isHover = true"
     @mouseleave="isHover = false">
  <div class="bbn-flex-width bbn-vmiddle bbn-h-100">
    <div class="bbn-vmiddle bbn-h-100">
      <div v-for="(p, i) in source.parents"
           class="bbn-vmiddle bbn-h-100">
        <div class="bbn-vmiddle bbn-h-100"
            :style="{
              backgroundColor: !isHover && p.view.bcolor ? p.view.bcolor : null,
              color: !isHover && p.view.fcolor ? p.view.fcolor : null
            }">
          <div class="bbn-router-breadcrumb-badge-container bbn-middle"
              v-if="numProperties(p.view.events)">
            <span class="bbn-badge bbn-small bbn-bg-red"
                  v-text="numProperties(p.view.events)"/>
          </div>
          <div class="bbn-router-breadcrumb-loader bbn-border-text"
              :style="{borderColor: p.view.fcolor || null}"
              v-show="p.view.loading"/>
          <div :class="['bbn-router-breadcrumb-element', 'bbn-h-100', 'bbn-vmiddle', {'bbn-router-breadcrumb-dirty': p.view.dirty}]">
            <span v-if="p.view.icon"
                  :title="p.view.title"
                  :class="'bbn-router-breadcrumb-element-icon bbn-h-100 bbn-vmiddle bbn-right-xsspace' + (p.view.notext ? ' bbn-lg' : ' bbn-m')">
              <i :class="p.view.icon"/>
            </span>
            <span v-if="!p.view.notext"
                  class="bbn-router-breadcrumb-element-text"
                  :title="p.view.title && (p.view.title.length > p.maxTitleLength) ? p.view.title : ''"
                  v-html="p.view.title ? shortTitle(p) : '` + bbn._('Untitled') + `'"/>
          </div>
        </div>
        <div>
          <i class="nf nf-fa-angle_right bbn-hsmargin bbn-router-breadcrumb-arrow"/>
        </div>
      </div>

      <div class="bbn-vmiddle bbn-h-100"
          :style="{
            backgroundColor: !isHover && source.view.bcolor ? source.view.bcolor : null,
            color: !isHover && source.view.fcolor ? source.view.fcolor : null
          }">
        <div class="bbn-router-breadcrumb-badge-container bbn-middle"
             v-if="numProperties(source.view.events)">
          <span class="bbn-badge bbn-small bbn-bg-red"
                v-text="numProperties(source.view.events)"/>
        </div>
        <div class="bbn-router-breadcrumb-loader bbn-border-text"
             :style="{borderColor: source.view.fcolor || null}"
             v-show="source.view.loading"/>
        <div :class="['bbn-router-breadcrumb-element', 'bbn-h-100', 'bbn-vmiddle', {'bbn-router-breadcrumb-dirty': source.view.dirty}]">
          <span v-if="source.view.icon"
                :title="source.view.title"
                :class="'bbn-router-breadcrumb-element-icon bbn-h-100 bbn-vmiddle bbn-right-xsspace' + (source.view.notext ? ' bbn-lg' : ' bbn-m')">
            <i :class="source.view.icon"/>
          </span>
          <span v-if="!source.view.notext"
                class="bbn-router-breadcrumb-element-text"
                :title="source.view.title && (source.view.title.length > source.maxTitleLength) ? source.view.title : ''"
                v-html="source.view.title ? (source.parents.length? shortTitle(source): source.view.title) : '` + bbn._('Untitled') + `'"/>
        </div>
      </div>

      <div v-for="(p, i) in source.children"
           class="bbn-vmiddle bbn-h-100">
        <div>
          <i class="nf nf-fa-angle_right bbn-hsmargin bbn-large bbn-router-breadcrumb-arrow"/>
        </div>
        <div class="bbn-vmiddle bbn-h-100"
             :style="{
               backgroundColor: !isHover && p.view.bcolor ? p.view.bcolor : null,
               color: !isHover && p.view.fcolor ? p.view.fcolor : null
             }">
          <div class="bbn-router-breadcrumb-badge-container bbn-middle"
              v-if="numProperties(p.view.events)">
            <span class="bbn-badge bbn-small bbn-bg-red"
                  v-text="numProperties(p.view.events)"/>
          </div>
          <div class="bbn-router-breadcrumb-loader bbn-border-text"
              :style="{borderColor: p.view.fcolor || null}"
              v-show="p.view.loading"/>
          <div :class="['bbn-router-breadcrumb-element', 'bbn-h-100', 'bbn-vmiddle', {'bbn-router-breadcrumb-dirty': p.view.dirty}]">
            <span v-if="p.view.icon"
                  :title="p.view.title"
                  :class="'bbn-router-breadcrumb-element-icon bbn-h-100 bbn-vmiddle bbn-right-xsspace' + (p.view.notext ? ' bbn-lg' : ' bbn-m')">
              <i :class="p.view.icon"/>
            </span>
            <span v-if="!p.view.notext"
                  class="bbn-router-breadcrumb-element-text"
                  :title="p.view.title && (p.view.title.length > p.maxTitleLength) ? p.view.title : ''"
                  v-html="p.view.title ? shortTitle(p) : '` + bbn._('Untitled') + `'"/>
             </div>
        </div>
      </div>
    </div>
    <div class="bbn-flex-fill bbn-h-100"
         :style="!isHover ? lastColors : {}">
      &nbsp;
    </div>
    <div v-if="!source.view.fixed"
          class="bbn-vmiddle bbn-h-100 bbn-hpadded"
          @mousedown.prevent.stop="close"
          @mouseup.prevent.stop
          :style="!isHover ? lastColors : {}">
      <i class="nf nf-fa-times_rectangle"/>
    </div>
  </div>
</div>
        `,
      props: {
        /**
         * @prop {Object} source
         * @memberof listItem
         */
        source: {
          type: Object,
          required: true
        }
      },
      data() {
        return {
          isHover: false
        };
      },
      computed: {
        lastColors() {
          let e = this.source.children.length ? this.source.children[this.source.children.length - 1].view : this.source.view;
          let r = {};
          if (e.bcolor) {
            r.backgroundColor = e.bcolor;
          }
          if (e.fcolor) {
            r.color = e.fcolor;
          }
          return r;
        }
      },
      methods: {
        numProperties: bbn.fn.numProperties,
        /**
         * @method close
         * @memberof listItem
         */
        close() {
          let k = this.source.key;
          if (this.source.closeAction()) {
            let list = this.closest('bbn-list');
            if (bbn.cp.isComponent(list) && list.source) {
              let idx = bbn.fn.search(list.source, {
                'data.key': k
              });
              if (idx > -1) {
                list.source.splice(idx, 1);
                if (list.source.length) {
                  list.updateData();
                  this.$nextTick(() => {
                    list.closest('bbn-floater').onResize(true);
                  });
                } else {
                  this.closest('bbn-floater').close();
                }
              }
            }
          }
        },
        shortTitle(src) {
          return src.view.title.length > src.maxTitleLength ? bbn.fn.shorten(src.view.title, src.maxTitleLength) : src.view.title;
        }
      }
    },
    searchResult: {
      template: `
<div class="bbn-router-search-result bbn-w-100 bbn-spadded bbn-default-alt-background bbn-p bbn-hover-effect-element"
     :style="{backgroundColor: source.bcolor, color: source.fcolor}">
  <div class="bbn-flex-width">
    <div class="bbn-flex-fill bbn-nowrap">
      <span class="bbn-s bbn-badge bbn-bg-blue"
            v-text="source.score"/>
      <span v-text="_('Opened container')"/>
      <em v-text="'URL: ' + source.url"></em><br>
      <span class="bbn-lg" v-text="source.title"></span>
    </div>
    <div class="bbn-hlpadded bbn-h-100 bbn-r"
          style="vertical-align: middle"
          v-html="source.match">
    </div>
  </div>
</div>
`,
      props: {
        source: {
          type: Object,
          required: true
        }
      }
    }
  }
};
import cpHtml from './router.html';
import cpStyle from './router.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./router.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-router',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-router component
 * @description bbn-router is a component that allows and manages the navigation (url) between the various containers of an application
 * @copyright BBN Solutions
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  statics() {
    const img = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
  viewBox="0 0 58 58" style="enable-background:new 0 0 58 58;" xml:space="preserve">
<g>
 <path d="M57,6H1C0.448,6,0,6.447,0,7v44c0,0.553,0.448,1,1,1h56c0.552,0,1-0.447,1-1V7C58,6.447,57.552,6,57,6z M56,50H2V8h54V50z"
   />
 <path d="M16,28.138c3.071,0,5.569-2.498,5.569-5.568C21.569,19.498,19.071,17,16,17s-5.569,2.498-5.569,5.569
   C10.431,25.64,12.929,28.138,16,28.138z M16,19c1.968,0,3.569,1.602,3.569,3.569S17.968,26.138,16,26.138s-3.569-1.601-3.569-3.568
   S14.032,19,16,19z"/>
 <path d="M7,46c0.234,0,0.47-0.082,0.66-0.249l16.313-14.362l10.302,10.301c0.391,0.391,1.023,0.391,1.414,0s0.391-1.023,0-1.414
   l-4.807-4.807l9.181-10.054l11.261,10.323c0.407,0.373,1.04,0.345,1.413-0.062c0.373-0.407,0.346-1.04-0.062-1.413l-12-11
   c-0.196-0.179-0.457-0.268-0.72-0.262c-0.265,0.012-0.515,0.129-0.694,0.325l-9.794,10.727l-4.743-4.743
   c-0.374-0.373-0.972-0.392-1.368-0.044L6.339,44.249c-0.415,0.365-0.455,0.997-0.09,1.412C6.447,45.886,6.723,46,7,46z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

`;
    return {
      img
    };
  },
  props: {
    router: {
      type: Object,
      required: true
    },
    visual: {
      type: Boolean,
      default: true
    },
    tabs: {
      type: Boolean,
      default: true
    },
    breadcrumb: {
      type: Boolean,
      default: true
    }
  },
  data() {
    let modes = ['visual', 'tabs', 'breadcrumb'];
    let num = 0;
    bbn.fn.each(modes, m => {
      if (this[m]) {
        num++;
      }
    });
    if (num < 2) {
      throw new Error(bbn._("You cannot have more then one mode disabled"));
    }
    return {
      numModes: num,
      svg: bbnRouterConfigCp.img,
      visualSelected: 2,
      breadcrumbSelected: 2,
      tabsSelected: 2,
      breadcrumbActive: false,
      visualShowAll: false
    };
  },
  computed: {
    orientations() {
      let tmp = {
        auto: {
          pos: bbn._("Auto"),
          text: bbn._("Picks left or top in function of your window's size"),
          value: false
        },
        left: {
          pos: bbn._("Left"),
          text: bbn._("On the left of the main content"),
          area: '1 / 2 / 6 / 6',
          value: false
        },
        top: {
          pos: bbn._("Top"),
          text: bbn._("On the top of the main content"),
          area: '2 / 1 / 6 / 6',
          value: false
        },
        right: {
          pos: bbn._("Right"),
          text: bbn._("On the right of the main content"),
          area: '1 / 1 / 6 / 5',
          value: false
        },
        bottom: {
          pos: bbn._("Bottom"),
          text: bbn._("On the bottom of the main content"),
          area: '1 / 1 / 5 / 6',
          value: false
        }
      };
      tmp.auto.area = tmp[this.guessedOrientation].area;
      return tmp;
    },
    mode: {
      get() {
        if (this.router.isVisual) {
          return 'visual';
        }
        if (this.router.isBreadcrumb) {
          return 'breadcrumb';
        }
        if (this.router.nav) {
          return 'tabs';
        }
        return false;
      },
      set(v) {
        switch (v) {
          case 'visual':
            this.router.isVisual = true;
            this.router.isBreadcrumb = false;
            break;
          case 'breadcrumb':
            this.router.isBreadcrumb = true;
            this.router.isVisual = false;
            break;
          default:
            this.router.isBreadcrumb = false;
            this.router.isVisual = false;
            break;
        }
      }
    },
    guessedOrientation() {
      return this.router.lastKnownWidth > this.router.lastKnownHeight ? 'left' : 'top';
    },
    currentOrientation: {
      get() {
        return this.router.lockedOrientation ? this.router.visualOrientation : 'auto';
      },
      set(v) {
        if (this.orientations[v]) {
          this.router.lockedOrientation = v !== 'auto';
          this.router.visualOrientation = v === 'auto' ? this.router.lastKnownWidth > this.router.lastKnownHeight ? 'left' : 'top' : v;
        }
      }
    }
  },
  methods: {
    onSelect(mode, index) {
      let v = this[mode + 'Selected'];
      if (v !== undefined) {
        if (v === index) {
          this.mode = mode;
        } else {
          this[mode + 'Selected'] = index;
          this.visualShowAll = false;
        }
      }
    }
  },
  /**
   * @event created
   */
  created() {},
  /**
   * @event mounted
   * @fires getStorage
   * @fires getDefaultURL
   * @fires add
   */
  mounted() {},
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {},
  watch: {}
};
import cpHtml from './router-config.html';
import cpStyle from './router-config.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./router-config.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-router-config',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-router component
 * @description bbn-router is a component that allows and manages the navigation (url) between the various containers of an application
 * @copyright BBN Solutions
 * @author BBN Solutions
 */
const cpDef = {
  name: 'bbn-router-group',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  props: {
    /**
     * The URL on which the router will be initialized.
     * @prop {String} ['!'] url
     */
    separator: {
      type: String,
      default: '!'
    },
    /**
     * The URL on which the router will be initialized.
     * @prop {String} [''] url
     */
    url: {
      type: String,
      default: ''
    }
  },
  data() {
    return {};
  },
  computed: {},
  methods: {},
  /**
   * @event created
   */
  created() {},
  /**
   * @event mounted
   * @fires getStorage
   * @fires getDefaultURL
   * @fires add
   */
  mounted() {},
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {},
  watch: {}
};
import cpHtml from './router-group.html';
import cpStyle from './router-group.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./router-group.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-router-group',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-rte component
 *
 * @description bbn-rte is a component that provides users with a range of options to insert and format text as desired, automatically displaying them as a preview.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 *
 * @created 11/01/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  statics() {
    const defaultParagraphSeparatorString = 'defaultParagraphSeparator';
    const formatBlock = 'formatBlock';
    const queryCommandState = command => document.queryCommandState(command);
    const queryCommandValue = command => document.queryCommandValue(command);
    const defaultButtons = bbnData.immunizeValue({
      blockStyle: {
        text: bbn._('Style'),
        active: false,
        component: bbnData.immunizeValue({
          name: 'bbn-rte-style',
          template: `
              <bbn-dropdown class="bbn-rte-style"
                            :source="styles"
                            v-model="currentStyle"
                            :writable="false"
                            @change="setStyle"
                            :clear-html="true"/>
            `,
          data() {
            return {
              styles: [{
                text: bbn._('Normal'),
                value: '<div>'
              }, {
                text: '<p>' + bbn._('Paragraph') + '</p>',
                value: '<p>'
              }, {
                text: '<h1>' + bbn._('Heading 1') + '</h1>',
                value: '<h1>'
              }, {
                text: '<h2>' + bbn._('Heading 2') + '</h2>',
                value: '<h2>'
              }, {
                text: '<h3>' + bbn._('Heading 3') + '</h3>',
                value: '<h3>'
              }, {
                text: '<h4>' + bbn._('Heading 4') + '</h4>',
                value: '<h4>'
              }, {
                text: '<h5>' + bbn._('Heading 5') + '</h5>',
                value: '<h5>'
              }, {
                text: '<h6>' + bbn._('Heading 6') + '</h6>',
                value: '<h6>'
              }, {
                text: '<pre>' + bbn._('Preformatted') + '</pre>',
                value: '<pre>'
              }, {
                text: '<blockquote>' + bbn._('Quote') + '</blockquote>',
                value: '<blockquote>'
              }],
              currentStyle: ''
            };
          },
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            setStyle(style) {
              exec(formatBlock, style);
            }
          },
          mounted() {
            this.rte.styleComponent = this;
            this.rte.setStyle();
          }
        })
      },
      fontsize: {
        text: bbn._('Font size'),
        active: false,
        component: {
          name: 'bbn-rte-fontsize',
          template: `
              <bbn-dropdown class="bbn-rte-fontsize"
                            :source="sizes"
                            v-model="currentSize"
                            :writable="false"
                            @change="setSize"
                            :clear-html="true"
                            title="` + bbn._('Font size') + `"/>
            `,
          data() {
            return {
              sizes: [{
                text: '<font class="bbn-rte-fontsize-font" size="1">1</font>',
                value: 1
              }, {
                text: '<font class="bbn-rte-fontsize-font" size="2">2</font>',
                value: 2
              }, {
                text: '<font class="bbn-rte-fontsize-font" size="3">3</font>',
                value: 3
              }, {
                text: '<font class="bbn-rte-fontsize-font" size="4">4</font>',
                value: 4
              }, {
                text: '<font class="bbn-rte-fontsize-font" size="5">5</font>',
                value: 5
              }, {
                text: '<font class="bbn-rte-fontsize-font" size="6">6</font>',
                value: 6
              }, {
                text: '<font class="bbn-rte-fontsize-font" size="7">7</font>',
                value: 7
              }],
              currentSize: ''
            };
          },
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            setSize(style) {
              exec('fontSize', style);
            }
          },
          mounted() {
            this.rte.fontsizeComponent = this;
            this.rte.setFontsize();
          }
        }
      },
      fontincrease: {
        text: bbn._('Increase font size'),
        component: {
          template: `
              <bbn-button text="` + bbn._('Increase font size') + `"
                          icon="nf nf-fa-plus"
                          :notext="true"
                          @click="onClick"/>
            `,
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            onClick() {
              let current = parseInt(bbnRteCp.queryCommandValue('fontSize'));
              if (current < 7) {
                exec('fontSize', current + 1);
                this.rte.setFontsize();
              }
            }
          }
        },
        active: false
      },
      fontdecrease: {
        text: bbn._('Decrease font size'),
        component: {
          template: `
              <bbn-button text="` + bbn._('Decrease font size') + `"
                          icon="nf nf-fa-minus"
                          :notext="true"
                          @click="onClick"/>
            `,
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            onClick() {
              let current = parseInt(bbnRteCp.queryCommandValue('fontSize'));
              if (current > 1) {
                exec('fontSize', current - 1);
                this.rte.setFontsize();
              }
            }
          }
        },
        notext: true,
        active: false
      },
      bold: {
        icon: 'nf nf-fa-bold',
        text: bbn._('Bold'),
        notext: true,
        active: false,
        action: () => exec('bold')
      },
      italic: {
        icon: 'nf nf-fa-italic',
        text: bbn._('Italic'),
        notext: true,
        active: false,
        action: () => exec('italic')
      },
      underline: {
        icon: 'nf nf-fa-underline',
        text: bbn._('Underline'),
        notext: true,
        active: false,
        action: () => exec('underline')
      },
      strikethrough: {
        icon: 'nf nf-fa-strikethrough',
        text: bbn._('Strike-through'),
        notext: true,
        active: false,
        action: () => exec('strikeThrough')
      },
      align: {
        text: bbn._('Align'),
        notext: true,
        active: false,
        component: {
          name: 'bbn-rte-align',
          template: `
              <bbn-radiobuttons :disabled="!!isDisabled || !!isReadOnly"
                                v-model="currentAlign"
                                :source="buttons"
                                :notext="true"
                                style="width: auto"
                                @input="setAlign"/>
            `,
          data() {
            return {
              buttons: [{
                text: bbn._('Align Left'),
                icon: 'nf nf-fa-align_left',
                value: 'justifyLeft'
              }, {
                text: bbn._('Align Center'),
                icon: 'nf nf-fa-align_center',
                value: 'justifyCenter'
              }, {
                text: bbn._('Align Right'),
                icon: 'nf nf-fa-align_right',
                value: 'justifyRight'
              }, {
                text: bbn._('Align Justify'),
                icon: 'nf nf-fa-align_justify',
                value: 'justifyFull'
              }],
              currentAlign: '',
              isDisabled: false,
              isReadOnly: false
            };
          },
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            setAlign(align) {
              exec(align);
            }
          },
          mounted() {
            this.rte.alignComponent = this;
            this.isDisabled = !!this.rte.disabled;
            this.isReadOnly = !!this.rte.readonly;
            this.disWatch = this.rte.$watch('disabled', val => this.isDisabled = !!val);
            this.readWatch = this.rte.$watch('readonly', val => this.isDisabled = !!val);
          },
          beforeDestroy() {
            this.disWatch();
            this.readWatch();
          }
        }
      },
      fontcolor: {
        text: bbn._('Font Color'),
        notext: true,
        active: false,
        component: {
          name: 'bbn-rte-fontcolor',
          template: `
              <span :class="['bbn-rte-fontcolor', 'bbn-vmiddle', 'bbn-iflex', 'bbn-bordered', 'bbn-radius', {
                      'disabled': !!isDisabled || !!isReadOnly,
                      'bbn-background': !isDisabled && !isReadOnly
                    }]">
                <i class="nf nf-mdi-format_color_text bbn-hxsspace"/>
                <bbn-colorpicker @change="setColor"
                                 v-model="currentColor"
                                 :disabled="isDisabled"
                                 :readonly="isReadOnly"/>
              </span>
            `,
          data() {
            return {
              currentColor: bbn.fn.rgb2hex(window.getComputedStyle(document.body).color),
              isDisabled: false,
              isReadOnly: false
            };
          },
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            setColor(color) {
              exec('foreColor', color);
            }
          },
          mounted() {
            this.rte.fontColorComponent = this;
            this.isDisabled = !!this.rte.disabled;
            this.isReadOnly = !!this.rte.readonly;
            this.disWatch = this.rte.$watch('disabled', val => this.isDisabled = !!val);
            this.readWatch = this.rte.$watch('readonly', val => this.isDisabled = !!val);
          },
          beforeDestroy() {
            this.disWatch();
            this.readWatch();
          }
        }
      },
      fontbgcolor: {
        text: bbn._('Font Background Color'),
        notext: true,
        active: false,
        component: {
          name: 'bbn-rte-fontbgcolor',
          template: `
            <span :class="['bbn-rte-fontbgcolor', 'bbn-vmiddle', 'bbn-iflex', 'bbn-bordered', 'bbn-radius', {
                    'disabled': !!isDisabled || !!isReadOnly,
                    'bbn-background': !isDisabled && !isReadOnly
                  }]">
                <i class="nf nf-mdi-format_color_fill bbn-hxsspace bbn-lg"/>
                <bbn-colorpicker @change="setColor"
                                 v-model="currentColor"
                                 :disabled="isDisabled"
                                 :readonly="isReadOnly"/>
              </span>
            `,
          data() {
            return {
              currentColor: '',
              isDisabled: false,
              isReadOnly: false
            };
          },
          computed: {
            rte() {
              return this.closest('bbn-floater').opener;
            }
          },
          methods: {
            setColor(color) {
              exec('hiliteColor', color);
            }
          },
          mounted() {
            this.rte.fontBgColorComponent = this;
            this.isDisabled = !!this.rte.disabled;
            this.isReadOnly = !!this.beforeDestroy, this.rte.readonly;
            this.disWatch = this.rte.$watch('disabled', val => this.isDisabled = !!val);
            this.readWatch = this.rte.$watch('readonly', val => this.isDisabled = !!val);
          },
          beforeDestroy() {
            this.disWatch();
            this.readWatch();
          }
        }
      },
      outdent: {
        icon: 'nf nf-md-arrow_expand_left',
        text: bbn._('Decrease indent'),
        notext: true,
        action: () => exec('outdent')
      },
      indent: {
        icon: 'nf nf-md-arrow_expand_right',
        text: bbn._('Increase indent'),
        notext: true,
        action: () => exec('indent')
      },
      /*
      heading: {
        icon: 'nf nf-fa-header',
        text: bbn._('Heading 1'),
        notext: true,
        items: [
          {
            icon: 'nf nf-mdi-format_header_1',
            text: bbn._('Heading 1'),
            notext: true,
            action: () => exec(formatBlock, '<h1>')
          },
          {
            icon: 'nf nf-mdi-format_header_2',
            text: bbn._('Heading 2'),
            notext: true,
            action: () => exec(formatBlock, '<h2>')
          },
          {
            icon: 'nf nf-mdi-format_header_3',
            text: bbn._('Heading 3'),
            notext: true,
            action: () => exec(formatBlock, '<h3>')
          },
          {
            icon: 'nf nf-mdi-format_header_4',
            text: bbn._('Heading 4'),
            notext: true,
            action: () => exec(formatBlock, '<h4>')
          },
          {
            icon: 'nf nf-mdi-format_header_5',
            text: bbn._('Heading 5'),
            notext: true,
            action: () => exec(formatBlock, '<h5>')
          },
          {
            icon: 'nf nf-mdi-format_header_6',
            text: bbn._('Heading 6'),
            notext: true,
            action: () => exec(formatBlock, '<h6>')
          },
        ]
      },
      paragraph: {
        icon: 'nf nf-fa-paragraph',
        text: bbn._('Paragraph'),
        notext: true,
        action: () => exec(formatBlock, '<p>')
      },
      */
      quote: {
        icon: 'nf nf-mdi-format_quote_open',
        text: bbn._('Quote'),
        notext: true,
        action: () => exec('formatBlock', '<blockquote>')
      },
      olist: {
        icon: 'nf nf-mdi-format_list_numbers',
        text: bbn._('Ordered List'),
        notext: true,
        action: () => exec('insertOrderedList')
      },
      ulist: {
        icon: 'nf nf-mdi-format_list_bulleted_type',
        text: bbn._('Unordered List'),
        notext: true,
        action: () => exec('insertUnorderedList')
      },
      code: {
        icon: 'nf nf-mdi-code_tags',
        text: bbn._('Code'),
        notext: true,
        action: () => exec('formatBlock', '<pre>')
      },
      line: {
        icon: 'nf nf-oct-horizontal_rule',
        text: bbn._('Horizontal Line'),
        notext: true,
        action: () => exec('insertHorizontalRule')
      },
      link: {
        icon: 'nf nf-oct-link',
        text: bbn._('Link'),
        notext: true,
        action: () => {
          const url = window.prompt(bbn._('Enter the link URL'));
          if (url) exec('createLink', url);
        }
      },
      image64: {
        text: bbn._('Image'),
        component: {
          template: `
              <bbn-button text="` + bbn._('Image') + `"
                          icon="nf nf-md-image_plus"
                          :notext="true"
                          @click="onClick"/>
            `,
          methods: {
            onClick() {
              let fileInput = this.rte.getRef('fileInput');
              if (fileInput) {
                fileInput.click();
              }
            }
          }
        },
        notext: true
      },
      image: {
        icon: 'nf nf-md-image_move',
        text: bbn._('Image from URL'),
        notext: true,
        action: () => {
          const url = window.prompt(bbn._('Enter the image URL'));
          if (url) exec('insertImage', url);
        }
      }
    });
    const setButtons = buttons => {
      let res = bbnData.immunizeValue([]);
      if (!buttons.length) {
        buttons = Object.keys(this.defaultButtons);
      }
      bbn.fn.each(buttons, a => {
        if (bbn.fn.isString(a) && this.defaultButtons[a]) {
          res.push(bbn.fn.extend({
            code: a
          }, this.defaultButtons[a]));
        } else {
          res.push(a);
        }
      });
      return res;
    };
    const exec = function (command) {
      let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return document.execCommand(command, false, value);
    };
    const defaultStates = {
      bold: {
        active: () => this.queryCommandState('bold')
      },
      italic: {
        active: () => this.queryCommandState('italic')
      },
      underline: {
        active: () => this.queryCommandState('underline')
      },
      strikethrough: {
        active: () => this.queryCommandState('strikeThrough')
      }
    };
    const defaultClasses = {
      actionbar: 'pell-actionbar',
      button: 'pell-button',
      content: 'pell-content',
      selected: 'pell-button-selected'
    };
    let openedFloatingRTE = [];
    return {
      defaultParagraphSeparatorString,
      formatBlock,
      queryCommandState,
      queryCommandValue,
      setButtons,
      exec,
      defaultButtons,
      defaultStates,
      defaultClasses,
      openedFloatingRTE
    };
  },
  props: {
    /**
     * @prop {Boolean} [true] toolbar
     */
    toolbar: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} ['top'] position
     */
    position: {
      type: String,
      default: 'top'
    },
    /**
     * @prop {Boolean} [false] iFrame
     */
    iFrame: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Array} [bbn.env.cdn + 'lib/bbnjs/1.0.1/src/css/iFrame.less'] iframeCSSLinks
     */
    iframeCSSLinks: {
      default() {
        return [bbn.env.cdn + 'lib/bbnjs/1.0.1/src/css/iFrame.less'];
      },
      type: Array
    },
    /**
     * The height of the editor
     * @prop {Number|String} ['100%'] height
     */
    height: {
      type: [String, Number]
    },
    cleanPaste: {
      type: Boolean,
      default: false
    },
    /**
     * The buttons to show on the toolbar
     * @prop {Array} [[['viewHTML'],['undo', 'redo'],['formatting'],['strong', 'em', 'underline', 'del'],['removeformat', 'foreColor', 'backColor'],['superscript', 'subscript'],['link'],['insertImage', 'base64'],['justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull'],['unorderedList', 'orderedList'],['horizontalRule'],['fullscreen']]] buttons
     */
    buttons: {
      type: Array,
      default() {
        return [];
      }
      /*default(){
        return ['source', '|', 'bold', 'italic', '|', 'ul', 'ol', '|', 'font', 'fontsize', 'brush', 'paragraph', '|','image', 'video', 'table', 'link', '|', 'left', 'center', 'right', 'justify', '|', 'undo', 'redo', '|', 'hr', 'eraser', 'fullsize'];
        return [
          ['viewHTML'],
          ['undo', 'redo'], // Only supported in Blink browsers
          ['formatting'],
          ['strong', 'em', 'underline', 'del'],
          ['removeformat', 'foreColor', 'backColor'],
          ['superscript', 'subscript'],
          ['link'],
          ['insertImage', 'base64'],
          ['justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull', 'center'],
          ['unorderedList', 'orderedList'],
          ['horizontalRule'],
          ['fullscreen'],
          ];
      }*/
    },

    /**
     * The object of configuration.
     * @prop {Object} cfg
     */
    cfg: {
      type: Object,
      default() {
        return {
          pinned: true,
          top: null,
          left: null,
          bottom: 5,
          right: 5
        };
      }
    },
    floating: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * The height to give to the editor depending on the value of the prop height.
       * @data {String} realHeight
       */
      realHeight: typeof this.height === 'string' ? this.height : this.height + 'px',
      /**
       * @data [false] widget
       */
      widget: false,
      /**
      * @data {String|Number} currentValue
      */
      currentValue: this.value,
      /**
       * @data {bbnCp} fontColorComponent
       */
      fontColorComponent: null,
      /**
       * @data {bbnCp} fontBgColorComponent
       */
      fontBgColorComponent: null,
      /**
       * @data {bbnCp} fontsizeComponent
       */
      fontsizeComponent: null,
      /**
       * @data {bbnCp} alignComponent
       */
      alignComponent: null,
      /**
       * @data {Bool} [false] isEditing
       */
      isEditing: false,
      showSource: false,
      body: document.body,
      currentButtons: null
    };
  },
  computed: {
    textboxStyle() {
      let style = {};
      if (this.toolbar) {
        if (this.position === 'top') {
          style.borderTop = '0px';
          style.borderTopLeftRadius = '0px';
          style.borderTopRightRadius = '0px';
        } else {
          style.borderBottom = '0px';
          style.borderBottomLeftRadius = '0px';
          style.borderBottomRightRadius = '0px';
        }
      }
      return style;
    },
    currentHeight() {
      if (this.height) {
        return bbn.fn.isNumber(this.height) && this.height > 0 ? this.height + 'px' : this.height;
      }
      return '';
    }
  },
  methods: {
    /**
     * @method onPaste
     */
    onPaste(ev) {
      if (this.cleanPaste) {
        ev.preventDefault();
        bbn.fn.replaceSelection(bbn.fn.nl2br(ev.clipboardData.getData('text/plain').trim(), true));
        this.emitInput(this.getRef('element').innerHTML);
      }
    },
    /**
     * @method setButtons
     */
    setButtons() {
      let tmp = bbnRteCp.setButtons(this.buttons);
      if (this.floating) {
        tmp.push({
          icon: 'nf nf-fa-times',
          text: bbn._('Close'),
          notext: true,
          active: false,
          action: () => {
            this.isEditing = false;
          }
        });
      }
      let row = bbn.fn.getRow(tmp, {
        code: 'code'
      });
      if (row) {
        row.action = () => {
          this.showSource = !this.showSource;
        };
      }
      this.currentButtons = tmp;
    },
    /**
     * @method updateButtonsState
     */
    updateButtonsState() {
      bbn.fn.iterate(this.currentStates, (a, n) => {
        let row = bbn.fn.getRow(this.currentButtons, {
          code: n
        });
        if (row) {
          row.active = a.active();
        }
      });
    },
    /**
     * @method rteOnKeydown
     * @fires setColors
     * @fires setStyle
     * @fires setAlign
     */
    rteOnKeydown(event) {
      if (event.key === 'Enter') {
        event.stopPropagation();
        event.stopImmediatePropagation();
      }
      if (event.key === 'Enter' && bbnRteCp.queryCommandValue(bbnRteCp.formatBlock) === 'blockquote') {
        setTimeout(() => exec(bbnRteCp.formatBlock, `<${this.defaultParagraphSeparator}>`), 0);
      }
      this.setColors();
      this.setStyle();
      this.setAlign();
    },
    /**
     * @method rteOnClick
     * @fires updateButtonsState
     * @fires setColors
     * @fires setStyle
     * @fires setFontsize
     * @fires setAlign
     */
    rteOnClick(event) {
      this.updateButtonsState();
      this.setColors();
      this.setStyle();
      this.setFontsize();
      this.setAlign();
    },
    /**
     * @method rteOnInput
     */
    rteOnInput(target) {
      let firstChild = target.firstChild;
      if (firstChild && firstChild.nodeType === 3) {
        exec(bbnRteCp.formatBlock, `<${this.defaultParagraphSeparator}>`);
      } else if (this.content.innerHTML === '<br>') {
        this.content.innerHTML = '';
      }
      this.updateButtonsState();
      this.currentValue = this.content.innerHTML;
      this.emitInput(this.currentValue);
    },
    /**
     * @method setStyle
     */
    setStyle() {
      if (this.styleComponent) {
        let style = bbnRteCp.queryCommandValue(bbnRteCp.formatBlock);
        this.styleComponent.currentStyle = !!style ? `<${style}>` : '<div>';
      }
    },
    /**
     * @method setColors
     */
    setColors() {
      if (this.fontColorComponent) {
        this.fontColorComponent.currentColor = bbn.fn.rgb2hex(bbnRteCp.queryCommandValue('foreColor'));
      }
      if (this.fontBgColorComponent) {
        this.fontBgColorComponent.currentColor = bbn.fn.rgb2hex(bbnRteCp.queryCommandValue('hiliteColor'));
        if (!this.fontBgColorComponent.currentColor) {
          this.fontBgColorComponent.currentColor = bbn.fn.rgb2hex(bbnRteCp.queryCommandValue('backColor'));
        }
      }
    },
    /**
     * @method setFontsize
     */
    setFontsize() {
      if (this.fontsizeComponent) {
        this.fontsizeComponent.currentSize = parseInt(bbnRteCp.queryCommandValue('fontSize')) || 2;
      }
    },
    /**
     * @method setAlign
     */
    setAlign() {
      if (this.alignComponent) {
        let current;
        if (queryCommandState('justifyLeft')) {
          current = 'justifyLeft';
        } else if (queryCommandState('justifyCenter')) {
          current = 'justifyCenter';
        } else if (queryCommandState('justifyRight')) {
          current = 'justifyRight';
        } else if (queryCommandState('justifyFull')) {
          current = 'justifyFull';
        }
        if (!!current && this.alignComponent.currentAlign != current) {
          this.alignComponent.currentAlign = current;
        }
      }
    },
    onClickDocument(e) {
      let floater = this.getRef('floater');
      let element = this.getRef('element');
      if (floater && element) {
        if (!bbn.fn.isInside(e.target, floater.$el) && !bbn.fn.isInside(e.target, element) && e.target !== element) {
          bbn.fn.log("onClickDocument");
          this.isEditing = false;
        }
      }
    },
    updateContenteditable() {
      let element = this.getRef('element');
      let st = element.innerHTML;
      if (st !== this.currentValue) {
        this.currentValue = st;
        this.emitInput(st);
      }
    },
    stopEdit() {
      if (bbn.fn.isNumber(this.stopEditTimeout)) {
        clearTimeout(this.stopEditTimeout);
      }
      this.stopEditTimeout = setTimeout(() => {
        this.isEditing = false;
      }, 2000);
    },
    onFileInputChange(ev) {
      const files = ev.target.files;
      if (files.length) {
        const [file] = files;
        const fileReader = new FileReader();
        fileReader.onload = () => {
          const img = fileReader.result;
          exec('insertHTML', `<img src="${img}" style="max-width: 100%; height: auto; object-fit: scale-down">`);
          this.getRef('fileInput').value = '';
        };
        fileReader.readAsDataURL(file);
      }
    }
  },
  /**
   * @event created
   */
  created() {
    if (!this.value && this.$slots.default && this.$slots.default[0] && this.$slots.default[0].text.length) {
      this.currentValue = this.$slots.default[0].text;
    }
    this.setButtons();
    bbn.fn.log("RTE!!", this);
    this.defaultParagraphSeparator = bbnRteCp.defaultParagraphSeparatorString || 'div';
  },
  /**
   * Initializes the component
   * @event mounted
   * @fires getRef
   * @emits input
   */
  mounted() {
    let cfg = {
      iframe: this.iFrame,
      disabled: this.isDisabled,
      readonly: this.readonly,
      required: this.required,
      allowResizeX: false,
      allowResizeY: false,
      spellcheck: false,
      useSplitMode: true,
      height: this.height,
      tabIndex: 0,
      maxHeight: '100%',
      uploader: {
        insertImageAsBase64URI: true
      },
      iframeCSSLinks: this.iFrame ? this.iframeCSSLinks : []
    };
    this.content = this.getRef('element');
    bbn.fn.log("CONTENT", this);
    this.content.innerHTML = this.currentValue;

    /*
    buttons.forEach(action => {
      const button = createElement('button')
      button.className = classes.button
      button.innerHTML = action.icon
      button.title = action.title
      button.setAttribute('type', 'button')
      button.onclick = () => action.result() && content.focus()
            if (action.state) {
        const handler = () => button.classList[action.state() ? 'add' : 'remove'](classes.selected)
        addEventListener(content, 'keyup', handler)
        addEventListener(content, 'mouseup', handler)
        addEventListener(button, 'click', handler)
      }
            appendChild(actionbar, button)
    })
        if (settings.styleWithCSS) exec('styleWithCSS')
      exec(defaultParagraphSeparatorString, defaultParagraphSeparator)
      */

    this.ready = true;
  },
  beforeDestroy() {
    if (this.floating) {
      window.document.body.removeEventListener('click', this.onClickDocument);
    }
  },
  watch: {
    value(v) {
      if (v !== this.currentValue) {
        this.currentValue = v;
        this.content.innerHTML = v;
      }
    },
    currentValue(v) {
      if (this.showSource) {
        this.content.innerHTML = v;
      }
    },
    /**
     * @watch value
     * @param newVal
     */
    buttons: {
      deep: true,
      handler() {
        this.setButtons();
      }
    },
    isEditing(v) {
      if (this.floating) {
        if (v) {
          window.document.body.addEventListener('click', ev => {
            this.onClickDocument(ev);
          });
          this.$nextTick(() => {
            this.getRef('floater').onResize(true);
          });
        } else {
          window.document.body.removeEventListener('click', ev => {
            this.onClickDocument(ev);
          });
        }
        /*
        if (v) {
          if (openedFloatingRTE.indexOf(this) === -1) {
            openedFloatingRTE.push(this);
          }
          bbn.fn.each(openedFloatingRTE, a => {
            if (a !== this) {
              a.isEditing = false;
              a.$forceUpdate();
            }
          });
          }
        else {
          let idx = openedFloatingRTE.indexOf(this);
          if (idx > -1) {
            openedFloatingRTE.splice(idx, 1);
          }
        }
        */
        this.$forceUpdate();
      }
    }
  }
};
import cpHtml from './rte.html';
import cpStyle from './rte.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./rte.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-rte',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-scroll component
 *
 * @description bbn-scroll is a component consisting of horizontal and vertical bars that allow the flow of content in both directions, if the container its smaller than the content, inserts and removes reactively vertical, horizontal bar or both.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017
 */
import '../../cp.js';
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.keepCool
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.keepCool, bbn.cp.mixins.events],
  props: {
    /**
     * @prop {(String|Number)} maxWidth 
     */
    maxWidth: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} maxHeight
     */
    maxHeight: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} minWidth 
     */
    minWidth: {
      type: [String, Number]
    },
    /**
     * @prop {(String|Number)} maxHeight 
     */
    minHeight: {
      type: [String, Number]
    },
    /**
     * The width of the scroll, if not defined the scroll container will have the class 'bbn-overlay'
     * @prop {(Number|Number)} width
     */
    width: {
      type: [String, Number]
    },
    /**
     * @todo not used defines currentheight never used
     * @prop {(String|Number)} height
     */
    height: {
      type: [String, Number]
    },
    /**
     * @todo not used
     * @prop {Number} [50] speed
     */
    speed: {
      type: Number,
      default: 50
    },
    /**
     * The axis where the scroll is applied ( 'x', 'y', 'both')
     * @prop {String} ['both'] axis
     */
    axis: {
      type: String,
      default: "both"
    },
    /**
     * @todo not used
     */
    scrollAlso: {
      type: [HTMLElement, Array, Function],
      default() {
        return [];
      }
    },
    /**
     * Defines the position of the x axis
     * @prop {Number} [0] x
     */
    x: {
      type: Number,
      default: 0
    },
    /**
     * Defines the position of the y axis
     * @prop {Number} [0] y
     */
    y: {
      type: Number,
      default: 0
    },
    /**
     * Defines if the scroll has to be hidden for one of the axis or both
     * @prop {Boolean|String} [false] hidden
     */
    hidden: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Defines the color of the scroll
     * @prop {String} barColor
     */
    barColor: {
      type: String
    },
    /**
     * The time of latency of the scroll
     * @prop {Number} [25] latency
     */
    latency: {
      type: Number,
      default: 25
    },
    /**
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] fullPage
     */
    fullPage: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [true] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {(Number|Array)} [0] offsetX
     */
    offsetX: {
      type: [Number, Array],
      default: 0
    },
    /**
     * @prop {(Number|Array)} [0] offsetY
     */
    offsetY: {
      type: [Number, Array],
      default: 0
    },
    /**
     * @prop {Number|HTMLElement} stepX
     */
    stepX: {
      type: [Number, HTMLElement]
    },
    /**
     * @prop {Number|HTMLElement} stepY
     */
    stepY: {
      type: [Number, HTMLElement]
    },
    afterScrollDelay: {
      type: Number,
      default: 500
    },
    /**
     * @prop {Boolean} [false] keepVisible
     */
    keepVisible: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] readyDelay
       */
      readyDelay: false,
      /**
       * @todo not used
       */
      show: false,
      /**
       * The position on the x axis basing on the prop x
       * @data {Number} [0] currentX
       */
      currentX: this.x || null,
      /**
       * The position on the y axis basing on the prop y
       * @data {Number} [0] currentY
       */
      currentY: this.y || null,
      /**
       * Defines the position ofthe scroll container
       * @data {String} scrollPos
       */
      scrollPos: '0px',
      /**
       * Defines the padding of the scroll container
       * @data {String} containerPadding
       */
      containerPadding: '0px',
      /**
       * Defines if the scroll has to be hidden basing on the prop hidden
       * @data {Boolean} hiddenX
       */
      hiddenX: this.hidden === true || this.hidden === 'x',
      /**
       * @todo not used
       * Defines if the scroll has to be hidden basing on the prop hidden
       * @data {Boolean} hiddenY
       */
      hiddenY: this.hidden === true || this.hidden === 'y',
      /**
       * Defines if the scroll container must have the class 'bbn-overlay'
       * @data {Number} currentWidth 
       */
      currentWidth: this.width || null,
      /**
       * @todo not used 
       */
      currentHeight: this.height || null,
      /**
       * @data {Number} [0] naturalWidth
       */
      naturalWidth: 0,
      /**
       * @data {Number} [0] naturalHeight
       */
      naturalHeight: 0,
      /**
       * @data {Number} [0] containerWidth
       */
      containerWidth: 0,
      /**
       * @data {Number} [0] containerHeight
       */
      containerHeight: 0,
      /**
       * @data {Number} [0] contentWidth
       */
      contentWidth: 0,
      /**
       * @data {Number} [0] contentHeight
       */
      contentHeight: 0,
      /**
       * @data {Boolean} [false] hasScroll
       */
      hasScroll: false,
      /**
       * @data {Boolean} [false] hasScrollX
       */
      hasScrollX: false,
      /**
       * @data {Boolean} [false] hasScrollY
       */
      hasScrollY: false,
      promise: false,
      isScrolling: false,
      isDragging: false,
      isFocused: false,
      previousTouch: {
        x: null,
        y: null
      },
      lastResize: null,
      scrollReady: false,
      touchX: false,
      touchY: false,
      scrollInitial: false,
      touchDirection: null,
      scrollTimeout: null,
      currentStepX: bbn.fn.isDom(this.stepX) ? this.stepX.clientHeight : this.stepX,
      currentStepY: bbn.fn.isDom(this.stepY) ? this.stepY.clientHeight : this.stepY
    };
  },
  computed: {
    resizerObserved() {
      return this.scrollable ? this.getRef('scrollContainer') : this.$el;
    },
    /**
     * Based on the prop fixedFooter and fullScreen, a string is returned containing the classes for the form template.
     *
     * @computed currentClass
     * @return {String}
     */
    elementClass() {
      let st = this.componentClass.join(' ');
      if (!this.ready) {
        st += ' bbn-invisible';
      }
      if (!this.scrollable) {
        st = bbn.fn.replaceAll('bbn-resize-emitter', '', st) + ' bbn-w-100';
      } else {
        st += ' bbn-overlay';
      }
      return st;
    },
    /**
     * @computed elementStyle
     * @return {Object}
     */
    elementStyle() {
      let cfg = {
        maxWidth: this.maxWidth ? bbn.fn.formatSize(this.maxWidth) : '100%',
        maxHeight: this.maxHeight ? bbn.fn.formatSize(this.maxHeight) : '100%',
        minWidth: this.minWidth ? bbn.fn.formatSize(this.minWidth) : '',
        minHeight: this.minHeight ? bbn.fn.formatSize(this.minHeight) : ''
      };
      if (this.currentWidth) {
        cfg.width = bbn.fn.formatSize(this.currentWidth);
      }
      if (this.currentHeight) {
        cfg.height = bbn.fn.formatSize(this.currentHeight);
      }
      return cfg;
    },
    containerClass() {
      let cls = 'bbn-scroll-container bbn-no-scrollbar';
      if (!this.scrollable) {
        cls += ' bbn-w-100';
        return cls;
      }
      if (this.disabled) {
        cls += ' bbn-scroll-disabled';
      }
      if (this.ready && !this.isDragging) {
        cls += ' bbn-scroll-not-dragged';
      }
      if (!this.scrollable) {
        cls += ' bbn-overlay';
      }
      if (this.hasX()) {
        cls += ' bbn-scroll-x';
      }
      if (this.hasY()) {
        cls += ' bbn-scroll-y';
      }
      return cls;
    },
    /**
     * @todo not used
     */
    contentStyle() {
      let cfg = {};
      if (this.minWidth) {
        cfg.minWidth = this.minWidth;
      }
      if (this.minHeight) {
        cfg.minHeight = this.minHeight;
      }
      if (this.maxWidth) {
        cfg.maxWidth = this.maxWidth;
      }
      if (this.maxHeight) {
        cfg.maxHeight = this.maxHeight;
      }
      if (!this.scrollable) {
        return cfg;
      }
      cfg.width = this.axis === 'x' || this.axis === 'both' ? 'auto' : '100%';
      cfg.height = this.axis === 'y' || this.axis === 'both' ? 'auto' : '100%';
      return cfg;
    }
  },
  methods: {
    hashJustChanged() {
      let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 600;
      if (document.location.hash) {
        let now = new Date().getTime();
        if (bbn.env.hashChanged >= now - length) {
          return true;
        }
      }
      return false;
    },
    onTouchstart(e) {
      if (!this.scrollable || this.disabled) {
        return;
      }
      if (e.targetTouches && e.targetTouches.length) {
        let ev = e.targetTouches[0];
        if (this.hasScrollX) {
          this.touchX = ev.clientX;
        }
        if (this.hasScrollY) {
          this.touchY = ev.clientY;
        }
        this.scrollInitial = {
          x: this.currentX,
          y: this.currentY,
          touched: true
        };
      }
    },
    onTouchend(e) {
      if (!this.scrollInitial) {
        return;
      }
      if (!this.scrollable || this.disabled) {
        return;
      }
      this.scrollInitial.touched = 'finished';
      this.setScrollDelay();
    },
    onTouchmove(e) {
      this.$emit('touchmove', e);
    },
    /**
     * @method onScroll
     * @param {Event} e 
     * @emits scroll
     */
    onScroll(e) {
      let ct = this.getRef('scrollContainer');
      if (ct) {
        if (this.disabled) {
          e.preventDefault();
          return;
        }
        if (this.hasScrollX && ct.scrollLeft < 0) {
          ct.scrollLeft = 0;
          e.preventDefault();
          return;
        }
        if (this.hasScrollY && ct.scrollTop < 0) {
          ct.scrollTop = 0;
          e.preventDefault();
          return;
        }
        this.currentX = ct.scrollLeft;
        this.currentY = ct.scrollTop;
        this.$emit('scroll', e);
        if (!e.defaultPrevented) {
          // Leaving touchscroll act normally
          if (this.scrollInitial && this.scrollInitial.touched === true) {
            // Removing the finishing delay in case it was pre-recorded
            clearTimeout(this.scrollTimeout);
            return;
          }
          // Not acting for events sent by scrollTo (scrollbars will write in nextLevel)
          if (this.hasScrollX && this.$refs.xScroller && bbn.fn.isNumber(this.$refs.xScroller.nextLevel) && Math.abs(this.currentX - this.$refs.xScroller.nextLevel) < 2) {
            return;
          }
          // Not acting for events sent by scrollTo (scrollbars will write in nextLevel)
          if (this.hasScrollY && this.$refs.yScroller && bbn.fn.isNumber(this.$refs.yScroller.nextLevel) && Math.abs(this.currentY - this.$refs.yScroller.nextLevel) < 2) {
            return;
          }
          if (!this.scrollInitial) {
            this.scrollInitial = {
              x: this.currentX,
              y: this.currentY
            };
          }
          this.setScrollDelay();
        }
      }
      if (this.scrollable && e) {
        e.stopImmediatePropagation();
      }
    },
    setScrollDelay() {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = setTimeout(() => {
        this.afterScroll();
      }, this.scrollInitial.touched === 'finished' ? 100 : this.afterScrollDelay);
    },
    afterScroll() {
      if (this.fullPage && this.scrollInitial) {
        if (this.hasScrollX && this.currentX !== this.scrollInitial.x) {
          let m = this.currentStepX || this.containerWidth;
          let r1 = this.scrollInitial.x ? Math.round(this.scrollInitial.x / m) : 0;
          let r2 = this.currentX ? Math.round(this.currentX / m) : 0;
          let left;
          if (r1 !== r2) {
            left = r2 * m;
          } else if (this.scrollInitial.x < this.currentX) {
            left = (r1 + 1) * m;
          } else if (this.scrollInitial.x > this.currentX) {
            left = (r1 - 1) * m;
          }
          if (bbn.fn.isNumber(left) && left !== this.currentX) {
            this.$refs.xScroller.scrollTo(left, true).then(() => {
              this.$emit('afterscroll');
            });
          }
        } else if (this.hasScrollY && this.currentY !== this.scrollInitial.y) {
          let m = this.currentStepY || this.containerHeight;
          let r1 = this.scrollInitial.y ? Math.round(this.scrollInitial.y / m) : 0;
          let r2 = this.currentY ? Math.round(this.currentY / m) : 0;
          let top;
          if (r1 !== r2) {
            top = r2 * m;
          } else if (this.scrollInitial.y < this.currentY) {
            top = (r1 + 1) * m;
          } else if (this.scrollInitial.y > this.currentY) {
            top = (r1 - 1) * m;
          }
          if (bbn.fn.isNumber(top) && top !== this.currentY) {
            this.$refs.yScroller.scrollTo(top, true).then(() => {
              this.$emit('afterscroll');
            });
          } else {
            this.$emit('afterscroll');
          }
        }
        this.scrollInitial = false;
      }
    },
    /**
     * Scrolls to the given coordinates of x and y using the given animation
     * @method scrollTo
     * @param {Number} x 
     * @param {Number} y 
     * @fires $refs.xScroller.scrollTo
     * @fires $refs.yScroller.scrollTo
     */
    scrollTo(x, y, anim) {
      return new Promise(resolve => {
        if (!this.hasScroll || !this.ready) {
          return;
        }
        if (this.hasScrollX && x !== undefined && x !== null && this.$refs.xScroller) {
          this.$refs.xScroller.scrollTo(x, anim).then(() => {
            if (this.hasScrollY && y !== undefined && y !== null && this.$refs.yScroller) {
              this.$refs.yScroller.scrollTo(y, anim).then(() => {
                try {
                  resolve();
                } catch (e) {}
              });
            } else {
              try {
                resolve();
              } catch (e) {}
            }
          });
        } else if (this.hasScrollY && y !== undefined && y !== null && this.$refs.yScroller) {
          this.$refs.yScroller.scrollTo(y, anim).then(() => {
            try {
              resolve();
            } catch (e) {}
          });
        }
      });
    },
    /**
     * @method scrollHorizontal
     * @param {Event} ev 
     * @param {Number} left 
     * @emits scrollx
     */
    scrollHorizontal(ev, left) {
      this.currentX = left;
      this.$emit('scrollx', left);
    },
    /**
     * @method scrollVertical
     * @param {Event} ev 
     * @param {Number} top 
     * @emits scrolly
     */
    scrollVertical(ev, top) {
      this.currentY = top;
      this.$emit('scrolly', top);
    },
    addVertical(y) {
      this.scrollTo(null, this.currentY + y);
      this.$emit('scrolly', this.currentY);
    },
    addHorizontal(x) {
      this.scrollTo(this.currentX + x);
      this.$emit('scrollx', this.currentX);
    },
    /**
     * @method scrollStart
     * @fires scrollStartX
     * @fires scrollStartY
     */
    scrollStart(anim) {
      this.scrollStartX(anim);
      this.scrollStartY(anim);
    },
    /**
     * @method scrollEnd
     * @fires scrollEndX
     * @fires scrollEndY
     */
    scrollEnd(anim) {
      this.scrollEndX(anim);
      this.scrollEndY(anim);
    },
    /**
     * @method scrollBefore
     * @fires scrollBeforeX
     * @fires scrollBeforeY
     */
    scrollBefore(anim) {
      this.scrollBeforeX(anim);
      this.scrollBeforeY(anim);
    },
    /**
     * @method scrollAfter
     * @fires scrollAfterX
     * @fires scrollAfterY
     */
    scrollAfter(anim) {
      this.scrollAfterX(anim);
      this.scrollAfterY(anim);
    },
    /**
     * Scroll the x axis to the position 0
     * @method scrollStartX
     * @fires this.$refs.xScroller.scrollTo
     */
    scrollStartX(anim) {
      if (this.hasScrollX) {
        let x = this.getRef('xScroller');
        if (x) {
          x.scrollStart(anim);
        }
      }
    },
    /**
     * Scroll the y axis to the position 0
     * @method scrollStartY
     * @fires this.$refs.yScroller.scrollTo
     */
    scrollStartY(anim) {
      if (this.hasScrollY) {
        let y = this.getRef('yScroller');
        if (y) {
          y.scrollStart(anim);
        }
      }
    },
    /**
     * Scroll the x axis to the previous page
     * @method scrollBeforeX
     * @fires this.$refs.xScroller.scrollBefore
     */
    scrollBeforeX(anim) {
      if (this.hasScrollX) {
        let x = this.getRef('xScroller');
        if (x) {
          x.scrollBefore(anim);
        }
      }
    },
    /**
     * Scroll the y axis to the previous page
     * @method scrollBeforeY
     * @fires this.$refs.yScroller.scrollBefore
     */
    scrollBeforeY(anim) {
      if (this.hasScrollY) {
        let y = this.getRef('yScroller');
        if (y) {
          y.scrollBefore(anim);
        }
      }
    },
    /**
     * Scroll the x axis to the next page
     * @method scrollBeforeX
     * @fires this.$refs.xScroller.scrollBefore
     */
    scrollAfterX(anim) {
      if (this.hasScrollX) {
        let x = this.getRef('xScroller');
        if (x) {
          x.scrollAfter(anim);
        }
      }
    },
    /**
     * Scroll the y axis to the next page
     * @method scrollBeforeY
     * @fires this.$refs.yScroller.scrollBefore
     */
    scrollAfterY(anim) {
      if (this.hasScrollY) {
        let y = this.getRef('yScroller');
        if (y) {
          y.scrollAfter(anim);
        }
      }
    },
    /**
     * Scroll the x axis to the end
     * @method scrollEndX
     * @thisfires this.getRef('xScroller').scrollTo
     */
    scrollEndX(anim) {
      if (this.hasScrollX) {
        let x = this.getRef('xScroller');
        if (x) {
          x.scrollEnd(anim);
        }
      }
    },
    /**
    * Scroll the y axis to the end
    * @method scrollEndY
    * @thisfires this.getRef('yScroller').scrollTo
    */
    scrollEndY(anim) {
      if (this.hasScrollY) {
        let y = this.getRef('yScroller');
        if (y) {
          y.scrollEnd(anim);
        }
      }
    },
    /**
     * Gets the dimensions after a resize
     * @method getNaturalDimensions
     * @fires getNaturalDimensions
     */
    getNaturalDimensions() {
      let sc = this.find('bbn-scroll');
      //bbn.fn.log(sc ? "THERE IS A SCROLL" : "THERE IS NO SCROLL");
      const old = {
        width: this.naturalWidth,
        height: this.naturalHeight
      };
      if (this.isResizing) {
        return;
      }
      if (this.scrollable) {
        const content = this.getRef('scrollContent');
        if (!content) {
          return;
        }
        this.isResizing = true;
        let oldWidth = this.$el.style.width;
        let oldHeight = this.$el.style.height;
        let oldcWidth = content.style.width;
        let oldcHeight = content.style.height;
        let oldVisibility = this.$el.style.visibility;
        this.$el.style.width = this.maxWidth ? bbn.fn.formatSize(this.maxWidth) : '100%';
        this.$el.style.height = this.maxHeight ? bbn.fn.formatSize(this.maxHeight) : '100%';
        content.style.width = 'auto';
        content.style.height = 'auto';
        content.classList.add('resizing');
        this.$el.style.visibility = 'hidden';
        let hasOverlay = this.getRef('scrollContainer').classList.contains('bbn-overlay');
        if (hasOverlay) {
          this.getRef('scrollContainer').classList.remove('bbn-overlay');
        }
        let d = {
          width: content.offsetWidth,
          height: content.offsetHeight
        };
        bbn.fn.log(["NAT DIM " + JSON.stringify(d)]);
        if (!d.width || !d.height) {
          if (sc && sc.$el.clientWidth === this.$el.clientWidth && sc.$el.clientHeight === this.$el.clientHeight) {
            sc.getNaturalDimensions();
            this.naturalWidth = sc.naturalWidth;
            this.naturalHeight = sc.naturalHeight;
          } else {
            this.naturalWidth = 0;
            this.naturalHeight = 0;
          }
        } else {
          this.naturalWidth = d.width;
          this.naturalHeight = d.height;
        }
        this.$el.style.width = oldWidth;
        this.$el.style.height = oldHeight;
        this.$el.style.visibility = oldVisibility;
        content.style.width = oldcWidth;
        content.style.height = oldcHeight;
        content.classList.remove('resizing');
        if (hasOverlay) {
          this.getRef('scrollContainer').classList.add('bbn-overlay');
        }
        this.isResizing = false;
      } else {
        if (sc && sc.$el.clientWidth === this.$el.clientWidth && sc.$el.clientHeight === this.$el.clientHeight) {
          sc.getNaturalDimensions();
          this.naturalWidth = sc.naturalWidth;
          this.naturalHeight = sc.naturalHeight;
        } else {
          this.naturalWidth = this.$el.offsetWidth;
          this.naturalHeight = this.$el.offsetHeight;
        }

        //this.$forceUpdate();
        if (old.width !== this.naturalWidth || old.height !== this.naturalHeight) {
          if (old.width || old.height) {
            this.$emit('resizecontent');
            bbn.fn.log({
              w: this.naturalWidth,
              h: this.naturalHeight
            });
          }
        }
      }
    },
    hasX() {
      return this.scrollable && (this.axis === 'both' || this.axis === 'x');
    },
    hasY() {
      return this.scrollable && (this.axis === 'both' || this.axis === 'y');
    },
    /**
     * @method initSize
     * @fires getNaturalDimensions
     * @fires onResize
     */
    async initSize() {
      //await this.$forceUpdate();
      if (this.maxHeight || this.maxWidth) {
        //throw new Error("BOOOOOO");
        this.getNaturalDimensions();
        if (!this.naturalWidth) {
          return this.waitReady();
        }
      }
      //bbn.fn.log(bbn._("Init size from %s with ID %s", this.$options.name, this.$cid));
      this.scrollReady = true;
      await this.onResize(true);
      this.ready = true;
      this.$emit('resizecontent');
      return this.$forceUpdate();
    },
    /**
     * Handles the resize of the scroll
     * @method onResize
     * @fires keepCool
     * @fires getNaturalDimensions
     * @emits resize
     * @returns Promise
     */
    onResize(force) {
      let res = bbn.cp.mixins.resizer.methods.onResize.apply(this);
      // If the container measures have changed
      if (!this.isResizing && (res || force)) {
        // Setting up the element's measures
        // getting current measures of element and scrollable container
        let container = this.$el;
        let content = this.getRef('scrollContent');
        let ct = this.getRef('scrollContainer');
        if (!this.scrollable || !content || !container.clientWidth || !container.clientHeight) {
          return;
        }
        let x = ct.scrollLeft;
        let y = ct.scrollTop;
        let sendResizeContent = false;
        if (content.clientWidth !== this.contentWidth || content.clientHeight !== this.contentHeight) {
          sendResizeContent = true;
        }
        this.contentWidth = content.scrollWidth;
        this.contentHeight = content.scrollHeight;
        this.containerWidth = container.clientWidth;
        this.containerHeight = container.clientHeight;
        // With scrolling on we check the scrollbars
        if (this.scrollable) {
          if ((this.axis === 'both' || this.axis === 'x') && this.contentWidth > this.containerWidth) {
            this.hasScrollX = true;
            this.$nextTick(() => {
              if (this.$refs.xScroller) {
                this.$refs.xScroller.onResize();
              }
            });
          } else {
            this.hasScrollX = false;
          }
          if ((this.axis === 'both' || this.axis === 'y') && this.contentHeight > this.containerHeight) {
            this.hasScrollY = true;
            this.$nextTick(() => {
              if (this.$refs.yScroller) {
                this.$refs.yScroller.onResize();
              }
            });
          } else {
            this.hasScrollY = false;
          }
          this.hasScroll = this.hasScrollY || this.hasScrollX;
          /** @todo Check if this shouldn't be with - (minus) containerSize */
          if (this.currentX > this.contentWidth) {
            // this.currentX = 0;
            x = this.contentWidth - this.containerWidth;
          }
          if (this.currentY > this.contentHeight) {
            // this.currentY = 0;
            y = this.contentHeight - this.containerHeight;
          }
          if (this.fullPage) {
            if (this.hasScrollX) {
              let tot = Math.round(x / this.containerWidth);
              x = this.containerWidth * tot;
            }
            if (this.hasScrollY) {
              let tot = Math.round(y / this.containerHeight);
              y = this.containerHeight * tot;
            }
          }
          if (this.currentX > this.contentWidth) {
            this.currentX = x;
          }
          if (this.currentY > this.contentHeight) {
            this.currentY = y;
          }
          // if (x !== this.currentX) {
          //   this.currentX = x;
          // }
          // if (y !== this.currentY) {
          //   this.currentY = y;
          // }

          if (this.scrollReady && bbn.fn.isNumber(this.currentX) && this.currentX !== ct.scrollLeft) {
            ct.scrollLeft = this.currentX;
          }
          if (this.scrollReady && bbn.fn.isNumber(this.currentY) && this.currentY !== ct.scrollTop) {
            ct.scrollTop = this.currentY;
          }
        }
        this.$emit('resize');
      }
    },
    /**
     * Creates a delay to set the scroll as ready
     * @method waitReady
     * @fires keepCool
     * @fires onResize
     */
    waitReady(ev) {
      if (this.isResizing) {
        return;
      }
      clearTimeout(this.readyTimeout);
      this.readyTimeout = setTimeout(() => {
        this.initSize();
      }, this.latency);
    },
    setObserver() {
      if (!this.scrollObserver) {
        this.scrollObserver = new MutationObserver(mutations_list => {
          let mutated = false;
          mutations_list.forEach(mutation => {
            if (mutation.addedNodes) {
              this.waitReady();
            }
          });
        });
      }
      this.scrollObserver.observe(this.getRef('scrollContent'), {
        subtree: true,
        childList: true
      });
    },
    unsetObserver() {
      if (this.scrollObserver) {
        this.scrollObserver.disconnect();
      }
    },
    preResize() {
      /*
      if (this.scrollable && this.$el.offsetParent && this.isActiveResizer()) {
        let container = this.getRef('scrollContent');
        let contentWidth = Math.max(container.scrollWidth, container.clientWidth);
        let contentHeight = Math.max(container.scrollHeight, container.clientHeight);
        if (
          (
            contentWidth
            && (this.contentWidth !== contentWidth)
            && (
              !this.contentWidth
              || (Math.abs(contentWidth - this.contentWidth) > 1)
            )
          )
          || (
            contentHeight
            && (this.contentHeight !== contentHeight)
            && (
              !this.contentHeight
              || (Math.abs(contentHeight - this.contentHeight) > 1)
            )
          )
        ) {
          let e = new Event('resizecontent', {
            cancelable: true
          });
          this.$emit('resizecontent', e, {
            width: contentWidth,
            height: contentHeight
          });
           if (!e.defaultPrevented) {
            this.onResize(true);
          }
        }
      }
      */
    }
  },
  created() {
    this.componentClass.push('bbn-resize-emitter');
  },
  /**
   * @event mounted
   * @fires waitReady
   */
  mounted() {
    this.setObserver();
    this.ready = true;
    this.waitReady();
    /*
    this.initSize().then(() => {
      this.scrollReady = true;
      bbn.fn.log("PARENT", this.$parent);
      if ((typeof bbnFloaterCp === 'function') && (this.$parent instanceof bbnFloaterCp)) {
        throw new Error("BOOOOOO");
      }
    });
    //cp.$emit('resizecontent');
    */
  },

  beforeDestroy() {
    this.unsetObserver();
  },
  watch: {
    /**
     * @watch ready
     * @param newVal 
     * @fires setInterval
     */
    /*
    ready(newVal){
      if (newVal) {
        this.preResize();
        this.$emit('ready');
        this.scrollReady = true;
      }
    },
    */
    /**
     * @watch scrollable
     * @param newVal 
     * @fires onResize
     */
    scrollable(newVal) {
      if (newVal) {
        this.initSize();
      } else {
        this.hasScroll = false;
        this.hasScrollX = false;
        this.hasScrollY = false;
      }
    },
    /**
     * @watch containerWidth
     * @param newVal 
     */
    containerWidth() {
      let x = this.getRef('xScroller');
      if (x) {
        x.onResize();
      }
    },
    /**
     * @watch containerHeight
     * @param newVal 
     */
    containerHeight() {
      let y = this.getRef('yScroller');
      if (y) {
        y.onResize();
      }
    },
    currentX(x) {
      if (!x) {
        this.$emit('reachleft');
      } else {
        let ct = this.getRef('scrollContainer');
        if (ct && x + ct.clientWidth >= ct.scrollWidth) {
          this.$emit('reachright');
        }
      }
      this.$emit('scrollx', x);
    },
    currentY(y) {
      if (!y) {
        this.$emit('reachtop');
      } else {
        let ct = this.getRef('scrollContainer');
        if (ct && y + ct.clientHeight >= ct.scrollHeight) {
          this.$emit('reachbottom');
        }
      }
      this.$emit('scrolly', y);
    },
    stepX(val) {
      this.currentStepX = bbn.fn.isDom(val) ? val.clientHeight : val;
    },
    stepY(val) {
      this.currentStepY = bbn.fn.isDom(val) ? val.clientHeight : val;
    }
  }
};
import cpHtml from './scroll.html';
import cpStyle from './scroll.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./scroll.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-scroll',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-scrollbar component
 *
 * @description bbn-scroolbar represents the scroll bar of the content 'it is used by the bbn-scroll component appearing in case of passing of the mouse pointer
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/07/2017
 */
import basic from '../../cp/mixins/basic.js';
import keepCool from '../../cp/mixins/keepCool.js';
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.keepCool 
   */
  mixins: [basic, keepCool],
  props: {
    /**
     * The orientation of the scrollbar (required).
     * @prop {String} orientation
     */
    orientation: {
      required: true,
      type: String
    },
    /**
     * The instance of bbn-scroll.
     * @prop {bbnCp} scroller  
     */
    scroller: {
      type: bbnCp
    },
    /**
     * The rail.
     * @prop {HTMLElement|Object} container
     */
    container: {
      type: HTMLElement
    },
    /**
     * Says if the scrollbar is shown, hidden, or shown when needed (auto).
     * @prop {String|Boolean} ['auto'] hidden
     */
    hidden: {
      type: [String, Boolean],
      default: 'auto'
    },
    /**
     * 
     * @prop {Number} [2] tolerance
     */
    tolerance: {
      type: Number,
      default: 2
    },
    /**
     * @prop {Number} [0] scrolling
     */
    scrolling: {
      type: Number,
      default: 0
    },
    /**
     * @prop {(HTMLElement|Array|Function)} [[]] scrollAlso
     */
    scrollAlso: {
      type: [HTMLElement, Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop {(Number|Object)} [0] initial 
     */
    initial: {
      type: [Number, Object],
      default: 0
    },
    /**
     * The color of the scrollbar.
     * @prop {String} color
     */
    color: {
      type: String
    },
    /**
     * The minimum size in pixel of the scrollbar.
     * @prop {Number} minSize
     */
    minSize: {
      type: Number,
      default: 20
    },
    /**
     * @prop {(Number|Array)} offset
     */
    offset: {
      type: [Number, Array],
      default() {
        return [0, 0];
      }
    },
    /**
     * @prop {Boolean} [false] keepVisible
     */
    keepVisible: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * The container's size.
       * @data {Number} [0] containerSize 
       */
      containerSize: 0,
      /**
       * The content size.
       * @data {Number} [0] contentSize 
       */
      contentSize: 0,
      /**
       * The container posiion.
       * @data {Number} [0] containerPos 
       */
      containerPos: 0,
      /**
       * The slider position.
       * @data {Number} [0] sliderPos 
       */
      sliderPos: bbn.fn.isArray(this.offset) ? this.offset[0] : this.offset,
      /**
       * @data {Boolean} [false] dragging 
       */
      dragging: false,
      /**
       * The size.
       * @data {Number} [100] size
       */
      size: 100,
      /**
       * The start.
       * @data {Number} [0] start
       */
      start: 0,
      /**
       * The position.
       * @data {Number} [0] position
       */
      position: this.scrolling,
      /**
       * @data {Number} [0] currentScroll
       * 
       */
      currentScroll: 0,
      /**
       * The move timeout.
       * @data {Number} [0] moveTimeout
       * 
       */
      moveTimeout: 0,
      /**
       * True if the scrollbar is shown.
       * @data {Boolean} show
       */
      show: this.hidden === 'auto' ? false : !this.hidden,
      /**
       * @data {Number|Object} scroll
       */
      scroll: this.initial,
      /**
       * @data {Boolean} [false] isReaching
       */
      isReaching: false,
      /**
       * @data {Boolean} [false] isActive
       */
      isActive: false,
      /**
       * @data {Boolean} [false] isOverSlider
       */
      isOverSlider: false,
      isOverContent: false,
      animationInterval: false,
      nextLevel: false,
      adjustTimeout: false
    };
  },
  computed: {
    /**
     * The container of the scrollbar or the ref scrol.
     * @data {bbnCp} realContainer 
     */
    realContainer() {
      if (this.container) {
        return this.container;
      }
      if (this.realScroller && this.realScroller.getRef) {
        return this.realScroller.getRef('scrollContainer');
      }
      return false;
    },
    realScroller() {
      if (this.scroller) {
        return this.scroller;
      }
      return this.closest('bbn-scroll');
    },
    /**
     * @computed showBother
     * @returns Boolean
     */
    shouldBother() {
      return this.contentSize > this.containerSize;
    },
    /**
     * @computed ratio
     * @returns {Number}
     */
    ratio() {
      if (this.shouldBother) {
        return (this.containerSize - this.offsetStart - this.offsetEnd) / this.contentSize;
      }
      return 1;
    },
    /**
     * @computed sliderSize
     * @return {Number}
     */
    sliderSize() {
      if (this.shouldBother) {
        let size = Math.round(this.containerSize * this.ratio);
        if (size < this.minSize) {
          size = this.minSize;
        }
        return size;
      }
      return 0;
    },
    /**
     * @computed maxSliderPos
     * @return {Number}
     */
    maxSliderPos() {
      return this.shouldBother ? this.containerSize - this.sliderSize - this.offsetStart - this.offsetEnd : 0;
    },
    offsetStart() {
      return bbn.fn.isArray(this.offset) ? this.offset[0] : this.offset;
    },
    offsetEnd() {
      return bbn.fn.isArray(this.offset) ? this.offset[1] : this.offset;
    },
    /**
     * @computed barStyle
     * @returns {Object}
     */
    barStyle() {
      return {
        display: this.isVisible || this.keepVisible ? 'block' : 'none',
        opacity: (this.show || this.keepVisible) && this.shouldBother ? 1 : 0,
        [this.isVertical ? 'top' : 'left']: this.offsetStart + 'px',
        [this.isVertical ? 'right' : 'bottom']: this.offsetEnd + 'px'
      };
    },
    /**
     * @computed sliderStyle
     * @returns {Object}
     */
    sliderStyle() {
      let res = {};
      if (this.shouldBother) {
        res[this.isVertical ? 'height' : 'width'] = this.sliderSize + 'px';
        res[this.isVertical ? 'top' : 'left'] = this.sliderPos + 'px';
        if (this.color) {
          res.backgroundColor = this.color;
        }
        if (this.isOverContent) {
          res.opacity = '0.15';
        }
      }
      return res;
    },
    /**
     * @computed isVertical
     * @returns {Boolean}
     */
    isVertical() {
      return this.orientation !== 'horizontal';
    },
    /**
     * @computed realSize
     * @returns {Number}
     */
    realSize() {
      return this.containerSize ? this.containerSize / 100 * this.size : 0;
    },
    /**
     * @computed isVisible
     * @returns {Boolean}
     */
    isVisible() {
      return this.hidden !== true && (this.realScroller && this.realScroller.isFocused && this.isActive || this.isActive);
    }
  },
  methods: {
    /**
     * @method startDrag
     * @param {Event} e
     */
    startDrag(e) {
      if (this.realContainer) {
        e.preventDefault();
        e.stopPropagation();
        e = e.changedTouches ? e.changedTouches[0] : e;
        this.dragging = true;
        // Start in pixels
        this.start = this.isVertical ? e.pageY : e.pageX;
      }
    },
    /**
     * @method onDrag
     * @param {Event} e
     */
    onDrag(e) {
      if (this.realContainer && this.dragging && this.containerSize) {
        this.keepCool(() => {
          e = e.changedTouches ? e.changedTouches[0] : e;
          // Movement in pixel
          let newStart = this.isVertical ? e.pageY : e.pageX;
          let movement = newStart - this.start;
          bbn.fn.warning(newStart + '/' + movement);
          if (movement && this.setSliderPos(this.sliderPos + movement)) {
            this.adjustFromBar();
          }
          this.start = newStart;
        });
      }
    },
    /**
     * @method stopDrag
     */
    stopDrag() {
      this.dragging = false;
    },
    setSliderPos(pos) {
      if (bbn.fn.isNumber(pos)) {
        if (pos < 0) {
          pos = 0;
        }
        if (pos > this.maxSliderPos) {
          pos = this.maxSliderPos;
        }
        if (this.sliderPos !== pos) {
          this.sliderPos = pos;
          return true;
        }
      }
      return false;
    },
    /**
     * @method adjustFromContainer
     * @param {bbnCp} container 
     */
    adjustFromContainer(container) {
      if (this.shouldBother && !this.dragging) {
        let prop = this.isVertical ? 'scrollTop' : 'scrollLeft';
        let ok = false;
        if (!container || !bbn.fn.isDom(container)) {
          container = this.realContainer;
          if (this.realScroller) {
            this.containerPos = this.realScroller['current' + (this.isVertical ? 'Y' : 'X')];
            ok = true;
          }
        }
        if (!ok) {
          this.containerPos = container[prop];
        }
        this.setSliderPos(this.containerPos * this.ratio);
        /*
        if ( container !== this.realContainer ){
          this.realContainer[prop] = this.containerPos;
        }
        */
        bbn.fn.each(this.scrollableElements(), a => {
          if (a !== container) {
            a[prop] = this.containerPos;
          }
        });
        this.overContent();
      }
    },
    /**
     * @method adjustFromBar
     */
    adjustFromBar(anim) {
      if (this.shouldBother) {
        this.$nextTick(() => {
          this.containerPos = this.sliderPos / this.ratio;
          let prop = this.isVertical ? 'scrollTop' : 'scrollLeft';
          if (this.realScroller) {
            this.scrollTo(this.containerPos, anim);
          } else {
            this.realContainer[prop] = this.containerPos;
            bbn.fn.each(this.scrollableElements(), a => {
              a[prop] = this.containerPos;
            });
          }
          let e = new Event('scroll');
          this.$emit('scroll' + (this.isVertical ? 'y' : 'x'), e, this.containerPos);
        });
      }
    },
    /**
     * When the users jumps by clicking the scrollbar while a double click will activate tillEnd.
     * @method jump
     * @param {Event} e
     * @param {Boolean} precise
     */
    jump(e, precise) {
      if (this.realContainer) {
        let isRail = e.target === this.$el;
        if (isRail) {
          let position = this.$refs.scrollSlider.getBoundingClientRect();
          // Calculate the Movement
          let clickPoint = this.isVertical ? e.pageY : e.pageX;
          let isBefore = clickPoint < position[this.isVertical ? 'top' : 'left'];
          let isAfter = clickPoint > position[this.isVertical ? 'bottom' : 'right'];
          if (isBefore || isAfter) {
            let movement = isBefore ? -(position[this.isVertical ? 'top' : 'left'] - clickPoint) : clickPoint - position[this.isVertical ? 'top' : 'left'] - position[this.isVertical ? 'height' : 'width'];
            if (!precise) {
              if (isBefore) {
                this.scrollBefore(true);
              } else {
                this.scrollAfter(true);
              }
            } else {
              this.scrollTo(Math.round((this.sliderPos + movement) / this.ratio));
            }
          }
        }
      }
    },
    /**
     * @method scrollLevel
     * @param {Boolean} before 
     */
    scrollLevel(before, anim) {
      if (this.sliderSize) {
        let movement = Math.round(this.sliderSize - this.sliderSize * 0.1);
        if (before) {
          movement = -movement;
        }
        this.scrollTo(Math.round((this.sliderPos + movement) / this.ratio), true);
      }
    },
    /**
     * @method scrollBefore
     * @fires scrollLevel
     */
    scrollBefore(anim) {
      return this.scrollLevel(true, anim);
    },
    /**
     * @method scrollAfter
     * @fires scrollLevel
     */
    scrollAfter(anim) {
      return this.scrollLevel(false, anim);
    },
    /**
     * Gets the array of scrollable elements according to scrollAlso attribute.
     * @method scrollableElements
     * @returns {Array}
     */
    scrollableElements() {
      let tmp = this.scrollAlso;
      if (bbn.fn.isFunction(tmp)) {
        tmp = tmp();
      } else if (!Array.isArray(tmp)) {
        tmp = [tmp];
      }
      let res = [];
      if (bbn.fn.isArray(tmp)) {
        bbn.fn.each(tmp, a => {
          if (a) {
            res.push(a);
          }
        });
      }
      return res;
    },
    /**
     * Calculates all the proportions based on content.
     * @method onResize
     */
    onResize() {
      if (this.realContainer) {
        let tmp1, tmp2;
        if (this.realScroller) {
          tmp1 = this.realScroller[this.isVertical ? 'lastKnownHeight' : 'lastKnownWidth'];
          tmp2 = this.realScroller[this.isVertical ? 'contentHeight' : 'contentWidth'];
        } else {
          tmp1 = this.isVertical ? this.realContainer.clientHeight : this.realContainer.clientWidth;
          tmp2 = this.realContainer[this.isVertical ? 'scrollHeight' : 'scrollWidth'] || tmp1;
        }
        if (tmp1 < 20) {
          this.containerSize = 0;
          this.contentSize = 0;
          this.size = 0;
          this.isActive = false;
          return;
        }
        if (tmp1 !== this.containerSize || tmp2 !== this.contentSize) {
          this.containerSize = tmp1 || 0;
          this.contentSize = tmp2 || 0;
        }
        this.isActive = this.contentSize > this.containerSize + 2;
      } else {
        this.isActive = false;
        this.initContainer();
        if (this.realContainer) {
          this.onResize();
        }
      }
    },
    /**
     * Sets all event listeners.
     * @method initContainer
     */
    initContainer() {
      var _this$realScroller;
      if (!this.realContainer && (_this$realScroller = this.realScroller) !== null && _this$realScroller !== void 0 && _this$realScroller.getRef) {
        this.realContainer = this.realScroller.getRef('scrollContainer');
      }
      if (this.realContainer && !this.isInit) {
        this.onResize();
        this.isInit = true;
        if (!this.container && this.realScroller) {
          bbn.fn.log(this, this.orientation);
          this.realScroller.$on("resize", this.onResize, false, this);
          this.scrollTo(this.initial);
          this.realScroller.$on("scroll", this.adjustFromContainer, false, this);
          this.realScroller.$on("mousemove", this.overContent, false, this);
        } else {
          this.realContainer.addEventListener("mousemove", this.overContent);
          this.realContainer.addEventListener('scroll', this.adjustFromContainer, {
            passive: true
          });
        }
        bbn.fn.each(this.scrollableElements(), a => {
          a.addEventListener('scroll', () => {
            this.adjustFromContainer(a);
          }, {
            passive: true
          });
          a.addEventListener('scroll', this.overContent);
        });
      }
    },
    /**
     * When the mouse is over the content.
     * @method overContent
     */
    overContent() {
      this.keepCool(() => {
        clearTimeout(this.moveTimeout);
        if (!this.isOverSlider) {
          this.isOverContent = true;
        }
        if (!this.show) {
          this.show = true;
        }
        this.moveTimeout = setTimeout(() => {
          if (!this.isOverSlider) {
            this.hideSlider();
            this.isOverContent = false;
          }
        }, 500);
      }, 'overContent', 250);
    },
    /**
     * @method showSlider
     */
    showSlider() {
      clearTimeout(this.moveTimeout);
      if (!this.show) {
        this.show = true;
      }
    },
    /**
     * @method hideSlider
     */
    hideSlider() {
      if (!this.dragging && this.show) {
        this.show = false;
      }
    },
    /**
     * Animates the bar.
     * @method animateBar
     */
    animateBar() {
      return;
      if (this.$refs.scrollSlider) {
        //this.dragging = true;
        let anim = {};
        if (this.isVertical) {
          anim.height = this.size + '%';
          anim.top = this.position + '%';
        } else {
          anim.width = this.size + '%';
          anim.left = this.position + '%';
        }
      }
    },
    /**
     * Smooth scroll animation
     * @param {int} endX: destination x coordinate
     * @param {int} endY: destination y coordinate
     * @param {int} duration: animation duration in ms
     */
    smoothScrollTo(end, duration) {
      return new Promise((resolve, reject) => {
        const start = this.realContainer['scroll' + (this.isVertical ? 'Top' : 'Left')];
        const distance = end - start;
        const startTime = new Date().getTime();
        duration = typeof duration !== 'undefined' ? duration : 400;

        // Easing function
        const easeInOutQuart = (time, from, distance, duration) => {
          if ((time /= duration / 2) < 1) return distance / 2 * time * time * time * time + from;
          return -distance / 2 * ((time -= 2) * time * time * time - 2) + from;
        };
        if (this.animationInterval) {
          clearInterval(this.animationInterval);
        }
        this.animationInterval = setInterval(() => {
          const time = new Date().getTime() - startTime;
          let newPos = easeInOutQuart(time, start, distance, duration);
          if (time >= duration) {
            clearInterval(this.animationInterval);
            newPos = end;
            resolve();
          }
          this.nextLevel = Math.round(newPos);
          this.realContainer['scroll' + (this.isVertical ? 'Top' : 'Left')] = this.nextLevel;
        }, 1000 / 60); // 60 fps
      });
    },

    /**
     * Scrolls to the given position using the given animation.
     * @method scrollTo
     * @fires adjustFromContainer
     */
    scrollTo(val, anim) {
      return new Promise(resolve => {
        if (this.shouldBother) {
          if (this.animationInterval) {
            clearInterval(this.animationInterval);
          }
          let num = 0;
          let ele = false;
          if (bbn.cp.isComponent(val) && val.$el) {
            ele = val.$el;
          } else if (bbn.fn.isDom(val)) {
            ele = val;
          }
          if (ele) {
            let container = ele.offsetParent;
            // The position is equal to the offset of the target
            // minus the size of the viewport, which isn't scrolled,
            // plus half the size of the viewport to center it
            // therefore removing half of the viewport does the trick
            num = ele[this.isVertical ? 'offsetTop' : 'offsetLeft'] - Math.round(this.containerSize / 2);
            while (container && container !== this.realScroller.$el) {
              if (container.contains(this.realScroller.$el)) {
                break;
              } else {
                num += container[this.isVertical ? 'offsetTop' : 'offsetLeft'];
                container = container.offsetParent;
              }
            }
          } else if (bbn.fn.isPercent(val)) {
            num = Math.round(parseFloat(val) * this.contentSize / 100);
          } else if (bbn.fn.isNumber(val)) {
            num = val;
          }
          if (bbn.fn.isNumber(num)) {
            //bbn.fn.log("scrollTo part 1", num);
            if (num < 0) {
              num = 0;
            } else if (num > this.contentSize - this.containerSize + 100) {
              num = this.contentSize - this.containerSize;
            }

            //bbn.fn.log("scrollTo part 2", num);
            this.containerPos = num;
            if (anim) {
              this.smoothScrollTo(num).then(() => {
                resolve();
              });
            } else {
              this.sliderPos = this.containerPos * this.ratio;
              this.nextLevel = Math.round(num);
              this.realContainer['scroll' + (this.isVertical ? 'Top' : 'Left')] = num;
              resolve();
            }
          }
        }
      });
    },
    /**
     * Moves the scrollbar to the position 0.
     * @method scrollStart
     * @fires scrollTo
     */
    scrollStart(anim) {
      this.scrollTo(0, anim);
    },
    /**
    * Moves the scrollbar to the end position.
    * @method scrollEnd
    * @fires scrollTo
    */
    scrollEnd(anim) {
      this.scrollTo(this.contentSize - this.containerSize, anim);
    }
  },
  watch: {
    /**
     * @watch isOverSlider
     * @fires initContainer
     */
    isOverSlider(v) {
      this.isOverContent = false;
      if (!this.dragging) {
        if (!v) {
          this.overContent();
        } else if (!this.show) {
          this.showSlider();
        }
      }
    },
    /**
     * @watch container
     * @fires initContainer
     */
    container() {
      this.initContainer();
    },
    /**
     * 
     * @watch show
     * @fires onResize
     */
    show(v) {
      if (v) {
        this.onResize();
      }
    },
    /**
     * @watch sliderPos
     * @fires showSlider
     */
    sliderPos() {
      this.showSlider();
    },
    dragging(v) {
      if (this.realScroller) {
        this.realScroller.isDragging = v;
      }
    }
  },
  /**
   * Adds the css class for the orientation of the scrollbar.
   * @event created
   */
  created() {
    this.componentClass.push(this.orientation);
  },
  /**
   * Adds the events listener and launch the resize of the scrollbar.
   * @event mounted
   */
  mounted() {
    this.initContainer();
    document.addEventListener("mousemove", this.onDrag, {
      passive: true
    });
    document.addEventListener("touchmove", this.onDrag, {
      passive: true
    });
    document.addEventListener("mouseup", this.stopDrag);
    document.addEventListener("touchend", this.stopDrag);
    this.onResize();
    this.overContent();
  },
  /**
   * Removes the events listener.
   * @event beforeDestroy
   */
  beforeDestroy() {
    if (this.realContainer && this.isInit) {
      if (!this.container && this.realScroller) {
        this.realScroller.$off("resize", this.onResize);
        this.realScroller.$off("scroll", this.adjustFromContainer);
        this.realScroller.$off("mousemove", this.overContent);
      } else {
        this.realContainer.removeEventListener('scroll', this.adjust, {
          passive: true
        });
        this.realContainer.removeEventListener('mousemove', this.overContent, {
          passive: true
        });
      }
      bbn.fn.each(this.scrollableElements(), a => {
        a.removeEventListener('scroll', this.adjustFromContainer, {
          passive: true
        });
        a.removeEventListener('mousemove', this.overContent, {
          passive: true
        });
      });
    }
    document.removeEventListener("mousemove", this.onDrag);
    document.removeEventListener("touchmove", this.onDrag);
    document.removeEventListener("mouseup", this.stopDrag);
    document.removeEventListener("touchend", this.stopDrag);
  }
};
import cpHtml from './scrollbar.html';
import cpStyle from './scrollbar.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./scrollbar.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-scrollbar',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-search component
 * @description The search allows to select a single value from a list of items by proposeing suggestions based on the typed characters.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 10/02/2017.
 */

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
   * @mixin bbn.cp.mixins.dropdown
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.resizer, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.url, bbn.cp.mixins.dropdown],
  props: {
    /**
     * For to apply the filters or not.
     *
     * @prop {Boolean} filterable
     */
    filterable: {
      type: Boolean,
      default: true
    },
    /**
     * To define the length of the string to start the filter.
     *
     * @prop {Number} [0] minLength
     */
    minLength: {
      type: Number,
      default: 2
    },
    /**
     * Specifies the time of delay.
     *
     * @prop {Number} [250] delay
     */
    delay: {
      type: Number,
      default: 250
    },
    /**
     * Specifies the mode of the filter.
     *
     * @prop {String} ['startswith'] filterMode
     */
    filterMode: {
      type: String,
      default: 'contains'
    },
    /**
     * Autobind defaults at false.
     *
     * @prop {Boolean} [false] autobind
     */
    autobind: {
      type: Boolean,
      default: false
    },
    /**
     * Defines if the component has to be disabled.
     * @prop {Boolean|Function} [false] disabled
     */
    disabled: {
      type: [Boolean, Function],
      default: false
    },
    /**
     * Set it to true if you want to auto-resize the input's width based on its value (in characters).
     * @prop {Boolean} [false] autosize
     */
    autosize: {
      type: Boolean,
      default: false
    },
    /**
     * The placeholder.
     * @prop {String} placeholder
     */
    placeholder: {
      type: String
    }
  },
  data() {
    return {
      /**
       * Indicates if the filter input is visible
       * @data {Boolean} [false] inputIsVisible
       */
      inputIsVisible: false,
      isDisabled: this.disabled
    };
  },
  methods: {
    /**
     * Shows the filter input
     * @method _setInputVisible
     */
    _setInputVisible() {
      this.filterString = this.currentText;
      this.inputIsVisible = true;
      this.$nextTick(() => {
        this.getRef('input').focus();
      });
    },
    onChange() {
      if (!this.ready) {
        this.ready = true;
      }
    },
    /**
     * Puts the focus on the element.
     *
     * @method click
     * @fires getRef
     */
    click() {
      if (!this.isDisabled) {
        this.getRef('input').focus();
        if (this.filteredData.length) {
          this.isOpened = !this.isOpened;
        }
      }
    },
    /**
     * Remove the filter and close the list if it is notabove it.
     *
     * @method leave
     * @fires getRef
     */
    leave() {
      if (this.isOpened && !this.getRef('list').isOver) {
        this.isOpened = false;
      }
      this.inputIsVisible = false;
      this.filterString = '';
    },
    /**
     * Emits the event 'select'.
     *
     * @method select
     * @param {Object} item
     * @fires emitInput
     * @fires getRef
     * @emit change
     */
    select(item) {
      if (item) {
        if (this.sourceUrl && item[this.sourceUrl]) {
          bbn.fn.link(item[this.sourceUrl]);
        } else if (this.sourceAction && item[this.sourceAction] && bbn.fn.isFunction(item[this.sourceAction])) {
          item[this.sourceAction](item);
        } else {
          this.$emit('select', item);
        }
        this.filterString = '';
      }
      this.isOpened = false;
    },
    /**
     * Function to do the reset and if the component is open it closes it.
     *
     * @method resetDropdown
     * @fires unfilter
     */
    resetDropdown() {
      this.currentText = this.currentTextValue;
      this.filterString = this.currentTextValue;
      this.unfilter();
      if (this.isOpened) {
        this.isOpened = false;
      }
    },
    /**
     * Function that performs different actions based on what is being pressed.
     *
     * @method keydown
     * @param {Event} e
     * @fires resetDropdown
     * @fires commonKeydown
     * @fires keynav
     */
    keydown(e) {
      if (this.commonKeydown(e)) {
        return;
      } else if (this.isOpened && e.key === 'Escape') {
        e.stopPropagation();
        e.preventDefault();
        this.resetDropdown();
        return;
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      }
    }
  },
  watch: {
    disabled(v) {
      this.isDisabled = v;
    },
    /**
     * @watch filterString
     * @fires onResize
     * @fires unfilter
     * @param {String} v
     */
    filterString(v) {
      if (!this.ready) {
        this.ready = true;
      }
      clearTimeout(this.filterTimeout);
      bbn.fn.log("CLEARED");
      if (!v && this.nullable && this.inputIsVisible) {
        bbn.fn.log("NO VALUE");
        this.unfilter();
        this.emitInput(null);
        this.currentText = '';
        if (this.currentData.length) {
          this.currentData.splice(0, this.currentData.length);
        }
      } else if (v) {
        bbn.fn.log("VALUE");
        if (v.length < this.minLength) {
          if (this.currentData.length) {
            this.currentData.splice(0, this.currentData.length);
          }
        } else if (v !== this.currentText) {
          bbn.fn.log("MIN PASSED");
          this.isOpened = false;
          this.filterTimeout = setTimeout(() => {
            // this.filterTimeout = false;
            // We don't relaunch the source if the component has been left
            if (this.isActive) {
              bbn.fn.log("UPDATING AUTOC");
              this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
                field: this.sourceText,
                operator: this.filterMode,
                value: v
              });
              this.updateData().then(() => {
                this.isOpened = true;
              });
            }
          }, this.delay);
        }
      } else if (!v) {
        this.unfilter();
      }
    }
  }
};
import cpHtml from './search.html';
import cpStyle from './search.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./search.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-search',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-slider component
 *
 * @description 
 *
 * @copyright BBN Solutions
 *
 * @author Vito Fava
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic 
   * @mixin bbn.cp.mixins.toggle
   * @mixin bbn.cp.mixins.resizer 
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.toggle],
  statics() {
    const orientations = {
      left: {
        shadow: '2px 0 20px 0',
        size: 'width',
        prop: 'top'
      },
      right: {
        shadow: '-2px 0 20px 0',
        size: 'width',
        prop: 'top'
      },
      top: {
        shadow: '2px 0 20px 0',
        size: 'height',
        prop: 'left'
      },
      bottom: {
        shadow: '2px 0 20px 0',
        size: 'height',
        prop: 'left'
      }
    };
    return {
      orientations
    };
  },
  props: {
    /**
     * The orientation of the slider.
     * @prop {String} ['left'] orientation 
     */
    orientation: {
      type: String,
      default: 'left'
    },
    /**
     * The close button.
     * @prop {Boolean|String} [true]
     */
    closeButton: {
      type: [Boolean, String],
      default: true
    },
    /**
     * Defines if the slider is visible.
     * @prop {Boolean} [false]visible
     */
    visible: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * True when the component has been opened.
       */
      hasBeenOpened: false,
      /**
       * The opacity of the slider.
       * @data {Number} [0] opacity
       */
      opacity: 1,
      /**
       * The current size.
       * @data {Number} [0] currentSize
       */
      currentSize: 0,
      /**
       * The position top.
       * @data [null] top
       */
      top: null,
      /**
       * The position left.
       * @data [null] left
       */
      left: null,
      /**
       * The position bottom.
       * @data [null] bottom
       */
      bottom: null,
      /**
       * The position right.
       * @data [null] right
       */
      right: null,
      /**
       * @data {Number|Boolean} [false] transitionTimeout
       */
      transitionTimeout: false,
      /**
       * Internal setting for when showing shadow.
       * @data {Boolean} showShadow
       */
      showShadow: this.visible
    };
  },
  computed: {
    /**
     * True if it is a vertical slider.
     * @computed isVertical
     * @returns {Boolean}
     */
    isVertical() {
      return this.orientation === 'left' || this.orientation === 'right';
    },
    /**
     * The current style.
     * @computed currentStyle
     * @returns {String}
     */
    currentStyle() {
      if (!bbnSliderCp.orientations[this.orientation]) {
        throw new Error(bbn._("Impossible to get an orientation for the slider"));
      }
      let o = {
        visibility: 'hidden'
      };
      let or = bbn.fn.createObject(bbnSliderCp.orientations[this.orientation]);
      if (this.showShadow) {
        o['-webkit-box-shadow'] = o['-moz-box-shadow'] = o['box-shadow'] = or.shadow + ' !important';
      }
      if (o[or.prop] !== null && this.ready && !this.isResizing) {
        o.transition = this.orientation + ' 0.5s';
        o.visibility = 'visible';
      }
      o[or.size] = 'auto';
      o[or.prop] = 0;
      o[this.orientation] = this.currentVisible ? 0 : -this.currentSize + 'px';
      return o;
    }
  },
  methods: {
    /**
     * Private method to manage the "touchstart" event
     * @method _touchStart
     */
    _touchStart() {
      this.touchStart = true;
      this.touchMove = false;
    },
    /**
     * Private method to manage the "touchmove" event
     * @method _touchMove
     */
    _touchMove() {
      this.touchMove = true;
    },
    /**
     * Private method to manage the "touchend" event
     * @method _touchEnd
     * @param {Event} e
     * @fires checkClick
     */
    _touchEnd(e) {
      if (!this.touchMove) {
        this.checkClick(e);
      }
      this.touchStart = false;
      this.touchMove = false;
    },
    /**
     * Adds or removes the event listener for mousedown and touchstart.
     * @method _setEvents
     * @param add
     */
    _setEvents(add) {
      if (add) {
        document.addEventListener('mouseup', this.checkClick.bind(this));
        document.addEventListener('touchstart', this._touchStart.bind(this));
        document.addEventListener('touchmove', this._touchMove.bind(this), {
          passive: true
        });
        document.addEventListener('touchend', this._touchEnd.bind(this));
      } else {
        document.removeEventListener('mouseup', this.checkClick.bind(this));
        document.removeEventListener('touchstart', this._touchStart.bind(this));
        document.removeEventListener('touchmove', this._touchMove.bind(this));
        document.removeEventListener('touchend', this._touchEnd.bind(this));
      }
    },
    /**
     * Handles the resize.
     * @method onResize
     */
    onResize() {
      this.isResizing = true;
      if (this.transitionTimeout) {
        clearTimeout(this.transitionTimeout);
      }
      this.transitionTimeout = setTimeout(() => {
        if (!this.$isMounted) {
          this.onResize();
        }
        if (this.setResizeMeasures() || this.setContainerMeasures()) {
          let s = this.$el.getBoundingClientRect()[this.isVertical ? 'width' : 'height'];
          if (s !== this.currentSize && s > 20) {
            this.currentSize = s + 7;
          }
        }
        this.isResizing = false;
        if (!this.ready) {
          this.ready = true;
        }
      }, 500);
    },
    /**
     * Handles the mousedown.
     * @param {Event} e 
     * @fires toggle
     */
    checkClick(e) {
      if (this.currentVisible) {
        const target = e.target;
        const ev = new CustomEvent('checkclick', {
          cancelable: true
        });
        bbn.fn.log("CHECK CLICK", target, ev);
        this.$emit('checkclick', target, ev);
        if (!ev.defaultPrevented) {
          var _e$target$closest;
          const cp = (_e$target$closest = e.target.closest(".bbn-component")) === null || _e$target$closest === void 0 ? void 0 : _e$target$closest.bbn;
          if (!cp || cp.closest("bbn-slider") !== this) {
            this.hide();
          }
          bbn.fn.log("CHECK CLICK", target, ev, cp);
        }
      }
    },
    changeVisible(v) {
      //bbn.fn.log("CHANGE SLIDER VISIBLE");
      if (v && !this.hasBeenOpened) {
        this.hasBeenOpened = true;
      }
      this.switchFocus(v);
    }
  },
  /**
   * Sets the events listener.
   * @event created
   * @fires _setEvents
   */
  created() {
    this.componentClass.push('bbn-resize-emitter');
    this._setEvents(true);
  },
  /**
   * Removes the events listener.
   * @event destroyed
   * @fires _setEvents
   */
  beforeDestroy() {
    this._setEvents();
  },
  /**
   * Initializes the component.
   * @event mounted
   */
  mounted() {
    this.onResize();
  },
  watch: {
    /**
     * @watch currentSize
     * @param v 
     */
    currentSize(v) {
      this.$el.style[this.isVertical ? 'width' : 'height'] = v;
    },
    visible(v) {
      this.currentVisible = v;
    },
    currentVisible(v) {
      if (!v) {
        this._shadowTimeout = setTimeout(() => {
          this.showShadow = false;
        }, 500);
      } else {
        if (this._shadowTimeout) {
          clearTimeout(this._shadowTimeout);
        }
        this.showShadow = true;
      }
    }
  }
};
import cpHtml from './slider.html';
import cpStyle from './slider.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./slider.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-slider',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-slider-menu component
 *
 * @description bbn-slider-menu component
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.resizer],
  props: {
    /**
     * The source of the floater.
     * @prop {Function|Array|String|Object} source
     */
    source: {
      type: [Function, Array, String, Object]
    },
    /**
     * The array containings the tree's children.
     * @prop {String} ['items'] children
     */
    children: {
      type: String,
      default: 'items'
    },
    /**
     * @prop {Array} [[]] selected
     */
    selected: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {String|Object|Function} component
     */
    component: {
      type: [String, Object, Function]
    }
  },
  data() {
    return {
      /**
       * @data {Array} [[]] currentSelected
       */
      currentSelected: this.selected.slice(),
      /**
       * The index (on filteredData) on which is the mouse cursor or the keyboard navigation
       * @data {Number} overIdx
       */
      overIdx: this.suggest ? 0 : null,
      /**
       * @data {Number|Boolean} [false] mouseLeaveTimeout
       */
      mouseLeaveTimeout: false,
      /**
       * @data {String|Object|Function} currentComponent
       */
      currentComponent: this.component,
      /**
       * @data {Number|Boolean} [false] selectedIndex
       */
      selectedIndex: false,
      /**
       * @data {Number} [0] maxDepth
       */
      maxDepth: 0
    };
  },
  computed: {
    /**
     * @computed items
     * @returns {Array}
     */
    items() {
      let depth = 0;
      let res = [{
        data: this.source,
        selected: true,
        visible: this.currentSelected.length === 0,
        last: false,
        depth: depth
      }];
      let sel = '';
      let list = this.source;
      bbn.fn.each(this.currentSelected, (a, i) => {
        if (sel) {
          sel += '.';
        }
        sel += a + '.' + this.children;
        let tmp = bbn.fn.getProperty(this.source, sel);
        list = tmp;
        if (tmp && tmp.length) {
          depth++;
          res.push({
            data: list,
            selected: true,
            visible: i === this.currentSelected.length - 1,
            last: i === this.currentSelected.length - 1,
            depth: depth
          });
        } else {
          res[res.length - 1].visible = true;
          res[res.length - 1].selected = true;
          res[res.length - 1].last = true;
        }
      });
      if (list && list.length) {
        let hasChildren = false;
        bbn.fn.each(list, a => {
          if (a[this.children] && a[this.children].length) {
            if (!hasChildren) {
              hasChildren = true;
              depth++;
            }
            res.push({
              data: a[this.children],
              selected: false,
              visible: false,
              last: true,
              depth: depth
            });
          }
        });
      } else if (!res[res.length - 1].visible) {}
      this.maxDepth = depth;
      return res;
    }
  },
  methods: {
    /**
     * @method getStyle
     * @param {Object} item
     * @returns {Object}
     */
    getStyle(item) {
      let left = '100%';
      if (item.visible) {
        left = '0px';
      } else if (item.selected) {
        left = '-100%';
      }
      return {
        left: left
      };
    },
    /**
     * @method mouseleave
     */
    mouseleave() {
      this.isOver = false;
      this.overIdx = this.suggest ? 0 : null;
    },
    /**
     * @method remove
     * @param {Number} idx
     * @fires realDelete
     */
    remove(idx) {
      //bbn.fn.log(this.currentData, idx);
      this.realDelete(idx);
    },
    /**
     * Handles the selection of the floater's items.
     * @method select
     * @param {Number} itemIdx
     * @param {Number} dataIdx
     * @emits select
     */
    select(itemIdx, dataIdx) {
      if (this.items[itemIdx].depth < this.maxDepth && this.items[itemIdx].data && this.items[itemIdx].data.length) {
        this.currentSelected.push(dataIdx);
        this.selectedIndex = false;
      } else {
        this.selectedIndex = dataIdx;
      }
      this.$emit('select', this.items[itemIdx].data[dataIdx]);
    },
    /**
     * @method unselect
     * @emits unselect
     */
    unselect() {
      this.selectedIndex = false;
      this.currentSelected.pop();
      this.$emit('unselect', this.currentSelected);
    },
    /**
     * @method reset
     */
    reset() {
      this.selectedIndex = false;
      this.currentSelected.splice(0, this.currentSelected.length);
    }
  },
  /**
   * @event mounted
   * @fires getRef
   * @fires $nextTick
   */
  mounted() {
    this.currentComponent = this.realComponent;
    if (!this.component && !this.template && this.$slots.default) {
      let tpl = this.getRef('slot').innerHTML;
      if (tpl) {
        this.currentTemplate = tpl;
        this.currentComponent = {
          props: ['source'],
          data() {
            return this.source;
          },
          template: this.currentTemplate
        };
      }
    }
    this.$nextTick(() => {
      if (this.$parent.$options && this.$parent.$options._componentTag === 'bbn-scroll') {
        this.hasScroll = true;
      }
      this.ready = true;
    });
  },
  watch: {
    /**
     * @watch source
     * @fires reset
     */
    source() {
      this.reset();
    }
  }
};
import cpHtml from './slider-menu.html';
import cpStyle from './slider-menu.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./slider-menu.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-slider-menu',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-slideshow component
 * @description bbn-slideshow is a highly configurable component, it also allows the display of reactive elements such as components, images, or texts; having full control of the transitions.
 * @copyright BBN Solutions
 *
 * @author Vito Fava
 *
 * @created 10/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],
  props: {
    /**
     * The source of the slideshow
     * @prop {Array|Function|String} source
     */
    source: {
      type: [Array, Function, String]
    },
    /**
     * If the type of the source is a string defines which character to use as separator between slides.
     * @prop {String} separator
     */
    separator: {
      type: String
    },
    /**
     * The component to use in each slide.
     * @prop {Object} component
     */
    component: {
      type: [String, Object, bbnCp]
    },
    /**
     * Insert a checkbox in each slide.
     * @prop {String|Boolean} [false] checkbox
     */
    checkbox: {
      type: [String, Boolean],
      default: false
    },
    /**
     * Set to true shows a list of all slides' title that can be used to navigate between them.
     * @prop {Boolean} [false] summary
     */
    summary: {
      type: Boolean,
      default: false
    },
    //for image
    /**
     * @prop {Boolean} [false] gallery
     */
    gallery: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true shows the list of previews of the slide.
     * @prop {Boolean|String} [false] preview
     */
    preview: {
      type: [Boolean, String],
      default: false
    },
    /**
     * The dimension of the preview.
     * @prop {Number} [45] dimensionPreview
     */
    dimensionPreview: {
      type: [Number, String],
      default: '60px'
    },
    /**
     * Set to true enables the autoplay using the default autoplay time (5000ms). If a number is given, multiplied * 1000, will define the new autoplay time .
     * @prop {Boolean|Number} [false] autoplay
     */
    autoPlay: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Shows the actions to start and stop autoplay.
     * @prop {Boolean|String} [false] ctrl
     */
    ctrl: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Set to true shows the arrow icons to move to next or previous slide. An object with 'left' and 'right' properties can be given to specify the css class for each arrow and to customize the icon.
     * @prop {Bolean|Object} [false] arrows
     */
    arrows: {
      type: [Boolean, Object],
      default: true
    },
    arrowsPosition: {
      type: String,
      default: 'default',
      validator: p => ['default', 'top', 'topleft', 'topright', 'bottom', 'bottomleft', 'bottomright'].includes(p)
    },
    /**
     * Shows or hides the navigation arrow at the bottom of the slider.
     * @prop {Boolean} [false] navigation
     */
    navigation: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true hides the preview images.
     * @prop {Boolean} [false] autoHidePreview
     */
    autoHidePreview: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true hides the arrow icons.
     * @prop {Boolean} [false] autoHideArrows
     */
    autoHideArrows: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true hides the action to start and stop the autoplay.
     * @prop {Boolean} [false] autoHideCtrl
     */
    autoHideCtrl: {
      type: Boolean,
      default: true
    },
    /**
     * If set to true shows the slides in a loop..
     * @prop {Boolean} [false] loop
     */
    loop: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true shows the slide in the full page.
     * @prop {Boolean} [false] fullSlide
     */
    fullSlide: {
      type: Boolean,
      default: false
    },
    /**
     * The index of the first slide to show.
     * @prop {Number} [0] initialSlide
     */
    initialSlide: {
      type: Number,
      default: 0
    },
    /**
     * Set to true shows the number of the current slide and the total number of slides.
     * @prop {Boolean} [false] showCount
     */
    showCount: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true shows the property info of the item.
     * @prop {Boolean} [false] showInfo
     */
    showInfo: {
      type: Boolean,
      default: false
    },
    /**
     * The property that will be used for the image info.
     * @prop {String} ['info'] sourceInfo
     */
    sourceInfo: {
      type: String,
      default: 'info'
    },
    /**
     * If the property content is given to the item, set to true insert the html content inside a scroll.
     * @prop {Boolean} [false] scrollable
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String|Number} ['50px'] minimumPreview
     */
    minimumPreview: {
      type: [String, Number],
      default: '50px'
    },
    /**
     * @prop {Boolean} [false] itemClickable
     */
    itemClickable: {
      type: Boolean,
      default: false
    },
    /**
     * Enables keyboard navigation
     * @prop {Boolean} [false] keyboard
     */
    keyboard: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {String} [bbn.fn.randomString().toLowerCase()] name
       */
      name: bbn.fn.randomString().toLowerCase(),
      /**
       * The current slide index
       * @data {Number} [0] currentIndex
       */
      currentIndex: 0,
      /**
       * The array of items.
       * @data {Array} [[]] items
       */
      items: [],
      /**
       * True if the type of the prop source is string and the prop separator is false.
       * @data {Boolean} isAjax
       */
      isAjax: bbn.fn.isString(this.source) && !this.separator,
      /**
       * The default text to show as label of the checkbox in a selectable slideshow.
       * @data {String} ['Don't show it again'] defaultTextCB
       */
      defaultTextCB: bbn._("Don't show it again"),
      /**
       * The values of the checkbox in a selectable slideshow.
       * @data {Object} [{}] valuesCB
       */
      valuesCB: {},
      /**
       * The active miniature.
       * @data {Number} [0] activeMiniature
       */
      activeMiniature: 0,
      /**
       * The default autoplay time in milliseconds.
       * @data {Number} [5000] defaultAutoPlay
       */
      defaultAutoPlay: 5000,
      /**
       * The interval of the autoplay.
       * @data {Boolean} [false] scrollInterval
       */
      scrollInterval: false,
      /**
       * Shows or hides the miniature.
       * @data {Boolean} [false] showMiniature
       */
      showMiniature: this.autoHidePreview ? false : true,
      /**
       * If true shows the left arrow icon.
       * @data {Boolean} [false] showArrowLeft
       */
      showArrowLeft: this.autoHideArrows ? false : true,
      /**
       * If true shows the right arrow icon. 
       * @data {Boolean} [false] showArrowRight
       */
      showArrowRight: this.autoHideArrows ? false : true,
      /**
       * True shows the controller of the component.
       * @data {Boolean} [false] showCtrl
       */
      showCtrl: this.autoHideCtrl ? false : true,
      /**
       * The classes of the arrow icons
       * @data {Object} [{left: 'nf nf-fa-arrow_circle_left',right: 'nf nf-fa-arrow_circle_right'}] arrowClass
       */
      arrowClass: {
        left: 'nf nf-fa-angle_left',
        right: 'nf nf-fa-angle_right'
      },
      /**
       * The width of the image.
       * @data {Number} [0] imageWidth
       */
      imageWidth: 0,
      /**
       * The height of the image.
       * @data {Number} [0] imageHeight
       */
      imageHeight: 0,
      /**
       * The margin left of the image.
       * @data {Number} [0] imageLeftMargin
       */
      imageLeftMargin: 0,
      /**
       * The margin top of the image.
       * @data {Number} [0] imageTopMargin
       */
      imageTopMargin: 0,
      maxImgWidth: 0,
      maxImgHeight: 0,
      loaded: false
    };
  },
  computed: {
    /**
     * The left arrow class
     * @computed {String} leftArrowClass
     */
    leftArrowClass() {
      if (bbn.fn.isObject(this.arrows) && this.arrows.left) {
        return this.arrows.left;
      }
      return this.arrowClass.left;
    },
    /**
     * The right arrow class
     * @computed {String} rightArrowClass
     */
    rightArrowClass() {
      if (bbn.fn.isObject(this.arrows) && this.arrows.right) {
        return this.arrows.right;
      }
      return this.arrowClass.right;
    },
    arrowsStyle() {
      let style = {
        clear: 'both'
      };
      switch (this.arrowsPosition) {
        case 'top':
        case 'bottom':
          style.justifyContent = 'center';
          break;
        case 'topleft':
        case 'bottomleft':
          style.justifyContent = 'flex-start';
          break;
        case 'topright':
        case 'bottomright':
          style.justifyContent = 'flex-end';
          break;
      }
      return style;
    }
  },
  methods: {
    /**
     * Handles the resize of the component.
     * @method onResize
     * @fires aspectRatio
     */
    onResize() {
      var _this$getRef, _this$getRef2;
      this.setContainerMeasures();
      this.setResizeMeasures();
      if (bbn.fn.isArray(this.source) && this.source.length) {
        this.source.forEach((v, i) => {
          if (v.loaded) {
            this.aspectRatio(i);
          }
        });
      }
      this.maxImgWidth = ((_this$getRef = this.getRef('slideContainer')) === null || _this$getRef === void 0 ? void 0 : _this$getRef.offsetWidth) || null;
      this.maxImgHeight = ((_this$getRef2 = this.getRef('slideContainer')) === null || _this$getRef2 === void 0 ? void 0 : _this$getRef2.offsetHeight) || null;
    },
    /**
     * Sets the property loaded to true.
     * @method afterLoad
     * @param {Number} idx 
     * @fires aspectRatio
     */
    afterLoad(idx) {
      this.$set(this.items[idx], 'loaded', true);
      this.aspectRatio(idx);
    },
    /**
     * Adjusts the dimensions of the slides basing on the 'mode' defined for the item.
     * @method aspectRatio
     * @param {Number} idx 
     */
    aspectRatio(idx) {
      this.$nextTick(() => {
        let cont = this.getRef('slideContainer'),
          ctnRatio = cont.offsetWidth / cont.offsetHeight,
          img = this.getRef('slide-img' + idx.toString()),
          imgW = img.naturalWidth,
          imgH = img.naturalHeight,
          imgRatio = imgW / imgH,
          diff = Math.abs(ctnRatio - imgRatio),
          mode = this.items[idx].mode ? this.items[idx].mode : 'original';
        if (imgRatio > ctnRatio) {
          if (mode === 'zoom') {
            this.$set(this.items[idx], 'imageWidth', 'auto');
            this.$set(this.items[idx], 'imageHeight', '100%');
            this.$set(this.items[idx], 'showImg', true);

            //this.items[idx].imageWidth = "auto";
            //this.items[idx].imageHeight =  "100%";
            //this.items[idx].showImg =  true;
          } else if (mode === 'full') {
            this.$set(this.items[idx], 'imageWidth', '100%');
            this.$set(this.items[idx], 'imageHeight', 'auto');
            this.$set(this.items[idx], 'showImg', true);
            //this.items[idx].imageWidth = "100%";
            //this.items[idx].imageHeight = "auto";
            //this.items[idx].showImg = true;
          }
        } else if (imgRatio <= ctnRatio) {
          if (mode === 'zoom') {
            this.$set(this.items[idx], 'imageWidth', '100%');
            this.$set(this.items[idx], 'imageHeight', 'auto');
            this.$set(this.items[idx], 'showImg', true);

            //this.items[idx].imageWidth = "100%";
            //this.items[idx].imageHeight = "auto";
            //this.items[idx].showImg =  true;
          } else if (mode === 'full') {
            this.$set(this.items[idx], 'imageWidth', 'auto');
            this.$set(this.items[idx], 'imageHeight', '100%');
            this.$set(this.items[idx], 'showImg', true);
            //this.items[idx].imageWidth = "auto";
            //this.items[idx].imageHeight = "100%";
            //this.items[idx].showImg =  true;
          }
        }

        if (mode === 'stretch') {
          this.$set(this.items[idx], 'imageWidth', cont.offsetWidth + 'px');
          this.$set(this.items[idx], 'imageHeight', cont.offsetHeight + 'px');
          this.$set(this.items[idx], 'showImg', true);

          //this.items[idx].imageWidth = this.lastKnownCtWidth + 'px';
          //this.items[idx].imageHeight = this.lastKnownCtHeight + 'px';
          //this.items[idx].showImg =  true;
        }

        if (mode === "original") {
          this.$set(this.items[idx], 'showImg', true);
          //this.items[idx].showImg = true;
        }

        if (cont.offsetWidth) {
          this.$set(this.items[idx], 'imageMaxWidth', cont.offsetWidth + 'px');
        }
        if (cont.offsetHeight) {
          this.$set(this.items[idx], 'imageMaxHeight', cont.offsetHeight + 'px');
        }
      });
    },
    /**
     * Manages the slides' style.
     * @method createStyle
     */
    createStyle() {
      let st = '',
        rules = [];
      this.items.forEach((it, i) => {
        st += '.bbn-slideshow .slideswitch:target ~ .bbn-slideshow-slide#' + (this.name + i.toString()) + ' .bbn-slideshow-content{opacity: 0}';
        st += '.bbn-slideshow .slideswitch[id="' + this.name + i.toString() + '"]:target ~ .bbn-slideshow-slide#' + this.name + i.toString() + ' .bbn-slideshow-navigation {display: block !important;}';
        st += '.bbn-slideshow .slideswitch[id="' + this.name + i.toString() + '"]:target ~ .bbn-slideshow-slide#' + this.name + i.toString() + ' .bbn-slideshow-content {animation-name: bbn-slideshow-effect-fade_in; animation-duration: 0.5s;}';
        if (it.animation) {
          st += '.bbn-slideshow .slideswitch[id="' + this.name + i.toString() + '"]:target ~ #' + this.name + i.toString() + ' .bbn-slideshow-effect-' + it.animation + ' {animation-name: bbn-slideshow-effect-' + it.animation + ' !important;animation-duration: ' + (it.duration || this.duration || '0.5') + 's;' + (it.animation === 'flip' ? 'backface-visibility: hidden;' : '') + '}';
        }
      });
      return st;
    },
    /**
     * Shows the previous slide.
     * @method prev
     * @fires stopAutoPlay
     * @fires startAutoPlay
     */
    prev() {
      let idx = this.currentIndex,
        isFirst = idx === 0;
      if (isFirst && !this.loop) {
        return;
      }
      if (!isFirst || this.loop) {
        let nextIdx = isFirst ? this.items.length - 1 : idx - 1;
        if (!this.items[nextIdx].animation) {
          let slide = this.getRef('slide' + nextIdx);
          if (slide) {
            slide.style.animationName = 'bbn-slideshow-effect-slide_from_right';
          }
        }
        this.currentIndex = nextIdx;
        this.$nextTick(() => {
          setTimeout(() => {
            let slide2 = this.getRef('slide' + nextIdx);
            if (!this.items[nextIdx].animation && !!slide2) {
              slide2.style.animationName = '';
            }
          }, 500);
        });
      }
      if (this.autoPlay) {
        this.stopAutoPlay();
        this.$nextTick(() => {
          this.startAutoPlay();
        });
      }
    },
    /**
     * Shows the next slide.
     * @method next
     * @fires stopAutoPlay
     * @fires startAutoPlay
     */
    next() {
      let idx = this.currentIndex;
      if (this.summary) {
        idx--;
      }
      let isLast = idx === this.items.length - 1;
      if (isLast && !this.loop) {
        return;
      }
      if (!isLast || this.loop) {
        let nextIdx = isLast ? 0 : idx + 1;
        if (!this.items[nextIdx].animation) {
          let slide = this.getRef('slide' + nextIdx);
          if (slide) {
            slide.style.animationName = 'bbn-slideshow-effect-slide_from_left';
          }
        }
        this.currentIndex = nextIdx;
        this.$nextTick(() => {
          setTimeout(() => {
            let slide2 = this.getRef('slide' + nextIdx);
            if (!this.items[nextIdx].animation && !!slide2) {
              slide2.style.animationName = '';
            }
          }, 500);
        });
      }
      if (this.autoPlay) {
        this.stopAutoPlay();
        this.$nextTick(() => {
          this.startAutoPlay();
        });
      }
    },
    /**
     * Starts the autoplay of slides.
     * @method startAutoPlay
     */
    startAutoPlay() {
      this.scrollInterval = setInterval(() => {
        if (this.currentIndex < this.items.length - 1) {
          this.next();
        } else if (this.currentIndex === this.items.length - 1) {
          this.currentIndex = 0;
        }
        if (this.preview) {
          this.activeMiniature = this.currentIndex;
        }
      }, typeof this.autoPlay === 'number' ? this.autoPlay * 1000 : this.defaultAutoPlay);
    },
    /**
    * Stops the autoplay of slides.
    * @method stopAutoPlay
    */
    stopAutoPlay() {
      if (this.scrollInterval) {
        clearInterval(this.scrollInterval);
        this.scrollInterval = false;
      }
    },
    /**
     * Shows or hides miniatures.
     * @method miniaturePreview
     * @param {Boolean} val 
     */
    miniaturePreview(val) {
      if (this.autoHidePreview) {
        this.showMiniature = val;
      }
    },
    /**
     * Shows or hides arrows.
     * @param {String} direction 
     * @param {Boolean} val 
     */
    arrowsPreview(direction, val) {
      if (this.autoHideArrows) {
        if (direction === 'next') {
          this.showArrowRight = val;
        }
        if (direction === 'prev') {
          this.showArrowLeft = val;
        }
      }
    },
    /**
     * Shows ors hides the controller for autoplay.
     * @param {Boolean} val 
     */
    ctrlPreview(val) {
      if (this.autoHideCtrl) {
        this.showCtrl = val;
      }
    },
    updateData() {
      let src = [];
      if (bbn.fn.isString(this.source) && this.separator) {
        // Slide between each separator (check help in app-ui)
        src = this.source.split(this.separator).map(a => {
          return {
            content: a,
            type: 'text'
          };
        });
      } else if (bbn.fn.isFunction(this.source)) {
        src = this.source();
      } else if (bbn.fn.isArray(this.source)) {
        if (this.checkbox) {
          if (this.separator) {
            this.source.forEach((v, i) => {
              v.content.split(this.separator).forEach((a, k) => {
                let o = {
                  type: 'text',
                  content: a,
                  id: v.id
                };
                if (k === 0) {
                  o.checkable = true;
                }
                src.push(o);
              });
              if (this.valuesCB[i] === undefined) {
                this.valuesCB[i] = false;
              }
            });
          }
        } else {
          src = bbn.fn.extend(true, [], this.source).map(val => {
            if (bbn.fn.isString(val)) {
              val = {
                type: this.gallery ? 'img' : 'text',
                content: val
              };
            }
            if (val.type === 'img') {
              bbn.fn.extend(val, {
                imageWidth: 0,
                imageHeight: 0,
                imageLeftMargin: 0,
                imageTopMargin: 0,
                showImg: false
              });
            }
            if (bbn.fn.isObject(val) && (!val.type || val.type !== 'img' && val.type !== 'text')) {
              val.type = 'text';
            }
            return bbn.fn.isObject(val) ? val : {};
          });
        }
      }
      this.items.splice(0, this.items.length, ...src);
      if (!this.loaded) {
        this.loaded = true;
      }
    }
  },
  /**
   * @event mounted
   * @fires createStyle
   * @fires startAutoPlay
   */
  mounted() {
    this.updateData();
    this.$nextTick(() => {
      this.currentIndex = this.initialSlide > this.items.length ? 0 : this.initialSlide;
      if (!this.isAjax && !this.items.length && this.getRef('slot').innerHTML.trim()) {
        if (this.separator) {
          this.items = this.getRef('slot').innerHTML.split(this.separator).map((txt, i) => {
            let el = document.createElement('div'),
              title = '';
            el.innerHTML = txt;
            if (el) {
              let titles = el.querySelectorAll('h1,h2,h3,h4,h5');
              if (titles.length) {
                bbn.fn.each(titles, (v, i) => {
                  let title = v.innerText.trim();
                });
              }
            }
            return {
              content: txt,
              type: 'text',
              title: title
            };
          });
        } else {
          this.items = [{
            content: this.getRef('slot').innerHTML,
            type: 'text'
          }];
        }
      }
      this.ready = true;
      this.$nextTick(() => {
        this.createStyle();
        if (this.autoPlay) {
          this.startAutoPlay();
        }
        if (bbn.fn.isObject(this.arrows)) {
          if (this.arrows.left && this.arrows.left.length) {
            this.arrowClass.left = this.arrows.left;
          }
          if (this.arrows.right && this.arrows.right.length) {
            this.arrowClass.right = this.arrows.right;
          }
        }
        this.onResize();
      });
    });
  },
  watch: {
    /**
     * @watch show
     * @param newVal
     * @param oldVal
     * @emits show
     * @emits hide
     */
    show(newVal, oldVal) {
      if (newVal != oldVal) {
        this.$emit(newVal ? "show" : "hide");
      }
    },
    /**
     * @watch valuesCB
     * @emits check
     * @emits uncheck
     */
    valuesCB: {
      deep: true,
      handler(newVal) {
        this.$emit(newVal[this.currentIndex] ? 'check' : 'uncheck', this.items[this.currentIndex]);
      }
    },
    /**
     * @watch currentIndex
     * @emits changeSlide
     * @param {Number} val 
     */
    currentIndex(val) {
      let miniatures = this.getRef('miniatures');
      if (miniatures) {
        let scroll = miniatures.getRef('scroll');
        if (scroll) {
          let xScroller = scroll.getRef('xScroller');
          if (xScroller) {
            xScroller.scrollTo(miniatures.$refs.items[val]);
          }
        }
      }
      this.$emit('changeSlide', val);
    },
    source: {
      deep: true,
      handler() {
        this.updateData();
      }
    }
  },
  components: {
    /**
     * @component miniature
     */
    miniature: {
      template: `
          <bbn-scroll axis="x"
                      ref="scroll"
                      @ready="init">
            <div class="bbn-w-100 bbn-middle">
              <template  v-for="(it, i) in items">
                <i v-if="type === 'circle'"
                    @click= "clickMiniature(it , i)"
                    :class="[
                      (mainComponent.currentIndex === i ? 'nf nf-fa-dot_circle_o' : 'nf nf-fa-circle'),
                      'bbn-padded',
                      'bbn-slideshow-circleMiniature',
                      'bbn-p',
                      {'bbn-primary-text-alt': mainComponent.currentIndex === i}
                    ]"
                    ref="items"
                ></i>
                <div v-else
                     @click= "clickMiniature(it , i)"
                     :class="['bbn-slideshow-zoom', 'bbn-bordered-internal', {
                       'bbn-primary-border': mainComponent.currentIndex === i,
                       'bbn-right-xsspace': !!items[i+1]
                     }]"
                     :style="{
                       'border-width': (mainComponent.currentIndex === i) ? 'medium' : '',
                       width: dimension,
                       height: dimension,
                       minWidth: minimumPreview,
                       minHeight: minimumPreview,
                     }"
                     ref="items"
                >
                  <div v-if="it.type === 'text'"
                      v-html="it.content"
                      class="bbn-slideshow-content"
                  ></div>
                  <img v-else-if="it.type === 'img'"
                      :src="getImgSrc(it.content)"
                      :alt="it.caption || it.text || ''"
                      width="100%"
                      height="100%"
                  >
                </div>
              </template>
            </div>
          </bbn-scroll>`,
      props: {
        /**
         * The array of items.
         * @prop {Array} [] items
         * @memberof miniature
         */
        items: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * 
         * @prop {Boolean} [true] compare
         * @memberof miniature
         */
        compare: {
          type: Boolean,
          default: true
        },
        /**
        * @prop {Boolean|String} ['image'] type
        * @memberof miniature
        */
        type: {
          type: [Boolean, String],
          default: 'image'
        },
        /**
        * @prop {Number} [45] dimension
        * @memberof miniature
        */
        dimension: {
          type: String
        },
        minimumPreview: {
          type: String
        }
      },
      data() {
        return {
          /**
           * The parent component bbn-slideshow
           * @data {Object} mainComponent
           */
          mainComponent: this.closest('bbn-slideshow')
        };
      },
      methods: {
        /**
         * @method clickMiniature
         * @param miniature
         * @param {Number} idx
         * @fires stopAutoPlay
         * @fires startAutoPlay
         * @memberof miniature
         */
        clickMiniature(miniature, idx) {
          this.mainComponent.activeMiniature = idx;
          this.mainComponent.currentIndex = idx;
          if (this.mainComponent.autoPlay) {
            this.mainComponent.stopAutoPlay();
            this.$nextTick(() => {
              this.mainComponent.startAutoPlay();
            });
          }
        },
        /**
         * @method getImgSrc
         * @param {Strng} content
         * @memberof miniature
         * @return {String}
         */
        getImgSrc(content) {
          return content.match(/data\:image\/[a-zA-Z]*\;base64/) ? content : `${content}${content.indexOf('?') > -1 ? '&' : '?'}w=${this.dimension.match(/\d+/)}&thumb=1`;
        },
        init() {
          const elem = this.$el.querySelector('div.bbn-slideshow-zoom div.bbn-slideshow-content');
          if (elem) {
            elem.style.transform = 'scale(0.2)';
            if (elem.querySelector('img')) {
              elem.querySelector('img').style.transform = 'scale(0.1)';
            }
          }
        }
      }
    }
  }
};
import cpHtml from './slideshow.html';
import cpStyle from './slideshow.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./slideshow.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-slideshow',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-splashscreen component
 * @description  bbn-splashscreen.
 * @author BBN Solutions
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.events
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.events, bbn.cp.mixins.resizer],
  props: {
    /**
     * @prop {Array} source
     */
    source: {
      type: Array
    },
    /**
     * @prop {Boolean} [true] arrows
     */
    arrows: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {(Boolean|String)} ['outsideBottom'] dots
     */
    dots: {
      type: [Boolean, String],
      default: 'outsideBottom',
      validator: d => [true, false, 'insideTop', 'insideBottom', 'outsideTop', 'outsideBottom'].includes(d)
    },
    /**
     * @prop {Boolean} [true] loop
     */
    loop: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} header
     */
    header: {
      type: String
    },
    /**
     * @prop {(String|Object|bbnCp)} headerComponent
     */
    headerComponent: {
      type: [String, Object, bbnCp]
    },
    /**
     * @prop {String} footer
     */
    footer: {
      type: String
    },
    /**
     * @prop {(String|Object|bbnCp)} footerComponent
     */
    footerComponent: {
      type: [String, Object, bbnCp]
    }
  },
  data() {
    return {
      currentSwipeClass: 'bbn-splashscreen-swipe-left',
      currentIndex: 0
    };
  },
  computed: {
    dotsPosition() {
      return this.dots === true ? 'outsideBottom' : this.dots;
    },
    currentIndexes() {
      return bbn.fn.map(this.filteredData, d => d.index);
    },
    currentStyle() {
      let style = {};
      if (this.currentData.length) {
        let item = this.currentData[this.currentIndex].data;
        if (item.background) {
          style.backgroundColor = item.background;
        }
        if (item.image) {
          style.backgroundImage = `url(${item.image})`;
          style.backgroundPosition = 'center';
          style.backgroundRepeat = 'no-repeat';
          style.backgroundSize = 'cover';
        }
      }
      return style;
    },
    showNextArrow() {
      let i = this.currentIndexes.indexOf(this.currentIndex);
      return i > -1 && (!!this.loop || this.currentIndexes[i + 1] !== undefined);
    },
    showPrevArrow() {
      let i = this.currentIndexes.indexOf(this.currentIndex);
      return i > -1 && (!!this.loop || this.currentIndexes[i - 1] !== undefined);
    }
  },
  methods: {
    prev() {
      if (this.currentIndexes.length) {
        let i = this.currentIndexes.indexOf(this.currentIndex);
        if (i > -1) {
          if (this.currentIndexes[i - 1] !== undefined) {
            this.currentIndex = this.currentIndexes[i - 1];
          } else if (this.loop) {
            this.currentIndex = this.currentIndexes[this.currentIndexes.length - 1];
          }
        }
      }
    },
    next() {
      if (this.currentIndexes.length) {
        let i = this.currentIndexes.indexOf(this.currentIndex);
        if (i > -1) {
          if (this.currentIndexes[i + 1] !== undefined) {
            this.currentIndex = this.currentIndexes[i + 1];
          } else if (this.loop) {
            this.currentIndex = this.currentIndexes[0];
          }
        }
      }
    },
    _map(data) {
      if (bbn.fn.isArray(data)) {
        data = data.map(a => {
          let o = bbn.fn.extend(true, {}, a);
          if (!o.headerComponent && (!bbn.fn.isString(o.header) || bbn.fn.substr(o.header, 0, 1) !== '<')) {
            o.headerComponent = o.header;
            delete o.header;
          }
          if (!o.headerComponent && (!bbn.fn.isString(o.body) || bbn.fn.substr(o.body, 0, 1) !== '<')) {
            o.bodyComponent = o.body;
            delete o.body;
          }
          if (!o.footerComponent && (!bbn.fn.isString(o.footer) || bbn.fn.substr(o.footer, 0, 1) !== '<')) {
            o.footerComponent = o.footer;
            delete o.footer;
          }
          return o;
        });
        return (this.map ? data.map(this.map) : data).slice();
      }
      return [];
    },
    _getStyle(item) {
      let style = {};
      if (item.background) {
        style.backgroundColor = item.background;
      }
      if (item.image) {
        style.backgroundImage = `url(${item.image})`;
        style.backgroundPosition = 'center';
        style.backgroundRepeat = 'no-repeat';
        style.backgroundSize = 'cover';
      }
      return style;
    },
    _swipeLeft() {
      this.currentSwipeClass = 'bbn-splashscreen-swipe-left';
      this.next();
    },
    _swipeRight() {
      this.currentSwipeClass = 'bbn-splashscreen-swipe-right';
      this.prev();
    }
  },
  created() {
    this.$on('swipeleft', this._swipeLeft);
    this.$on('swiperight', this._swipeRight);
  },
  mounted() {
    this.ready = true;
  },
  beforeDestroy() {
    this.$off('swipeleft', this._swipeLeft);
    this.$off('swiperight', this._swipeRight);
  },
  watch: {
    source: {
      deep: true,
      handler() {
        this.updateData();
      }
    },
    currentIndex(idx) {
      this.$emit('change', idx, this.source[idx]);
    }
  },
  components: {
    dots: {
      template: `
          <div class="bbn-splashscreen-dots bbn-c">
            <i v-for="idx in indexes"
               @click="select(idx)"
               :class="['bbn-padded', 'bbn-p', 'nf nf-fa-circle', {
                 ' bbn-primary-text': value !== idx,
                 'bbn-primary-text-alt': value === idx
               }]"
               style="width: 02rem; height: 0.2rem"/>
          </div>
        `,
      props: {
        value: {
          type: Number
        },
        indexes: {
          type: Array
        }
      },
      methods: {
        select(idx) {
          this.$emit('input', idx);
        }
      }
    }
  }
};
import cpHtml from './splashscreen.html';
import cpStyle from './splashscreen.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./splashscreen.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-splashscreen',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-split-tabs component
 *
 * @description Allows and manages the navigation (url) different routers in a splitter
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
"use strict";

/**
 * @component
 * @param {string} url - The URL on which the tabNav will be initialized.
 * @param {boolean} autoload - Defines if the tab will be automatically loaded based on URLs. False by default
 * except if it is true for the parent.
 * @param {string} orientation - The position of the views' titles: top (default) or bottom.
 * @param {string} root - The root URL of the tabNav, will be only taken into account for the top parents'
 * tabNav, will be automatically calculated for the children.
 * @param {boolean} scrollable - Sets if the views' titles will be scrollable in case they have a greater width
 * than the page (true), or if they will be shown multilines (false, default).
 * @param {array} source - The views shown at init.
 * @param {string} currentURL - The URL to which the tabnav currently corresponds (its selected tab).
 * @param {string} baseURL - The parent TabNav's URL (if any) on top of which the tabNav has been built.
 * @param {array} parents - The views shown at init.
 * @param {array} views - The views configuration and state.
 * @param {boolean} parentTab - If the tabNav has a tabNav parent, the tab Vue object in which it stands, false
 * otherwise.
 * @param {boolean|number} selected - The index of the currently selected tab, and false otherwise.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage],
  props: {
    // Routes automatically after mount
    /**
     * @prop {Boolean} [true] auto
     */
    auto: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} [''] url
     */
    url: {
      type: String,
      default: ''
    },
    /**
     * @prop {Boolean} [true] autoload
     */
    autoload: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] observer
     */
    observer: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} [''] root
     */
    root: {
      type: String,
      default: ''
    },
    /**
     * @prop {String} def
     */
    def: {
      type: String
    },
    /**
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {String} ['horizontal'] orientation
     */
    orientation: {
      type: String,
      default: 'horizontal'
    },
    /**
     * @prop {Boolean} [true] resizable
     */
    resizable: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      registeredChildren: []
    };
  },
  computed: {
    // Not only the baseURL but a combination of all the parent's baseURLs
    fullBaseURL() {
      let vm = this,
        base = '',
        tmp;
      while (tmp = vm.baseURL) {
        base = tmp + base;
        if (!vm.parents.length) {
          break;
        }
        vm = vm.parents[0];
      }
      return base;
    },
    // Returns true if there are any unsaved views
    isDirty() {
      return !!this.dirtyContainers.length;
    }
  },
  methods: {
    /**
     * Function used by container to make themselves known when they are mounted
     *
     * @param {bbnCp} cp
     */
    register(cp, fake) {
      if (fake) {
        this.add(cp);
        return;
      }
      this.numRegistered++;
      if (cp.url && !this.urls[cp.url]) {
        this.urls[cp.url] = cp;
      }
      if (!this.isInit && this.numRegistered === this.views.length) {
        this.isInit = true;
        if (this.auto) {
          this.route(this.getDefaultURL(), true);
        }
      }
    },
    /**
     * Function used by container to make themselves known when they are destroyed
     *
     * @param {bbnCp} cp
     */
    unregister(cp) {
      this.numRegistered--;
      if (cp.url && this.urls[cp.url]) {
        delete this.urls[cp.url];
      }
    },
    registerSubrouter(cp) {
      this.registeredChildren.push({
        idx: this.registeredChildren.length,
        cp: cp
      });
    },
    unregisterSubrouter(cp) {
      let deleted = false;
      bbn.fn.each(this.registeredChildren, (c, i) => {
        if (c.cp === cp) {
          this.registeredChildren.splice(c.idx, 1);
          deleted = true;
        } else if (deleted) {
          c.idx--;
        }
      });
    },
    retrieveDirtyContainers() {
      // Array of unsaved views
      let r = [];
      bbn.fn.iterate(this.urls, v => {
        if (v.dirty) {
          r.push({
            idx: v.idx,
            url: v.url
          });
        }
      });
      this.dirtyContainers = r;
      this.dirty = this.dirtyContainers.length > 0;
    },
    /**
     * Given a URL returns the existing path of a corresponding view or false, or the default view if forced
     *
     * @param {String} url
     * @param {Boolean} force
     * @returns {String|false}
     */
    getRoute(url, force) {
      if (!url && !this.parent) {
        url = this.parseURL(bbn.env.path);
      }
      if (!url && force && this.parent) {
        url = this.parseURL(this.router.getFullCurrentURL());
      }
      if (url) {
        let bits = url.split('/');
        while (bits.length) {
          let st = bits.join('/');
          if (this.urls[st]) {
            return st;
          }
          bits.pop();
        }
      }
      if (this.def && force) {
        return this.def;
      }
      if (this.views.length && force) {
        return this.views[0].current;
      }
      return false;
    },
    /**
     * Formats a baseURL correctly (without 1st slash and with end slash
     *
     * @param {String} baseURL
     * @returns {String}
     */
    setBaseURL(baseURL) {
      while (bbn.fn.substr(baseURL, -1) === '/') {
        baseURL = bbn.fn.substr(baseURL, 0, baseURL.length - 1);
      }
      while (bbn.fn.substr(baseURL, 0, 1) === '/') {
        baseURL = bbn.fn.substr(baseURL, 1);
      }
      return baseURL ? baseURL + '/' : '';
    },
    getDefaultView() {
      return {
        source: null,
        title: bbn._("Untitled"),
        options: null,
        cached: false,
        scrollable: true,
        component: null,
        icon: '',
        notext: false,
        content: null,
        menu: [],
        loaded: null,
        fcolor: null,
        bcolor: null,
        load: false,
        selected: null,
        css: '',
        advert: null,
        dirty: false,
        help: null,
        imessages: [],
        script: null,
        fixed: false,
        pinned: false,
        url: null,
        current: null,
        real: false,
        cfg: {},
        events: {}
      };
    },
    /*
    observerEmit(newVal, obs){
      bbn.fn.log("OBS EMIT", newVal, obs);
      let ele = $(".bbn-observer-" + obs.element, this.$el);
      if ( ele.length ){
        let idx = this.getIndex(ele);
        if ( idx !== false ){
          let i = bbn.fn.search(this.observers, {id: obs.id, element: obs.element});
          if ( (i > -1) && (this.observers[i].value !== newVal) ){
            if ( idx === this.selected ){
              this.$emit('bbnObs' + obs.element + obs.id, newVal);
              this.observers[i].value = newVal;
            }
            else{
              this.observers[i].value = newVal;
              this.$set(this.views[idx].events, 'bbnObs' + obs.element + obs.id, newVal);
            }
          }
        }
      }
    },
    */

    /**
     * Sends event beforeRoute (cancellable) and launch real routing
     *
     * @param {String} url
     * @param {Boolean} force
     * @returns {void}
     */
    route(url, force) {
      if (this.ready && (force || !this.activeContainer || url !== this.currentURL)) {
        let event = new CustomEvent("beforeRoute", {
          bubbles: false,
          cancelable: true
        });
        this.$emit("beforeRoute", event, url);
        if (!event.defaultPrevented) {
          // Checks weather the container is already there
          if (!url) {
            let idx = this.getRoute('', true);
            if (idx) {
              url = this.urls[idx].currentURL;
            }
          }
          let st = url ? this.getRoute(url) : '';
          //bbn.fn.log("ROUTING FUNCTION EXECUTING FOR " + url + " (CORRESPONDING TO " + st + ")");
          if (!url) {
            return;
          }
          if (!force && this.currentURL === url) {
            //bbn.fn.log("SAME URL END ROUTING");
            return;
          }
          if (url && (!st && this.autoload || this.urls[st] && this.urls[st].load && !this.urls[st].isLoaded)) {
            this.load(url);
          }
          // Otherwise the container is activated ie made visible
          else {
            //bbn.fn.log("LOADED " + url);
            if (!st && this.def && (!url || force)) {
              st = this.getRoute(this.def);
              if (st) {
                url = this.def;
              }
            }
            if (!st && force && this.views.length) {
              st = this.views[0].url;
              if (st) {
                url = this.urls[st].currentURL || st;
              }
            }
            if (st) {
              this.urls[st].setCurrent(url);
              this.realRoute(url, st, force);
            }
          }
        }
      }
    },
    /**
     * Route the router!
     *
     * @param {String} url The URL to route to
     * @param {String} st The URL/key of the container on which we will route
     * @param {Boolean} force
     */
    realRoute(url, st, force) {
      if (st && this.urls[st]) {
        //bbn.fn.log("REAL ROUTING GOING ON FOR " + url);
        if (url !== this.currentURL) {
          //bbn.fn.log("THE URL IS DIFFERENT FROM THE ORIGINAL " + this.currentURL);
          this.currentURL = url;
        }
        // First routing, triggered only once
        if (!this.routed) {
          this.routed = true;
          this.$emit("route1", this);
        }
        this.activate(url, this.urls[st]);
        if (this.urls[st]) {
          this.urls[st].currentURL = url;
          this.urls[st].init();
          this.$nextTick(() => {
            let child = this.urls[st].find('bbn-router');
            if (child) {
              //bbn.fn.log("CHILD ROUTER ROUTING: " + bbn.fn.substr(url, st.length + 1));
              child.route(bbn.fn.substr(url, st.length + 1), force);
            }
          });
        }
      }
    },
    /**
     * Looks for a subrouter and route through it if found.
     *
     * @param container
     */
    updateView(container) {
      return;
      // Looking for a subrouter in the activated container
      let subRouter = this.getSubRouter();
      if (subRouter) {
        // If so routing also this container
        //bbn.fn.log("FROM UPDATEVIEW");
        subRouter.route(container.currentURL);
      } else {
        //bbn.fn.log(container);
        if (this.$children.length && !this.currentURL && this.auto) {
          //bbn.fn.log("ROUTING " + this.url + " FROM METHOD UPDATEVIEW");
          this.route(this.url, true);
        } else {
          //bbn.fn.log("NOT ROUTING " + this.currentURL + " NOR " + this.url + "FROM METHOD UPDATEVIEW");
        }
      }
    },
    /**
     * Shows the container with the corresponding URL and hide all others.
     *
     * @param url
     * @param container
     */
    activate(url, container) {
      let todo = false;
      //bbn.fn.log("ACTIVATING " + url + " AND SENDING FOLLOWING CONTAINER:", container);
      if (!this.activeContainer || container && this.activeContainer !== container) {
        this.activeContainer = null;
        bbn.fn.each(this.$children, cp => {
          if (bbn.fn.isFunction(cp.hide)) {
            if (cp !== container) {
              cp.hide();
            } else {
              cp.setCurrent(url);
              this.activeContainer = cp;
            }
          }
        });
        if (this.activeContainer) {
          this.activeContainer.show();
        }
      } else if (url !== this.activeContainer.currentURL) {
        this.activeContainer.setCurrent(url);
      }
      //bbn.fn.log("ACTIVATED " + url + " AND ACTIVATED CONTAINER BELOW:", this.activeContainer);
    },

    /**
     * Function triggered every time a container is shown (at the start of the animation) to change the URL if needed.
     */
    enter(container) {
      //bbn.fn.log("THE CONTAINER WILL BE SHOWN: ", container);
    },
    changeURL(url, title, replace) {
      //bbn.fn.log("CHANGE URL TO " + url);
      if (!bbn.env.isInit) {
        return;
      }
      if (url !== this.currentURL) {
        this.currentURL = url;
      }
      // Changing the current property of the view cascades on the container's currentURL
      if (this.views[this.selected] && url.indexOf(this.views[this.selected].url) === 0) {
        this.$set(this.views[this.selected], 'current', url);
      }
      if (this.parent) {
        this.parent.changeURL(this.baseURL + url, title, replace);
      } else if (replace || url !== bbn.env.path) {
        if (!replace) {
          //bbn.fn.log("NO REPLAACE", this.getFullBaseURL() + url, bbn.env.path);
        }
        if (!replace && (this.getFullBaseURL() + url).indexOf(bbn.env.path) === 0) {
          //bbn.fn.log("REPLACING");
          replace = true;
        }
        bbn.fn.setNavigationVars(this.getFullBaseURL() + url, title, {}, replace);
      }
    },
    /**
     * Returns the baseURL property.
     *
     * @returns {string}
     */
    getBaseURL() {
      return this.baseURL;
    },
    /**
     * Returns a string of all the baseURL properties till root.
     *
     * @returns {string}
     */
    getFullBaseURL() {
      return this.fullBaseURL;
    },
    /**
     * Returns the full URL from the root router (without the hostname)
     *
     * @returns {string}
     */
    getFullURL() {
      let url = this.getURL();
      if (url !== false) {
        return this.getFullBaseURL() + url;
      }
      return '';
    },
    /**
     * Returns the current URL of the current router
     *
     * @returns {string}
     */
    getCurrentURL() {
      return this.currentURL;
    },
    /**
     * Returns the full current URL from the root router (without the hostname)
     *
     * @returns {string}
     */
    getFullCurrentURL() {
      let url = this.getCurrentURL();
      if (url !== false) {
        return this.getFullBaseURL() + url;
      }
      return false;
    },
    /**
     * Returns the url relative to the current tabNav from the given url.
     *
     * @param fullURL
     * @returns {string}
     */
    parseURL(fullURL) {
      let url = fullURL;
      if (fullURL === undefined) {
        return '';
      }
      if (typeof fullURL !== 'string') {
        fullURL = fullURL.toString();
      }
      if (fullURL.indexOf(bbn.env.root) === 0) {
        fullURL = bbn.fn.substr(fullURL, bbn.env.root.length);
      }
      fullURL = bbn.fn.removeTrailingChars(fullURL, '/');
      if (this.fullBaseURL === fullURL + '/' || fullURL === '') {
        return '';
      }
      if (this.fullBaseURL) {
        if (fullURL.indexOf(this.fullBaseURL) === 0) {
          fullURL = bbn.fn.substr(fullURL, this.fullBaseURL.length);
        } else {
          fullURL = '';
        }
      }
      //bbn.fn.log("PARSING " + url + ' INTO ' + fullURL + ' with a baseURL like this: ' + this.fullBaseURL);
      return fullURL;
    },
    isValidIndex(idx) {
      return this.views[idx] !== undefined;
    },
    /**
     * Activates the default view, or the first one if no default
     */
    activateDefault() {
      let idx = vm.getIndex('', true);
      if (this.isValidIndex(idx)) {
        //bbn.fn.log("ACTIVATE6", this.views[idx].current ? this.views[idx].current : this.views[idx].url);
        this.activate(this.views[idx].current ? this.views[idx].current : this.views[idx].url);
      }
    },
    activateIndex(idx) {
      if (this.isValidIndex(idx)) {
        if (this.urls[this.views[idx].url]) {
          this.route(this.urls[this.views[idx].url].currentURL);
        } else {
          this.route(this.views[idx].current);
        }
      }
    },
    getVue(idx) {
      if (idx === undefined) {
        idx = this.selected;
      }
      if (this.isValidIndex(idx)) {
        return this.urls[this.views[idx].url];
      }
      return false;
    },
    // Returns the corresponding container's component's DOM element
    getContainer(idx) {
      if (idx === undefined) {
        idx = this.selected;
      }
      let c = this.getVue(idx);
      return c ? c.$el : false;
    },
    // Returns the next router in the corresponding container if there's any
    getSubRouter(misc) {
      let idx = this.getIndex(misc);
      if (idx === undefined) {
        idx = this.selected;
      }
      let container = this.getVue(idx);
      if (container) {
        return container.find('bbn-router') || null;
      }
      return null;
    },
    getRealVue(misc) {
      let idx = this.getIndex(misc);
      let tabnav = this,
        sub = tabnav;
      if (idx === undefined) {
        idx = this.selected;
      }
      while (tabnav) {
        tabnav = sub.getSubRouter(idx);
        if (tabnav) {
          sub = tabnav;
          idx = sub.selected;
        }
      }
      return sub.getVue(idx);
    },
    getIndex(misc) {
      if (!this.views.length) {
        return false;
      }
      if (misc === undefined) {
        return this.selected;
      }
      if (!this.isValidIndex(misc)) {
        if (typeof misc === 'string') {
          misc = this.search(misc);
        } else if (typeof misc === 'object') {
          // Vue
          if (misc.$el) {
            misc = misc.$el;
          }
          if (misc.tagName) {
            bbn.fn.each(this.$children, ct => {
              if (ct.$vnode && ct.$vnode.componentOptions && ct.$vnode.componentOptions.tag === 'bbn-container' && (ct.$el === misc || ct.$el.contains(misc))) {
                misc = ct.currentIndex;
                return false;
              }
            });
          }
        }
      }
      return this.isValidIndex(misc) ? misc : false;
    },
    remove(misc, force) {
      let idx = this.getIndex(misc);
      if (idx > -1 && !this.views[idx].slot) {
        let ev = new Event('close', {
          cancelable: true
        });
        if (this.isDirty && this.views[idx].dirty && !ev.defaultPrevented && !force) {
          ev.preventDefault();
          this.confirm(this.confirmLeave, () => {
            let forms = this.views[idx].findAll('bbn-form');
            if (Array.isArray(forms) && forms.length) {
              bbn.fn.each(forms, (f, k) => {
                f.reset();
              });
            }
            this.$nextTick(() => {
              this.$emit('close', idx, ev);
              this.remove(idx, true);
            });
          });
        }
        this.$emit('close', idx, ev);
        if (force || !ev.defaultPrevented) {
          let t = this.views.splice(idx, 1);
          delete this.urls[t.url];
          bbn.fn.each(this.views, (v, i) => {
            if (v.idx !== i) {
              v.idx = i;
            }
          });
        }
        return true;
      }
      return false;
    },
    add(obj, idx) {
      let index;
      //obj must be an object with property url
      //bbn.fn.log("ADDING", obj);
      if (typeof obj === 'object' && obj.url && (idx === undefined || this.isValidIndex(idx) || idx === this.views.length)) {
        if (!obj.current) {
          if (bbn.env.path.indexOf(this.getFullBaseURL() + obj.url + '/') === 0) {
            obj.current = bbn.fn.substr(bbn.env.path, this.getFullBaseURL().length);
          } else {
            obj.current = obj.url;
          }
        } else if (obj.current !== obj.url && obj.current.indexOf(obj.url + '/') !== 0) {
          obj.current = obj.url;
        }
        if (!obj.current) {
          obj.current = obj.url;
        }
        if (obj.content) {
          obj.loaded = true;
        }
        obj.events = {};
        if (obj.menu === undefined) {
          obj.menu = [];
        }
        index = this.search(obj.url);
        //bbn.fn.log("ADDING CONTAINER " + obj.current + " (" + index + ")");
        if (index !== false) {
          let o = this.views[index],
            cn = this.urls[this.views[index].url];
          if (idx === undefined) {
            idx = index;
          }
          if (cn) {
            cn.currentIndex = idx;
          }
          if (obj.real) {
            return;
          }
          bbn.fn.iterate(obj, (a, n) => {
            if (o[n] !== a) {
              // Each new property must be set with $set
              this.$set(o, n, a);
            }
          });
        } else {
          if (this.single) {
            if (this.views.length) {
              this.views.splice(0, this.views.length);
            }
            obj.selected = true;
            obj.idx = this.views.length;
          } else {
            obj.selected = false;
            obj.idx = idx === undefined ? this.views.length : idx;
          }
          bbn.fn.iterate(this.getDefaultView(), (a, n) => {
            if (obj[n] === undefined) {
              // Each new property must be set with $set
              this.$set(obj, n, a);
            }
          });
          this.views.push(obj);
        }
      }
    },
    search(url) {
      let r = bbn.fn.search(this.views, "url", url);
      if (r === -1) {
        bbn.fn.each(this.views, (tab, index) => {
          if (url.indexOf(tab.url + '/') === 0) {
            r = index;
            return false;
          }
        });
      }
      return r > -1 ? r : false;
    },
    callRouter(url, st) {
      if (this.parent) {
        let containers = this.ancestors('bbn-container');
        url = this.getFullBaseURL().substr(this.router.baseURL.length) + url;
        //bbn.fn.log("CALL ROOT ROUTER WITH URL " + url);
        // The URL of the last bbn-container as index of the root router
        this.router.realRoute(url, containers[containers.length - 1].url, true);
      } else {
        this.realRoute(url, st, true);
      }
    },
    load(url, force) {
      if (url) {
        this.isLoading = true;
        let finalURL = this.fullBaseURL + url;
        let idx = this.search(url);
        let toAdd = false;
        //bbn.fn.log("START LOADING FN FOR IDX " + idx + " ON URL " + finalURL);
        if (idx !== false) {
          //bbn.fn.log("INDEX RETRIEVED BEFORE LOAD: " + idx.toString(), this.views[idx].slot, this.views[idx].loading);
          if (this.views[idx].loading || !force && !this.views[idx].load) {
            return;
          }
          if (force) {
            toAdd = true;
            this.views.splice(idx, 1);
          }
        } else {
          toAdd = true;
          idx = this.views.length;
        }
        if (toAdd) {
          this.$nextTick(() => {
            this.add({
              url: url,
              title: bbn._('Loading'),
              load: true,
              loading: true,
              visible: true,
              real: false,
              current: url,
              error: false,
              loaded: false
            }, idx);
          });
        }
        this.$emit('update', this.views);
        return this.post(finalURL, {
          _bbn_baseURL: this.fullBaseURL
        }, d => {
          this.isLoading = false;
          //this.remove(url);
          if (d.url) {
            d.url = this.parseURL(d.url);
          }
          if (!d.url) {
            d.url = url;
          }
          //bbn.fn.log("URLS", url, d.url);
          if (url.indexOf(d.url) === 0) {
            d.current = url;
            //bbn.fn.log("CURRENT DEFINED AS " + d.current);
          }

          if (d.data) {
            d.source = d.data;
            delete d.data;
          }
          if (d.url !== d.current && this.urls[d.current]) {
            //bbn.fn.log("DELETING VIEW CASE");
            this.views.splice(this.urls[d.current].idx, 1);
            delete this.urls[d.current];
          }
          if (!d.title || d.title === bbn._('Loading')) {
            let title = bbn._('Untitled');
            let num = 1;
            while (bbn.fn.search(this.views, {
              title: title
            }) > -1) {
              num++;
              title = bbn._('Untitled') + ' ' + num;
            }
            d.title = title;
          }
          this.$nextTick(() => {
            this.add(bbn.fn.extend(d, {
              slot: false,
              loading: false,
              load: true,
              real: false,
              loaded: true
            }));
            setTimeout(() => {
              if (!this.urls[d.url]) {
                throw new Error(bbn._("Impossible to find the container for URL") + ' ' + d.url);
              }
              //bbn.fn.log("LOADED " + d.url, url);
              this.urls[d.url].setLoaded(true);
              // Otherwise the changes we just did on the props wont be taken into account at container level
              this.urls[d.url].init();
              this.callRouter(d.current, d.url);
              this.$emit('update', this.views);
            });
          });
          /*
          setTimeout(() => {
            bbn.fn.log(d.url, d, ';;;;;');
            if ( !this.urls[d.url] ){
              throw new Error(bbn._("Impossible to find the container for URL") + ' ' + d.url);
            }
            this.urls[d.url].setLoaded(true);
            this.urls[d.url].init();
            setTimeout(() => {
              bbn.fn.log("ROUTER LOADED:" + d.current);
              //this.callRouter(d.current, d.url);
            }, 200)
          }, 200)
          */
        }, (xhr, textStatus, errorThrown) => {
          this.isLoading = false;
          this.alert(textStatus);
          let idx = this.search(this.parseURL(finalURL));
          if (idx > -1) {
            let url = this.views[idx].url;
            this.views.splice(this.urls[url].idx, 1);
            delete this.urls[url];
          }
          /*
          if ( this.isValidIndex(idx) ){
            this.views[idx].state = xhr.status;
            this.views[idx].error = errorThrown;
            this.views[idx].loading = false;
            this.views[idx].loaded = true;
            this.views[idx].menu = false;
            this.views[idx].title = bbn._('Error') + ' ' + xhr.status;
            if ( this.views[idx].load !== false ){
              this.views[idx].load = null;
            }
            this.navigate(url);
            this.activate(url);
          }
          */
          //bbn.fn.log(arguments)
        }, () => {
          this.isLoading = false;
        });
      }
    },
    reload(idx) {
      if (this.views[idx] && !this.views[idx].slot && this.views[idx].load && this.urls[this.views[idx].url] && this.urls[this.views[idx].url].isLoaded) {
        this.views[idx].loaded = false;
        this.urls[this.views[idx].url].isLoaded = false;
        this.$nextTick(() => {
          this.route(this.urls[this.views[idx].url].currentURL, true);
        });
      }
    },
    getDefaultURL() {
      // If there is a parent router we automatically give the proper baseURL
      if (this.url) {
        return this.url;
      } else if (this.parentContainer && this.parentContainer.currentURL !== this.parentContainer.url) {
        return bbn.fn.substr(this.parentContainer.currentURL, this.parentContainer.url.length + 1);
      }
      if (this.def) {
        return this.def;
      } else {
        return this.parseURL(bbn.env.path);
      }
    },
    getTitle(idx) {
      let cp = this,
        res = '';
      if (idx === undefined) {
        idx = this.selected;
      }
      if (cp.views[idx]) {
        res += cp.views[idx].title || bbn._('Untitled');
        if (cp.parentTab) {
          idx = cp.parentTab.idx;
          cp = cp.parentTab.tabNav;
          while (cp) {
            res += ' < ' + (cp.views[idx].title || bbn._('Untitled'));
            if (cp.parentTab) {
              idx = cp.parentTab.idx;
              cp = cp.parentTab.tabNav;
            } else {
              cp = false;
            }
          }
        }
        res += ' - ';
      }
      res += bbn.env.siteTitle || bbn._("Untitled site");
      return res;
    }
  },
  mounted() {
    // All routers above (which constitute the fullBaseURL)
    this.parents = this.ancestors('bbn-router');
    // The closest
    this.parent = this.parents.length ? this.parents[0] : false;
    // The root
    this.router = this.parents.length ? this.parents[this.parents.length - 1] : this;
    if (this.parent) {
      this.parentContainer = this.closest('bbn-container');
      if (this.parentContainer && this.parentContainer.url) {
        let uri = this.parentContainer.url;
        if (this.root && uri !== this.root && uri.indexOf(this.root) === 0) {
          uri = this.root;
        }
        bbn.fn.log("URI", uri);
        this.baseURL = this.setBaseURL(uri);
      } else {
        bbn.fn.log("NO URI", this.root);
        this.baseURL = this.setBaseURL(this.root);
      }
      this.parent.registerSubrouter(this);
    }
    this.ready = true;
  },
  beforeDestroy() {
    if (this.parent) {
      this.parent.unregisterRouter(this);
    }
  },
  watch: {
    currentURL(newVal, oldVal) {
      if (this.ready) {
        this.$nextTick(() => {
          if (this.activeContainer) {
            this.changeURL(newVal, this.activeContainer.title);
          } else if (this.isLoading) {
            this.changeURL(newVal, bbn._("Loading"));
          }
          let idx = this.search(newVal);
          if (idx !== false && this.selected !== idx) {
            this.selected = idx;
          }
          this.$emit('change', newVal);
        });
        this.$emit('route', newVal);
      }
    },
    url(newVal) {
      if (this.ready) {
        //bbn.fn.log("ROUTER change URL", newVal);
        this.route(newVal);
      }
    }
  }
};
import cpHtml from './split-tabs.html';
import cpStyle from './split-tabs.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./split-tabs.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-split-tabs',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-splitter component
 *
 * @description bbn-splitter is a component that can interact dynamically, allowing the division of a layout into resizable areas.
 * To do so it needs another component, the "bbn-pane" that represents the portion of the single area that the splitter contains.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 * 
 * @created 15/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic 
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer],
  props: {
    /**
     * The orientation of the splitter ('horizontal', 'vertical', 'auto').
     * @prop {String} ['auto'] orientation
     */
    orientation: {
      type: String,
      default: 'auto'
    },
    /**
     * Set to true allows the splitter to be resizable. 
     * @prop {boolean} [false] resizable
     */
    resizable: {
      type: Boolean,
      default: false
    },
    /**
    * Set to true allows the panes inside the splitter to be collapsible. 
    * @prop {boolean} [false] collapsible
    */
    collapsible: {
      type: Boolean,
      default: false
    },
    // @todo not used
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the size of the resizer element, width if vertical, height if horizontal.
     * @prop {number} [15] resizerSize
     */
    resizerSize: {
      type: Number,
      default: 15
    },
    /**
     * A class name to add on the resizer element.
     * @prop {String|Function} resizerClass
     */
    resizerClass: {
      type: [String, Function]
    },
    /**
     * The minimum size that can have a pane (non collapsed).
     * @prop {Number} [40] minPaneSize
     */
    minPaneSize: {
      type: Number,
      default: 40
    },
    fullSize: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * The timeout used to launch the initial process (reset each time a new pane is added).
       * @data {Number} [0] initTimeout
       */
      initTimeout: 0,
      /**
       * Will be set to true once the splitter has been resized.
       * @data {Boolean} [false] isResized
       */
      isResized: false,
      /**
       * Will be set to true when the splitter is being resized by the user.
       * @data {Boolean} [false] isResizing
       */
      isResizing: false,
      /**
       * An object containing info about current user resizing when it occurs.
       * @data {Boolean} [null] resizeCfg
       */
      resizeCfg: null,
      /**
       * An array consisting of each resizer objects (the bars separating resizable panes).
       * @data {Array} [[]] resizers
       */
      resizers: [],
      /**
       * The content of the prop orientation.
       * @data {String} currentOrientation
       */
      currentOrientation: this.orientation,
      /**
       * The configuration of the panes.
       * @data {Array} [[]] panes
       */
      panes: []
    };
  },
  computed: {
    splitterStyle() {
      return {
        gridTemplateColumns: this.columnsCfg,
        gridTemplateRows: this.rowsCfg
      };
    },
    isHorizontal() {
      return this.currentOrientation === 'horizontal';
    },
    /**
     * Return true if at least 2 panes are resizable - and so is the splitter.
     * @computed isResizable
     * @return {Boolean}
     */
    isResizable() {
      return (this.resizable || this.collapsible) && bbn.fn.count(this.panes, {
        resizable: true
      }) >= 2;
    },
    /**
     * What will be actually in the CSS for grid-template-columns.
     * @computed columnsCfg
     * @return {String}
     */
    columnsCfg() {
      return this.panes.length && this.isHorizontal ? this.getFormatted() : 'auto';
    },
    /**
     * What will be actually in the CSS for grid-template-rows.
     * @computed rowsCfg
     * @return {String}
     */
    rowsCfg() {
      return this.panes.length && !this.isHorizontal ? this.getFormatted() : 'auto';
    },
    /**
     * X or y depending on the current orientation.
     * @computed currentAxis
     * @return {String}
     */
    currentAxis() {
      return this.isHorizontal ? 'x' : 'y';
    },
    /**
     * Width or height depending on the current orientation.
     * @computed currentSizeType
     * @return {String}
     */
    currentSizeType() {
      return this.isHorizontal ? 'Width' : 'Height';
    },
    /**
     * Width or height depending on the current orientation.
     * @computed currentOffsetType
     * @return {String}
     */
    currentOffsetType() {
      return this.isHorizontal ? 'left' : 'top';
    },
    /**
     * Size of the container as given by bbn.
     * @computed currentSize
     * @return {String}
     */
    currentSize() {
      return this['lastKnown' + this.currentSizeType];
    },
    /**
     * Available for the panes: difference between currentSize (container's size) and the total of resizers' sizes.
     * @computed availableSize
     * @return {bbn-splitter.computed.currentSize}
     */
    availableSize() {
      let availableSize = this.currentSize;
      bbn.fn.each(this.resizers, () => {
        availableSize -= this.resizerSize;
      });
      return availableSize;
    }
  },
  methods: {
    /**
     * Returns the calculated grid-template-rows or grid-template-columns as CSS string.
     * @method getFormatted
     * @return {String}
     */
    getFormatted() {
      /**
       * The position of the panes, starting at 1; gapos will be created for resizers.
       * 
       * @type {Number}
       */
      let pos = 1,
        lastVisibleResizer = false,
        tmp = this.panes.map(a => {
          /**
           * The additions of the 3 differences:
           * - currentDiff is the current difference while resizing
           * - savedDiff is the original difference resulting from other resizings
           * - tmpDiff is the temporary difference applied from other(s) collapsed pane(s)
           * @type {number}
           */
          let diff = a.currentDiff + a.savedDiff + a.tmpDiff,
            /**
             * The resulting string for the CSS property.
             * @type {string}
             */
            sz = '';
          // If position is not the one expected it means a resizer is before so it's added as a column
          while (a.position > pos) {
            sz += lastVisibleResizer && !a.title ? '0 ' : 'max-content ';
            lastVisibleResizer = true;
            pos++;
          }
          // If the pane is collapsed we just mark its size at 0
          if (a.collapsed) {
            sz += a.title ? 'max-content ' : '0 ';
          }
          // If it's a number it will be a sum with the existing diff
          else {
            lastVisibleResizer = false;
            if (a.addedSize && a.addedSize === 'auto') {
              sz += 'auto';
            } else if (a.value) {
              if (a.addedSize || diff) {
                sz += 'calc( ';
                sz += a.value + (a.isNumber ? 'px' : '');
                if (diff) {
                  sz += ' + ' + diff + 'px';
                }
                if (a.addedSize) {
                  sz += ' + ' + (typeof a.addedSize === 'number' ? a.addedSize + 'px' : a.addedSize);
                }
                sz += ')';
              } else if (a.value) {
                sz += a.value + (a.isNumber ? 'px' : '');
              }
            } else {
              sz += 'auto';
            }
          }
          pos++;
          return sz;
        });
      return tmp.join(' ');
    },
    /**
     * Returns the resizer's class according to its resizerClass prop.
     * @method realResizerClass
     * @param resizer
     * @return {String}
     */
    realResizerClass(resizer) {
      if (bbn.fn.isFunction(this.resizerClass)) {
        return this.resizerClass(resizer);
      }
      return this.resizerClass || '';
    },
    /**
     * Returns orientation based on the largest side.
     * @method getOrientation
     * @return {String}
     */
    getOrientation() {
      return this.lastKnownWidth > this.lastKnownHeight ? 'horizontal' : 'vertical';
    },
    /**
     * Handles the resize of the splitter
     * @method onResize
     * @fires getOrientation
     */
    onResize() {
      if (!this.isResizing) {
        this.isResizing = true;
        this.setContainerMeasures();
        this.setResizeMeasures();
        if (this.orientation === 'auto') {
          let o = this.getOrientation();
          if (o !== this.currentOrientation) {
            this.currentOrientation = o;
          }
        }
        /** @todo so far only fuckin way to make it re-render the right dimensions */
        let w = this.$el.style.width;
        let h = this.$el.style.height;
        this.$el.style.width = '100%';
        this.$el.style.height = '100%';
        setTimeout(() => {
          this.$el.style.width = w;
          this.$el.style.height = h;
          this.isResizing = false;
          this.$emit('resize');
        }, 100);
      }
    },
    /**
     * Is used when collapsed
     * @todo check it out
     * @ignore
     */
    updatePositions() {
      /*
      bbn.fn.each(this.panes, (pane, i) => {
        this.$children[pane.index].$el.style.gridColumn = this.currentOrientation === 'horizontal' ? pane.position : 1;
        this.$children[pane.index].$el.style.gridRow = this.currentOrientation === 'vertical' ? pane.position : 1;
      })
      */
    },
    /**
     * Gets the next resizable pane.
     * @method getNextResizable
     * @param {Number} idx 
     * @param {Array} arr 
     * @return {Boolean|Number}
     */
    getNextResizable(idx, arr) {
      for (let i = idx + 1; i < arr.length; i++) {
        if (this.resizable && arr[i].resizable !== false) {
          return i;
        }
      }
      return false;
    },
    /**
     * Gets the previous resizable pane.
     * @method getPrevResizable
     * @param {Number} idx 
     * @param {Array} arr 
     * @return {Boolean|Number}
     */
    getPrevResizable(idx, arr) {
      for (let i = idx - 1; i >= 0; i--) {
        if (this.resizable && arr[i].resizable !== false) {
          return i;
        }
      }
      return false;
    },
    /**
     * Gets the next collapsible pane.
     * @method getNextCollapsible
     * @param {Number} idx 
     * @param {Array} arr 
     * @return {Boolean|Number}
     */
    getNextCollapsible(idx, arr) {
      for (let i = idx + 1; i < arr.length; i++) {
        if (this.collapsible && arr[i].collapsible !== false) {
          return i;
        }
      }
      return false;
    },
    /**
     * Gets the previous collassible pane.
     * @method getPrevCollapsible
     * @param {Number} idx 
     * @param {Array} arr 
     * @return {Boolean|Number}
     */
    getPrevCollapsible(idx, arr) {
      for (let i = idx - 1; i >= 0; i--) {
        if (this.collapsible && arr[i].collapsible !== false) {
          return i;
        }
      }
      return false;
    },
    /**
     * Triggered by the panes being mounted, analyzes the splitter's content in order to define its panes.
     * @method init
     * @fires getPrevResizable
     * @fires getNextResizable
     * @fires getPrevCollapsible
     * @fires getNextCollapsible
     */
    init() {
      // As we want to execute it only once and as it is triggered multiple times (by each pane)
      // We add a timeout which cancels the previous one so it should be only triggered once at mount
      clearTimeout(this.initTimeout);
      this.initTimeout = setTimeout(() => {
        // Emptying the panes array if it's filled
        this.panes.splice(0, this.panes.length);
        // position starts at 1
        let currentPosition = 1,
          tmp = [],
          hasAuto = false,
          hasPercent = false,
          hasResizers = false;
        // If 1st pane is collapsible we add a resizer at the start
        this.$children.forEach((pane, i) => {
          // Defining the panes base on the content
          if (pane.$options.name === 'bbn-pane') {
            let isPercent = false,
              isFixed = false,
              isNumber = false,
              props = pane.$props,
              resizable = (this.resizable || props.resizable) && props.resizable !== false,
              collapsible = (this.collapsible || props.collapsible) && props.collapsible !== false,
              value = parseInt(props.size) || 0;
            if (props.size) {
              isFixed = true;
              if (props.size === 'auto') {
                props.size = false;
                hasAuto = true;
              } else if (typeof props.size === 'string' && bbn.fn.substr(props.size, -1) === '%') {
                isPercent = true;
                hasPercent = true;
              } else if (typeof props.size === 'string' && bbn.fn.substr(props.size, -2) === 'px') {
                isNumber = true;
                props.size = parseInt(props.size);
              } else if (typeof props.size === 'number') {
                isNumber = true;
              }
            } else {
              hasAuto = true;
            }
            let obj = bbn.fn.extend({
              index: i,
              value: value,
              currentDiff: 0,
              savedDiff: 0,
              addedSize: '',
              tmpDiff: 0,
              collapsed: false,
              isPercent: isPercent,
              isFixed: isFixed,
              isNumber: isNumber,
              resizable: resizable,
              collapsible: collapsible,
              isResizable: collapsible || resizable,
              pane: pane
            }, props);
            tmp.push(obj);
          }
        });
        /*
        if ( (idx === 0) && pane.collapsible ){
          this.resizers.push({
            position: pos,
            pane1: {
              obj: this.panes[assoc.index],
              cp: this.find('bbn-pane', assoc.index)
            },
            pane2: {
              obj: pane,
              cp: this.find('bbn-pane', i)
            },
          });
          pos++;
        }
        */
        let isResizable = bbn.fn.count(tmp, {
          isResizable: true
        }) >= 2;
        let hasPanes = tmp.length > 1;
        // We will populate resizers
        if (this.resizers.length) {
          this.resizers.splice(0, this.resizers.length);
        }
        tmp.forEach((pane, idx) => {
          let prev, next, prevc, nextc;
          if (hasPanes && isResizable && pane.isResizable) {
            prev = this.getPrevResizable(idx, tmp);
            next = this.getNextResizable(idx, tmp);
            prevc = this.getPrevCollapsible(idx, tmp);
            nextc = this.getNextCollapsible(idx, tmp);
            bbn.fn.log([prev, prevc, next, nextc, '----']);
            // First collapsible
            if (prev !== false || prevc !== false) {
              bbn.fn.log("------ case 2", idx + ' position ' + currentPosition);
              let o = {
                position: currentPosition,
                panec1: false,
                panec2: false,
                pane1: false,
                pane2: false
              };
              if (this.resizable && pane.resizable !== false && prev !== false) {
                o.pane1 = prev;
                o.pane2 = idx;
              }
              if (this.collapsible && pane.collapsible !== false && prevc !== false) {
                o.panec1 = prevc;
                o.panec2 = idx;
              }
              this.resizers.push(o);
              hasResizers = true;
              currentPosition++;
            }
          }
          pane.position = currentPosition;
          /*
          if ( pane.size === undefined ){
            pane.isNumber = true;
            pane.size = Math.floor(this.availableSize / tmp.length) + (idx < tmp.length - 1 ? 0 : this.availableSize % tmp.length)
          }
          */
          this.panes.push(pane);
          currentPosition++;
          if (hasPanes && isResizable && pane.isResizable) {
            // Last collapsible
            let o = {
              position: currentPosition,
              panec1: false,
              panec2: false,
              pane1: false,
              pane2: false
            };
            if (prev === false && next && tmp[idx + 1].resizable === false || prevc === false && nextc && tmp[idx + 1].collapsible === false) {
              //bbn.fn.log("------ case 4", idx + ' position ' + currentPosition);
              if (this.resizable && pane.resizable !== false && prev === false && next && tmp[idx + 1].resizable === false) {
                o.pane1 = idx;
                o.pane2 = next;
              }
              if (this.collapsible && pane.collapsible !== false && prevc === false && nextc && tmp[idx + 1].collapsible === false) {
                o.panec1 = idx;
                o.panec2 = nextc;
              }
            }
            if (o.panec2 || o.pane2) {
              this.resizers.push(o);
              hasResizers = true;
              currentPosition++;
            }
          }
        });
        if (hasPercent && hasResizers && !hasAuto) {
          throw bbn._('In a resizable splitter, if a pane has a percentage measure, at least one pane must be meausreless or set at "auto"');
        } else {
          this.$forceUpdate();
          this.ready = true;
          this.selfEmit(true);
        }
      }, 200);
    },
    /**
     * Return true if one of the two panes given is collassible.
     * @method areCollapsible
     * @param {Number} idxPane1 
     * @param {Number} idxPane2 
     * @return {Boolean}
     */
    areCollapsible(idxPane1, idxPane2) {
      return this.collapsible && this.panes[idxPane1] && this.panes[idxPane2] && (this.panes[idxPane1].collapsible !== false || this.panes[idxPane2].collapsible !== false);
    },
    /**
     * Returns true if the previous pane is collapsible.
     * @method isCollapsiblePrev
     * @param {Number} idxPane1 
     * @param {Number} idxPane2 
     * @return {Boolean}
     */
    isCollapsiblePrev(idxPane1, idxPane2) {
      return this.collapsible && (this.panes[idxPane2].collapsed || !this.panes[idxPane1].collapsed && (idxPane2 === this.panes.length - 1 || !this.panes[idxPane2].collapsed));
    },
    /**
     * Returns true if the next pane is collapsible.
     * @method isCollapsibleNext
     * @param {Number} idxPane1 
     * @param {Number} idxPane2 
     * @return {Boolean}
     */
    isCollapsibleNext(idxPane1, idxPane2) {
      return this.collapsible && (this.panes[idxPane1].collapsed || !this.panes[idxPane2].collapsed && (idxPane1 === 0 || !this.panes[idxPane2].collapsed));
    },
    /**
     * Returns true if teh previous pane is fully collapsible.
     * @method isFullyCollapsiblePrev
     * @param {Number} idxPane1 
     * @param {Number} idxPane2 
     * @param {Number} idxResizer 
     * @return {Boolean}
     */
    isFullyCollapsiblePrev(idxPane1, idxPane2, idxResizer) {
      return this.collapsible && this.panes[idxPane2].collapsed && (idxPane2 === this.panes.length - 1 && idxResizer === this.resizers.length - 1 || idxPane1 === idxPane2 - 1 || this.panes[idxPane1 + 1].collapsible !== false);
    },
    /**
     * Returns true if the next pane is fully collapsible.
     * @method isFullyCollapsibleNext
     * @param {Number} idxPane1 
     * @param {Number} idxPane2 
     * @param {Number} idxResizer 
     * @return {Boolean}
     */
    isFullyCollapsibleNext(idxPane1, idxPane2, idxResizer) {
      return this.collapsible && this.panes[idxPane1].collapsed && (idxPane1 === 0 && idxResizer === 0 || idxPane1 === idxPane2 - 1 || this.panes[idxPane2 - 1].collapsible !== false);
    },
    /**
     * Handles the resize of panes on dragging the resizer
     * @method resizeDrag
     * @param {Event} e 
     */
    resizeDrag(e) {
      if (this.isResizing && this.resizeCfg && this.resizeCfg.panes) {
        e.preventDefault();
        e.stopImmediatePropagation();
        let diff = (e['client' + this.currentAxis.toUpperCase()] || (e.touches.length ? e.touches[0] : e.changedTouches[0])['page' + this.currentAxis.toUpperCase()]) - this.resizeCfg[this.currentOffsetType];
        if (diff >= this.resizeCfg.max) {
          diff = this.resizeCfg.max;
        } else if (diff <= this.resizeCfg.min) {
          diff = this.resizeCfg.min;
        }
        this.panes[this.resizeCfg.resizer.pane1].currentDiff = diff;
        this.panes[this.resizeCfg.resizer.pane2].currentDiff = -diff;
      }
    },
    /**
     * Ends the resize
     * @method resizeEnd
     * @param {Event} e 
     */
    resizeEnd(e) {
      if (this.isResizing && this.resizeCfg && this.resizeCfg.panes) {
        let diff = (e['client' + this.currentAxis.toUpperCase()] || (e.touches.length ? e.touches[0] : e.changedTouches[0])['page' + this.currentAxis.toUpperCase()]) - this.resizeCfg[this.currentOffsetType];
        if (diff >= this.resizeCfg.max) {
          diff = this.resizeCfg.max;
        } else if (diff <= this.resizeCfg.min) {
          diff = this.resizeCfg.min;
        }
        this.panes[this.resizeCfg.resizer.pane1].currentDiff = 0;
        this.panes[this.resizeCfg.resizer.pane2].currentDiff = 0;
        this.panes[this.resizeCfg.resizer.pane1].savedDiff = this.panes[this.resizeCfg.resizer.pane1].savedDiff + diff;
        this.panes[this.resizeCfg.resizer.pane2].savedDiff = this.panes[this.resizeCfg.resizer.pane2].savedDiff - diff;
        this.isResizing = false;
        document.body.removeEventListener("touchmove", this.resizeDrag);
        document.body.removeEventListener("mousemove", this.resizeDrag);
        document.body.removeEventListener("touchend", this.resizeEnd);
        document.body.removeEventListener("touchcancel", this.resizeEnd);
        document.body.removeEventListener("mouseup", this.resizeEnd);
        document.body.removeEventListener("mouseleave", this.resizeEnd);
        this.panes[this.resizeCfg.resizer.pane1].pane.selfEmit(true);
        this.panes[this.resizeCfg.resizer.pane2].pane.selfEmit(true);
        this.resizeCfg = null;
      }
    },
    /**
     * @ignore
     * @todo Remove this function.
     * Obliged to do that because of sliders (closing one with right orientation moves the splitter!)
     */
    preventScroll() {
      this.$el.scrollLeft = 0;
      this.$el.scrollTop = 0;
    },
    /**
     * Starts the resize.
     * @param {Event} e 
     * @param {Object} rs 
     */
    resizeStart(e, rs) {
      if (e.target.tagName.toLowerCase() === 'i') {
        e.target.click();
        return;
      }
      if (this.isResizable && !this.isResizing && this.panes[rs.pane1] && !this.panes[rs.pane1].collapsed && this.panes[rs.pane2] && !this.panes[rs.pane2].collapsed) {
        this.isResizing = true;
        document.body.addEventListener("touchmove", this.resizeDrag, {
          passive: true
        });
        document.body.addEventListener("mousemove", this.resizeDrag, {
          passive: true
        });
        document.body.addEventListener("touchend", this.resizeEnd);
        document.body.addEventListener("touchcancel", this.resizeEnd);
        document.body.addEventListener("mouseup", this.resizeEnd);
        document.body.addEventListener("mouseleave", this.resizeEnd);
        let vue1 = this.find('bbn-pane', rs.pane1),
          vue2 = this.find('bbn-pane', rs.pane2),
          pos = e.target.getBoundingClientRect(),
          pos1 = vue1.$el.getBoundingClientRect(),
          pos2 = vue2.$el.getBoundingClientRect();
        if (!this.panes[rs.pane1].size && !this.panes[rs.pane2].size) {
          this.$set(this.panes[rs.pane1], "size", this.currentOrientation === 'horizontal' ? pos1.width : pos1.height);
          this.$set(this.panes[rs.pane2], "size", this.currentOrientation === 'horizontal' ? pos2.width : pos2.height);
          this.$forceUpdate();
        }
        this.resizeCfg = {
          resizer: rs,
          panes: [vue1, vue2],
          min: -pos1[this.currentSizeType.toLowerCase()] + this.minPaneSize,
          max: pos2[this.currentSizeType.toLowerCase()] - this.minPaneSize - this.resizerSize
        };
        this.resizeCfg[this.currentOffsetType] = pos[this.currentOffsetType];
        //bbn.fn.log("START", this.resizeCfg, e, "------------");
      }
      /*
          setTimeout(() =>{
            this.resizers.forEach((a, i) => {
              if ( a.pane2 ){
                //bbn.fn.log("DRAGGABLE?", this.$refs.resizer[i]);
                let prop = this.currentOrientation === 'horizontal' ? 'left' : 'top',
                    pane1 = this.find('bbn-pane', a.pane1),
                    pane2 = this.find('bbn-pane', a.pane2),
                    max,
                    min;
                $(this.$refs.resizer[i]).draggable({
                  helper: 'clone',
                  containment: "parent",
                  opacity: 0.1,
                  zIndex: 6000,
                  axis: this.currentAxis,
                  start: (e, ui) => {
                    if ( (a.panec1 && a.panec1.collapsed) || (a.panec2 && a.panec2.collapsed) ){
                      e.preventDefault();
                      bbn.fn.log("PREVENTING");
                      return false;
                    }
                    /**
                     * Pane on the left side of the resizer
                     * @type {ClientRect}
                     *
                    let pos1 = pane1.$el.getBoundingClientRect(),
                        /**
                         * Pane on the right side of the resizer
                         * @type {ClientRect}
                         *
                        pos2 = pane2.$el.getBoundingClientRect();
                    min = -pos1.width;
                    max = pos2.width;
                    bbn.fn.log("START", min, max, ui.position[prop] + '/' + ui.originalPosition[prop], "------------");
                  },
                  drag: (e, ui) =>{
                    let diff = ui.position[prop] - ui.originalPosition[prop];
                    bbn.fn.log(diff, max, min);
                    if ( diff >= max ){
                      diff = max - 5;
                    }
                    else if ( diff <= min ){
                      diff = min + 5;
                    }
                    this.$set(this.panes[a.pane2], 'currentDiff', -diff);
                    this.$set(this.panes[a.pane1], 'currentDiff', diff);
                  },
                  stop: (e, ui) =>{
                    let diff = ui.position[prop] - ui.originalPosition[prop];
                    if ( diff >= max ){
                      diff = max - 5;
                    }
                    else if ( diff <= min ){
                      diff = min + 5;
                    }
                    bbn.fn.log(diff, max, min);
                    this.$set(this.panes[a.pane2], 'currentDiff', 0);
                    this.$set(this.panes[a.pane1], 'currentDiff', 0);
                    this.$set(this.panes[a.pane2], 'savedDiff', this.panes[a.pane2].savedDiff - diff);
                    this.$set(this.panes[a.pane1], 'savedDiff', this.panes[a.pane1].savedDiff + diff);
                    this.selfEmit(true);
                  }
                })
              }
            });
          }, 200)
        }
        */
    },

    /**
     * Collapses a collapsible pane.
     * @param {Number} toCollapse 
     * @param {Number} toUpdate 
     * @param {Boolean} full 
     */
    collapse(toCollapse, toUpdate, full) {
      if (this.collapsible && this.panes[toCollapse] && this.panes[toUpdate]) {
        let collapsing = !this.panes[toCollapse].collapsed,
          smaller = collapsing ? toCollapse : toUpdate,
          bigger = collapsing ? toUpdate : toCollapse,
          diff1 = this.panes[smaller].savedDiff,
          diff2 = this.panes[bigger].savedDiff;
        //bbn.fn.log(toCollapse, toUpdate, smaller, bigger, diff1, diff2);
        // Not a full collapse (=- double) but with a already collapsed pane
        if (!full && (this.panes[toCollapse].collapsed || this.panes[toUpdate].collapsed)) {
          this.panes[smaller].addedSize = '';
          this.panes[bigger].addedSize = '';
          this.panes[smaller].tmpDiff = 0;
          this.panes[bigger].tmpDiff = 0;
          this.panes[smaller].collapsed = false;
          this.panes[smaller].pane.isCollapsed = false;
          this.panes[bigger].collapsed = false;
          this.panes[bigger].pane.isCollapsed = false;
        }
        // The other is also collapsed and the double arrow is clicked: switching
        else if (full && this.panes[toUpdate].collapsed === collapsing) {
          this.panes[bigger].tmpDiff = diff1 - this.resizerSize;
          this.panes[smaller].tmpDiff = 0;
          if (this.panes[smaller].size) {
            this.panes[bigger].addedSize = this.panes[smaller].size;
          }
          this.panes[bigger].collapsed = false;
          this.panes[smaller].collapsed = true;
          this.panes[bigger].pane.isCollapsed = false;
          this.panes[smaller].pane.isCollapsed = true;
        } else {
          if (this.panes[toCollapse].size && this.panes[toUpdate].size) {
            this.panes[bigger].addedSize = this.panes[smaller].size;
          } else {
            this.panes[bigger].addedSize = 'auto';
          }
          this.panes[bigger].tmpDiff = diff1 - this.resizerSize;
          this.panes[smaller].tmpDiff = 0;
          this.panes[toCollapse].collapsed = collapsing;
          this.panes[toCollapse].pane.isCollapsed = collapsing;
        }
        this.$nextTick(() => {
          this.selfEmit();
        });
      }
    },
    //@todo not used
    hasExpander(paneIdx, resizerIdx) {
      return false;
      let pane = this.panes[paneIdx],
        paneBefore = this.panes[paneIdx + 1];
      if (this.collapsible && pane.collapsible !== false && paneBefore && paneBefore.collapsible !== false && paneBefore.resizable !== false) {
        return true;
      }
      return false;
    },
    expanderClass(paneIdx, resizerIdx) {
      return '';
      /*
      let direction = this.panes[paneIdx].collapsed || (resizerIdx === 1) ?
            (this.currentOrientation === 'horizontal' ? 'right' : 'down') :
            (this.currentOrientation === 'horizontal' ? 'left' : 'up'),
          icon = (resizerIdx === 1) && this.panes[paneIdx].collapsed ? 'angle-double-' : 'angle-',
          cls = 'bbn-p nf nf-fa-' + icon + direction;
      return cls;
      */
    }
  },

  /**
   * Defines the current orientation and forces the update of the component.
   * @event mounted 
   * @fires getOrientation
   */
  mounted() {
    if (this.currentOrientation === 'auto') {
      this.currentOrientation = this.getOrientation();
      this.$forceUpdate();
    }
  },
  updated() {
    //this.onResize();
  },
  watch: {
    /**
     * Reinitializes the component when the value of the prop orientation changes
     * @watch orientation 
     * @param {String} newVal 
     * @param {String} oldVal 
     */
    orientation(newVal, oldVal) {
      if (newVal !== oldVal && newVal !== this.currentOrientation) {
        this.currentOrientation = newVal === 'auto' ? this.getOrientation() : newVal;
      }
    },
    /**
     * Reinitializes the component when the value of currentOrientation changes
     * @watch currentOrientation
     * @fires init
     */
    currentOrientation() {
      this.init();
    }
  }
};
import cpHtml from './splitter.html';
import cpStyle from './splitter.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./splitter.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-splitter',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.list, bbn.cp.mixins.basic],
  props: {
    /**
     * @prop {Array} source
     */
    source: {
      type: Array
    }
  },
  data() {
    return {
      current: []
    };
  },
  created() {
    bbn.fn.log('mounted', this.source);
    this.current = this.source;
    //this.currentData = this.source;
  },

  methods: {
    setCurrent(a) {
      this.current = a;
    }
  }
};
import cpHtml from './stack.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./stack.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-stack',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-switch component
 *
 * @description bbn-switch is a component with easy implementation and customization that allows the user to switch between selected and unselected states, defining the value and novalue in the appropriate properties.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 13/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * The value of the component.
     * @prop {Boolean} [true] value
     */
    value: {
      default: true
    },
    /**
     * The value of the component when switch is off.
     * @prop [null] novalue
     */
    novalue: {
      default: null
    },
    /**
     * The name of the input.
     * @prop {String} [null] name
     */
    name: {
      type: String,
      default: null
    },
    /**
     * The id of the input.
     * @prop {String} [bbn.fn.randomString(10, 25)] id
     */
    id: {
      type: String,
      default() {
        return bbn.fn.randomString(10, 25);
      }
    },
    /**
     * The class(es) to add to the tag span.
     * @prop {String|Array} cls
     */
    cls: {
      type: [String, Array]
    },
    /**
     * The class(es) to add to the switch button.
     * @prop {String|Array} sliderCls
     */
    sliderCls: {
      type: [String, Array]
    },
    /**
     * The property used for the component's value instead of the classic "value" property.
     * @prop {String|Boolean|Number} [undefined] modelValue
     */
    modelValue: {
      type: [String, Boolean, Number],
      default: undefined
    },
    /**
     * True if a value is required.
     * @prop {Boolean} [false] required
     */
    required: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true disables the switch.
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true for a readonly switch.
     * @prop {Boolean} [false] readonly
     */
    readonly: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true to have the component switched on.
     * @prop {Boolean} [false] checked
     */
    checked: {
      type: Boolean,
      default: false
    },
    /**
     * If set to true, a comparison will also be made on the component value type.
     * @prop {Boolean} [false] strict
     */
    strict: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the icon for the component when switched on.
     * @prop {String} ['nf nf-fa-play'] onIcon
     */
    onIcon: {
      type: String,
      default: 'nf nf-fa-play'
    },
    /**
     * Defines the icon for the component when switched off.
     * @prop {String} ['nf nf-fa-stop'] offIcon
     */
    offIcon: {
      type: String,
      default: 'nf nf-fa-stop'
    },
    /**
     * Set to true does not show onIcon and offIcon.
     * @prop {Boolean} [tre] noIcon
     */
    noIcon: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true gives the component a rounded appearance.
     * @prop {Boolean} [false] radius
     */
    radius: {
      type: Boolean,
      default: false
    }
  },
  model: {
    prop: 'modelValue',
    event: 'input'
  },
  computed: {
    /**
     * Gives information about the state of the switch
     * @computed state
     * @return {Boolean}
     */
    state() {
      if (this.modelValue === undefined) {
        return this.checked;
      }
      if (this.checked && (!this.strict && this.modelValue != this.value || this.strict && this.modelValue !== this.value)) {
        return false;
      }
      if (this.strict && this.modelValue === this.value || !this.strict && this.modelValue == this.value) {
        return true;
      }
      return this.checked;
    },
    /**
     * If the prop noIcon is set to false returns the icon basing on the component's state.
     * @computed currentIcon
     * @return {String}
     */
    currentIcon() {
      return this.noIcon ? '' : this.state ? this.onIcon : this.offIcon;
    }
  },
  methods: {
    /**
     * Switches the component.
     * @method toggle
     * @emits input
     * @emits change
     */
    toggle() {
      if (!this.isDisabled && !this.readonly) {
        let emitVal = !this.state ? this.value : this.novalue;
        this.$emit('input', emitVal);
        this.$emit('change', emitVal, this);
      }
    }
  },
  /**
   * Sets the initial state of the component.
   * @event mounted
   * @fires toggle
   * @emits input
   */
  mounted() {
    if (this.checked && !this.state) {
      this.toggle();
    }
    if (!this.checked && !this.state) {
      this.$emit('input', this.novalue);
    }
  },
  watch: {
    /**
     * @watch checked
     * @param {Boolean} newValue
     * @fires toggle
     */
    checked(newValue) {
      if (newValue !== this.state) {
        this.toggle();
      }
    }
  }
};
import cpHtml from './switch.html';
import cpStyle from './switch.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./switch.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-switch',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-table component
 *
 * @description  bbn-table is a powerful component of wide configuration that offers vast customizations.
 * The source obtains it by giving a url to retrieve data or directly supplying an array.
 * It allows you to easily modify the content by entering new data in the input field corresponding to the type of column being defined.
 * The table rows can be sorted by clicking on a column header.
 * Table elements can be filtered with the help of a built-in filters in the column headings or using a multifilter panel and a reset by removing a filter or all filters with just one click.
 * It's possible to create fixed areas that will keep their position by always having them available during scrolling.
 * It gives the possibility to group the data.
 * These are some examples of what can be done with this component, from the few configuration lines we can express considerable work complexity.
 *
 * @author BBN Solutions
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.editableList
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.dataEditor
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.observer
   * @mixin bbn.cp.mixins.data
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.editableList, bbn.cp.mixins.list, bbn.cp.mixins.config, bbn.cp.mixins.dataEditor, bbn.cp.mixins.localStorage, bbn.cp.mixins.observer, bbn.cp.mixins.keepCool, bbn.cp.mixins.data],
  iface() {
    return {
      config: {
        name: 'bbns-column',
        data: 'columns',
        props: {
          /**
           * The width of the component.
           * @prop {String|Number} width
           * @memberof fieldComponent
           */
          width: {
            type: [String, Number]
          },
          /**
           * The min-width of the component.
           * @prop {String|Number} minWidth
           * @memberof fieldComponent
           */
          minWidth: {
            type: [String, Number]
          },
          /**
           * The max-width of the component.
           * @prop {String|Number} maxWidth
           * @memberof fieldComponent
           */
          maxWidth: {
            type: [String, Number]
          },
          /**
           * The render of the component.
           * @prop {String|Function} render
           * @memberof fieldComponent
           */
          render: {
            type: [String, Function]
          },
          /**
           * The title of the component.
           * @prop {String|Number} title
           * @memberof fieldComponent
           */
          title: {
            type: [String, Number]
          },
          /**
           * The full title of the component.
           * @prop {String} ftitle
           * @memberof fieldComponent
           */
          ftitle: {
            type: String
          },
          /**
           * @prop {String|Object} tcomponent
           * @memberof fieldComponent
           */
          tcomponent: {
            type: [String, Object]
          },
          /**
           * The icon of the component.
           * @prop {String} icon
           * @memberof fieldComponent
           */
          icon: {
            type: String
          },
          /**
           * The classes added to the component.
           * @prop {String|Function} cls
           * @memberof fieldComponent
           */
          cls: {
            type: [String, Function]
          },
          /**
           * The component's type.
           * @prop {String} type
           * @memberof fieldComponent
           */
          type: {
            type: String
          },
          /**
           * The component's field.
           * @prop {String} field
           * @memberof fieldComponent
           */
          field: {
            type: String
          },
          /**
           * Defines if the component has to be fixed.
           * @prop {Boolean|String} [false] fixed
           * @memberof fieldComponent
           */
          fixed: {
            type: [Boolean, String],
            default: false
          },
          /**
           * Defines if the component has to be hidden.
           * @prop {Boolean} hidden
           * @memberof fieldComponent
           */
          hidden: {
            type: Boolean
          },
          /**
           * Defines if the componenent has to be encoded.
           * @prop {Boolean} [false] encoded
           * @memberof fieldComponent
           */
          encoded: {
            type: Boolean,
            default: false
          },
          /**
           * Defines if the componenent has to be sortable.
           * @prop {Boolean|Function} [true] sortable 
           * @memberof fieldComponent
           */
          sortable: {
            type: [Boolean, Function],
            default: true
          },
          /**
           * Defines if the componenent has to be editable.
           * @prop {Boolean|Function} [true] editable 
           * @memberof fieldComponent
           */
          editable: {
            type: [Boolean, Function],
            default: true
          },
          /**
           * Defines if the componenent has to be filterable.
           * @prop {Boolean|Function} [true] filterable 
           * @memberof fieldComponent
           */
          filterable: {
            type: [Boolean, Function],
            default: true
          },
          /**
           * Defines if the componenent has to be resizable.
           * @prop {Boolean|Function} [true] resizable 
           * @memberof fieldComponent
           */
          resizable: {
            type: [Boolean, Function],
            default: true
          },
          /**
           * Defines if the componenent has to be showable.
           * @prop {Boolean|Function} [true] showable 
           * @memberof fieldComponent
           */
          showable: {
            type: [Boolean, Function],
            default: true
          },
          /**
           * Defines if the componenent can have a null value.
           * @prop {Boolean|Function} nullable 
           * @memberof fieldComponent
           */
          nullable: {
            type: [Boolean, Function]
          },
          /**
           * The buttons of the component.
           * @prop {Array|Function} buttons 
           * @memberof fieldComponent
           */
          buttons: {
            type: [Array, Function]
          },
          /**
           * The source of the component.
           * @prop {Array|Object|String|Function} source 
           * @memberof fieldComponent
           */
          source: {
            type: [Array, Object, String, Function]
          },
          /**
           * Defines if the the value of the component is required.
           * @prop {Boolean|Function} required 
           * @memberof fieldComponent
           */
          required: {
            type: [Boolean, Function]
          },
          /**
           * Defines the precision of the component.
           * @prop {Number} [0] precision 
           * @memberof fieldComponent
           */
          precision: {
            type: Number
          },
          /**
           * Defines the number of decimals for the component.
           * @prop {Number} [0] decimals 
           * @memberof fieldComponent
           */
          decimals: {
            type: Number
          },
          /**
           * Defines the precision of the component.
           * @prop {Number} [0] precision 
           * @memberof fieldComponent
           */
          unit: {
            type: String
          },
          /**
           * Defines the options of the component.
           * @prop {Object|Function} options
           * @memberof fieldComponent
           */
          options: {
            type: [Object, Function],
            default() {
              return {};
            }
          },
          /**
           * Defines the editor of the component.
           * @prop {String|Object} editor
           * @memberof fieldComponent
           */
          editor: {
            type: [String, Object]
          },
          /**
           * Defines the maxLength of the component.
           * @prop {Number} maxLength 
           * @memberof fieldComponent
           */
          maxLength: {
            type: Number
          },
          /**
           * Defines the max number of chars visible in reading.
           * @prop {Number} maxVisible 
           * @memberof fieldComponent
           */
          maxVisible: {
            type: Number
          },
          /**
           * Defines the sqlType of the component.
           * @prop {String} sqlType 
           * @memberof fieldComponent
           */
          sqlType: {
            type: String
          },
          /**
           * @prop {String|Array} aggregate
           * @memberof fieldComponent
           */
          aggregate: {
            type: [String, Array]
          },
          /**
           * Define a component to use.
           * @prop {String|Object} component
           * @memberof fieldComponent
           */
          component: {
            type: [String, Object]
          },
          /**
           * A function to map the data of the component.
           * @prop {Function} mapper
           * @memberof fieldComponent
           */
          mapper: {
            type: Function
          },
          /**
           * Defines the group of the component.
           * @prop {String} group
           * @memberof fieldComponent
           */
          group: {
            type: String
          }
        }
      }
    };
  },
  beforeCreate() {
    bbn.fn.log(["BEFORE CREATE", this.$el, this.$slots, this.$el.bbnSlots, this.closest('bbn-anon')]);
  },
  props: {
    /**
     * True if the columns has to have titles.
     * @prop {Boolean} [true] titles
     */
    titles: {
      type: Boolean,
      default: true
    },
    /**
     * The message to show when the table has no data.
     * @prop {String} ['<h3>' + bbn._('No Data') + '</h3>'] noData
     */
    noData: {
      default: '<h3>' + bbn._('No Data') + '</h3>'
    },
    /**
     * If the property 'group' is given to one or more columns in the table (ex: group="test"), it defines the title of a group of columns. (ex: titleGroups="[{value: 'test', text: 'My group'}]").
     * @prop {Array|Function} titleGroups
     */
    titleGroups: {
      type: [Array, Function]
    },
    /**
     * Defines the behaviour of the table about the scroll.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true allows the table to be resizable.
     * @prop {Boolean} [false] resizable
     */
    resizable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true shows a button at the bottom right of the table that opens a column picker for the table.
     * @prop {Boolean} [false] showable
     */
    showable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true shows a save icon that allows to save the current configuration of the table at the bottom right of the table.
     * @prop {Boolean} [false] saveable
     */
    saveable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true allows the table to be groupable according to the props groupBy.
     * @prop {Boolean} [false] groupable
     */
    groupable: {
      type: Boolean,
      default: false
    },
    /**
     * In case of Ajax table, set to true will make an Ajax call to group the table by a field.
     * @prop {Boolean} [true] serverGrouping
     */
    serverGrouping: {
      type: Boolean,
      default: true
    },
    /**
     * Set to false will make an Ajax call for the grouping.
     * @prop {Boolean} [true] localGrouping
     */
    localGrouping: {
      type: Boolean,
      default: true
    },
    /**
     * Defines the minimum columns width.
     * @prop {Number} [30] minimumColumnWidth
     */
    minimumColumnWidth: {
      type: Number,
      default: 30
    },
    /**
     * Defines the minimum columns width for mobile devices.
     * @prop {Number} [100] minimumColumnWidthMobile
     */
    minimumColumnWidthMobile: {
      type: Number,
      default: 100
    },
    /**
     * Defines the default columns width.
     * @prop {Number} [150] defaultColumnWidth
     */
    defaultColumnWidth: {
      type: Number,
      default: 150
    },
    /**
     * A function to define css class(es) for each row.
     * @prop {Function} trClass
     */
    trClass: {
      type: [String, Function, Object]
    },
    /**
     * A function to define css style(s) for each row.
     * @prop {Function} trStyle
     */
    trStyle: {
      type: [String, Function, Object]
    },
    /**
     * Defines the message to show in the confirm when an action is made on the row.
     * @prop {String|Function|Boolean} confirmMessage
     */
    confirmMessage: {
      type: [String, Function, Boolean],
      default: bbn._('Are you sure you want to delete this row?')
    },
    /**
     * Defines the expander of the rows.
     * @prop  {Object|String|Function} expander
     */
    expander: {
      type: [Object, String, Function]
    },
    /**
     * Customize the loading text or hide it
     * @prop {String|Boolean} [true] loader
     */
    loader: {
      type: [String, Boolean],
      default: true
    },
    /**
     * If one or more columns have the property fixed set to true it defines the side of the fixed column(s).
     * @prop {String} ['left'] fixedDefaultSide
     */
    fixedDefaultSide: {
      type: String,
      default: 'left'
    },
    /**
     * Defines the toolbar of the table.
     * @prop {Array|Object|String|Function} toolbar
     */
    toolbar: {
      type: [Array, Object, String, Function]
    },
    /**
     * An array of objects with at least the property 'field' that can replace the html '<bbns-column></bbns-column>' or extend them.
     * @prop {Array} [[]] columns
     */
    columns: {
      type: Array,
      default: function () {
        return [];
      }
    },
    /**
     * The index of the property to group by the table referred to the object of data of the row.
     * @prop {Number} groupBy
     */
    groupBy: {
      type: Number
    },
    /**
     * The list of expanded rows based on a specific value (ex. group field) and not on the row index
     * @prop {Array|Function} expandedValues
     */
    expandedValues: {
      type: [Array, Function]
    },
    /**
     * In a grouped table, if set to true defines that all rows will be expanded. If an array is given defines which row(s) of the table will be expanded.
     * @prop {Boolean|Array} [[]] expanded
     */
    expanded: {
      type: [Boolean, Array],
      default() {
        return [];
      }
    },
    /**
     * Defines the footer of the table.
     * Allowed values are the name or the object of a component, a boolean or a function (to inject custom html)
     * @prop {String|Object|Boolean|Function} footer
     */
    footer: {
      type: [String, Object, Boolean, Function],
      default: true
    },
    /**
     * Defines the footer for a group of rows.
     * Allowed values are the name or the object of a component or a function (to inject custom html)
     * @prop {String|Object|Function} groupFooter
     */
    groupFooter: {
      type: [String, Object, Function]
    },
    /**
     * @todo desc
     * @prop {Object} [{tot: 'Total',med: 'Average',num: 'Count',max: 'Maximum',min: 'Minimum'}] aggregateExp
     */
    aggregateExp: {
      type: Object,
      default() {
        return {
          tot: bbn._('Total'),
          med: bbn._('Average'),
          num: bbn._('Count'),
          max: bbn._('Maximum'),
          min: bbn._('Minimum')
        };
      }
    },
    /**
     * @prop {String|Array} aggregate
     */
    aggregate: {
      type: [String, Array]
    },
    /**
     * @todo desc
     * @prop {Object} loadedConfig
     */
    loadedConfig: {
      type: Object
    },
    /**
     * Shows the footer's arrows as buttons
     * @prop {Boolean} [true] footerButtons
     */
    footerButtons: {
      type: Boolean,
      default() {
        return !bbn.fn.isMobile() || bbn.fn.isTabletDevice();
      }
    },
    /**
     * The name of the `page` word as used in the pager interface.
     * @prop {String} ['Page'] pageName
     */
    pageName: {
      type: String,
      default: bbn._("page")
    },
    /**
     * The name of the `record` word as used in the pager interface.
     * @prop {String} ['Record(s)'] itemName
     */
    itemName: {
      type: String,
      default: bbn._("rows")
    },
    /**
     * The way `buttons` should be displayed, either as buttons, dropdown or as a menu.
     * @prop {String} ['buttons'] buttonMode
     */
    buttonMode: {
      type: String,
      default: 'buttons',
      validator(v) {
        return ['buttons', 'dropdown', 'menu'].includes(v);
      }
    },
    /**
     * The name of the `record` word as used in the pager interface.
     * @prop {String} ['nf nf-mdi-dots_vertical'] buttonIcon
     */
    buttonIcon: {
      type: String,
      default: 'nf nf-mdi-dots_vertical'
    },
    /**
     * Allows you to see the contents of a cell in a popup
     * @prop {Boolean} [false] zoomable
     */
    zoomable: {
      type: Boolean,
      default: false
    },
    /**
     * The max row height value
     * @prop {Number} maxRowHeight
     */
    maxRowHeight: {
      type: Number
    },
    /**
     * Property sloBefore for the toolbar
     * @prop {Boolean} toolbarSlotBefore
     */
    toolbarSlotBefore: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      initialConfig: null,
      isTable: null,
      /**
       * @data {Boolean} [false] _observerReceived
       */
      _observerReceived: false,
      allRowsChecked: false,
      /**
       * The group of columns.
       * @data {Object} [[{name: 'left',width: 0,visible: 0,cols: []},{name: 'main',width: 0,visible: 0,cols: []},{name: 'right',width: 0,visible: 0,cols: []}]] groupCols
       */
      groupCols: [{
        name: 'left',
        width: 0,
        visible: 0,
        cols: []
      }, {
        name: 'main',
        width: 0,
        visible: 0,
        cols: []
      }, {
        name: 'right',
        width: 0,
        visible: 0,
        cols: []
      }],
      /**
       * @data {Boolean} [false] initReady
       */
      initReady: false,
      /**
       * The current configuration object.
       * @data {Object} [{}] currentConfig
       */
      currentConfig: {},
      /**
       * The saved configuration.
       * @data {Boolean} [false] savedConfig
       */
      savedConfig: false,
      /**
       * The default confuguration
       * @data {Object} defaultConfig
       */
      defaultConfig: bbn.fn.extend({
        filters: this.filters,
        limit: this.limit,
        order: this.order,
        hidden: this.hidden || null
      }, this.loadedConfig || {}),
      /**
       * @data {Boolean} [false] editedFilter
       */
      editedFilter: false,
      /**
       * @data {Number} [0] floatingFilterX
       */
      floatingFilterX: 0,
      /**
       * @data {Number} [0] floatingFilterY
       */
      floatingFilterY: 0,
      /**
       * @data {Number} [0] floatingFilterTimeOut
       */
      floatingFilterTimeOut: 0,
      /**
       * @data {Array} currentHidden
       */
      currentHidden: this.hidden || [],
      /**
       * @data {Boolean|Number} [false] group
       */
      group: this.groupBy === undefined ? false : this.groupBy,
      /**
       * @data {Array} [[]] cols
       */
      cols: [],
      /**
       * @data {Boolean} [false] table
       */
      table: false,
      /**
       * @data {Boolean} [false] colButtons
       */
      colButtons: false,
      /**
       * @data {} [null] scrollableContainer
       */
      scrollableContainer: null,
      /**
       * @data {Boolean} [true] hiddenScroll
       */
      hiddenScroll: true,
      /**
       * @data {Array} [[]] popups
       */
      popups: [],
      /**
       * @data {Boolean} [false] isAggregated
       */
      isAggregated: false,
      /**
       * @data {Array} [[]] aggregatedColumns
       */
      aggregatedColumns: [],
      /**
       * @data {Boolean} [false] updaterTimeout
       */
      updaterTimeout: false,
      /**
       * @data {Boolean} allExpanded
       */
      allExpanded: this.expanded === true ? true : false,
      /**
       * @data {Boolean} [false] groupInit
       */
      groupInit: false,
      /**
       * @data {Array} currentExpanded
       */
      currentExpanded: Array.isArray(this.expanded) ? this.expanded : [],
      /**
       * @data {Array} currentExpandedValues
       */
      currentExpandedValues: Array.isArray(this.expandedValues) ? this.expandedValues : [],
      /**
       * @data {Boolean} [false] focusedRow
       */
      focusedRow: false,
      /**
       * @data {} [null] rowIndexTimeOut
       */
      rowIndexTimeOut: null,
      /**
       * @data {String} containerPadding
       */
      containerPadding: (bbn.fn.getScrollBarSize() ? bbn.fn.getScrollBarSize() : '0') + 'px',
      /**
       * @data {bbnCp} [null] container
       */
      container: null,
      /**
       * The current scroll top position.
       * @data {Number} [0] currentScrollTop
       */
      currentScrollTop: 0,
      /**
       * @data [null] marginStyleSheet
       */
      marginStyleSheet: null,
      /**
       * @data {String} [bbn.fn.randomString().toLowerCase()] cssRuleName
       */
      cssRuleName: bbn.fn.randomString().toLowerCase(),
      /**
       * @data {String} [false] initStarted
       */
      initStarted: false,
      /**
       * @data [null] inTable
       */
      inTable: null,
      /**
       * @data [null] filterElement
       */
      filterElement: null,
      /**
       * @data {Boolean} [false] hasScrollX 
       */
      hasScrollX: false,
      /**
       * @data {Boolean} [false] hasScrollY
       */
      hasScrollY: false,
      /**
       * @data {Number} [0] borderLeft
       */
      borderLeft: 0,
      /**
       * @data {Number} [0] borderRight
       */
      borderRight: 0,
      /**
       * @data {DOMElement} [undefined] focusedElement
       */
      focusedElement: null,
      /**
       * @data {Number} [0] focusedElementX Horizontal coordinate of focused element
       */
      focusedElementX: 0,
      /**
       * @data {Number} [0] focusedElementY Vertical coordinate of focused element
       */
      focusedElementY: 0,
      /**
       * @data {Boolean} [false] isTableDataUpdating Will be set to true during the whole update process
       */
      isTableDataUpdating: false,
      /**
       * The text shown during loading
       * @data {String} ['Loading...'] currentLoaderText
       */
      currentLoaderText: bbn.fn.isString(this.loader) ? this.loader : bbn._('Loading') + '...',
      /**
       * True if the table is resizing its width
       * @data {Boolean} [false] isResizingWidth
       */
      isResizingWidth: false,
      /**
       * The portal element for the buttons' floater (menu mode)
       * @data {HTMLElement} [document.body] portalElement
       */
      portalElement: document.body
    };
  },
  computed: {
    realButtons() {
      if (this.cols.length && this.cols[this.colButtons] && this.cols[this.colButtons].buttons) {
        if (bbn.fn.isFunction(this.cols[this.colButtons].buttons)) {
          return this.cols[this.colButtons].buttons.bind(this.$origin);
        } else if (bbn.fn.isArray(this.cols[this.colButtons].buttons)) {
          let res = [];
          bbn.fn.each(this.cols[this.colButtons].buttons, a => {
            if (bbn.fn.isString(a)) {
              switch (a) {
                case 'edit':
                  res.push({
                    text: bbn._('Edit'),
                    action: 'edit',
                    icon: 'nf nf-fa-edit'
                  });
                  break;
                case 'copy':
                  res.push({
                    text: bbn._("Copy"),
                    action: 'copy',
                    icon: 'nf nf-fa-copy'
                  });
                  break;
                case 'delete':
                  res.push({
                    text: bbn._("Delete"),
                    action: 'remove',
                    icon: 'nf nf-fa-times'
                  });
                  break;
              }
            } else {
              if (bbn.fn.isFunction(a.action)) {
                a.action = a.action.bind(this.$origin);
              }
              res.push(a);
            }
          });
          if (this.cols[this.colButtons].notext) {
            bbn.fn.each(res, a => {
              a.notext = true;
              return a;
            });
          }
          return res;
        }
      }
      return [];
    },
    /**
     * The array of selected values if the table is selectable.
     * @computed selectedValues
     * @returns {Array}
     */
    selectedValues() {
      return this.currentSelected.map(a => {
        return this.uid ? this.currentData[a].data[this.uid] : this.currentData[a].data;
      });
    },
    /**
     * The container width.
     * @computed containerWidth
     * @returns {String}
     */
    containerWidth() {
      if (!this.groupCols || !this.groupCols[1] || !this.groupCols[1].width || !this.lastKnownCtWidth) {
        return '0px';
      }
      return this.lastKnownCtWidth - this.groupCols[0].width - this.groupCols[2].width + 'px';
    },
    /**
     * The total width.
     * @computed totalWidth
     * @returns {String}
     */
    totalWidth() {
      if (!this.groupCols || !this.groupCols[1] || !this.groupCols[1].width || !this.lastKnownCtWidth) {
        return '0px';
      }
      return this.groupCols[0].width + this.groupCols[1].width + this.groupCols[2].width + 'px';
    },
    /**
     * Return true if the table has the prop toolbar defined.
     * @computed hasToolbar
     * @returns {Boolean}
     */
    hasToolbar() {
      return this.toolbarButtons.length || bbn.fn.isObject(this.toolbar) || bbn.fn.isFunction(this.toolbar) || bbn.fn.isString(this.toolbar);
    },
    /**
     * @computed hasPager
     * @return {Boolean}
     */
    hasPager() {
      return (this.pageable || this.saveable || this.filterable || this.isAjax || this.showable) && this.footer === true;
    },
    /**
     * Return an array of shown fields (the hidden ones are excluded).
     * @computed shownFields
     * @returns {Array}
     */
    shownFields() {
      let r = [];
      bbn.fn.each(this.cols, a => {
        if (a.field && !a.hidden) {
          r.push(a.field);
        }
      });
      return r;
    },
    /**
     * Return the json string of currentConfig.
     * @computed jsonConfig
     * @returns {String}
     */
    jsonConfig() {
      return JSON.stringify(this.currentConfig);
    },
    /**
     * Return true if the saved config is identic to the jsonConfig.
     * @computed isSaved
     * @returns {Boolean}
     */
    isSaved() {
      return this.jsonConfig === this.savedConfig;
    },
    /**
     * Return true if the json string of currentConfig is different from initialConfig
     * @computed isChanged
     * @returns {Boolean}
     */
    isChanged() {
      return JSON.stringify(this.currentConfig) !== this.initialConfig;
    },
    /**
     * Return an array with the object(s) button for the toolbar.
     * @computed toolbarButtons
     * @returns {Array}
     */
    toolbarButtons() {
      let r = [],
        ar = [];
      if (this.toolbar) {
        ar = bbn.fn.isFunction(this.toolbar) ? this.toolbar() : Array.isArray(this.toolbar) ? this.toolbar.slice() : [];
        if (!Array.isArray(ar)) {
          ar = [];
        }
        bbn.fn.each(ar, a => {
          let o;
          if (bbn.fn.isString(a)) {
            switch (a) {
              case 'insert':
                o = {
                  text: bbn._('Add'),
                  action: this.insert,
                  icon: 'nf nf-fa-plus'
                };
                break;
              case 'export':
                o = {};
                break;
              case 'print':
                o = {};
                break;
              // separator or other toolbar param
              default:
                o = a;
            }
          } else if (bbn.fn.isObject(a)) {
            o = bbn.fn.clone(a);
          }
          if (o && bbn.fn.isObject(o) && bbn.fn.isString(o.action)) {
            o.action = () => {
              this._execCommand(a);
            };
          }
          if (!o) {
            throw new Error(bbn._("Wrong parameter for toolbar"));
          }
          r.push(o);
        });
      }
      return r;
    },
    /**
     * Return false if a required field of a column is missing.
     * @computed isEditedValid
     * @returns {Boolean}
     */
    isEditedValid() {
      let ok = true;
      if (this.tmpRow) {
        bbn.fn.each(this.columns, a => {
          if (a.field && a.required && !this.tmpRow[a.field]) {
            ok = false;
            return false;
          }
        });
      }
      return ok;
    },
    /**
     * Return the number of visible columns of the table.
     * @computed numVisible
     * @returns {number}
     */
    numVisible() {
      return this.cols.length - bbn.fn.count(this.cols, {
        hidden: true
      }) + (this.hasExpander ? 1 : 0) + (this.selection ? 1 : 0);
    },
    /**
     * Return the object scroller.
     * @computed scroller
     * @returns {Object}
     */
    scroller() {
      return bbn.cp.isComponent(this.$refs.scroller) ? this.$refs.scroller : null;
    },
    /**
     * Return an array of objects containing the data of the row and other information about the current view of the table.
     * @computed items
     * @fires _checkConditionsOnValue
     * @fires expandedValues
     * @fires isExpanded
     * @returns {Array}
     */
    items() {
      if (!this.cols.length) {
        return [];
      }
      // The final result
      let res = [],
        isGroup = this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field,
        groupField = isGroup ? this.cols[this.group].field : false,
        // The group value will change each time a row has a different value on the group's column
        currentGroupValue,
        /* @todo Not sure of what it does ! */
        currentLink,
        // the data is put in a new array with its original index
        o,
        rowIndex = 0,
        end = this.pageable ? this.currentLimit : this.currentData.length,
        aggregates = {},
        aggregateModes = [],
        aggIndex = 0,
        i = 0,
        data = this.filteredData;
      // Aggregated
      if (this.isAggregated) {
        aggregateModes = bbn.fn.isArray(this.aggregate) ? this.aggregate : [this.aggregate];
        bbn.fn.each(this.aggregatedColumns, a => {
          aggregates[a.field] = {
            tot: 0,
            num: 0,
            min: false,
            max: false,
            groups: []
          };
        });
      }
      // Paging locally
      if (this.pageable && (!this.isAjax || !this.serverPaging)) {
        i = this.start;
        end = this.start + this.currentLimit > data.length ? data.length : this.start + this.currentLimit;
      }
      // Grouping (and sorting) locally
      let pos;
      if (isGroup && (this.isAjax && this.serverGrouping || !this.isAjax && this.localGrouping) && (pos = bbn.fn.search(this.currentOrder, {
        field: this.cols[this.group].field
      })) !== 0) {
        // First ordering the data
        let orders = [{
          field: this.cols[this.group].field,
          dir: pos > 0 ? this.currentOrder[pos].dir : 'asc'
        }];
        if (this.sortable && this.currentOrder.length) {
          orders = orders.concat(JSON.parse(JSON.stringify(this.currentOrder)));
        }
        data = bbn.fn.multiorder(data, orders.map(item => {
          item.field = 'data.' + item.field;
          return item;
        }));
      }
      // Sorting locally
      else if (this.sortable && this.currentOrder.length && (!this.serverSorting || !this.isAjax)) {
        // If there is a source, we sort based on the text (not the value), so we replace temporary the values
        // with the text + a boundary + the value just the time of sorting
        if (bbn.fn.count(this.cols, {
          source: undefined
        }, '!==')) {
          /** @var will contain the original value of the column to reset it once the array is sorted */
          let tmpData = {};
          bbn.fn.each(this.cols, function (col) {
            if (col.source && col.field) {
              tmpData[col.field] = {};
              bbn.fn.each(data, function (d) {
                tmpData[col.field][d.index] = d.data[col.field];
                d.data[col.field] = d.data[col.field] ? bbn.fn.getField(col.source, col.sourceText ? col.sourceText : 'text', col.sourceValue ? col.sourceValue : 'value', d.data[col.field]) || '' : '';
              });
            }
          });
          data = bbn.fn.multiorder(data, JSON.parse(JSON.stringify(this.currentOrder)).map(item => {
            item.field = 'data.' + item.field;
            return item;
          }));
          bbn.fn.each(this.cols, col => {
            if (col.source && col.field) {
              bbn.fn.each(data, (d, i) => {
                d.data[col.field] = tmpData[col.field][d.index];
              });
            }
          });
        } else {
          data = bbn.fn.multiorder(data, JSON.parse(JSON.stringify(this.currentOrder)).map(item => {
            item.field = 'data.' + item.field;
            return item;
          }));
        }
      }

      // A new row being edited
      if (this.tmpRow) {
        res.push({
          index: -1,
          rowIndex: 0,
          rowKey: this.isAjax ? '-1-' + this.hashCfg : -1,
          data: this.tmpRow,
          selected: false,
          expander: false
        });
        this.editedIndex = -1;
        rowIndex++;
      }

      // If there's a group that will be the row index of its 1st value (where the expander is)
      let currentGroupIndex = -1,
        currentGroupRow = -1,
        isExpanded = false,
        groupNumCheckboxes = 0,
        groupNumChecked = 0,
        lastInGroup = false,
        expanderIndex = 0;
      while (data[i] && i < end) {
        let a = data[i].data;
        // True if the element is the last of its group
        lastInGroup = isGroup && (!data[i + 1] || data[i + 1].data[groupField] !== currentGroupValue);
        // Is a new group
        if (isGroup && currentGroupValue !== a[groupField]) {
          groupNumCheckboxes = 0;
          // If the row doesn't have the column
          if (a[groupField] === undefined || bbn.fn.isNull(a[groupField]) || a[groupField] === '') {
            currentGroupValue = null;
            currentGroupIndex = -1;
            isExpanded = true;
          } else {
            isExpanded = false;
            currentGroupValue = a[groupField];
            currentGroupIndex = data.index;
            currentGroupRow = res.length;
            let tmp = {
              group: true,
              index: data[i].index,
              value: currentGroupValue,
              data: a,
              rowIndex: rowIndex,
              rowKey: data[i].key,
              expander: true,
              num: bbn.fn.count(data, 'data.' + this.cols[this.group].field, currentGroupValue)
            };
            // Expanded is true: all is opened
            if (this.allExpanded) {
              isExpanded = true;
              if (this.currentExpandedValues.indexOf(currentGroupValue) === -1) {
                this.currentExpandedValues.push(currentGroupValue);
              }
            }
            // expandedValues is a function, which will be executed on each value
            else if (bbn.fn.isFunction(this.expandedValues)) {
              if (this.expandedValues(currentGroupValue) && this.currentExpandedValues.indexOf(currentGroupValue) === -1) {
                isExpanded = true;
              }
            }
            // The current group value should be opened
            else if (this.currentExpandedValues.indexOf(currentGroupValue) > -1) {
              isExpanded = true;
            }
            currentLink = res.length;
            if (!isExpanded && data[i - 1] && currentGroupValue === data[i - 1].data[groupField]) {
              if (res.length) {
                res.push(tmp);
              }
            } else {
              tmp.expanded = isExpanded;
              if (this.expander) {
                expanderIndex = tmp.index;
              }
              res.push(tmp);
              rowIndex++;
            }
          }
        } else if (this.expander) {
          let exp = bbn.fn.isFunction(this.expander) ? this.expander(data[i], i) : this.expander;
          isExpanded = exp ? this.currentExpanded.includes(data[i].index) || this.allExpanded : false;
          if (!isGroup) {
            let tmp = {
              index: data[i].index,
              data: a,
              rowIndex: rowIndex,
              rowKey: data[i].key,
              expander: true,
              expanded: isExpanded
            };
            if (this.selection && (!bbn.fn.isFunction(this.selection) || this.selection(tmp))) {
              tmp.selected = !this.uid && this.currentSelected.includes(data[i].index) || this.uid && this.currentSelected.includes(data[i].data[this.uid]);
              tmp.selection = true;
              groupNumCheckboxes++;
              if (tmp.selected) {
                groupNumChecked++;
              }
            }
            res.push(tmp);
            rowIndex++;
          }
        }
        if (!isGroup || isExpanded || !currentGroupValue || this.expander && (!bbn.fn.isFunction(this.expander) || this.expander(data[i], i))) {
          o = {
            index: data[i].index,
            data: a,
            rowIndex: rowIndex,
            rowKey: data[i].key
          };
          if (isGroup) {
            if (!currentGroupValue) {
              o.expanded = true;
            } else {
              o.isGrouped = true;
              o.link = currentLink;
              o.rowKey = o.rowIndex + '-' + o.rowKey;
            }
          }
          if (this.expander && (!bbn.fn.isFunction(this.expander) || this.expander(data[i], i))) {
            o.expansion = true;
            o.expanderIndex = expanderIndex;
            o.rowKey = rowIndex + '-' + data[i].key;
          }
          if (this.selection && (!o.isGrouped && !this.expander || o.isGrouped && !o.expander || o.isGrouped && o.expansion) && (!bbn.fn.isFunction(this.selection) || this.selection(o))) {
            o.selected = !this.uid && this.currentSelected.includes(data[i].index) || this.uid && this.currentSelected.includes(data[i].data[this.uid]);
            o.selection = true;
            groupNumCheckboxes++;
            if (o.selected) {
              groupNumChecked++;
            }
          }
          res.push(o);
          rowIndex++;
          if (isGroup && this.groupable && this.groupFooter && !this.expander && (!data[i + 1] || data[i + 1].data[groupField] !== data[i].data[groupField])) {
            res.push({
              index: data[i].index,
              data: bbn.fn.filter(data, v => {
                return v.data[groupField] === data[i].data[groupField];
              }),
              rowIndex: rowIndex,
              rowKey: data[i].key,
              isGrouped: true,
              footer: true,
              selection: false,
              expander: false
            });
            rowIndex++;
          }
        } else {
          end++;
        }
        // Group or just global aggregation
        if (aggregateModes.length) {
          bbn.fn.each(this.aggregatedColumns, ac => {
            let aggr = aggregates[ac.field];
            aggr.num++;
            aggr.tot += parseFloat(a[ac.field]);
            if (aggr.min === false) {
              aggr.min = parseFloat(a[ac.field]);
            } else if (aggr.min > parseFloat(a[ac.field])) {
              aggr.min = parseFloat(a[ac.field]);
            }
            if (aggr.max === false) {
              aggr.max = parseFloat(a[ac.field]);
            } else if (aggr.max < parseFloat(a[ac.field])) {
              aggr.max = parseFloat(a[ac.field]);
            }
            if (isGroup && currentGroupValue) {
              let searchRes = bbn.fn.search(aggr.groups, {
                value: currentGroupValue
              });
              if (searchRes === -1) {
                searchRes = aggr.groups.length;
                aggr.groups.push({
                  value: currentGroupValue,
                  tot: 0,
                  num: 0,
                  min: false,
                  max: false
                });
              }
              let b = aggr.groups[searchRes];
              b.num++;
              b.tot += parseFloat(a[ac.field]);
              if (b.min === false) {
                b.min = parseFloat(a[ac.field]);
              } else if (b.min > parseFloat(a[ac.field])) {
                b.min = parseFloat(a[ac.field]);
              }
              if (b.max === false) {
                b.max = parseFloat(a[ac.field]);
              } else if (b.max < parseFloat(a[ac.field])) {
                b.max = parseFloat(a[ac.field]);
              }
              if (isExpanded && (!data[i + 1] || i === end - 1 || currentGroupValue !== data[i + 1].data[this.cols[this.group].field])) {
                let b = aggr.groups[aggr.groups.length - 1];
                b.med = b.tot / b.num;
                bbn.fn.each(aggregateModes, c => {
                  let tmp = {};
                  tmp[ac.field] = b[c];
                  res.push({
                    index: data[i] ? data[i].index : 0,
                    rowIndex: rowIndex,
                    rowKey: 'a' + aggIndex + '-' + (data[i] ? data[i].key : rowIndex),
                    groupAggregated: true,
                    link: currentLink,
                    value: currentGroupValue,
                    name: c,
                    data: tmp
                  });
                  rowIndex++;
                  aggIndex++;
                });
              }
            }
            if (!data[i + 1] || i === end - 1) {
              aggr.med = aggr.tot / aggr.num;
              bbn.fn.each(aggregateModes, c => {
                let tmp = {};
                tmp[ac.field] = aggr[c];
                res.push({
                  index: data[i] ? data[i].index : 0,
                  rowIndex: rowIndex,
                  rowKey: 'a' + aggIndex + '-' + (data[i] ? data[i].key : rowIndex),
                  aggregated: true,
                  name: c,
                  data: tmp
                });
                rowIndex++;
                aggIndex++;
              });
            }
          });
        }
        if (isGroup && this.selection && lastInGroup && groupNumCheckboxes) {
          res[currentGroupRow].selection = true;
          res[currentGroupRow].selected = groupNumChecked === groupNumCheckboxes;
        }
        i++;
      }
      let fdata = [];
      res.forEach(d => {
        //if (d.group || d.expander || this.isExpanded(d) || d.aggregated || (this.isExpanded(d) && d.groupAggregated)) {
        if (d.group || d.expander || this.isExpanded(d) || d.aggregated || this.isExpanded(d) && d.groupAggregated || !!d.isFooter || !d.expander && !!d.expansion && this.isExpanded(bbn.fn.getRow(res, {
          index: d.expanderIndex,
          expander: true
        })) && (!bbn.fn.isFunction(this.expander) || !!this.expander(d))) {
          if (fdata.length) {
            d.rowIndex = fdata[fdata.length - 1].rowIndex + 1;
          }
          fdata.push(d);
        }
      });
      return fdata;
    },
    /**
     * Returns true if an expander is defined or if the table is groupable and the group is 'number'.
     * @computed hasExpander
     * @returns {Boolean}
     */
    hasExpander() {
      return this.expander || this.groupable && typeof this.group === 'number' && this.cols[this.group];
    },
    /**
     * The current columns of the table.
     * @computed currentColumns
     * @returns {Array}
     */
    currentColumns() {
      let r = [];
      bbn.fn.each([].concat(this.groupCols), (a, i) => {
        bbn.fn.each(a.cols, b => {
          r.push(bbn.fn.extend(true, {}, b, {
            fixed: i !== 1,
            isLeft: i === 0,
            isRight: i === 2,
            realWidth: b.realWidth ? b.realWidth + 'px' : 'auto'
          }));
        });
      });
      return r;
    },
    /**
     * Indicates whether the column for the expander should be shown
     * @computed expanderColumnVisible
     * @returns {Boolean}
     */
    expanderColumnVisible() {
      if (this.items && this.items.length) {
        return !!this.items.filter(i => !!i.expander).length;
      }
      return false;
    },
    currentMaxRowHeight() {
      return !!this.maxRowHeight ? this.maxRowHeight + 'px' : 'auto';
    }
  },
  methods: {
    buttonSource() {
      if (bbn.fn.isFunction(this.realButtons)) {
        return this.realButtons(...arguments);
      }
      if (bbn.fn.isArray(this.realButtons)) {
        return this.realButtons;
      }
      return [];
    },
    convertActions(arr, data, col, idx) {
      return bbn.fn.map(arr, a => {
        let b = bbn.fn.clone(a);
        if (a.action && bbn.fn.isFunction(a.action)) {
          b.action = e => {
            this._execCommand(a, data, col, idx, e);
          };
        }
        return b;
      });
    },
    getTrClass(row) {
      if (bbn.fn.isFunction(this.trClass)) {
        return this.trClass(row);
      }
      if (this.trClass) {
        return this.trClass;
      }
      return '';
    },
    getTrStyle(row) {
      if (bbn.fn.isFunction(this.trStyle)) {
        return this.trStyle(row);
      }
      if (this.trStyle) {
        return this.trStyle;
      }
      return '';
    },
    /**
     * Normalizes the row's data.
     * @method _defaultRow
     * @param initialData
     * @returns {Object}
     */
    _defaultRow(initialData) {
      let res = {},
        data = initialData ? bbn.fn.clone(initialData) : {};
      bbn.fn.each(this.cols, function (a) {
        if (a.field) {
          if (data[a.field] !== undefined) {
            res[a.field] = data[a.field];
          } else if (a.default !== undefined) {
            res[a.field] = bbn.fn.isFunction(a.default) ? a.default() : a.default;
          } else if (a.nullable) {
            res[a.field] = null;
          } else if (a.type) {
            switch (a.type) {
              case 'number':
              case 'money':
                res[a.field] = a.min > 0 ? a.min : 0;
                break;
              default:
                res[a.field] = '';
            }
          } else {
            res[a.field] = '';
          }
          if (bbn.fn.isArray(res[a.field])) {
            res[a.field] = res[a.field].slice();
          } else if (res[a.field] instanceof Date) {
            res[a.field] = new Date(res[a.field].getTime());
          } else if (null !== res[a.field] && typeof res[a.field] === 'object') {
            res[a.field] = bbn.fn.clone(res[a.field]);
          }
        }
      });
      return res;
    },
    /**
     * Prepares the data to export the table to CSV.
     * @method _export
     * @returns {Array}
     */
    _export() {
      let span = window.document.createElement('span');
      let cols = {};
      let res = [];
      bbn.fn.each(this.currentData, a => {
        let o = bbn.fn.clone(a.data);
        let row = [];
        bbn.fn.each(this.cols, b => {
          if (!b.hidden && !b.buttons && b.field) {
            if (typeof o[b.field] === 'string') {
              span.innerHTML = o[b.field];
              row.push(span.textContent.trim());
            } else {
              row.push(o[b.field]);
            }
          }
        });
        res.push(row);
      });
      return res;
    },
    /**
     * Executes the action of the button.
     *
     * @method _execCommand
     * @param {Object} button
     * @param {Object} data
     * @param {Object} col
     * @param {Number} index
     * @param {Event} ev
     * @returns {Function|Boolean}
     */
    _execCommand(button, data, col, index, ev) {
      if (ev) {
        ev.preventDefault();
        ev.stopImmediatePropagation();
      }
      //bbn.fn.log("EXEC COMMAND");
      if (button.action) {
        if (bbn.fn.isFunction(button.action)) {
          return button.action(data, col, index);
        } else if (typeof button.action === 'string') {
          switch (button.action) {
            case 'csv':
              return this.exportCSV();
            case 'excel':
              return this.exportExcel();
            case 'insert':
              return this.insert(data, {
                title: bbn._('New row creation')
              }, -1);
            case 'select':
              return this.select(index);
            case 'edit':
              return this.edit(data, {
                title: bbn._('Row edition')
              }, index);
            case 'add':
              return this.add(data);
            case 'copy':
              return this.copy(data, {
                title: bbn._('Row copy')
              }, index);
            case 'delete':
              return this.remove(index);
          }
        }
      }
      return false;
    },
    /**
     * Exports to csv and download the given filename.
     * @method exportCSV
     * @param {String} filename
     * @param {String} valSep
     * @param {String} rowSep
     * @param {String} valEsc
     * @fires _export
     */
    exportCSV(filename, valSep, rowSep, valEsc) {
      let data = bbn.fn.toCSV(this._export(), valSep, rowSep, valEsc);
      if (!filename) {
        filename = 'export-' + bbn.fn.dateSQL().replace('/:/g', '-') + '.csv';
      }
      bbn.fn.downloadContent(filename, data, 'csv');
    },
    /**
     * Exports to excel.
     * @method exportExcel
     * @fires getPostData
     */
    exportExcel() {
      if (this.isAjax && !this.isLoading) {
        if (this.pageable) {
          this.getPopup({
            title: bbn._('Warning'),
            content: '<div class="bbn-padded bbn-c">' + bbn._('What do you want to export?') + '</div>',
            buttons: [{
              text: bbn._('Cancel'),
              action: () => {
                this.getPopup().close();
              }
            }, {
              text: bbn._('This view'),
              action: () => {
                bbn.fn.postOut(this.source, this.getExcelPostData(true));
                this.getPopup().close();
              }
            }, {
              text: bbn._('All'),
              action: () => {
                bbn.fn.postOut(this.source, this.getExcelPostData());
                this.getPopup().close();
              }
            }],
            width: 300
          });
        } else {
          this.confirm(bbn._('Are you sure you want to export to Excel?'), () => {
            bbn.fn.postOut(this.source, this.getExcelPostData());
          });
        }
      }
    },
    /**
     * @method getExcelPostData
     * @param {Boolean} currentView 
     * @returns {Object}
     */
    getExcelPostData(currentView) {
      let cols = bbn.fn.filter(bbn.fn.extend(true, [], this.cols), c => {
          return this.shownFields.includes(c.field) && (c.export === undefined || !c.export.excluded) || c.export && !c.export.excluded;
        }),
        data = {
          excel: {
            fields: bbn.fn.map(cols, c => {
              return {
                field: c.field,
                // check if is present a custom 'title' on column's export property
                title: c.export && c.export.title ? c.export.title : c.title || '',
                // check if is present a custom 'type' on column's export property
                type: c.export && c.export.type ? c.export.type : c.type || 'string',
                hidden: c.export && c.export.hidden !== undefined ? +c.export.hidden : !this.shownFields.includes(c.field) ? 1 : 0,
                format: c.export && c.export.format ? c.export.format : null
              };
            })
          },
          // the current fields
          fields: bbn.fn.map(cols.slice(), f => {
            return f.field;
          }),
          limit: currentView ? this.currentLimit : 50000,
          start: currentView ? this.start : 0,
          data: this.getPostData()
        };
      if (this.sortable) {
        data.order = this.currentOrder;
      }
      if (this.isFilterable) {
        data.filters = this.currentFilters;
      }
      return data;
    },
    /**
     * Opens a popup showing the database query.
     * @method showQuery 
     */
    showQuery() {
      if (this.currentQuery) {
        this.getPopup({
          title: bbn._('Database query and parameters'),
          scrollable: true,
          component: {
            template: `
<div class="bbn-block bbn-spadded">
  <h3 @click="showValues = !showValues"
      v-text="showValues ? _('Hide the values') : _('Show the values')"
      class="bbn-p"></h3>
  <ol class="bbn-space-bottom" v-if="showValues">
    <li v-for="v in source.values" v-text="v"></li>
  </ol>
  <pre v-text="source.query"></pre>
</div>
              `,
            props: ['source'],
            data() {
              return {
                showValues: false
              };
            }
          },
          closable: true,
          source: {
            query: this.currentQuery,
            values: this.currentQueryValues
          }
        });
      }
    },
    /**
     * Returns true if a column is editable.
     * @method isEditable
     * @param {Object} row
     * @param {Object} col
     * @param {Number} index
     * @returns {Boolean}
     */
    isEditable(row, col, index) {
      if (!this.editable) {
        return false;
      }
      if (bbn.fn.isFunction(col.editable)) {
        return col.editable(row, col, index);
      }
      return col.editable !== false;
    },
    /**
     * Returns true if the given row is edited.
     * @method isEdited
     * @param {Object} data
     * @param {Object} col
     * @param {Number} idx
     * @fires isEditable
     * @returns {Boolean}
     */
    isEdited(data, col, idx) {
      return this.isEditable(data, col, idx) && this.editMode === 'inline' && this.items[idx].index === this.editedIndex;
    },
    /**
     * Returns the configuration for the cells of the titles of grouped columns.
     * @method titleGroupsCells
     * @param {Number} groupIndex
     * @returns {Array}
     */
    titleGroupsCells(groupIndex) {
      if (this.titleGroups) {
        let cells = [],
          group = null,
          corresp = {};
        bbn.fn.each(this.groupCols[groupIndex].cols, a => {
          if (!a.hidden) {
            if (a.group === group) {
              cells[cells.length - 1].colspan++;
              cells[cells.length - 1].width += a.realWidth;
              if (a.left !== undefined) {
                if (cells[cells.length - 1].left === undefined || a.left < cells[cells.length - 1].left) {
                  cells[cells.length - 1].left = a.left;
                }
              }
              if (a.right !== undefined) {
                if (cells[cells.length - 1].right === undefined || a.right < cells[cells.length - 1].right) {
                  cells[cells.length - 1].right = a.right;
                }
              }
            } else {
              if (corresp[a.group] === undefined) {
                let idx = bbn.fn.search(this.titleGroups, 'value', a.group);
                if (idx > -1) {
                  corresp[a.group] = idx;
                }
              }
              if (corresp[a.group] !== undefined) {
                cells.push({
                  text: this.titleGroups[corresp[a.group]].text || '&nbsp;',
                  style: this.titleGroups[corresp[a.group]].style || {},
                  cls: this.titleGroups[corresp[a.group]].cls || '',
                  colspan: 1,
                  width: a.realWidth,
                  left: a.left !== undefined ? a.left : undefined,
                  right: a.right !== undefined ? a.right : undefined
                });
              }
              /*
              else if ( this.titleGroups.default ){
                cells.push({
                  text: this.titleGroups.default.text || '&nbsp;',
                  style: this.titleGroups.default.style || {},
                  cls: this.titleGroups.default.cls || '',
                  colspan: 1,
                  width: a.realWidth
                });
              }
              */else {
                cells.push({
                  text: '&nbsp;',
                  style: '',
                  cls: '',
                  colspan: 1,
                  width: a.realWidth,
                  left: a.left !== undefined ? a.left : undefined,
                  right: a.right !== undefined ? a.right : undefined
                });
              }
              group = a.group;
            }
          }
        });
        return cells;
      }
    },
    /**
     * Returns true if the table has currentFilters defined for the given column.
     * @method hasFilter
     * @param {Object} col The column
     * @returns {Boolean}
     */
    hasFilter(col) {
      if (col.field) {
        for (let i = 0; i < this.currentFilters.conditions.length; i++) {
          if (this.currentFilters.conditions[i].field === col.field) {
            return true;
          }
        }
      }
      return false;
    },
    /**
     * The behavior of the component at mouseMove.
     * @method moveMouse
     * @param {Event} e
     * @fires keepCool
     * @fires checkFilterWindow
     */
    moveMouse(e) {
      this.keepCool(() => {
        this.checkFilterWindow(e);
      }, 'moveMouse');
    },
    /**
     * Handles the floatingFilterTimeOut.
     * @method checkFilterWindow
     * @param {Event} e
     */
    checkFilterWindow(e) {
      if (this.currentFilter) {
        if (this.floatingFilterTimeOut) {
          clearTimeout(this.floatingFilterTimeOut);
        }
        if (e.clientX < this.floatingFilterX || e.clientX > this.floatingFilterX + 600 || e.clientY < this.floatingFilterY || e.clientY > this.floatingFilterY + 200) {
          if (!this.floatingFilterTimeOut) {
            this.floatingFilterTimeOut = setTimeout(() => {
              this.currentFilter = false;
              this.editedFilter = false;
            }, 500);
          }
        } else {
          this.floatingFilterTimeOut = 0;
        }
      }
    },
    /**
     * Returns the options for the bind of the table filter.
     *
     * @method getFilterOptions
     * @fires getColFilters
     * @returns {Object}
     */
    getFilterOptions() {
      if (this.currentFilter) {
        let o = this.editorGetComponentOptions(this.currentFilter);
        if (o.field) {
          o.conditions = this.getColFilters(this.currentFilter);
        }
        if (o.conditions.length) {
          o.value = o.conditions[0].value;
          o.operator = o.conditions[0].operator;
          this.editedFilter = o.conditions[0];
        }
        o.multi = false;
        return o;
      }
    },
    /**
     * Opens the popup containing the multifilter.
     * @method openMultiFilter
     */
    openMultiFilter() {
      this.currentFilter = false;
      let table = this;
      this.getPopup({
        title: bbn._('Multiple filters'),
        component: {
          template: `<bbn-scroll><bbn-filter v-bind="source" @change="changeConditions" :multi="true"></bbn-filter></bbn-scroll>`,
          props: ['source'],
          methods: {
            changeConditions(o) {
              table.currentFilters.logic = o.logic;
              table.currentFilters.conditions = o.conditions;
            }
          }
        },
        width: '90%',
        height: '90%',
        source: {
          fields: bbn.fn.filter(this.cols, a => {
            return a.filterable !== false && !a.buttons;
          }),
          conditions: this.currentFilters.conditions,
          logic: this.currentFilters.logic
        }
      });
    },
    /**
     * Returns the filter of the given column.
     * @method getColFilters
     * @param {Object} col
     * @returns {Object}
     */
    getColFilters(col) {
      let r = [];
      if (col.field) {
        bbn.fn.each(this.currentFilters.conditions, a => {
          if (a.field === col.field) {
            r.push(a);
          }
        });
      }
      return r;
    },
    /**
     * Shows the filter of the column.
     * @method showFilter
     * @param {Object} col
     * @param {Event} ev
     */
    showFilter(col, ev) {
      //bbn.fn.log(ev);
      this.filterElement = ev.target;
      this.floatingFilterX = ev.pageX - 10 < 0 ? 0 : ev.pageX - 10 + 600 > this.$el.clientWidth ? this.$el.clientWidth - 600 : ev.pageX - 10;
      this.floatingFilterY = ev.pageY - 10 < 0 ? 0 : ev.pageY - 10 + 200 > this.$el.clientHeight ? this.$el.clientHeight - 200 : ev.pageY - 10;
      this.currentFilter = col;
    },
    /**
     * Returns the list of the showable columns
     * @method pickableColumnList
     * @returns {Array}
     */
    pickableColumnList() {
      return this.cols.slice().map(a => {
        return a.showable !== false;
      });
    },
    /**
     * Opens the popup containing the column picker.
     * @method openColumnsPicker
     */
    openColumnsPicker() {
      let table = this;
      this.getPopup({
        title: bbn._("Columns' picker"),
        height: '90%',
        width: '90%',
        component: {
          template: `
<div class="bbn-table-column-picker">
  <bbn-form ref="scroll"
            :source="formData"
            :scrollable="true"
            :prefilled="true"
            @success="applyColumnsShown">
    <div class="bbn-padded">
      <ul v-if="source.titleGroups">
        <li v-for="(tg, idx) in source.titleGroups">
          <h3>
            <bbn-checkbox :checked="allVisible(tg.value)"
                          @change="checkAll(tg.value)"
                          :label="tg.text"/>
          </h3>
          <ul>
            <li v-for="(col, i) in source.cols"
                v-if="!col.fixed && (col.group === tg.value) && (col.showable !== false) && (col.title || col.ftitle)">
              <bbn-checkbox :checked="shownCols[i]"
                            @change="check(col, i)"
                            :label="col.ftitle || col.title"
                            :contrary="true"/>
            </li>
          </ul>
        </li>
      </ul>
      <ul v-else>
        <li v-for="(col, i) in source.cols"
            v-if="!col.fixed && (col.showable !== false) && (col.title || col.ftitle)">
          <bbn-checkbox :checked="shownCols[i]"
                        @change="check(col, i)"
                        :label="col.ftitle || col.title"
                        :contrary="true"/>
        </li>
      </ul>
    </div>
  </bbn-form>
</div>
`,
          props: ['source'],
          data() {
            let shownColumns = this.source.cols.map(a => !a.hidden);
            return {
              table: table,
              formData: {
                changed: false
              },
              shownCols: shownColumns
            };
          },
          methods: {
            applyColumnsShown() {
              let toShow = [],
                toHide = [];
              bbn.fn.each(this.source.cols, (a, i) => {
                if (a.hidden == this.shownCols[i]) {
                  if (this.shownCols[i]) {
                    toShow.push(i);
                  } else {
                    toHide.push(i);
                  }
                }
              });
              if (toShow.length) {
                table.show(toShow);
              }
              if (toHide.length) {
                table.show(toHide, true);
              }
            },
            allVisible(group) {
              let ok = true;
              //bbn.fn.log("allVisible", group);
              bbn.fn.each(this.source.cols, (a, i) => {
                if (a.showable !== false && a.group === group && !a.fixed) {
                  if (!this.shownCols[i]) {
                    ok = false;
                    //bbn.fn.log("NOT ALL VISIBLE!!!!!!!!!!!!!!!!!!!!!!", a);
                    return false;
                  }
                }
              });
              return ok;
            },
            check(col, index) {
              this.$set(this.shownCols, index, !this.shownCols[index]);
            },
            checkAll(group) {
              let show = !this.allVisible(group),
                shown = [];
              bbn.fn.each(this.source.cols, (a, i) => {
                if (a.showable !== false && a.group === group && !a.fixed) {
                  if (this.shownCols[i] != show) {
                    this.shownCols.splice(i, 1, show);
                  }
                }
              });
              this.$forceUpdate();
              //bbn.fn.log('forceupdate3');
            }
          },

          watch: {
            shownCols: {
              deep: true,
              handler() {
                this.formData.changed = true;
              }
            }
          }
        },
        source: {
          cols: this.cols,
          titleGroups: this.titleGroups
        }
      });
    },
    /**
     * Returns wheter or not the cell is grouped.
     * @method isGroupedCell
     * @param {Number} groupIndex
     * @param {Object} row
     * @returns {Boolean}
     */
    isGroupedCell(groupIndex, row) {
      if (this.groupable && row.group) {
        if (this.groupCols[0].width > 200) {
          return groupIndex === 0;
        } else {
          return groupIndex === 1;
        }
      }
      return false;
    },
    /**
     * Returns the current configuration of the table.
     * @method getConfig
     * @returns {Object}
     */
    getConfig() {
      return {
        searchValue: this.searchValue,
        limit: this.currentLimit,
        order: this.currentOrder,
        filters: this.currentFilters,
        hidden: this.currentHidden
      };
    },
    /**
     * Returns the columns configuration.
     * @method getColumnsConfig
     * @returns {Array}
     */
    getColumnsConfig() {
      return JSON.parse(JSON.stringify(this.cols));
    },
    /**
     * Sets the current config of the table.
     * @method setConfig
     * @param {Object} cfg
     * @param {Boolean} no_storage
     * @fires getConfig
     * @fires setStorage
     */
    setConfig(cfg, no_storage) {
      if (cfg === false) {
        cfg = bbn.fn.clone(this.defaultConfig);
      } else if (cfg === true) {
        cfg = this.getConfig();
      }
      if (cfg && cfg.limit) {
        if (this.filterable && cfg.filters && this.currentFilters !== cfg.filters) {
          this.currentFilters = cfg.filters;
        }
        if (this.pageable && this.currentLimit !== cfg.limit) {
          this.currentLimit = cfg.limit;
        }
        if (this.search) {
          this.searchValue = cfg.searchValue || '';
        }
        if (this.sortable && this.currentOrder !== cfg.order) {
          if (bbn.fn.isObject(cfg.order)) {
            let currentOrder = [];
            bbn.fn.iterate(cfg.order, (v, n) => {
              currentOrder.push({
                field: n,
                dir: v.toUpperCase() === 'DESC' ? 'DESC' : 'ASC'
              });
            });
            this.currentOrder = currentOrder;
          } else if (bbn.fn.isArray(cfg.order)) {
            this.currentOrder = cfg.order;
          }
        }
        if (this.showable) {
          if (cfg.hidden !== undefined && cfg.hidden !== this.currentHidden) {
            this.currentHidden = cfg.hidden;
          }
          bbn.fn.each(this.cols, (a, i) => {
            let hidden = this.currentHidden.indexOf(i) > -1;
            if (a.hidden !== hidden) {
              //bbn.fn.log("CHANGING HIDDEN");
              this.$set(this.cols[i], 'hidden', hidden);
            }
          });
        }
        this.currentConfig = {
          searchValue: this.searchValue,
          limit: this.currentLimit,
          order: this.currentOrder,
          filters: this.currentFilters,
          hidden: this.currentHidden
        };
        if (!no_storage) {
          this.setStorage(this.currentConfig);
        }
      }
    },
    /**
     * Saves the current configuration.
     * @method save
     */
    save() {
      this.savedConfig = this.jsonConfig;
    },
    beforeSelect(index, ev) {
      this.$emit('beforeselect', ev, index, this.items[index]);
    },
    /**
     * Emits 'select',  'unselect' or 'toggle' at change of checkbox of the row in a selectable table.
     * @method checkSelection
     * @param {Number}  index
     * @param {Boolean} index
     * @emit unselect
     * @emit select
     * @emit toggle
     */
    checkSelection(index, state) {
      if (this.cancelSelection) {
        this.cancelSelection = false;
        return;
      }
      let row = this.items[index];
      if (row) {
        if (this.groupable && row.group) {
          if (row.expanded) {
            bbn.fn.fori((d, i) => {
              if (d && d.selection && d.data[this.cols[this.group].field] === row.value) {
                this.checkSelection(i, state);
              }
            }, this.items, index + row.num, index + 1);
          }
        } else if (row.selection) {
          let idx = this.currentSelected.indexOf(this.uid ? this.currentData[row.index].data[this.uid] : row.index);
          let isSelected = false;
          let toggled = false;
          if (idx > -1) {
            if ([undefined, false].includes(state)) {
              toggled = true;
              this.$emit('unselect', row.data);
              this.currentSelected.splice(idx, 1);
            }
          } else if ([undefined, true].includes(state)) {
            toggled = true;
            this.$emit('select', row.data);
            this.currentSelected.push(this.uid ? this.currentData[row.index].data[this.uid] : row.index);
            isSelected = true;
          }
          if (toggled) {
            this.$emit('toggle', isSelected, this.currentData[row.index].data);
          }
        }
      }
    },
    /**
     * Refresh the current data set.
     *
     * @method updateData
     * @param withoutOriginal
     * @fires _removeTmp
     * @fires init
     */
    updateData(withoutOriginal) {
      /** Mini reset?? */
      this.isTableDataUpdating = true;
      this.allRowsChecked = false;
      this.currentExpanded = [];
      this._removeTmp();
      this.editedRow = false;
      this.editedIndex = false;
      this.$forceUpdate();
      //bbn.fn.log('forceupdate4');
      return bbn.cp.mixins.list.methods.updateData.apply(this, [withoutOriginal]).then(() => {
        if (this.currentData.length && this.selection && this.currentSelected.length && !this.uid) {
          this.currentSelected = [];
        }
        if (this.editable) {
          this.originalData = JSON.parse(JSON.stringify(this.currentData.map(a => {
            return a.data;
          })));
        }
        const pager = this.getRef('pager');
        if (pager) {
          pager.$forceUpdate();
        }
        this.isTableDataUpdating = false;
      });
    },
    /**
     * Return true if the given row is changed from originalData.
     * @method isDirty
     * @param {Object} row
     * @param {Object} col
     * @param {Number} idx
     */
    isDirty(row, col, idx) {
      return this.isBatch && col && row.index !== this.editedIndex && !row.aggregated && !row.groupAggregated && col.editable !== false && col.field && this.originalData && this.originalData[row.index] && row.data[col.field] != this.originalData[row.index][col.field];
    },
    /**
     * Returns the css class of the given column.
     * @method currentClass
     * @param {Object} column
     * @param {Object} data
     * @param {Number} index
     */
    currentClass(column, data, index) {
      let tr = this.trClass ? bbn.fn.isFunction(this.trClass) ? this.trClass(data) : this.trClass : '';
      if (column.cls) {
        return (!!tr ? tr + ' ' : '') + (bbn.fn.isFunction(column.cls) ? column.cls(data, index, column) : column.cls);
      }
      return tr || '';
    },
    /**
     * Returns true if the given column is sorted.
     * @method isSorted
     * @param {Object} col
     */
    isSorted(col) {
      if (this.sortable && col.sortable !== false && !col.buttons && col.field) {
        let idx = bbn.fn.search(this.currentOrder, {
          field: col.field
        });
        if (idx > -1) {
          return this.currentOrder[idx];
        }
      }
      return false;
    },
    /**
     * Sorts the given column.
     * @method sort
     * @param {Object} col
     * @fires updateData
     */
    sort(col) {
      if (!this.isLoading && this.sortable && col.field && col.sortable !== false) {
        let f = col.field,
          pos = bbn.fn.search(this.currentOrder, {
            field: f
          });
        if (pos > -1) {
          if (this.currentOrder[pos].dir === 'ASC') {
            this.currentOrder[pos].dir = 'DESC';
          } else {
            this.currentOrder.splice(0, this.currentOrder.length);
          }
        } else {
          this.currentOrder.splice(0, this.currentOrder.length);
          this.currentOrder.push({
            field: f,
            dir: 'ASC'
          });
        }
        if (this.isAjax) {
          this.updateData();
        }
      }
    },
    /**
     * Deprecated. Not removed for backwards compatibility.
     * @method updateTable
     */
    updateTable() {
      return;
    },
    /**
     * Renders a cell according to column's config.
     * @method render
     * @param {Object} data
     * @param {Object} column
     * @param {Number} index
     * @fires renderData
     * @returns {Function}
     */
    render(data, column, index) {
      let value = data && this.isValidField(column.field) ? data[column.field] : undefined;
      if (column.render) {
        return column.render(data, column, index, value);
      }
      return this.renderData(data, column, index);
    },
    /**
     * Resets configuration of the table.
     * @method reset
     * @param noCfg
     * @fires setConfig
     * @fires init
     */
    reset(noCfg) {
      this.initReady = false;
      this.$emit('reset', this);
      if (!noCfg) {
        this.setConfig(false);
      }
      this.init();
    },
    /**
     * Adds the given column to table's configuration
     * @method addColumn
     * @param {Object} obj
     */
    addColumn(obj) {
      if (!obj) {
        return;
      }
      let def = this.defaultObject();
      if (obj.aggregate && !Array.isArray(obj.aggregate)) {
        obj.aggregate = [obj.aggregate];
      }
      for (let n in obj) {
        def[bbn.fn.camelize(n)] = obj[n];
      }
      if (!!obj.buttons) {
        def.filterable = false;
        def.sortable = false;
      }
      this.cols.push(def);
    },
    /**
     * Return true if the cell is before aggregated cells.
     * @method isBeforeAggregated
     * @param {Number} groupIndex
     * @param {Number} idx
     * @returns {Boolean}
     */
    isBeforeAggregated(groupIndex, idx) {
      return this.isAggregated && (this.groupCols[groupIndex].cols[idx + 1] && this.groupCols[groupIndex].cols[idx + 1].field === this.isAggregated || !this.groupCols[groupIndex].cols[idx + 1] && this.groupCols[groupIndex + 1] && this.groupCols[groupIndex + 1].cols[0] && this.groupCols[groupIndex + 1].cols[0].field === this.isAggregated);
    },
    /**
     * Returns an object of numbers as width and height based on whatever unit given.
     * 
     * @method getDimensions
     * @param {Number} width
     * @param {Number} height
     * @return {Number}
     */
    getDimensionWidth(width) {
      if (bbn.fn.isNumber(width) && width) {
        return parseInt(width);
      }
      let parent = this.$el || this.$root.$el;
      let r = 0;
      if (parent && width) {
        if (!parent.insertAdjacentElement) {
          return 0;
        }
        let el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.opacity = 0;
        el.className = 'bbn-reset';
        el.style.width = this.formatSize(width);
        try {
          parent.insertAdjacentElement('beforeend', el);
        } catch (e) {
          bbn.fn.log("Error while inserting adjacent element for dimensioncalculation", e, this.$el);
          return 0;
        }
        r = el.offsetWidth || el.clientWidth || 0;
        el.remove();
      }
      return r;
    },
    /**
     * Resizes the table.
     * @method resizeWidth
     * @returns {bbnCp}
     */
    resizeWidth() {
      let currentTot = this.groupCols[0].width + this.groupCols[1].width + this.groupCols[2].width,
        parentWidth = this.$el.offsetParent ? this.$el.offsetParent.getBoundingClientRect().width : this.lastKnownCtWidth,
        diff = parentWidth - this.borderLeft - this.borderRight - currentTot,
        numDynCols = this.currentColumns.filter(c => c.width === undefined && !c.isExpander && !c.isSelection && !c.hidden).length,
        numStaticCols = this.currentColumns.filter(c => !!c.width && !c.isExpander && !c.isSelection && !c.hidden).length,
        newWidth = numDynCols || numStaticCols ? diff / (numDynCols || numStaticCols) : 0;
      if (newWidth) {
        this.isResizingWidth = true;
        bbn.fn.each(this.groupCols, (groupCol, groupIdx) => {
          let sum = 0,
            sumRight = 0,
            sumLeft = 0;
          bbn.fn.each(groupIdx !== 2 ? groupCol.cols : groupCol.cols.slice().reverse(), col => {
            if (!col.hidden) {
              if (!col.isExpander && !col.isSelection && (!!numDynCols && col.width === undefined || !numDynCols && !!numStaticCols && !!col.width)) {
                let tmp = col.realWidth + newWidth;
                if (col.width !== undefined && (!bbn.fn.isString(col.width) || bbn.fn.isNumber(bbn.fn.substr(col.width, -1)))) {
                  if (tmp < parseFloat(col.width)) {
                    tmp = parseFloat(col.width);
                  }
                } else if (tmp < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {
                  tmp = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;
                }
                let minWidth = this.getDimensionWidth(col.minWidth);
                let maxWidth = this.getDimensionWidth(col.maxWidth);
                if (col.minWidth && tmp < minWidth) {
                  tmp = minWidth;
                }
                if (col.maxWidth && tmp > maxWidth) {
                  tmp = maxWidth;
                }
                this.$set(col, 'realWidth', tmp);
              }
              sum += col.realWidth;
              if (groupIdx === 0) {
                this.$set(col, 'left', sumLeft);
                sumLeft += col.realWidth;
              }
              if (groupIdx === 2) {
                this.$set(col, 'right', sumRight);
                sumRight += col.realWidth;
              }
            }
          });
          this.$set(this.groupCols[groupIdx], 'width', sum);
          sum = 0;
          sumLeft = 0;
          sumRight = 0;
        });
        this.isResizingWidth = false;
      }
      return this;
    },
    /**
     * Returns if the given row is expanded.
     * @method isExpanded
     * @param {Object} d
     * @returns {boolean}
     */
    isExpanded(d) {
      if (this.allExpanded) {
        return true;
      }
      if (!this.expander && (this.group === false || !this.groupable)) {
        return true;
      }
      if (this.expander && !this.groupable) {
        return this.currentExpanded.includes(d.index);
      }
      if (this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field) {
        if (d.data[this.cols[this.group].field] !== undefined) {
          return this.currentExpandedValues.includes(d.data[this.cols[this.group].field]);
        }
        return true;
      }
      if ((d.isGrouped || d.groupAggregated) && this.currentExpanded.includes(d.link)) {
        return true;
      }
      return false;
    },
    /**
     * Toggles the expander of the row corresponding to the given idx.
     * @method toggleExpanded
     * @param {Number} idx
     */
    toggleExpanded(idx) {
      if (this.currentData[idx]) {
        if (this.allExpanded) {
          this.allExpanded = false;
        }
        if (this.groupable && this.group !== false && this.cols[this.group] && this.cols[this.group].field && this.currentData[idx].data[this.cols[this.group].field] !== undefined) {
          let groupValue = this.currentData[idx].data[this.cols[this.group].field],
            groupIndex = this.currentExpandedValues.indexOf(groupValue);
          if (groupIndex > -1) {
            this.currentExpandedValues.splice(groupIndex, 1);
          } else {
            this.currentExpandedValues.push(groupValue);
          }
        } else {
          let i = this.currentExpanded.indexOf(idx);
          if (i > -1) {
            this.currentExpanded.splice(i, 1);
          } else {
            this.currentExpanded.push(idx);
          }
        }
      }
    },
    /**
     * Returns wheter or not the given row has the expander.
     * @method rowHasExpander
     * @param d
     * @returns {Boolean}
     */
    rowHasExpander(d) {
      if (this.hasExpander) {
        if (!bbn.fn.isFunction(this.expander)) {
          return true;
        }
        return !!this.expander(d);
      }
      return false;
    },
    /**
     * Returns true if the given index is selected.
     * @method isSelected
     * @param {Number} index
     * @returns {Boolean}
     */
    isSelected(index) {
      return this.selection && (!this.uid && this.currentSelected.includes(index) || this.uid && this.currentSelected.includes(this.currentData[index].data[this.uid]));
    },
    /**
     * Returns true if the given row has td.
     *
     * @method hasTd
     * @param {Object} data
     * @param {Number} colIndex
     * @param {Number} groupIndex
     */
    hasTd(data, colIndex, groupIndex) {
      let tdIndex = colIndex;
      for (let i = 0; i < groupIndex; i++) {
        tdIndex += this.groupCols[groupIndex].cols.length;
      }
      if (data.selection) {
        if (tdIndex === 0) {
          return false;
        } else if (data.group || data.expander) {
          if (tdIndex === 1) {
            return false;
          }
        }
      }
      if (data.group || data.expander) {
        if (tdIndex === 0) {
          return false;
        }
      }
      if (data.group || data.expansion) {
        return false;
      }
      if (data.hidden) {
        return false;
      }
      return true;
    },
    /**
     * Initializes the table.
     * @method init
     * @param {Boolean} with_data
     * @fires updateData
     */
    init(with_data) {
      bbn.fn.warning("INIT TABLE");
      this.initStarted = true;
      this.setContainerMeasures();
      this.setResizeMeasures();
      let groupCols = [{
          name: 'left',
          width: 0,
          visible: 0,
          cols: []
        }, {
          name: 'main',
          width: 0,
          visible: 0,
          cols: []
        }, {
          name: 'right',
          width: 0,
          visible: 0,
          cols: []
        }],
        numUnknown = 0,
        colButtons = false,
        isAggregated = false,
        aggregatedColIndex = false,
        aggregatedColTitle = false,
        aggregatedColumns = [],
        parentWidth = this.$el.offsetParent ? this.$el.offsetParent.getBoundingClientRect().width : this.lastKnownCtWidth;
      this.groupCols.splice(0, this.groupCols.length, ...groupCols);
      bbn.fn.each(this.cols, a => {
        a.realWidth = 0;
      });
      bbn.fn.each(this.cols, (a, i) => {
        if (!a.hidden && (!this.groupable || this.group !== i)) {
          let minWidth = null;
          let maxWidth = null;
          if (a.minWidth) {
            minWidth = this.getDimensionWidth(a.minWidth);
          }
          if (a.maxWidth) {
            maxWidth = this.getDimensionWidth(a.maxWidth);
          }
          a.index = i;
          if (a.hidden) {
            a.realWidth = 0;
          } else {
            if (this.aggregate && a.aggregate) {
              if (aggregatedColIndex === false) {
                aggregatedColIndex = i;
                isAggregated = true;
              }
              aggregatedColumns.push(a);
            }
            if (a.width) {
              if (bbn.fn.isString(a.width) && bbn.fn.substr(a.width, -1) === '%') {
                a.realWidth = Math.floor(parentWidth * this.getDimensionWidth(a.width) / 100);
                if (a.realWidth < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {
                  a.realWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;
                }
              } else {
                a.realWidth = this.getDimensionWidth(a.width);
              }
            } else {
              a.realWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;
              numUnknown++;
            }
            if (minWidth && a.realWidth < minWidth) {
              a.realWidth = minWidth;
            }
            if (maxWidth && a.realWidth > maxWidth) {
              a.realWidth = maxWidth;
            }
            if (a.buttons !== undefined) {
              colButtons = i;
            }
            if (a.fixed) {
              if (a.fixed === 'left' || a.fixed !== 'right' && this.fixedDefaultSide === 'left') {
                if (a.buttons !== undefined) {
                  //colButtons = groupCols[0].cols.length;
                }
                groupCols[0].cols.push(a);
                if (!a.hidden) {
                  groupCols[0].visible++;
                }
              } else {
                if (a.buttons !== undefined) {
                  //colButtons = groupCols[0].cols.length + groupCols[1].cols.length + groupCols[2].cols.length;
                }
                groupCols[2].cols.push(a);
                if (!a.hidden) {
                  groupCols[2].visible++;
                }
              }
            } else {
              if (a.buttons !== undefined) {
                //colButtons = groupCols[0].cols.length + groupCols[1].cols.length;
              }
              groupCols[1].cols.push(a);
              if (!a.hidden) {
                groupCols[1].visible++;
              }
            }
          }
        }
      });
      let firstGroup = groupCols[0].visible ? 0 : 1;
      if (this.selection) {
        let o = {
          isExpander: false,
          isSelection: true,
          title: ' ',
          filterable: false,
          width: 40,
          realWidth: 40
        };
        if (firstGroup === 0) {
          o.fixed = true;
          o.isLeft = true;
        }
        groupCols[firstGroup].cols.unshift(o);
        groupCols[firstGroup].visible++;
      }
      if (this.hasExpander) {
        let o = {
          isExpander: true,
          isSelection: false,
          title: ' ',
          filterable: false,
          width: 30,
          realWidth: 30
        };
        if (firstGroup === 0) {
          o.fixed = true;
          o.isLeft = true;
        }
        groupCols[firstGroup].cols.unshift(o);
        groupCols[firstGroup].visible++;
      }
      let tot = 0;
      bbn.fn.each(groupCols, a => {
        a.sum = bbn.fn.sum(a.cols, 'realWidth');
        tot += a.sum;
      });
      let styles = window.getComputedStyle(this.$el),
        borderLeft = styles.getPropertyValue('border-left-width').slice(0, -2),
        borderRight = styles.getPropertyValue('border-right-width').slice(0, -2),
        toFill = parentWidth - borderLeft - borderRight - tot;
      this.borderLeft = borderLeft;
      this.borderRight = borderRight;
      // We must arrive to 100% minimum
      if (toFill > 0) {
        if (numUnknown) {
          let newWidth = toFill / numUnknown;
          if (newWidth < (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth)) {
            newWidth = bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth;
          }
          let maxPreAggregatedWidth = 0;
          bbn.fn.each(this.cols, (a, i) => {
            if (!a.hidden) {
              if (!a.width) {
                a.realWidth = newWidth + (bbn.fn.isMobile() ? this.minimumColumnWidthMobile : this.minimumColumnWidth);
              }
              if (isAggregated && i < aggregatedColIndex && a.realWidth >= maxPreAggregatedWidth) {
                maxPreAggregatedWidth = a.realWidth;
                aggregatedColTitle = a;
              }
            }
          });
        }
        // Otherwise we dispatch it through the existing column
        else {
          let num = this.numVisible;
          let ignore = 0;
          if (this.hasExpander) {
            num--;
            ignore++;
          }
          if (this.selection) {
            num--;
            ignore++;
          }
          //let bonus = Math.floor(toFill / num * 100) / 100;
          let bonus = toFill / num;
          let maxPreAggregatedWidth = 0;
          bbn.fn.each(this.cols, (a, i) => {
            if (!a.hidden && i >= ignore) {
              a.realWidth += bonus;
              if (isAggregated && i < aggregatedColIndex && a.realWidth >= maxPreAggregatedWidth) {
                maxPreAggregatedWidth = a.realWidth;
                aggregatedColTitle = a;
              }
            }
          });
        }
      }
      if (aggregatedColTitle) {
        aggregatedColTitle.isAggregatedTitle = true;
      }
      let sum = 0,
        sumLeft = 0,
        sumRight = 0;
      bbn.fn.each(groupCols, (a, i) => {
        bbn.fn.each(i !== 2 ? a.cols : a.cols.slice().reverse(), c => {
          if (!c.hidden) {
            sum += c.realWidth;
            if (i === 0) {
              c.left = sumLeft;
              sumLeft += c.realWidth;
            } else if (i === 2) {
              c.right = sumRight;
              sumRight += c.realWidth;
            }
          }
        });
        a.width = sum;
        sum = 0;
        sumLeft = 0;
        sumRight = 0;
      });
      this.groupCols.splice(0, this.groupCols.length, ...groupCols);
      this.colButtons = colButtons;
      this.isAggregated = isAggregated;
      this.aggregatedColumns = aggregatedColumns;
      this.resizeWidth();
      this.initReady = true;
      if (with_data) {
        this.$once('dataloaded', () => {
          this.initStarted = false;
        });
        this.updateData();
      } else {
        this.initStarted = false;
      }
      this.$forceUpdate();
      //bbn.fn.log('forceupdate5');
    },

    /**
     * Prevents default if enter or tab keys are pressed.
     * @method keydown
     * @param {Event} e
     */
    keydown(e) {
      if (this.isBatch && this.editedRow && e.which === 9 || e.which === 13) {
        e.preventDefault();
      }
    },
    /**
     * Show or hide the given column index.
     * @method show
     * @param {Array} colIndexes
     * @param {Boolean} hide
     * @fires $forceUpdate
     * @fires setConfig
     * @fires init
     */
    show(colIndexes, hide) {
      if (!Array.isArray(colIndexes)) {
        colIndexes = [colIndexes];
      }
      bbn.fn.each(colIndexes, colIndex => {
        if (this.cols[colIndex]) {
          if (this.cols[colIndex].hidden && !hide || !this.cols[colIndex].hidden && hide) {
            let idx = this.currentHidden.indexOf(colIndex);
            if (hide && idx === -1) {
              this.currentHidden.push(colIndex);
            } else if (!hide && idx > -1) {
              this.currentHidden.splice(idx, 1);
            }
          }
        }
      });
      this.$forceUpdate();
      //bbn.fn.log('forceupdate1');
      this.setConfig(true);
      this.init(true);
    },
    /**
     * If no editor is given to the table returns the correct component to edit the field basing on the column type.
     *
     * @method getEditableComponent
     * @param {Object} col
     * @param {Object} data
     * @return {String}
     */
    getEditableComponent(col, data) {
      if (col.editor) {
        return col.editor;
      }
      if (col.type) {
        switch (col.type) {
          case "date":
            return 'bbn-datepicker';
          case "email":
            return 'bbn-input';
          case "url":
            return 'bbn-input';
          case "number":
            return 'bbn-numeric';
          case "money":
            return 'bbn-numeric';
          case "bool":
          case "boolean":
            return 'bbn-checkbox';
        }
      }
      if (col.source) {
        return 'bbn-dropdown';
      }
      return 'bbn-input';
    },
    /**
     * Returns the object of properties to bind with the editable component.
     * @method getEditableOptions
     * @param {Object} col
     * @param {Object} data
     * @returns {Object}
     */
    getEditableOptions(col, data) {
      let res = col.options ? bbn.fn.isFunction(col.options) ? col.options(data, col) : col.options : {};
      if (!res.name && col.field) {
        res.name = col.field;
      }
      if (col.type) {
        switch (col.type) {
          case "date":
            break;
          case "email":
            bbn.fn.extend(res, {
              type: 'email'
            });
            break;
          case "url":
            bbn.fn.extend(res, {
              type: 'url'
            });
            break;
          case "number":
            break;
          case "money":
            break;
          case "bool":
          case "boolean":
            bbn.fn.extend(res, {
              value: 1,
              novalue: 0
            });
            break;
        }
      }
      if (col.source) {
        bbn.fn.extend(res, {
          source: col.source
        });
      } else if (col.editor) {
        res.source = data;
      }
      return res;
    },
    /**
     * Returns the html element of the given row index.
     * @method getTr
     * @param {Number} i
     * @returns {String}
     */
    getTr(i) {
      let row = false;
      if (bbn.fn.isNumber(i)) {
        bbn.fn.each(this.getRef('tbody').rows, tr => {
          if (tr.getAttribute('index') == i) {
            row = tr;
            return true;
          }
        });
      }
      return row;
    },
    /**
     * Returns an object of the default values for the different types of fields.
     * @method defaultObject
     * @returns {Object}
     */
    defaultObject() {
      let o = {};
      bbn.fn.iterate(bbn.cp.mixins.field.props, (v, n) => {
        if (v.default !== undefined) {
          o[n] = bbn.fn.isFunction(v.default) ? v.default() : v.default;
        }
      });
      return o;
    },
    /**
     * Returns true if the filter should be shown on the given column.
     * @method showFilterOnColumn
     * @param {Object} col
     * @returns {Boolean}
     */
    showFilterOnColumn(col) {
      if (!this.filterable || col.filterable === false || col.hideFilter) {
        return false;
      }
      if (col.filterable === true) {
        return true;
      }
      return !col.buttons && col.field;
    },
    /**
     * Focuses the given row index.
     * @method focusRow
     * @param {Event} ev
     * @param {Number} idx
     */
    focusRow(ev, idx) {
      if (ev.target.tagName !== 'BUTTON') {
        this.focusedRow = idx;
      }
    },
    /**
     * Blurs the given row index.
     * @method blurRow
     * @param {Event} ev
     * @param {Number} idx
     */
    blurRow(ev, idx) {
      if (ev.target.tagName !== 'BUTTON') {
        this.focusedRow = false;
      }
    },
    /**
     * @method clickCell
     * @param {Object} col
     * @param {Number} colIndex
     * @param {Number} dataIndex
     * @emits click-row
     * @emits click-cell
     */
    clickCell(col, colIndex, dataIndex) {
      if (this.filteredData[dataIndex]) {
        this.$emit('click-row', this.filteredData[dataIndex].data, dataIndex);
        this.$emit('click-cell', col, colIndex, dataIndex);
      }
    },
    /**
     * @method dbclickCell
     * @param {Object} col
     * @param {Number} colIndex
     * @param {Number} dataIndex
     */
    dbclickCell(col, colIndex, dataIndex, data, itemIndex, force) {
      if (this.zoomable && (!!col.zoomable || force)) {
        let obj = {
          title: col.title || col.ftitle,
          minHeight: '20%',
          minWidth: '20%'
        };
        if (!!col.component) {
          obj.component = col.component;
          obj.source = bbn.fn.isFunction(col.mapper) ? col.mapper(data) : data;
          obj.componentOptions = col.options;
        } else if (bbn.fn.isFunction(col.render)) {
          obj.content = `<div class="bbn-spadded">${col.render(data, col, itemIndex)}</div>`;
        } else {
          obj.content = `<div class="bbn-spadded">${data.text}</div>`;
        }
        this.getPopup().open(obj);
      }
    },
    /**
     * Removes the focus from the given row.
     * @param {Number} idx 
     */
    focusout(idx) {
      this.clickedTd = null;
      if (idx === undefined || idx === this.focusedRow) {
        this.focused = false;
        //this.focusedElement = undefined;
        setTimeout(() => {
          if (!this.focused) {
            this.focusedRow = false;
          }
        }, 50);
      }
    },
    /**
     * Focuses the given row.
     * @param {Number} idx 
     * @param {Event} e 
     */
    focusin(idx, e) {
      if (!e.target.closest('td') || !e.target.closest('td').classList.contains('bbn-table-buttons') || e.target.closest('td').classList.contains('bbn-table-edit-buttons')) {
        this.focused = true;
        this.clickedTd = e.target;
        //this.setFocusedElement(e)
        if (this.focusedRow !== idx) {
          this.focusedRow = idx;
        }
      }
    },
    listOnBeforeMount() {},
    checkAll() {
      bbn.fn.each(this.items, (a, i) => {
        this.checkSelection(i, true);
      });
    },
    uncheckAll() {
      bbn.fn.each(this.items, (a, i) => {
        this.checkSelection(i, false);
      });
    },
    getDataIndex(itemIndex) {
      return this.items[itemIndex] ? this.items[itemIndex].index : -1;
    },
    setFocusedElement(ev) {
      if (this.editable && this.editMode === 'inline' && (this.tmpRow || this.editedRow) && ev.target.tagName !== 'TR' && ev.target.tagName !== 'TD') {
        let e = ev.target.closest('td'),
          pos = e.getBoundingClientRect();
        this.focuseElementX = pos.x;
        this.focusedElementY = pos.y - pos.height;
        this.focusedElement = ev.target;
      }
    },
    getColOptions(data, col, idx) {
      if (col.options) {
        return bbn.fn.isFunction(col.options) ? col.options(data, col, idx) : col.options;
      }
      return {};
    },
    /**
     * The method called on a column resize (by user)
     * @method onUserResize
     * @param {Event} e
     * @fires $forceUpdate
     */
    onUserResize(e) {
      let d = e.target._bbn.directives.resizable.options.data,
        nextCol = this.groupCols[d.groupColIndex].cols[d.columnIndex + 1],
        nextColSize = nextCol ? nextCol.realWidth + e.detail.movement : 0;
      if (d.column.realWidth !== e.detail.size && e.detail.size >= this.defaultColumnWidth && (!nextCol || nextColSize >= this.defaultColumnWidth)) {
        this.groupCols[d.groupColIndex].cols[d.columnIndex].realWidth = e.detail.size;
        if (nextCol) {
          this.groupCols[d.groupColIndex].cols[d.columnIndex + 1].realWidth = nextColSize;
        }
        this.$forceUpdate();
      }
    },
    onButtonsMenuSelect(item, data, col, i, ev, floater) {
      ev.preventDefault();
      this._execCommand(item, data, col, i, ev);
      floater.closeAll();
    }
  },
  /**
   * Adds bbns-column from the slot and sets the initial configuration of the table.
   * @event created
   * @fires addColumn
   * @fires setConfig
   * @fires getStorage
   */
  created() {
    this.componentClass.push('bbn-resize-emitter');
    // Adding bbns-column from the slot
    if (this.$slots.default) {
      //bbn.fn.log("SLOTS TABLE CREATED", this.$slots, this.$el.bbnSlots);
      for (let node of this.$slots.default) {
        var _node$bbnSchema;
        if (((_node$bbnSchema = node.bbnSchema) === null || _node$bbnSchema === void 0 ? void 0 : _node$bbnSchema.tag) === 'tr') {
          this.hasTrSlot = true;
          break;
        }
      }
    }
    if (this.columns.length) {
      bbn.fn.each(this.columns, a => this.addColumn(a));
    }
    if (this.defaultConfig.hidden === null) {
      let tmp = [];
      let initColumn = [];
      bbn.fn.each(this.cols, (a, i) => {
        if (a.hidden) {
          tmp.push(i);
        } else if (initColumn.length <= 10) {
          initColumn.push(i);
        }
      });
      this.defaultConfig.hidden = tmp;
    }
    this.setConfig(false, true);
    this.initialConfig = this.jsonConfig;
    this.savedConfig = this.jsonConfig;
    let cfg = this.getStorage();
    if (cfg) {
      this.setConfig(cfg, true);
    }
    this.$on('addTmp', () => {
      let scroll = this.getRef('scroll');
      if (bbn.cp.isComponent(scroll) && bbn.fn.isFunction(scroll.scrollStartY) && bbn.fn.isFunction(scroll.scrollStartX)) {
        scroll.scrollStartY();
        scroll.scrollStartX();
      }
    });
  },
  beforeDestroy() {
    bbn.fn.log("DESTROYING TABLE");
  },
  /**
   * After the initialization of the component sets the property ready on true.
   * @event mounted
   * @fires init
   * @fires updateData
   */
  mounted() {
    bbn.fn.log("TABLE MOUNTED");
    this.container = this.getRef('container');
    this.marginStyleSheet = document.createElement('style');
    document.body.appendChild(this.marginStyleSheet);
    this.isTable = !!this.closest('bbn-table');
    let floater = this.closest('bbn-floater');
    if (floater) {
      if (floater.ready) {
        this.init();
        this.$once('dataloaded', () => {
          this.ready = true;
          this.setResizeEvent();
          floater.onResize();
        });
      } else {
        floater.$on('ready', () => {
          this.init();
          this.$once('dataloaded', () => {
            this.ready = true;
            this.setResizeEvent();
            floater.onResize();
          });
        });
      }
      if (this.isAutobind) {
        this.updateData();
      }
    } else {
      this.$once('dataloaded', () => {
        this.ready = true;
      });
      this.init(!!this.isAutobind);
    }
  },
  watch: {
    columns() {
      if (this.ready) {
        this.cols.splice(0, this.cols.length);
        if (this.columns.length) {
          bbn.fn.each(this.columns, a => this.addColumn(a));
        }
        if (this.defaultConfig.hidden === null) {
          let tmp = [];
          let initColumn = [];
          bbn.fn.each(this.cols, (a, i) => {
            if (a.hidden) {
              tmp.push(i);
            } else if (initColumn.length <= 10) {
              initColumn.push(i);
            }
          });
          this.defaultConfig.hidden = tmp;
        }
        this.init();
      }
    },
    /**
     * Updates the data.
     * @watch observerValue
     * @fires updateData
     */
    /*observerValue(newVal) {
      if ((newVal !== this._observerReceived) && !this.editedRow) {
        this._observerReceived = newVal;
        //bbn.fn.log("watch observerValue");
        this.updateData();
      }
    },*/
    /**
     * Updates the data.
     * @watch observerDirty
     * @fires updateData
     */
    observerDirty(v) {
      if (v && !this.editedRow) {
        this.observerDirty = false;
        this.updateData();
      }
    },
    allRowsChecked(v) {
      if (v) {
        this.checkAll();
      } else if (!this.isTableDataUpdating) {
        this.uncheckAll();
      }
    },
    /**
     * Forces the update of the component.
     * @watch currentHidden
     * @fires setConfig
     */
    currentHidden: {
      deep: true,
      handler() {
        if (this.ready) {
          this.setConfig(true);
          this.$forceUpdate();
          //bbn.fn.log('forceupdate2');
        }
      }
    },

    /**
     * @watch group
     * @fires init
     */
    group() {
      this.currentExpandedValues = [];
      this.currentExpanded = [];
      this.init();
    },
    /**
     * @watch focusedRow
     * @fires isModified
     * @fires edit
     * @emit change
     * @emit focus
     * @emit focusout
     */
    focusedRow(newIndex, oldIndex) {
      if (bbn.fn.isNumber(oldIndex)) {
        this.$emit('focusout', oldIndex, this.items[oldIndex] ? this.items[oldIndex].index : undefined);
      }
      if (this.items[newIndex]) {
        this.$emit('focus', this.items[newIndex].data, newIndex, this.items[newIndex].index);
      }
      if (this.editable && this.editMode === 'inline') {
        if (bbn.fn.isNumber(oldIndex) && this.items[oldIndex]) {
          let idx = this.items[oldIndex].index;
          if (this.editedIndex === idx && (idx === -1 || this.isModified(idx))) {
            if (this.autoSave) {
              this.saveInline();
            } else if (this.autoReset) {
              this.cancel();
            } else {
              this.$emit('change', this.items[oldIndex].data, idx);
            }
          }
        }
        this.editedRow = false;
        if (bbn.fn.isNumber(newIndex) && this.items[newIndex] && !this.items[newIndex].group && !this.items[newIndex].expander) {
          let comeFromAfter = bbn.fn.isNumber(oldIndex) && newIndex === oldIndex - 1;
          this.$nextTick(() => {
            this.edit(this.items[newIndex].data, null, newIndex);
            this.$nextTick(() => {
              let ele = this.clickedTd || this.getTr(newIndex);
              let nextInputs = ele ? ele.querySelectorAll('input') : [];
              let nextInput;
              bbn.fn.each(nextInputs, a => {
                if (a.offsetWidth) {
                  nextInput = a;
                  if (!comeFromAfter) {
                    return false;
                  }
                }
              });
              if (nextInput) {
                nextInput.focus();
              }
            });
          });
        }
      }
    },
    /**
     * @watch lastKnownCtWidth
     * @fires resizeWidth
     */
    lastKnownCtWidth() {
      if (this.groupCols.length && !this.initStarted && (this.groupCols[0].cols.length || this.groupCols[1].cols.length || this.groupCols[2].cols.length)) {
        this.resizeWidth();
      }
    }
  },
  components: {
    /**
     * @component table-dots
     */
    tableDots: {
      name: 'table-dots',
      template: `
<div class="bbn-c bbn-lg"
     @click="table.dbclickCell(source.column, source.index, source.dataIndex, source.data, source.itemIndex, true)"
     :style="{display: visible ? 'block !important' : 'none !important'}">
  <i class="nf nf-mdi-dots_horizontal bbn-p bbn-primary-text-alt"/>
</div>
        `,
      props: {
        /**
         * @prop {Object} source
         * @memberof bbn-table-dots
         */
        source: {
          type: Object
        }
      },
      data() {
        return {
          /**
          * @data {Boolean} [false] visible
          * @memberof bbn-table-dots
          */
          visible: false,
          /**
          * @data {bbnCp} table
          * @memberof bbn-table-dots
          */
          table: this.closest('bbn-table')
        };
      },
      methods: {
        /**
         * @method {Object} checkVisibility
         * @memberof bbn-table-dots
         */
        checkVisibility() {
          if (this.table.maxRowHeight && this.table.zoomable) {
            let td = this.$el.closest('td');
            if (!!td && !!td.firstElementChild && !!td.firstElementChild.firstElementChild) {
              let styleFirst = window.getComputedStyle(td.firstElementChild),
                styleSecond = window.getComputedStyle(td.firstElementChild.firstElementChild);
              this.visible = parseFloat(styleSecond.height) + parseFloat(styleFirst.paddingTop) + parseFloat(styleFirst.paddingBottom) > this.table.maxRowHeight;
              if (this.visible) {
                td.firstElementChild.firstElementChild.style.setProperty('height', 'calc(' + this.table.maxRowHeight + 'px - 2.3rem)');
                td.firstElementChild.firstElementChild.style.overflow = 'hidden';
              }
            }
          } else {
            this.visible = false;
          }
        }
      },
      /**
       * @event mounted
       * @memberof bbn-table-dots
       * @fires checkVisibility
       */
      mounted() {
        this.checkVisibility();
      }
    }
  }
};
import cpHtml from './table.html';
import cpStyle from './table.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./table.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-table',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-switch component
 *
 * @description bbn-switch is a component with easy implementation and customization that allows the user to switch between selected and unselected states, defining the value and novalue in the appropriate properties.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 13/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input],
  props: {
    noRouter: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true gives the component a rounded appearance.
     * @prop {Boolean} [false] radius
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    scrollable: {
      type: Boolean,
      default: false
    },
    fill: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: true
    },
    limit: {
      type: Number
    },
    maxTitleLength: {
      type: Number,
      default: 35
    },
    position: {
      type: String,
      default: 'top'
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * The value of the component.
       * @data {Boolean} valueToSet
       */
      valueToSet: this.value,
      selectedBarColor: null,
      altTextColor: bbn.fn.getCssVar('alt-text')
    };
  },
  computed: {
    /**
     * Returns the scroll configuration
     * @computed scrollCfg
     * @return {Object}
     */
    scrollCfg() {
      return this.scrollable ? {
        axis: 'x',
        container: true,
        hidden: true
      } : {};
    },
    isVertical() {
      return this.position === 'left' || this.position === 'right';
    }
  },
  methods: {
    numProperties: bbn.fn.numProperties,
    /**
     * Returns the title attribute for the tab.
     * 
     * @method getTabTitle
     * @param {Object} obj
     * @return {String|null}
     */
    getTabTitle(obj) {
      let t = '';
      if (obj.notext || obj.title.length > this.maxTitleLength) {
        t += obj.title;
      }
      if (obj.ftitle) {
        t += (t.length ? ' - ' : '') + obj.ftitle;
      }
      return t || null;
    },
    /**
     * @method scrollTabs
     * @param {String} dir
     * @fires getRef
     */
    scrollTabs(dir) {
      let scroll = this.getRef('horizontal-scroll');
      if (scroll) {
        if (dir === 'right') {
          scroll.scrollAfter(true);
        } else {
          scroll.scrollBefore(true);
        }
      }
    },
    /**
     * Cuts the given string by 'maxTitleLength' property value
     * @method cutTitle
     * @param {String} title
     * @return {String}
     */
    cutTitle(title) {
      return bbn.fn.shorten(title, this.maxTitleLength);
    },
    /**
     * @method getFontColor
     * @param {Number} idx
     * @fires getRef
     * @return {String}
     */
    getFontColor(idx) {
      if (bbn.fn.isNumber(idx) && this.source[idx]) {
        if (this.source[idx].fcolor) {
          return this.source[idx].fcolor;
        }
        /*
        let el = this.getRef('title-' + idx);
        if (el) {
          return window.getComputedStyle(el.$el ? el.$el : el).color || '';
        }
        */
      }

      return '';
    },
    getMenuFn(idx) {
      var _this$source$idx;
      if ((_this$source$idx = this.source[idx]) !== null && _this$source$idx !== void 0 && _this$source$idx.idx) {
        idx = this.source[idx].idx;
      }
      if (this.router) {
        return this.router.getMenuFn(idx);
      } else if (this.noRouter) {
        //bbn.fn.log("GET MENU FN", idx, this.source[idx].menu);
        return this.source[idx].menu || [];
      }
      return [];
    },
    clickLi(tabIndex) {
      const tab = this.source[tabIndex];
      if (!tab.disabled && tabIndex !== this.value) {
        //bbn.fn.log("TABS CHANGING TO " + tabIndex);
        this.emitInput(tabIndex);
      }
    },
    onScrollReady() {
      bbn.fn.log("on scroll, ready");
      setTimeout(() => {
        this.updateScroll();
      }, 1500);
    },
    updateScroll() {
      if (this.scrollable) {
        const scroll = this.getRef('horizontal-scroll');
        const tab = this.getRef('tab-' + this.value);
        if (scroll && tab) {
          const x = tab.offsetLeft;
          if (x < scroll.currentX || x > scroll.currentX + scroll.containerWidth) {
            scroll.scrollTo(tab.offsetLeft, 0, true);
          }
        }
      }
    }
  },
  watch: {
    value(v) {
      this.selectedBarColor = this.source[v] ? this.getFontColor(v) : null;
      this.$nextTick(() => {
        this.updateScroll();
      });
    },
    source: {
      deep: true,
      handler() {
        bbn.fn.log("CHANGING TABS SOURCE");
        this.$forceUpdate();
      }
    }
  },
  updated() {
    if (this.source[this.value]) {
      this.selectedBarColor = this.getFontColor(this.value);
    }
  },
  /**
   * Sets the initial state of the component.
   * @event mounted
   * @fires toggle
   * @emits input
   */
  mounted() {
    if (!this.noRouter) {
      this.router = this.closest('bbn-router');
    }
    this.ready = true;
    // If no timeout color won't work
    setTimeout(() => {
      if (this.source[this.value]) {
        this.selectedBarColor = this.getFontColor(this.value);
      }
    }, 500);
  }
};
import cpHtml from './tabs.html';
import cpStyle from './tabs.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./tabs.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-tabs',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-textarea component
 *
 * @description bbn-textarea is an easy to configure component, it represents a multiline text field, in which it is possible to assign an initial value among the various configurations, validate the content and provide a maximum number of characters that can be inserted.
 * You can define actions on the events activated on it.
 *
 * @copyright BBN Solutions
 * 
 * @author BBN Solutions
 */
const cpDef = {
  mixins: [bbn.cp.mixins.basic],
  props: {},
  data() {
    return {
      widget: false,
      fitter: false,
      searcher: false
    };
  },
  methods: {
    clear() {},
    write(st) {
      this.widget.write(st);
    },
    resize() {
      //this.fitter.fit(300, 300);
    }
  },
  mounted() {
    this.ready = true;
    this.widget = new Terminal();
    this.fitter = new FitAddon.FitAddon();
    this.widget.loadAddon(this.fitter);
    //this.widget.loadAddon(new WebLinksAddon.WebLinksAddon());
    //this.searcher = new SearchAddon.SearchAddon();
    //this.widget.loadAddon(this.searcher);
    this.widget.open(this.$el);
    this.fitter.fit();
  }
};
import cpHtml from './terminal.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./terminal.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-terminal',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-textarea component
 *
 * @description bbn-textarea is an easy to configure component, it represents a multiline text field, in which it is possible to assign an initial value among the various configurations, validate the content and provide a maximum number of characters that can be inserted.
 * You can define actions on the events activated on it.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * The number of rows of the textarea.
     * @prop {Number} rows
     */
    rows: {
      validator: bbn.fn.isNumber
    },
    /**
     * The number of columns of the textarea.
     * @prop {Number} cols
     */
    cols: {
      validator: bbn.fn.isNumber
    },
    /**
     * The max length of the text inside the textarea.
     * @prop {Number}  maxlength
     */
    maxlength: {
      type: Number
    },
    /**
     * Sets the textarea resizable
     * @prop {Boolean} [true] resizable
     */
    resizable: {
      type: Boolean,
      default: true
    },
    /**
     * Sets the textarea resizable
     * @prop {Boolean} [true] resizable
     */
    autosize: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      currentHeight: null
    };
  },
  computed: {
    currentRows() {
      if (this.rows) {
        return this.rows;
      }
      if (this.autosize) {
        return 1;
      }
      return undefined;
    },
    currentStyle() {
      const st = {
        resize: 'none'
      };
      if (this.resizable) {
        st.resize = bbn.fn.isString(this.resizable) ? this.resizable : 'both';
      }
      if (this.currentHeight) {
        st.height = this.currentHeight + 'px';
      }
      return st;
    }
  },
  methods: {
    onInput(e) {
      if (this.maxlength && e.target.value.length > this.maxlength) {
        this.emitInput(this.value);
        return;
      }
      if (this.autosize) {
        e.target.style.height = 'auto';
        this.currentHeight = e.target.scrollHeight;
        e.target.style.height = e.target.scrollHeight + 'px';
      }
      this.emitInput(e.target.value);
    },
    /**
     * @method textareaKeydown
     * @param {Event} ev
     * @fires keydown
     */
    textareaKeydown(ev) {
      if (this.maxlength && this.value.length >= this.maxlength) {
        ev.preventDefault();
      } else {
        this.keydown(ev);
      }
    },
    /**
     * Clears the textarea.
     * @method clear
     * @fires emitInput
     */
    clear() {
      this.emitInput('');
    }
  },
  /**
   * Sets the prop ready to true.
   * @event mounted
   */
  mounted() {
    this.ready = true;
    const el = this.getRef('element');
    el.value = this.value;
    if (this.autosize) {
      el.style.height = 'auto';
      el.style.height = el.scrollHeight + 'px';
    }
  }
};
import cpHtml from './textarea.html';
import cpStyle from './textarea.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./textarea.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-textarea',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-timepicker component
 *
 * @description bbn-timepicker is a component that allowes the user to choose a time value.
 * This component allows the association of data in a bidirectional way and allows the users to choose a validation interval period and the format of the value entered.

 * @author Mirko Argentino
 *
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * The view mode.
     * @prop {String} ['scroll'] mode
     */
    mode: {
      type: String,
      default: 'dropdown',
      validator: m => ['scroll', 'dropdown', 'block'].includes(m)
    },
    /**
     * The format of the time displayed.
     *
     * @prop {String} format
     */
    format: {
      type: String
    },
    /**
     * The format of the value.
     *
     * @prop {String|Function} valueFormat
     */
    valueFormat: {
      type: [String, Function]
    },
    /**
     * The mask for the time input.
     *
     * @prop {String} mask
     */
    mask: {
      type: String
    },
    /**
     * The maximum allowed value.
     *
     * @prop {String} max
     */
    max: {
      type: String
    },
    /**
     * The minimum allowed value.
     * @prop {String} min
     */
    min: {
      type: String
    },
    /**
     * Shows/hides the "seconds" selection.
     * @prop {Boolean} [false] showSecond
     */
    showSecond: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to false if you dont' want to auto-resize the input's width based on its value (in characters).
     * @prop {Boolean} [true] autosize
     */
    autosize: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * Shows/hides the floater.
       *
       * @data {Boolean} [false] isOpened
      */
      isOpened: false,
      /**
       * Indicates if the bbn-masked component is mounted.
       *
       * @data {Boolean} [false] maskedMounted
      */
      maskedMounted: false,
      /**
       * The current value displayed on the input.
       *
       * @data {String} [''] inputValue
      */
      inputValue: '',
      /**
       * The old value displayed in the input.
       *
       * @data {String} [''] oldInputvalue
       */
      oldInputValue: ''
    };
  },
  computed: {
    /**
     * The current mask for the time input.
     *
     * @computed currentMask
     * @return {String}
     */
    currentMask() {
      return this.mask || (this.showSecond ? '00:00:00' : '00:00');
    },
    /**
     * The current value format.
     *
     * @computed currentValueFormat
     * @return {String}
     */
    currentValueFormat() {
      return this.valueFormat || (this.showSecond ? 'HH:mm:ss' : 'HH:mm');
    },
    /**
     * The current format displayed on the input.
     *
     * @computed currentFormat
     * @return {String}
     */
    currentFormat() {
      return this.format || (this.showSecond ? 'HH:mm:ss' : 'HH:mm');
    },
    /**
     * True if the values of the inputValue and the oldInputValue properties are different.
     *
     * @computed intuValueChanged
     * @return {String}
     */
    inputValueChanged() {
      return this.inputValue !== this.oldInputValue;
    },
    scrollMode() {
      return this.mode === 'scroll';
    },
    dropdownMode() {
      return this.mode === 'dropdown';
    },
    blockMode() {
      return this.mode === 'block';
    }
  },
  methods: {
    /**
     * Gets the correct value format.
     *
     * @method getValueFormat
     * @param {String} val The value.
     * @return {String}
     */
    getValueFormat(val) {
      return bbn.fn.isFunction(this.valueFormat) ? this.valueFormat(val) : this.currentValueFormat;
    },
    /**
     * Sets the value.
     *
     * @method setValue
     * @param {String} val The value.
     * @param {String} format 
     * @fires getValueFormat
     * @fires setInputValue
     * @fires emitInput
     * @emits input
    */
    setValue(val, format) {
      if (!format) {
        format = !!val ? this.getValueFormat(val.toString()) : false;
      }
      let value = !!format && !!val ? dayjs(val.toString(), format).isValid() ? dayjs(val.toString(), format).format(format) : '' : '';
      if (value) {
        if (value && this.min && value < this.min) {
          value = this.min;
        }
        if (value && this.max && value > this.max) {
          value = this.max;
        }
      } else if (this.nullable) {
        value = null;
      }
      if (value !== this.value) {
        this.emitInput(value);
        this.$emit('change', value);
      } else {
        this.setInputValue(value);
      }
      if (!value) {
        this.inputValue = '';
        this.oldInputValue = '';
      }
      this.isOpened = false;
    },
    /**
     * Triggered when the value is changed by the input.
     *
     * @method change
     * @param {$event} event Original event.
     * @fires getValueFormat
     * @fires setValue
     * @emits change
    */
    inputChanged() {
      let mask = this.getRef('element'),
        newVal = mask.inputValue,
        value = !!newVal ? dayjs(newVal, this.currentFormat).format(this.getValueFormat(newVal)) : '';
      if (mask.raw(newVal) !== this.oldInputValue) {
        if (value && this.min && value < this.min) {
          value = this.min;
        }
        if (value && this.max && value > this.max) {
          value = this.max;
        }
        this.setValue(value);
      }
    },
    /**
     * Sets the value of the input.
     * @method setInputValue
     * @param {String} newVal 
     * @fires getValueFormat
     * @fires setValue
     */
    setInputValue(newVal) {
      if (newVal) {
        let mask = this.getRef('element'),
          mom = dayjs(newVal.toString(), this.getValueFormat(newVal.toString()));
        this.inputValue = newVal && mask && mom.isValid() ? mask.raw(mom.format(this.currentFormat)) : '';
      } else {
        this.inputValue = '';
      }
      this.oldInputValue = this.inputValue;
    },
    /**
     * Clears the input.
     * @method clear
     */
    clear() {
      this.setValue('');
      this.$nextTick(() => {
        this.$set(this.getRef('element'), 'inputValue', '');
      });
    }
  },
  /**
   * Defines the locale set basing on the lang of the environment (bbn.env.lang).
   * @event beforeCreate
   */
  beforeCreate() {
    if (bbn.env && bbn.env.lang && bbn.env.lang !== dayjs.locale()) {
      dayjs.locale(bbn.env.lang);
    }
  },
  /**
   * @event mounted
   * @fires setValue
   */
  mounted() {
    if (this.value) {
      this.setValue(this.value);
    }
    this.ready = true;
  },
  watch: {
    /**
     * @watch min
     * @fires setValue
     */
    min() {
      this.setValue(this.value || '');
    },
    /**
     * @watch max
     * @fires setValue
     */
    max() {
      this.setValue(this.value || '');
    },
    /**
     * @watch valueFormat
     * @fires setValue
     */
    valueFormat() {
      this.setValue(this.value || '');
    },
    /**
     * @watch maskedMounted
     * @fires getValueFormat
     * @param {String} newVal
     */
    maskedMounted(newVal) {
      if (newVal) {
        this.setInputValue(this.value);
      }
    },
    /**
     * @watch value
     * @param {String} newVal
     * @fires getValueFormat
     * @fires updateCalendar
    */
    value(newVal) {
      this.setInputValue(newVal);
    }
  }
};
import cpHtml from './timepicker.html';
import cpStyle from './timepicker.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./timepicker.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-timepicker',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-countdown component
 * @description bbn-countdown is a component that performs a countdown of a user-defined date, based on the measure of time defined in the construction.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 13/02/2017.
*/

/** @todo try this way

 const timestamp = 1519482900000;
 const formatted = dayjs(timestamp).format('L');

 console.log(formatted);*/

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  statics() {
    const VALUES = [{
      name: 'year',
      title: bbn._('year'),
      titles: bbn._('years'),
      code: 'y',
      separator: 'y',
      timeout: 3600000
    }, {
      name: 'month',
      title: bbn._('month'),
      titles: bbn._('months'),
      code: 'm',
      separator: 'm',
      diff: 12,
      timeout: 3600000
    }, {
      name: 'day',
      title: bbn._('day'),
      titles: bbn._('days'),
      code: 'd',
      diff: 31,
      separator: 'd',
      timeout: 3600000
    }, {
      name: 'hour',
      title: bbn._('hour'),
      titles: bbn._('hours'),
      code: 'h',
      diff: 24,
      separator: ':',
      timeout: 3600000
    }, {
      name: 'minute',
      title: bbn._('minute'),
      titles: bbn._('minutes'),
      code: 'i',
      diff: 60,
      separator: ':',
      timeout: 60000
    }, {
      name: 'second',
      title: bbn._('second'),
      titles: bbn._('seconds'),
      code: 's',
      diff: 60,
      separator: '.',
      timeout: 1000
    }, {
      name: 'millisecond',
      title: bbn._('millisecond'),
      titles: bbn._('milliseconds'),
      code: 'x',
      diff: 1000,
      separator: '',
      timeout: 50
    }];
  },
  props: {
    /**
     * The precision of the visible timer.
     * @prop {string} ['second'] precision
     */
    precision: {
      type: String,
      default: 'minute'
    },
    /**
     * The scale of the timer (largest unit).
     * @prop {string} ['hour'] scale
     */
    scale: {
      type: String,
      default: 'hour'
    },
    /**
     * Shows unit even if empty for countdown mode.
     * @prop {Boolean} [false] showZero
     */
    showZero: {
      type: Boolean,
      default: false
    },
    /**
     * The target date(s) if countdown or alarm.
     * @prop {Array|Date|String|Function} target
     */
    source: {
      type: [Object, Array, Date, String, Function]
    },
    /**
     * @prop {String} ['date'] sourceDate
     */
    sourceDate: {
      type: String,
      default: 'date'
    },
    /**
     * Set to true the remaining day and month and year will be displayed.
     * @prop {Boolean} [true] zeroFill
     */
    zeroFill: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} ['clock'] mode
     */
    mode: {
      type: String,
      default: 'clock'
    }
  },
  data() {
    return {
      isInit: false,
      currentTasks: [],
      taskIndex: 0,
      /**
       * The target year.
       * @data {Boolean} [false] targetYear
       */
      targetYear: false,
      /**
       * The target month.
       * @data {Boolean} [false] targetMonth
       */
      targetMonth: false,
      /**
       * The target day.
       * @data {Boolean} [false] targetDay
       */
      targetDay: false,
      /**
       * The target hour.
       * @data {Boolean} [false] targetHour
       */
      targetHour: false,
      /**
       * The target minute.
       * @data {Boolean} [false] targetMinute
       */
      targetMinute: false,
      /**
       * The target second.
       * @data {Boolean} [false] targetSecond
       */
      targetSecond: false,
      /**
       * The target millisecond.
       * @data {Boolean} [false] targetMillisecond
       */
      targetMillisecond: false,
      /* year: false,
      month: false,
      day: false,
      hour: false,
      minute: false,
      second: false,
      millisecond: false,*/
      /**
       * The interval of the countdown.
       * @data {Number} [0] interval
       */
      interval: 0,
      /**
       * The timestamp of the real target date.
       * @data {Boolean|Number} [false] time
       */
      time: false,
      /**
       * @data {String} ["{}"] prevValues
       */
      prevValues: JSON.stringify({}),
      /**
       * @data {Object} [{}] shown
       */
      shown: {},
      /**
       * @data {Object} [{}] text
       */
      text: {},
      /**
       * @data {Boolean} [false] isValid
       */
      isValid: false,
      /**
       * @data {Boolean} [false] currentTime
       */
      currentTime: null
    };
  },
  computed: {
    /**
     * The index of the 'precision' property in the array of the constant VALUES.
     * @return {Number} [5] precisionIdx
     */
    precisionIdx() {
      return bbn.fn.search(bbnTimerCp.VALUES, this.precision.length === 1 ? 'code' : 'name', this.precision);
    },
    /**
     * The index of the 'scale' property in the array of the constant VALUES.
     * @return {Number} [5] scaleIdx
     */
    scaleIdx() {
      return bbn.fn.search(bbnTimerCp.VALUES, this.scale.length === 1 ? 'code' : 'name', this.scale);
    },
    /**
     * List type of periods.
     * @return {Array} periods
     */
    periods() {
      return bbnTimerCp.VALUES;
    },
    // @todo incomplete
    rendered() {
      if (this.template) {}
      return false;
    }
  },
  methods: {
    /**
     * Checks if the component has been correctly set up.
     * @method check
     * @return {Boolean}
     */
    check() {
      return this.precisionIdx > -1 && this.scaleIdx > -1 && this.precisionIdx >= this.scaleIdx;
    },
    /**
     * Initializes the component.
     * @method init
     * @fires update
     */
    init() {
      if (this.precisionIdx === -1) {
        throw new Error(bbn._("The precision is incorrect"));
      } else if (this.scaleIdx === -1) {
        throw new Error(bbn._("The scale is incorrect"));
      } else {
        let tmp = bbn.fn.isFunction(this.source) ? this.source() : this.source;
        if (!bbn.fn.isArray(tmp)) {
          tmp = [tmp];
        }
        bbn.fn.each(tmp, t => this.addTask(t));
        this.cleanTasks();
        this.launch();
      }
    },
    launch() {
      clearInterval(this.interval);
      if (this.currentTasks.length && this.mode === 'countdown') {
        this.time = this.currentTasks[0].timestamp.getTime();
      }
      let timeout = bbnTimerCp.VALUES[this.precisionIdx].timeout;
      this.update();
      this.interval = setInterval(this.update, timeout);
    },
    /**
     * Removes the past tasks
     */
    cleanTasks() {
      let now = new Date().getTime();
      for (let i = 0; i < this.currentTasks.length; i++) {
        while (now > this.currentTasks[i].timestamp) {
          this.currentTasks.shift();
        }
      }
    },
    /**
     * Adds a new task to the timer, should be in the future.
     * 
     * @param {mixed} task 
     */
    addTask(task) {
      let r;
      if (bbn.fn.isString(task)) {
        r = {
          [this.sourceDate]: bbn.fn.date(task)
        };
      } else if (bbn.fn.isDate(task)) {
        r = {
          [this.sourceDate]: bbn.fn.date(task)
        };
      } else if (bbn.fn.isObject(task)) {
        r = task;
      }
      if (r && r[this.sourceDate] && bbn.fn.isDate(r[this.sourceDate])) {
        let now = new Date().getTime();
        r.timestamp = r[this.sourceDate].getTime();
        for (let i = 0; i < this.currentTasks.length; i++) {
          if (this.currentTasks[i].timestamp < r.timestamp) {
            this.currentTasks.unshift(r);
            return true;
          } else if (this.currentTasks[i].timestamp === r.timestamp) {
            let tmp = this.currentTasks[i].action;
            if (tmp && r.action) {
              this.currentTasks[i].action = () => {
                tmp();
                r.action();
              };
              return true;
            }
          }
        }
        this.currentTasks.push(r);
        return true;
      }
      return false;
    },
    /**
     * Udates the component.
     * @method update
     * @fires check
     * @fires getShown
     * @fires getText
     */
    update() {
      if (this.check()) {
        let d = new Date();
        if (this.mode === 'countdown' && this.time) {
          let secs = this.time - d.getTime();
          if (secs <= 0) {
            if (this.isValid) {
              bbn.fn.each(bbnTimerCp.VALUES, (a, i) => {
                this[a.name] = 0;
              });
              this.isValid = false;
            }
          } else if (secs) {
            let diff = dayjs.duration(secs, 'seconds');
            let diffs = {};
            bbn.fn.each(bbnTimerCp.VALUES, (a, i) => {
              diffs[a.name] = diff['as' + a.name[0].toUpperCase() + bbn.fn.substr(a.name, 1) + 's']();
              if (i >= this.scaleIdx && i <= this.precisionIdx) {
                let round = Math.floor(diffs[a.name]);
                diffs[a.name] = round;
                if (i < this.precisionIdx) {
                  diff = diff.subtract(dayjs.duration(round, a.name + 's'));
                }
              }
            });
            bbn.fn.iterate(diffs, (b, n) => {
              this[n] = b;
            });
            if (!this.isValid) {
              this.isValid = true;
            }
            this.shown = this.getShown();
            this.text = this.getText();
            this.$forceUpdate();
          }
        } else {
          this.currentTime = bbn.fn.formatDate(d, "HH:mm");
        }
      }
    },
    /**
     * Returns the descriptive list of units used in the countdown.
     *
     * @method getShow
     * @return {Object}
     */
    getShown() {
      let res = {};
      bbn.fn.each(bbnTimerCp.VALUES, (a, i) => {
        res[a.name] = (this.showZero || this[a.name] || this.zeroFill) && this.precisionIdx >= i && this.scaleIdx <= i;
      });
      return res;
    },
    /**
     * Returns the descriptive list of units used in the countdown with the value that contains it when calling this function.
     *
     * @method getText
     * @return {Object}
     */
    getText() {
      let res = {};
      bbn.fn.each(bbnTimerCp.VALUES, (a, i) => {
        res[a.name] = this[a.name] || 0;
        if (this.zeroFill && this.scaleIdx !== i && res[a.name].toString().length <= 1) {
          res[a.name] = '0' + res[a.name];
        }
      });
      return res;
    }
  },
  /**
   * @event created
   * @fires init
   */
  created() {
    this.init();
  },
  /**
   * @event beforeDestroy
   */
  beforeDestroy() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
};
import cpHtml from './timer.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./timer.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-timer',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-timewheel component
 * @description bbn-timewheel is a component that allowes the user to choose a time value.
 * @author Mirko Argentino
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.input
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.list, bbn.cp.mixins.input],
  props: {
    /**
     * @prop {String} ['HH:mm:ss'] format
     */
    format: {
      type: String,
      default: 'HH:mm:ss'
    },
    /**
     * @prop {Boolean} [true] showSecond
     */
    showSecond: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {String} min
     */
    min: {
      type: String
    },
    /**
     * @prop {String} max
     */
    max: {
      type: String
    },
    /**
     * @prop {Array|Boolean} ['cancel','submit'] buttons
     */
    buttons: {
      type: [Array, Boolean],
      default() {
        return ['cancel', 'submit'];
      }
    }
  },
  data() {
    let d = this.value && this.value.length ? dayjs(this.value, this.format) : dayjs();
    return {
      /**
       * The array used to make the minutes and the seconds.
       *
       * @data {Array} minsec
       */
      minsec: Array.from({
        length: 60
      }, (v, i) => {
        return {
          text: i.toString().length === 1 ? '0' + i : i,
          value: i
        };
      }),
      /**
       * The current hour.
       *
       * @data {String|null} [null] hour
       */
      hour: d.hour(),
      /**
       * The current minute.
       *
       * @data {String|null} [null] minute
       */
      minute: d.minute(),
      /**
       * The current second.
       *
       * @data {String|null} [null] second
       */
      second: d.second(),
      /**
       * The hours scroll is ready.
       *
       * @data {Boolean} [false] hourReady
       */
      hourReady: false,
      /**
       * The minutes scroll is ready.
       *
       * @data {Boolean} [false] minuteReady
       */
      minuteReady: false,
      /**
       * The seconds scroll is ready.
       *
       * @data {Boolean} [false] secondReady
       */
      secondReady: false,
      /**
       * The component is ready.
       *
       * @data {Boolean} [false] ready
       */
      ready: false
    };
  },
  computed: {
    /**
     * The array used to make the hours.
     * @computed hours
     * @return {Array}
     */
    hours() {
      let res = Array.from({
        length: 24
      }, (v, i) => {
        return {
          text: i.toString().length === 1 ? '0' + i : i,
          value: i
        };
      }).filter(v => {
        return !(this.min && v.value < this.min || this.max && v.value > this.max);
      });
      return res;
    },
    /**
     * Checks if all timescroll components are ready.
     * @computed checkReady
     * @return {Boolean}
     */
    checkReady() {
      return this.hourReady && this.minuteReady && (!this.showSecond || this.secondReady);
    },
    /**
     * The current buttons config
     * @computed currentButtons
     * @return {Array}
     */
    currentButtons() {
      let res = [];
      if (this.buttons) {
        let def = {
          cancel: {
            title: bbn._('Cancel'),
            icon: 'nf nf-fa-close',
            cls: '',
            action: this.cancel
          },
          submit: {
            title: bbn._('Confirm'),
            icon: 'nf nf-fa-check',
            cls: 'bbn-primary',
            action: this.save
          }
        };
        bbn.fn.each(this.buttons, b => {
          if (bbn.fn.isString(b)) {
            if (def[b] !== undefined) {
              res.push(def[b]);
            }
          } else {
            let but = bbn.fn.extend(true, {}, b);
            if (bbn.fn.isString(b.action) && def[b.action]) {
              but.action = def[b.action].action;
            }
            res.push(but);
          }
        });
      }
      return res;
    }
  },
  methods: {
    /**
     * Gets the current time value.
     * @method getTime
     * @returns {String}
     */
    getTime() {
      if (!bbn.fn.isNull(this.hour) && !bbn.fn.isNull(this.minute) && (!this.showSecond || !bbn.fn.isNull(this.second))) {
        let v = !!this.value ? dayjs(this.value, this.format) : dayjs();
        v = dayjs(v).minute(this.minute).hour(this.hour);
        if (this.showSecond) {
          v = dayjs(v).second(this.second);
        }
        bbn.fn.log('aaa', v.format(this.format));
        return v.format(this.format);
      }
      return '';
    },
    /**
     * Sets the current hour.
     * @method setHour
     * @param {Number} h The hour.
     * @fires emitInput
     * @emits change
     */
    setHour(h) {
      if (!bbn.fn.isNull(h)) {
        this.hour = h;
        let time = this.getTime();
        if (!!time && !this.buttons) {
          this.emitInput(time);
          this.$emit('change', time, this.format);
        }
      }
    },
    /**
     * Sets the current minute.
     * @method setMinute
     * @param {Number} m The minute.
     * @fires emitInput
     * @emits change
     */
    setMinute(m) {
      if (!bbn.fn.isNull(m)) {
        this.minute = m;
        let time = this.getTime();
        if (!!time && !this.buttons) {
          this.emitInput(time);
          this.$emit('change', time, this.format);
        }
      }
    },
    /**
     * Sets the current second.
     * @method setSecond
     * @param {Number} s The second.
     * @fires emitInput
     * @emits change
     */
    setSecond(s) {
      if (!bbn.fn.isNull(s)) {
        this.second = s;
        let time = this.getTime();
        if (!!time && !this.buttons) {
          this.emitInput(time);
          this.$emit('change', time, this.format);
        }
      }
    },
    /**
     * Emits cancel
     * @method camcel
     * @emits cancel
     */
    cancel() {
      this.$emit('cancel');
    },
    /**
     * Emits input
     * @method save
     * @fires emitInput
     * @emits change
     */
    save() {
      let time = this.getTime();
      if (!!time) {
        this.emitInput(time);
        this.$emit('change', time, this.format);
      }
    }
  },
  watch: {
    /**
     * @watch hour
     * @fires setHour
    */
    hour(newVal, oldVal) {
      if (this.ready && newVal !== oldVal) {
        this.setHour(newVal);
      }
    },
    /**
     * @watch minute
     * @fires setMinute
    */
    minute(newVal, oldVal) {
      if (this.ready && newVal !== oldVal) {
        this.setMinute(newVal);
      }
    },
    /**
     * @watch second
     * @fires setSecond
    */
    second(newVal, oldVal) {
      if (this.ready && newVal !== oldVal && this.showSecond) {
        this.setSecond(newVal);
      }
    },
    /**
     * @watch checkReady
     */
    checkReady(val) {
      this.ready = val;
    }
  }
};
import cpHtml from './timewheel.html';
import cpStyle from './timewheel.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./timewheel.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-timewheel',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-toolbar component
 * @description bbn-toolbar is an horizontal or vertical layout containing elements or components performing actions defined by the user.
 * Very useful for applications, simplifying navigation. Bbn-toolbar is responsive to its container.
 * A separator beetwen elements can be created by giving to empty div inside the toolbar the class 'toolbar-horizontal-separator' or 'toolbar-separator'
 * @copyright BBN Solutions
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * The toolbat elements
     * @prop {Array} [[]] source
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * If true there will be a small margin between buttons
     * @prop {String} [true] slotBefore
     */
    buttonSpace: {
      type: Boolean,
      default: true
    },
    /**
     * If true the content of the slot is placed before the content generated by the configuration.
     * @prop {String} [true] slotBefore
     */
    slotBefore: {
      type: Boolean,
      default: true
    },
    /**
     * The orientation of the bar.
     * @prop {String} ['horizontal'] orientation
     */
    orientation: {
      type: String,
      default: 'horizontal'
    },
    /**
     * The size of the toolbar, height for horizontal toolbar and width for vertical toolbar.
     * @prop {String|Number} size
     */
    size: {
      type: [Number, String]
    },
    /**
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function () {
    return {
      /**
       * The real size of the toolbar basing on the props size and orientation.
       * @data {String} [''] currentSize
       */
      currentSize: '',
      /**
       * The style of the toolbar.
       * @data {String} [''] style
       */
      style: ''
    };
  },
  methods: {
    clickButton(button) {
      if (button.items) {} else if (button.action) {
        button.action();
      }
    },
    updateSlot() {
      if (this.$slots.default) {
        for (let node of this.$slots.default) {
          var _node$bbnSchema;
          if (((_node$bbnSchema = node.bbnSchema) === null || _node$bbnSchema === void 0 ? void 0 : _node$bbnSchema.tag) === 'div' && !node.childNodes.length) {
            node.classList.add('bbn-toolbar-separator');
          }
        }
      }
    }
  },
  /**
   * Defines the current size of the bar basing on its style.
   * @event mounted
   */
  mounted() {
    this.updateSlot();
    if (this.orientation) {
      if (this.orientation === 'horizontal') {
        if (this.size) {
          if (bbn.fn.isString(this.size)) {
            this.currentSize = this.size;
          } else if (bbn.fn.isNumber(this.size)) {
            this.currentSize = this.size + 'px';
          }
          this.style += 'height:' + this.currentSize + ';';
        } else {
          this.style += '';
        }
      } else if (this.orientation === 'vertical') {
        if (this.size) {
          if (bbn.fn.isString(this.size)) {
            this.currentSize = this.size;
          } else if (bbn.fn.isNumber(this.size)) {
            this.currentSize = this.size + 'px';
          }
          this.style += 'width:' + this.currentSize + ';';
        } else {
          this.style += 'width:inherit;';
        }
      }
    }
  }
};
import cpHtml from './toolbar.html';
import cpStyle from './toolbar.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./toolbar.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-toolbar',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-tooltip component
 *
 * @description the bbn-tooltip represents a display of information that is related to an element and which is displayed when is focused or clicked.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * @prop {(String|Object|bbnCp)} component
     */
    component: {
      type: [String, Object, bbnCp]
    },
    /**
     * The source of the component tooltip.
     * @prop {Function|Array} source
     */
    source: {
      type: [Function, String]
    },
    /**
     * @prop {String|Boolean} ['nf nf-mdi-information_outline'] icon
     */
    icon: {
      type: [String, Boolean],
      default: 'nf nf-mdi-information_outline'
    },
    /**
     * The html tag.
     * @prop {String} ['span'] tag
     */
    tag: {
      type: String,
      default: 'span'
    },
    /**
     * If an element is given this will force the position.
     * @prop {String} ['bottom'] position
     */
    position: {
      type: String,
      validator: p => ['', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'top', 'bottom', 'left', 'right'].includes(p),
      default: 'bottom'
    },
    /**
      * Tooltip offset from the element
      * @prop {Number} [10] distance
    */
    distance: {
      type: Number,
      default: 10
    },
    /**
     * The HTML element to which the floater must bind
     * @prop {HTMLElement} element
     */
    element: {
      type: HTMLElement
    },
    raw: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] currentVisible
       */
      currentVisible: false
    };
  },
  methods: {
    /**
     * Returns the items of the component from the source.
     * @method getContent
     * @return {String}
     */
    getContent() {
      let st = bbn.fn.isFunction(this.source) ? this.source() : this.source;
      if (!this.raw) {
        st = '<div class="bbn-vxspadding bbn-hspadding">' + st + '</div>';
      }
      return st;
    }
  }
};
import cpHtml from './tooltip.html';
import cpStyle from './tooltip.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./tooltip.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-tooltip',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-tree component
 * @description bbn-tree is the component that is easily implemented by allowing data to be displayed hierarchically using a tree structure.
 * The component can contain the data loaded only once or it can be created dynamically by making ajax calls, it also allows (after a correct configuration) to perform operations on them, for example drag & drop.
 * @copyright BBN Solutions
 * @author BBN Solutions
 * @created 10/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.localStorage
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage, bbn.cp.mixins.list],
  statics() {
    return {
      NODE_PROPERTIES: ['text', 'icon', 'num', 'numChildren', 'data', 'cls', 'selectedClass', 'activeClass', 'selection', 'selectable', 'multiple', 'filterable', 'sortable', 'selected', 'expanded', 'component', 'tooltip', 'path', 'visible']
    };
  },
  props: {
    /**
     *  @prop {Boolean} [false] excludedSectionFilter
     */
    excludedSectionFilter: {
      type: Boolean,
      default: false
    },
    /**
     * The level until which the tree must be opened.
     * @prop {Number} [0] minExpandLevel
     */
    minExpandLevel: {
      type: Number,
      default: 0
    },
    /**
     * True if the whole tree must be opened.
     * @prop {Boolean} [false] opened
     */
    opened: {
      type: Boolean,
      default: false
    },
    /**
     * An array of objects representing the nodes.
     * @prop {(Array|String|Object|Function)} source
     */
    source: {
      Type: [Array, String, Object, Function]
    },
    /**
     * The class given to the node (or a function returning the class name).
     * @prop {(Function|String)} cls
     */
    cls: {
      type: [Function, String]
    },
    /**
     * A component for the entire node block.
     * @prop {(Function|String|Object)} component
     */
    component: {
      type: [Function, String, Object]
    },
    /**
     * A component for the node.
     * @prop {(Function|String|Object)} itemComponent
     */
    itemComponent: {
      type: [Function, String, Object]
    },
    /**
     * Set to true to have the nodes draggable.
     * @prop {Boolean} [false] draggable
     */
    draggable: {
      type: Boolean,
      default: false
    },
    /**
     * An array (or a function returning one) of elements for the node context menu.
     * @prop {(Array|Function)} menu
     */
    menu: {
      type: [Array, Function]
    },
    /**
     * Set to true to use the icon given in the source object of the node.
     * @prop {Boolean} [true] icons
     */
    icons: {
      type: Boolean,
      default: true
    },
    /**
     * An string (or a function returning one) for the icon's color.
     * @prop {(String|Function)} iconColor
     */
    iconColor: {
      type: [String, Function]
    },
    /**
     * The value of the UID to send for the root tree.
     * @prop {(String|Number)} root
     */
    root: {
      type: [String, Number]
    },
    /**
     * The hierarchy level, root is 0, and for each generation 1 is added to the level.
     * @prop {Number} [0] level
     */
    level: {
      type: Number,
      default: 0
    },
    /**
     * Other trees where nodes can be dropped on.
     * @prop {Array} [[]] droppables
     */
    droppables: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Set to true allows to use an object for the tree items.
     * @prop {Boolean} [false] object
     */
    object: {
      type: Boolean,
      default: false
    },
    /**
     * If set to false a draggable tree will not be able to drop on itself.
     * @prop {Boolean} [true] selfDrop
     */
    selfDrop: {
      type: Boolean,
      default: true
    },
    /**
     * Helper to transform data when passing from one tree to another.
     * @prop {Function} transferData
     */
    transferData: {
      type: Function
    },
    /**
     * The opened path if there is one.
     * @prop {Array} [[]] path
     */
    path: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Set to true for a selectable tree.
     * @prop {Boolean} [true] selectable
     */
    selectable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] hierarchy
     */
    hierarchy: {
      type: Boolean,
      default: true
    },
    /**
     * The string to use as quick filter in the tree.
     * @prop {String} [''] quickFilter
     */
    quickFilter: {
      type: String,
      default: ''
    },
    /**
     * The order of items.
     * @prop {Array} [[{field: 'num', dir: 'DESC'}, {field: 'text', dir: 'ASC'}]] order
     */
    order: {
      type: Array,
      default() {
        return [{
          field: 'num',
          dir: 'ASC'
        }];
      }
    },
    /**
     * @prop {Object} [{}] state
     */
    state: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Set to true if the prop 'ajax' is true,
     * the tree will make the ajax call only for
     * the source of the root level and will take
     * the current data for the source of other levels
     * @prop {Boolean} [false] hybrid
     */
    hybrid: {
      type: Boolean,
      default: false
    },
    /**
     * Set to false if you want remove the scroll inside the tree.
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * Only for the origin tree.
       * @data {Boolean} [false] isRoot
       */
      isRoot: false,
      /**
       * The parent node if not root.
       * @data {Boolean|bbnCp} [false] node
       */
      node: false,
      /**
       * The parent tree if not root.
       * @data {Boolean|bbnCp} [false] tree
       */
      tree: false,
      /**
       * The URL where to pick the data from if isAjax.
       * @data {String|Boolean} url
       */
      url: typeof this.source === 'string' ? this.source : false,
      /**
       * True when the data is currently loading in the current tree.
       * @data {Boolean} [false] loading
       */
      loading: false,
      /**
       * True once the data of the tree has been loaded.
       * @data {Boolean} [false] isLoaded
       */
      isLoaded: false,
      /**
       * True once the component is mounted.
       * @data {Boolean} [false] isMounted
       */
      isMounted: false,
      /**
       * The currently active node component object.
       * @data {Boolean|bbnCp} [false] activeNode
       */
      activeNode: false,
      /**
       * The component node object over which the mouse is now.
       * @data {Boolean|bbnCp} [false] overNode
       */
      overNode: false,
      /**
       * Dragging state, true if an element is being dragged.
       * @data {Boolean|bbnCp} [false] dragging
       */
      dragging: false,
      /**
       * Real dragging will start after the mouse's first move, useful to kow if we are in a select or drag context.
       * @data {Boolean} [false] realDragging
       */
      realDragging: false,
      /**
       * An array containing the indexes of checked nodes.
       * @data {Array} [[]] checked
       */
      checked: [],
      /**
       * An array containing the indexes of disabled checkbox
       * @data {Array} [[]] disabled
       */
      disabled: [],
      /**
       * An array containing the components of expanded nodes.
       * @data {Array} [[]] currentExpanded
       */
      currentExpanded: [],
      /**
       * The component node object over which the mouse is now.
       * @data {Boolean|bbnCp} [false] overOrder
       */
      overOrder: false,
      /**
       * The array of nodes.
       * @data {Array} [[]] nodes
       */
      nodes: [],
      /**
       * The state for the storage.
       * @data {Array} [[]] nodes
       */
      currentState: {},
      /**
       * Set to true once it has been loaded.
       * @data {Array} [[]] nodes
       */
      isInit: false
    };
  },
  computed: {
    /**
     * The current data of the tree.
     * @computed filteredData
     * @fires _checkConditionsOnItem
     * @return {Array}
     */
    filteredData() {
      let ret = [];
      if (this.currentData.length && this.currentFilters && this.currentFilters.conditions && this.currentFilters.conditions.length && (!this.serverFiltering || !this.isAjax)) {
        ret = bbn.fn.filter(this.currentData, a => {
          return this._checkConditionsOnItem(this.currentFilters, a.data);
        });
      } else {
        ret = this.currentData;
      }
      if (this.sortable && this.order.length) {
        /* ret = bbn.fn.multiorder(ret, bbn.fn.map(this.order, o => {
          let r = bbn.fn.extend(true, {}, o);
          r.field = 'data.' + r.field;
          return r;
        })); */
        ret = bbn.fn.multiorder(ret, this.order);
        ret = bbn.fn.map(ret, (v, i) => {
          v.num = i + 1;
          return v;
        });
      }
      return ret;
    },
    /**
     * The selected node.
     * @computed selectedNode
     * @return {Vue|Boolean}
     */
    selectedNode() {
      return this.tree && this.tree.currentSelected.length ? this.tree.currentSelected[this.tree.currentSelected.length - 1] : false;
    },
    /**
     * Array of droppables trees.
     * @computed droppableTrees
     * @return {Array}
     */
    droppableTrees() {
      let r = this.selfDrop ? [this] : [];
      if (this.droppables.length) {
        r.push(...this.droppables);
      }
      return r;
    }
  },
  methods: {
    /**
     * Normalizes the list of items basing on it's type.
     * @method _objectMapper
     * @param {Array|Object} items
     * @fires _objectMapper
     * @return {Array}
     */
    _objectMapper(items) {
      let res = [];
      if (bbn.fn.isArray(items)) {
        bbn.fn.each(items, (a, i) => {
          let numChildren = 0;
          let o = {
            text: bbn._('Node') + ' ' + i,
            numChildren: numChildren
          };
          if (a !== undefined) {
            if (bbn.fn.isArray(a)) {
              numChildren = a.length;
            } else if (typeof a === 'object') {
              numChildren = bbn.fn.numProperties(a);
            } else {
              o.text = typeof a === 'string' ? a : a.toString();
            }
          }
          if (numChildren) {
            o.numChildren = numChildren;
            o[this.children] = this._objectMapper(a);
          }
          res.push(o);
        });
      } else if (items && typeof items === 'object' && bbn.fn.numProperties(items)) {
        bbn.fn.iterate(items, (a, n) => {
          let numChildren = 0;
          let o = {
            text: n,
            numChildren: numChildren
          };
          if (a !== undefined) {
            if (bbn.fn.isArray(a)) {
              numChildren = a.length;
            } else if (typeof a === 'object') {
              numChildren = bbn.fn.numProperties(a);
            } else {
              o.text = '<strong>' + o.text + ': </strong>' + a;
            }
          }
          if (numChildren) {
            o.numChildren = numChildren;
            o[this.children] = this._objectMapper(a);
          }
          res.push(o);
        });
      }
      return res;
    },
    _getTreeState(uid) {
      if (uid !== undefined && this.currentState[uid]) {
        //bbn.fn.log('CURRENT STATE FOUND', this.currentState[uid][this.children]);
        //return bbn.fn.clone(this.currentState[uid].items);
        return this.currentState[uid].items;
      }
      return {};
    },
    /**
     * A function to normalize the structure of items.
     * @method _map
     * @param {Array} items
     * @fires tree.map
     * @fires _objectMapper
     * @return {Array}
     */
    _map(items) {
      if (this.object) {
        items = this._objectMapper(items.reduce((r, k) => {
          r[k.value] = k.text;
          return r;
        }, {}));
      }
      items = bbn.fn.map(items, item => {
        let o = {};
        if (this.tree.map) {
          item = this.tree.map(item.data !== undefined ? item.data : item, this.level + 1, item.data !== undefined ? item : {});
        }
        bbn.fn.each(bbnTreeCp.NODE_PROPERTIES, p => {
          o[p] = p === 'text' ? item[this.tree.sourceText] : item[p];
        });
        if (!!item.data && !!item.data[this.tree.children]) {
          o.numChildren = item.data[this.tree.children].length;
        }
        if (!!item[this.tree.children]) {
          o.numChildren = item[this.tree.children].length;
        }
        if (o.data === undefined) {
          o.data = item;
        }
        return o;
      });
      return items;
    },
    /**
     * Resets the tree to the original configuration.
     * @method reset
     * @fires updateData
     */
    reset() {
      this.isLoaded = false;
      //this.$set(this, 'currentData', []);
      //this.$forceUpdate();
      //this.$nextTick(() => {
      this.updateData();
      //})
    },

    /**
     * Resizes the root scroller.
     * @method resize
     */
    resize() {
      let scroll = this.tree.getRef('scroll');
      if (scroll && bbn.fn.isFunction(scroll.onResize)) {
        scroll.onResize();
      }
    },
    /**
     * Resizes the root tree and emit an open event
     * @method onOpen
     * @fires resize
     * @emits open
     */
    onOpen() {
      this.resize();
      this.$emit('open');
      this.tree.$emit('open', this);
    },
    /**
     * Resizes the root tree and emit a close event.
     * @method onClose
     * @fires resize
     * @emits close
     */
    onClose() {
      this.resize();
      this.$emit('close');
      this.tree.$emit('close', this);
    },
    /**
     * Finds a node based on its props.
     * @method findNode
     * @param {Object} props
     * @param {Object} node
     * @return {Object}
     */
    findNode(props, expand) {
      let ret = false;
      if (this.isRoot || this.node.numChildren && bbn.fn.isObject(props)) {
        if (expand && !this.isRoot && !this.node.isExpanded) {
          this.node.isExpanded = true;
        }
        let lst = this.getRef('list');
        if (lst && lst.querySelectorAll) {
          const eles = lst.querySelectorAll('li[is=bbn-tree-node]');
          if (eles.length) {
            const data = [];
            eles.forEach(a => {
              data.push(a.bbn.data);
            });
            let idx = bbn.fn.search(data, props);
            if (idx > -1) {
              ret = eles[idx].bbn;
            } else {
              bbn.fn.each(eles, node => {
                let tree = node.bbn.getRef('tree');
                if (tree) {
                  ret = tree.findNode(props, expand);
                  if (ret) {
                    return false;
                  }
                }
              });
            }
          }
        }
      }
      return ret;
    },
    /**
     * Returns the node corresponding to the given idx.
     * @method getNodeByIdx
     * @param {Number} idx
     * @return {bbnCp|Boolean}
     */
    getNodeByIdx(idx) {
      if (bbn.fn.isNumber(idx) && this.nodes.length) {
        return bbn.fn.getRow(this.nodes, {
          idx: parseInt(idx)
        });
      }
      return false;
    },
    /**
     * Adds a node to the tree.
     * @param {Object} obj The item to add.
     * Returns {Boolean|Object}
     */
    addNode(obj) {
      if (bbn.fn.isObject(obj)) {
        obj = this._map([obj])[0];
        obj._bbn = true;
        obj.index = this.currentData.length;
        this.currentData.push(obj);
        return obj;
      }
      return false;
    },
    /**
     * Returns the menu of the given node.
     * @method getMenu
     * @param {Object} node
     * @fires reload
     * @fires menu
     * @return {Array}
     */
    getMenu(node) {
      let menu = [],
        tree = node.getRef('tree');
      if (node.numChildren) {
        menu.push({
          text: node.isExpanded ? bbn._("Close") : bbn._("Open"),
          icon: node.isExpanded ? 'nf nf-fa-arrow_circle_up' : 'nf nf-fa-arrow_circle_down',
          action: () => {
            node.isExpanded = !node.isExpanded;
          }
        });
      }
      if (this.isAjax && node.numChildren && tree && tree.isLoaded) {
        menu.push({
          text: bbn._("Refresh"),
          icon: 'nf nf-fa-refresh',
          action: () => {
            this.reload(node);
          }
        });
      }
      if (this.menu) {
        let m2 = bbn.fn.isFunction(this.menu) ? this.menu(node, node.idx) : this.menu;
        if (m2.length) {
          bbn.fn.each(m2, function (a, i) {
            menu.push({
              text: a.text,
              icon: a.icon ? a.icon : '',
              action: a.action ? () => {
                a.action(node);
              } : false
            });
          });
        }
      }
      return menu;
    },
    /**
     * Returns an object with the data to send for a given node.
     * If UID has been given obj will only have this prop other the whole data object.
     * @method getPostData
     * @fires data
     * @return {Object}
     */
    getPostData() {
      // The final object to send
      let r = {},
        uid = this.uid || this.tree.uid;
      // If the uid field is defined
      if (uid) {
        // If an item has been given we send the corresponding data, or otherwise an empty string
        if (this.node) {
          r[uid] = this.node.data && this.node.data[uid] ? this.node.data[uid] : '';
        } else if (this.isRoot) {
          r[uid] = this.root ? this.root : '';
        }
      } else if (this.node) {
        r = this.node.data;
      }
      if (bbn.fn.isFunction(this.tree.data)) {
        r = bbn.fn.extend(true, {}, this.tree.data(this.node ? this.node.data : {}), r);
      } else {
        r = bbn.fn.extend(true, {}, this.tree.data, r);
      }
      return r;
    },
    /**
     * Manages the key navigation inside the tree.
     * @method keyNav
     * @param {Event} e The event
     */
    keyNav(e) {
      this.tree.$emit('keynav', e.key);
      if (this.tree.activeNode) {
        let parent = this.tree.activeNode.parent;
        let data = parent.filteredData.filter(d => !!d.visible);
        let min = 0;
        let max = data.length - 1;
        let idx = bbn.fn.search(data, {
          index: this.tree.activeNode.idx
        });
        let subtree = this.tree.activeNode.getRef('tree');
        switch (e.key) {
          case 'Enter':
          case ' ':
            if (this.tree.activeNode.selectable) {
              this.tree.activeNode.isSelected = !this.tree.activeNode.isSelected;
            } else {
              let ev = new Event('nodeclick', {
                cancelable: true
              });
              this.tree.$emit('nodeclick', this.tree.activeNode, ev);
            }
            break;
          case 'PageDown':
          case 'End':
            if (data.length) {
              bbn.fn.getRow(parent.nodes, {
                idx: data[data.length - 1].index
              }).isActive = true;
              this.scrollToActive();
            }
            break;
          case 'PageUp':
          case 'Home':
            if (data.length) {
              bbn.fn.getRow(parent.nodes, {
                idx: data[0].index
              }).isActive = true;
              this.scrollToActive();
            }
            break;
          case 'ArrowLeft':
            if (this.tree.activeNode.numChildren && this.tree.activeNode.isExpanded) {
              this.tree.activeNode.isExpanded = false;
            } else if (!this.tree.activeNode.parent.isRoot) {
              this.tree.activeNode.parent.node.isActive = true;
              this.scrollToActive();
            }
            break;
          case 'ArrowRight':
            if (this.tree.activeNode.numChildren) {
              if (!this.tree.activeNode.isExpanded) {
                this.tree.activeNode.isExpanded = true;
              } else if (subtree && subtree.nodes.length) {
                bbn.fn.getRow(subtree.nodes, {
                  idx: subtree.filteredData[0].index
                }).isActive = true;
                this.scrollToActive();
              }
            }
            break;
          case 'ArrowDown':
            if (idx + 1 <= max) {
              bbn.fn.getRow(parent.nodes, {
                idx: data[idx + 1].index
              }).isActive = true;
              this.scrollToActive();
            } else if (parent.node && parent.node.parent) {
              data = parent.node.parent.filteredData.filter(d => !!d.visible);
              idx = bbn.fn.search(data, {
                index: parent.node.idx
              });
              if (idx > -1 && data[idx + 1]) {
                bbn.fn.getRow(parent.node.parent.nodes, {
                  idx: data[idx + 1].index
                }).isActive = true;
                this.scrollToActive();
              }
            }
            break;
          case 'ArrowUp':
            if (idx - 1 >= min) {
              bbn.fn.getRow(parent.nodes, {
                idx: data[idx - 1].index
              }).isActive = true;
              this.scrollToActive();
            } else if (!parent.isRoot && parent.node) {
              parent.node.isActive = true;
              this.scrollToActive();
            }
            break;
        }
      } else if (this.tree.selectedNode) {
        this.tree.activeNode = this.tree.selectedNode;
        this.scrollToActive();
      } else if (this.tree.filteredData.length) {
        bbn.fn.getRow(this.tree.nodes, {
          idx: this.tree.filteredData[0].index
        }).isActive = true;
        this.scrollToActive();
      }
    },
    /**
     * Reloads a node already loaded.
     * @method reload
     * @param {bbnCp} node
     * @fires updateData
     */
    reload(node) {
      //if ( this.isAjax ){
      if (this.isRoot && !node) {
        this.isLoaded = false;
        return this.init();
      } else {
        node = !node ? this.node : node;
        let tree = node.getRef('tree');
        if (tree) {
          tree.isLoaded = false;
          return tree.updateData();
        }
      }
      //}
    },

    /**
     * Loads a node.
     * @method load
     * @fires updateData
     */
    load() {
      this.updateData();
    },
    getNodeByUid(uid) {
      let res = false;
      if (this.uid) {
        bbn.fn.each(this.findAll('bbn-tree-node'), e => {
          if (e.source && e.source.data && e.source.data[this.uid] === uid) {
            res = e;
            return false;
          }
        });
      }
      return res;
    },
    /**
     * Returns the node's path.
     * @method getNodePath
     * @param {Object} node
     * @param {String} field
     */
    getNodePath(node, field) {
      let f = field || this.uid || false,
        obj = Object.keys(node.data).length ? bbn.fn.extend(true, {}, node.data) : false,
        fromObj = !f || node.data[f] === undefined;
      if (!fromObj || obj) {
        let r = [fromObj ? obj : node.data[f]],
          tree = node.parent;
        while (tree && tree !== this) {
          node = tree.node;
          r.unshift(fromObj ? bbn.fn.extend(true, {}, node.data) : node.data[f]);
          tree = node.parent;
        }
        return r;
      }
      return false;
    },
    /**
     * Unselects the currently selected node.
     * @method unselect
     */
    unselect() {
      if (this.tree.selectedNode) {
        this.tree.selectedNode.isSelected = false;
        if (!this.multiple) {
          this.$emit('unselect', this);
        }
      }
    },
    /**
     * Deactivate the active nodes.
     * @method deactivateAll
     */
    deactivateAll() {
      if (this.tree.activeNode) {
        this.tree.activeNode.isActive = true;
      }
    },
    /**
     * Returns true if the first argument node descends from the second.
     * @method isNodeOf
     * @param {Object} childNode
     * @param {Object} parentNode
     * @return {Boolean}
     */
    isNodeOf(childNode, parentNode) {
      childNode = childNode.closest('bbn-tree-node');
      while (childNode) {
        if (childNode === parentNode) {
          return true;
        }
        childNode = childNode.closest('bbn-tree-node');
      }
      return false;
    },
    /**
     *  Moves a node to or inside a tree.
     * @method move
     * @param {Object} node
     * @param {Object} target
     * @param {Boolean} [false] force
     */
    move(node, target) {
      let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // initializing and sending an event cancelable if force is false
      let ev = new Event("move", {
        cancelable: !force
      });
      this.tree.$emit('move', node, target, ev);
      // if the action has not been prevented
      if (!ev.defaultPrevented) {
        // getting the parent of the source node
        let parent = node.parent;
        // getting the position of the source node
        let idx = !!node.parent ? bbn.fn.search(parent.currentData, {
          index: node.idx
        }) : -1;
        // getting all the nodes at a lower level than the source node
        let nodes = node.findAll('bbn-tree-node');
        // filtered by those who are expanded
        let expanded = nodes.filter(n => !!n.isExpanded);
        // and by those who are selected
        let selected = nodes.filter(n => !!n.isSelected);
        // verification if the node had parent et his index is greater than or equel to 0
        if (idx >= 0 && parent) {
          // if there is no children then we set the number of children to 1
          if (!target.source.numChildren) {
            target.$set(target.source, 'numChildren', 1);
          }
          // otherwhise we increase the number of children by one
          else {
            target.source.numChildren++;
          }
          // updating the DOM of VUE
          this.$nextTick(() => {
            // get the ref and put it in the targetTree
            let targetTree = target.getRef('tree');
            if (node.isExpanded) {
              // if the node is expanded we're adding it to the expanded
              expanded.unshift(node);
            }
            // if the node is selected we're adding it to the selected
            if (node.isSelected) {
              selected.unshift(node);
            }
            // If the source node is inside a parent node and is moved then we lower the number of children by one
            if (parent.node) {
              parent.node.numChildren--;
            }
            // adding the node and push it to the tree
            if (this.tree.isAjax) {
              let nodeSource = bbn.fn.extend(true, {}, parent.currentData[idx]);
              if (bbn.fn.isFunction(this.transferData)) {
                nodeSource = this.transferData(nodeSource);
              }
              let children = target.source.data[this.tree.children];
              if (!children) {
                target.source.data[this.tree.children] = [];
                children = target.source.data[this.tree.children];
              }
              if (!target.isExpanded) {
                targetTree.$once('dataloaded', () => {
                  // adding in the node source the length of the target tree if there is no length then we set it at 1
                  nodeSource.num = targetTree.currentData.length || 1;
                  // we're adding the index also
                  nodeSource.index = nodeSource.num - 1;
                  // and then we push node source in the targetTree
                  children.push(nodeSource);
                });
              } else {
                // adding in the node source the length of the target tree if there is no length then we set it at 1
                nodeSource.num = targetTree.currentData.length || 1;
                // we're adding the index also
                nodeSource.index = nodeSource.num - 1;
                // and then we push node source in the targetTree
                children.push(nodeSource);
              }
            } else {
              let nodeSource = parent.source.splice(idx, 1)[0];
              if (bbn.fn.isFunction(this.transferData)) {
                nodeSource = this.transferData(nodeSource);
              }
              // if the array is empty we set one
              if (!bbn.fn.isArray(target.source.data[this.tree.children])) {
                target.$set(target.source.data, this.tree.children, []);
              }
              // otherwise we just push the data inside the array
              target.source.data[this.tree.children].push(nodeSource);
            }
            // we remove the expanded node
            bbn.fn.each(expanded, n => {
              n.removeFromExpanded(false);
            });
            // we remove the selected node
            bbn.fn.each(selected, n => {
              n.removeFromSelected(false);
            });
            // remove the old node
            parent.currentData.splice(idx, 1);
            this.$nextTick(() => {
              // if the target node isn't expanded we do it
              if (!target.isExpanded) {
                target.isExpanded = true;
              }
              // then we update the data
              if (!this.tree.isAjax) {
                let path = target.getPath();
                targetTree.updateData().then(() => {
                  targetTree.expandPath(path);
                });
              }
            });
          });
        }
      }
    },
    /**
     * Returns an object with all the unknown properties of the node component.
     * @param {Object} data
     * @return {Object}
     */
    toData(data) {
      let r = {};
      for (let n in data) {
        if (bbnTreeCp.NODE_PROPERTIES.indexOf(n) === -1) {
          r[n] = data[n];
        }
      }
      return r;
    },
    /**
     * Returns the current configuration of the tree.
     * @method getConfig
     * @returns {Object}
     */
    getConfig() {
      let cfg = {
        expanded: [],
        selected: [],
        state: this.currentState
      };
      if (!this.uid) {
        return cfg;
      }
      // Expanded
      bbn.fn.each(this.currentExpanded, c => {
        if (c.data && c.data[this.uid]) {
          cfg.expanded.push(c.data[this.uid]);
        }
      });
      // Selected
      bbn.fn.each(this.currentSelected, c => {
        if (c.data && c.data[this.uid] && (!!this.multiple || !cfg.selected.length)) {
          cfg.selected.push(c.data[this.uid]);
        }
      });
      return cfg;
    },
    /**
     * Gets the local storage.
     * @method getLocalStorage
     */
    getLocalStorage() {
      if (this.isRoot && this.hasStorage) {
        return this.getStorage(this.storageFullName || this.storageName, !!this.storageFullName);
      }
    },
    /**
     * Sets the local storage.
     * @method setLocalStorage
     */
    setLocalStorage() {
      let ev = new Event('setStorage', {
          cancelable: true
        }),
        cfg = this.getConfig();
      this.$emit('setStorage', cfg, this.storageFullName || this.storageName, ev);
      if (!ev.defaultPrevented) {
        this.setStorage(cfg, this.storageFullName || this.storageName, !!this.storageFullName);
      }
    },
    /**
     * Scrolls the tree to the selected node.
     * @method scrollToSelected
     */
    scrollToSelected() {
      if (this.tree && this.tree.selectedNode) {
        let scroll = this.tree.getRef('scroll');
        if (scroll) {
          scroll.scrollTo(0, this.tree.selectedNode.$el);
        }
      }
    },
    /**
     * Scrolls the tree to the active node.
     * @method scrollToActive
     */
    scrollToActive() {
      if (this.tree && this.tree.activeNode) {
        let scroll = this.tree.getRef('scroll');
        if (scroll) {
          scroll.scrollTo(0, this.tree.activeNode.$el);
        }
      }
    },
    _setCurrentState(state) {
      this.currentState = state;
    },
    initStorage() {
      let state;
      if (this.hasStorage && this.isRoot) {
        let storage = this.getLocalStorage();
        if (storage) {
          state = storage.state || null;
        }
      } else if (this.state) {
        state = this.state;
      }
      if (state) {
        this._setCurrentState(state);
      }
    },
    expandPath(path, field) {
      let select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      field = field || this.uid || false;
      if (field && path && path.length) {
        if (!bbn.fn.isArray(path)) {
          path = [path];
        }
        let currentPaths = path.slice(),
          uid = currentPaths.shift(),
          isLast = !currentPaths.length;
        if (uid !== undefined) {
          if (this.isLoading || !this.isLoaded) {
            this.$once('dataloaded', () => {
              this.$nextTick(() => {
                this.expandPath(path, field, select);
              });
            });
          } else if (this.isLoaded && !this.isLoading) {
            this.$nextTick(() => {
              let node = this.findNode({
                [field]: uid
              });
              if (node) {
                if (isLast && !!select) {
                  node.isSelected = true;
                } else if (!!node.numChildren) {
                  let tree = node.getRef('tree');
                  if (tree) {
                    if (!node.isExpanded) {
                      tree.$once('dataloaded', () => {
                        this.$nextTick(() => {
                          tree.expandPath(currentPaths, field, select);
                        });
                      });
                      node.isExpanded = true;
                    } else if (!isLast) {
                      tree.expandPath(currentPaths, field, select);
                    }
                  }
                }
              } else if (time === 1) {
                setTimeout(() => {
                  this.expandPath(path, field, select, 2);
                }, 100);
              }
            });
          }
        }
      }
    },
    selectPath(path, field) {
      this.expandPath(path, field, true);
    },
    initState() {
      var _this$node;
      if (((_this$node = this.node) !== null && _this$node !== void 0 && _this$node.isExpanded || this.isRoot || bbn.fn.count(Object.values(this.currentState), {
        expanded: true
      }) || bbn.fn.count(Object.values(this.currentState), {
        selected: true
      })) && bbn.fn.numProperties(this.currentState) && this.filteredData.length) {
        setTimeout(() => {
          bbn.fn.iterate(this.currentState, (o, uid) => {
            let it = this.uid !== undefined ? this.findNode({
              [this.uid]: uid
            }) : false;
            if (it) {
              if (o.items && bbn.fn.numProperties(o.items) || o.expanded) {
                it.isExpanded = true;
              }
              if (o.selected) {
                if (it.selectable) {
                  it.isSelected = true;
                } else {
                  o.selected = false;
                }
              }
            } else {
              delete this.currentState[uid];
            }
          });
        }, 250);
      }
    },
    /**
     * @method init
     * @fires updateData
     * @fires initState
     */
    init() {
      if (this.node.isExpanded || this.isRoot || bbn.fn.count(Object.values(this.currentState), {
        expanded: true
      }) || bbn.fn.count(Object.values(this.currentState), {
        selected: true
      })) {
        return this.updateData().then(() => {
          this.isInit = true;
          this.$forceUpdate().then(() => {
            this.initState();
          });
        });
      } else {
        this.isInit = true;
      }
    },
    /**
     * Keep to prevent the one from list to exexute
     * @method listOnBeforeMount
     */
    listOnBeforeMount() {
      return;
    },
    /**
     * @method afterUpdate
     * @event dataloaded
     * @fires $nextTick
     * @fires initState
     */
    afterUpdate() {
      /*
      if (!this.isLoaded && this.ready && !this.tree.autobind) {
        this.$once('dataloaded', () => {
          this.$nextTick(this.initState);
        });
      }
      */
    }
  },
  /**
   * Emits the event beforeLoad and load. And opens the nodes defined in the prop path.
   * Definition of the root tree and parent node.
   * @event beforeupdate
   * @event startloading
   * @event datareceived
   * @emits tree,beforeLoad
   * @emits load
   * @fires closest
   */
  created() {
    this.$on('beforeupdate', e => {
      if (this.isAjax && (this.tree.isLoading || this.isLoading)) {
        e.preventDefault();
      }
      if (!e.defaultPrevented) {
        this.tree.$emit('beforeload', this.getPostData());
      }
    });
    this.$on('startloading', () => {
      this.loading = true;
    });
    this.$on('datareceived', d => {
      this.loading = false;
      this.tree.$emit('load', d);
    });
    this.$on('dataloaded', d => {
      this.tree.$emit('afterload', d);
    });
    if (bbn.fn.isFunction(this.source)) {
      this.isFunction = true;
    }
    let cp = this.closest('bbn-tree');
    if (!cp) {
      this.isRoot = true;
      this.node = false;
      this.tree = this;
    } else {
      while (cp && cp.level) {
        cp = cp.closest('bbn-tree');
      }
      if (cp && !cp.level) {
        this.tree = cp;
        this.isAjax = this.tree.isAjax && !this.tree.hybrid;
      }
      this.node = this.closest('bbn-tree-node');
    }
  },
  /**
   * Updates the data of the tree and sets the prop 'ready' to true.
   * @event mounted
   * @fires updateData
   */
  mounted() {
    this.ready = true;
    this.initStorage();
    if (this.tree.autobind) {
      this.$nextTick(() => {
        this.init();
      });
    } else {
      this.isInit = true;
    }
  },
  watch: {
    /**
     *
     * @param {Object} newVal
     */
    activeNode(newVal) {
      if (newVal && this.isRoot) {
        let scroll = this.getRef('scroll');
        if (scroll) {
          //scroll.scrollTo(0, newVal.$el);
        }
      }
    },
    selectedNode(newVal) {
      if (newVal && this.isRoot) {
        let scroll = this.getRef('scroll');
        if (scroll) {
          //scroll.scrollTo(0, newVal.$el);
        }
      }
    },
    /**
     * Updates the ree overNode and overOrder when the prop 'dragging' changes.
     * @param {Boolean} newVal
     */
    dragging(newVal) {
      if (!newVal) {
        this.overNode = false;
        this.overOrder = false;
      }
    },
    quickFilter(newVal) {
      if (!this.isAjax && this.nodes.length) {
        bbn.fn.each(this.nodes, n => {
          n.isExpanded = !!newVal.length;
        });
      }
    }
  },
  components: {
    /**
     * @component bbn-tree-node
     */
    node: {
      tag: 'li',
      props: {
        /**
         * @prop {String} filterString
         * @memberof bbn-tree-node
         */
        filterString: {
          type: String
        },
        /**
         * @prop {Boolean} [false] excludedSectionFilter
         * @memberof bbn-tree-node
         */
        excludedSectionFilter: {
          type: Boolean,
          default: false
        },
        /**
         * True if the node is selectable
         * @prop {Boolean} [true] selectable
         * @memberof bbn-tree-node
         */
        selectable: {
          type: Boolean,
          default: false
        },
        multiple: {
          type: Boolean,
          default: false
        },
        /**
         * True if the node is selection
         * @prop {Boolean} [false] selection
         * @memberof bbn-tree-node
         */
        selection: {
          type: Boolean,
          default: true
        },
        /**
         * The opened path if there is one
         * @prop {Array} [[]] path
         * @memberof bbn-tree-node
         */
        path: {
          type: Array,
          default() {
            return [];
          }
        },
        /**
         * A component for the node
         * @prop {String|Function|bbnCp} component
         * @memberof bbn-tree-node
         */
        component: {
          type: [String, Function, bbnCp, Object]
        },
        /**
         * The list of children from the node
         * @prop {Array} [[]] source
         * @memberof bbn-tree-node
         */
        source: {
          type: Object,
          default() {
            return {};
          }
        },
        /**
         * Node's level (see tree)
         * @prop {Number} [1] level
         * @memberof bbn-tree-node
         */
        level: {
          type: Number,
          default: 1
        },
        /**
         * @prop {Number} idx
         * @memberof bbn-tree-node
         */
        idx: {
          type: Number
        },
        quickFilter: {
          type: String,
          default: ''
        },
        sortable: {
          type: Boolean,
          default: true
        },
        uid: {
          type: String
        },
        treeState: {
          type: Object,
          default() {
            return {};
          }
        },
        flat: {
          type: Boolean,
          default: false
        }
      },
      data() {
        return {
          ready: false,
          /**
          * The parent tree
          * @data {Boolean} [false] parent
          * @memberof bbn-tree-node
          */
          parent: false,
          /**
           * The root tree
           * @data {Boolean} [false] tree
           * @memberof bbn-tree-node
           */
          tree: false,
          /**
           * True if the node is active
           * @data {Boolean} [false] isActive
           * @memberof bbn-tree-node
           */
          isActive: false,
          /**
           * The animation of the node
           * @data {Boolean} animation
           * @memberof bbn-tree-node
           */
          animation: this.level > 0,
          /**
           * True if the component bbn-tree-node is mounted
           * @data {Boolean} [false] isMounted
           * @memberof bbn-tree-node
           */
          isMounted: false,
          orderOver: false
        };
      },
      computed: {
        isOverOrderTop() {
          return this.tree && this.tree.realDragging && this.tree.overOrder && this.tree.overOrder === this.getRef('orderTop');
        },
        isOverOrderBottom() {
          return this.tree && this.tree.realDragging && this.tree.overOrder && this.tree.overOrder === this.getRef('orderBottom');
        },
        data() {
          return this.source.data;
        },
        isVisible() {
          let tree = this.getRef('tree');
          return !this.quickFilter || this.source.text.toLowerCase().includes(this.quickFilter.toLowerCase()) && (!this.numChildren || !this.tree.excludedSectionFilter || tree && tree.nodes && bbn.fn.filter(tree.nodes, n => !!n.isVisible).length) || tree && tree.nodes && bbn.fn.filter(tree.nodes, n => !!n.isVisible).length;
        },
        isExpanded: {
          get() {
            return !!this.source.expanded;
          },
          set(v) {
            this.source.expanded = v;
          }
        },
        isSelected: {
          get() {
            return !!this.source.selected;
          },
          set(v) {
            this.source.selected = v;
          }
        },
        isFilterable() {
          return this.source.filterable !== undefined ? !!this.source.filterable : !!this.tree.filterable;
        },
        hasFilters() {
          let tree = this.getRef('tree');
          return tree && tree.hasFilters;
        },
        numChildren: {
          get() {
            return this.source.numChildren;
          },
          set(v) {
            this.source.numChildren = v;
          }
        },
        /**
         * The style of the item's icon
         * @computed iconStyle
         * @return {Object}s
         * @memberof bbn-tree-node
         */
        iconStyle() {
          let style = {};
          if (this.tree.iconColor) {
            style.color = bbn.fn.isFunction(this.tree.iconColor) ? this.tree.iconColor(this) : this.tree.iconColor;
          }
          return style;
        },
        textFromText() {
          if (this.source.data.text) {
            return bbn.fn.html2text(this.source.data.text);
          }
          return '';
        }
      },
      methods: {
        randomString: bbn.fn.randomString,
        /**
         * Return true if the node is checked
         * @method isChecked
         * @memberof bbn-tree-node
         */
        isChecked(uid) {
          return this.tree.checked.includes(uid);
        },
        /**
         * Return true if the node is disabled
         * @method isDisabled
         * @memberof bbn-tree-node
         */
        isDisabled() {
          return this.tree.disabled.includes(this.data[this.tree.uid]);
        },
        /**
         * Checks the node and emits the events check and uncheck
         * @method checkNode
         * @emits check
         * @emits uncheck
         * @memberof bbn-tree-node
         */
        checkNode(val) {
          if (val && this.data[this.tree.uid] && !this.tree.checked.includes(this.data[this.tree.uid])) {
            this.tree.checked.push(this.data[this.tree.uid]);
            this.tree.$emit('check', this.data[this.tree.uid]);
          } else if (!val) {
            let tmp = this.tree.checked.indexOf(this.data[this.tree.uid]);
            if (tmp > -1) {
              this.tree.checked.splice(tmp, 1);
              this.tree.$emit('uncheck', this.data[this.tree.uid]);
            }
          }
        },
        /**
         * Activate the node
         * @method activate
         * @memberof bbn-tree-node
         */
        activate() {
          this.isActive = true;
        },
        update(attr) {
          for (let n in attr) {
            this[n] = attr[n];
          }
        },
        /**
         * Resize the parent tree
         * @method tree.resize
         * @memberof bbn-tree-node
         * @memberof bbn-tree-node
         */
        resize() {
          this.tree.resize();
        },
        reload() {
          this.tree.reload(this);
        },
        /**
         * Gets the menu of the parent tree
         * @method getMenu
         * @memberof bbn-tree-node
         * @fires tree.getMenu
         */
        getMenu() {
          return this.tree.getMenu(this);
        },
        beforeEnter() {
          if (this.animation) {
            //alert("beforeEnter " + $(this.$refs.container).height());
          }
        },
        enter() {
          if (this.animation) {
            //alert("enter " + $(this.$refs.container).height());
          }
        },
        afterEnter() {
          if (this.animation) {
            //alert("afterEnter " + $(this.$refs.container).height());
          }
        },
        /**
         * Handles the start of dragging of the tree
         * @method startDrag
         * @param {Event} e The event
         * @emits tree.dragstart
         * @memberof bbn-tree-node
         */
        startDrag(e) {
          if ((this.tree.draggable || this.sortable) && !this.tree.realDragging) {
            if (this.tree.selectedNode) {
              //this.tree.selectedNode.isSelected = false;
            }
            this.tree.$emit("dragstart", this, e);
            if (!e.defaultPrevented) {
              this.tree.dragging = this;
              this.tree.realDragging = true;
              if (this.tree.droppableTrees.length) {
                bbn.fn.each(this.tree.droppableTrees, dt => {
                  if (dt !== this.tree) {
                    dt.dragging = this;
                  }
                });
              }
            }
          } else {
            e.preventDefault();
          }
        },
        /**
         * Handles the dragging of the node
         * @method drag
         * @param {Event} e The event
         * @emits tree.dragstart
         * @emits  dragover
         * @memberof bbn-tree-node
         */
        drag(e) {
          this.mouseOver();
          // we prevent default from the event
          if (this.sortable) {
            if (e.target.classList.contains('bbn-tree-order')) {
              if (this.tree.overOrder !== e.target) {
                this.tree.overOrder = e.target;
              }
            } else {
              this.tree.overOrder = false;
            }
          }
          if (!!this.tree.dragging) {
            let subTree = this.getRef('tree');
            if (!!this.tree.overNode && this === this.tree.overNode && this !== this.tree.dragging && !this.tree.isNodeOf(this, this.tree.dragging) && (!subTree || subTree !== this.parent)) {
              this.tree.$emit("dragover", this, this.tree.dragging, e);
              if (e.defaultPrevented) {
                this.tree.overNode = false;
              }
            } else {
              this.tree.overNode = false;
            }
          }
        },
        /**
         * Handles the leave of dragging
         * @method leaveDrag
         * @param {Event} e The event
         * @memberof bbn-tree-node
         */
        leaveDrag(e) {
          this.tree.overNode = false;
        },
        /**
         * Handles the drop of dragging
         * @method drop
         * @param {Event} e The event
         * @emits dragend
         * @memberof bbn-tree-node
         */
        drop(e) {
          e.preventDefault();
          e.stopImmediatePropagation();
          if (this.tree.dragging && this.tree.overNode && this === this.tree.overNode) {
            let ev = new CustomEvent('drop', {
              cancelable: true,
              bubbles: true,
              detail: e.detail
            });
            let originalTree = this.tree.dragging.tree;
            this.tree.$emit('drop', this.tree.dragging, this, ev);
            if (!ev.defaultPrevented) {
              if (this.tree.overOrder) {
                let numBefore = this.tree.dragging.source.num,
                  numAfter = this.tree.overOrder.classList.contains('bbn-tree-order-top') ? 1 : this.tree.overNode.source.num + (numBefore > this.tree.overNode.source.num ? 1 : 0);
                if (numBefore !== numAfter && this.tree.dragging.parent === this.tree.overNode.parent) {
                  this.reorder(this.tree.dragging.source.num, numAfter);
                }
              } else if (this.tree.draggable && this.tree.dragging.parent !== this.tree.overNode) {
                originalTree.move(this.tree.dragging, this);
              }
            }
          }
          let ev = new CustomEvent('dragend', {
            cancelable: true,
            bubbles: true
          });
          this.tree.$emit('dragend', ev);
        },
        /**
         * Handles the end of dragging
         * @method endDrag
         * @param {Event} e The event
         * @emits tree.dragend
         * @memberof bbn-tree-node
         */
        endDrag(e) {
          e.preventDefault();
          e.stopImmediatePropagation();
          let ev = new CustomEvent('dragend', {
            cancelable: true,
            bubbles: true
          });
          this.tree.$emit('dragend', this.source, ev);
          if (!ev.defaultPrevented) {
            bbn.fn.each(this.tree.dragging.tree.droppableTrees, dt => {
              dt.overNode = false;
              dt.realDragging = false;
              dt.dragging = false;
            });
            if (!!this.tree.dragging && !this.tree.dragging.tree.selfDrop) {
              this.tree.dragging.tree.overNode = false;
              this.tree.dragging.tree.realDragging = false;
              this.tree.dragging.tree.dragging = false;
            }
          }
        },
        // the args are the old index the new index and if we force the reorder or not
        reorder(oldNum, newNum, force) {
          // checking if the indexes are the same to order or not the data
          if (oldNum !== newNum) {
            // arr became the filteredData i don't know what the slice is for
            let arr = this.parent.filteredData.slice();
            // remove the data at old index
            let ele = arr.splice(oldNum - 1, 1);
            // create a new event beforeOrder that is cancelable
            let ev = new Event('beforeOrder', {
              cancelable: true
            });
            // if there is datas in ele
            if (ele.length) {
              // and force is false
              if (!force) {
                // we call the event beforeOrfer
                this.tree.$emit('beforeOrder', oldNum, newNum, this.tree.dragging, ev);
              }
              if (!!force || !ev.defaultPrevented) {
                // remove the data at the index
                arr.splice(newNum - 1, 0, ele[0]);
                bbn.fn.each(arr, (e, i) => {
                  // and add the data
                  if (e.num !== i + 1) {
                    let data = bbn.fn.extend(true, {}, e.data);
                    e.num = i + 1;
                    if (e.data.num !== undefined) {
                      //e.data.num = e.num;
                    }
                    // then it orders is
                    this.tree.$emit('order', data, e.num);
                  }
                });
                //this.parent.updateData();
              }
            }
          }
        },

        /**
         * Defines the parent tree overNode
         * @method mouseOver
         * @memberof bbn-tree-node
         */
        mouseOver() {
          this.tree.overNode = this.tree.dragging && this !== this.tree.dragging && (this.tree.draggable || this.sortable) ? this : false;
        },
        /**
         * @method checkPath
         * @memberof bbn-tree-node
         */
        checkPath() {
          return;
          if (this.tree.path.length > this.level) {
            let item = this.tree.path.slice(this.level, this.level + 1)[0],
              type = typeof item,
              match = false;
            if (type === 'object' && bbn.fn.search([this.data], item) === 0) {
              match = true;
            } else if (this.tree.uid && this.data[this.tree.uid] && this.data[this.tree.uid] === item) {
              match = true;
            } else if (type === 'number' && this.idx === item) {
              match = true;
            }
            if (match) {
              if (this.tree.path.length > this.level + 1) {
                this.isExpanded = true;
              } else {
                if (this.numChildren) {
                  this.isExpanded = true;
                }
                this.isSelected = true;
                this.tree.$refs.scroll.scrollTo(0, this.$el);
              }
            }
          }
        },
        // this function get the fullPath where you path the separtor as arguments
        getFullPath(separator, field) {
          let f = field || this.uid || false;
          if (f) {
            let st = '';
            let p = this;
            while (p && p.$is('bbn-tree-node')) {
              if (p.data[f]) {
                if (p !== this) {
                  st = separator + st;
                }
                st = p.data[f] + st;
                p = p.parent.$parent;
              } else {
                return false;
              }
            }
            return st;
          }
          return false;
        },
        getPath(field) {
          return this.tree.getNodePath(this, field);
        },
        addToSelected() {
          let emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          let storage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          // if the current node isn't already selected
          if (!this.tree.currentSelected.includes(this)) {
            let sameParent = this.tree.selectedNode && this.tree.selectedNode.parent === this.parent;
            // initializing and calling the event beforeSelect
            let ev = new Event('beforeSelect', {
              cancelable: true
            });
            if (emit) {
              this.tree.$emit('beforeSelect', this, ev);
            }
            if (!ev.defaultPrevented) {
              if (this.tree.selectedNode && (!this.multiple || sameParent && !this.parent.multiple)) {
                bbn.fn.log(["UNSELECT NODE", this.tree.selectedNode, this.tree.currentSelected[this.tree.currentSelected.length - 1]]);
                this.tree.currentSelected[this.tree.currentSelected.length - 1].isSelected = false;
                this.tree.selectedNode.$tick();
              }
              // adding the node to selected
              this.tree.currentSelected.push(this);
              // call the event select
              if (emit) {
                this.tree.$emit('select', this);
              }
              // adding the node selected
              if (this.tree !== this.parent) {
                this.parent.currentSelected.push(this);
                if (emit) {
                  // call the event select
                  this.parent.$emit('select', this);
                }
              }
              if (!!this.uid) {
                // getting all the nodes from root until this
                let path = this.tree.getNodePath(this);
                // Set the 'selected' property to true for this node on currentState
                path.reduce((o, uid) => {
                  if (!uid || !o) {
                    return undefined;
                  }
                  if (o[uid] === undefined) {
                    o[uid] = {
                      expanded: false,
                      items: {},
                      selected: false
                    };
                  }
                  if (uid === this.data[this.uid] && !o[uid].selected) {
                    o[uid].selected = true;
                  }
                  return o[uid].items;
                }, this.tree.currentState);
              }
              if (storage) {
                this.$nextTick(() => {
                  // and put it in the local storage
                  this.tree.setLocalStorage();
                });
              }
            }
          }
        },
        removeFromSelected() {
          let emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          let storage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          // getting index of the currentTree select dans its parent
          let idx = this.tree.currentSelected.indexOf(this);
          let idx2 = this.parent.currentSelected.indexOf(this);
          // initializing and sending an event cancelable if emit is false
          let ev = new Event('beforeUnselect', {
            cancelable: true
          });
          if (emit) {
            // if emit is here we call the event beforeUnselect
            this.tree.$emit('beforeUnselect', this, ev);
          }
          if (!ev.defaultPrevented) {
            let path = [];
            if (!!this.uid) {
              // getting all the nodes from root until this
              path = this.tree.getNodePath(this);
            }
            // if the tree is selected
            if (idx > -1) {
              // we remove it
              this.tree.currentSelected.splice(idx, 1);
              if (emit && (this.multiple || !this.tree.currentSelected.length)) {
                this.tree.$emit('unselect', this);
              }
            }
            // if the tree is selected and different from his parent
            if (idx2 > -1 && this.tree !== this.parent) {
              // we remove it and call the event unselect
              this.parent.currentSelected.splice(idx, 1);
              if (emit && (this.multiple || !this.tree.currentSelected.length)) {
                this.parent.$emit('unselect', this);
              }
            }
            if (!!this.uid) {
              // uid of the last node
              let last = path[path.length - 1];
              // Set the 'selected' property to false for this node on currentState
              path.reduce((o, uid) => {
                if (!uid || !o) {
                  return undefined;
                }
                if (o[uid]) {
                  if (uid === last) {
                    o[uid].selected = false;
                    if (!bbn.fn.numProperties(o[uid].items) && !o[uid].expanded) {
                      delete o[uid];
                    }
                  }
                }
                return !!o[uid] ? o[uid].items : false;
              }, this.tree.currentState);
            }
            if (storage) {
              // if storage exists we call setLocalStorage
              this.$nextTick(() => {
                this.tree.setLocalStorage();
              });
            }
          }
        },
        addToExpanded() {
          let emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          let storage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          if (!this.tree.currentExpanded.includes(this)) {
            // initializing and sending a cancelable event if emit is true
            let ev;
            if (emit) {
              ev = new Event('beforeUnfold', {
                cancelable: true
              });
              this.tree.$emit('beforeUnfold', this, ev);
            }
            if (!emit || !ev.defaultPrevented) {
              // adding to the list of nodes that are currently expanded
              this.tree.currentExpanded.push(this);
              // if storage is true we update its content
              // if emit is true we call unfold event
              if (emit) {
                this.tree.$emit('unfold', this);
              }
              // Starting from the parent
              let parent = this.parent;
              // going up until there is no parent anymore
              while (parent && parent !== this.tree) {
                // adding itself to the currentExpanded
                parent.currentExpanded.push(this);
                // parent becomes the next parent tree if it exists otherwise it's null
                parent = parent.node ? parent.node.parent : null;
              }
              if (!!this.uid) {
                // getting all the nodes from root until this
                let path = this.tree.getNodePath(this);
                // Adds for each of them the expanded property and sets to true
                path.reduce((o, uid) => {
                  if (!uid || !o) {
                    return undefined;
                  }
                  if (o[uid] === undefined) {
                    o[uid] = {
                      expanded: true,
                      items: {},
                      selected: false
                    };
                  } else if (!o[uid].expanded) {
                    o[uid].expanded = true;
                  }
                  return o[uid].items;
                }, this.tree.currentState);
              }
              if (storage) {
                this.$nextTick(() => {
                  this.tree.setLocalStorage();
                });
              }
              return true;
            }
          }
          return false;
        },
        removeFromExpanded() {
          let emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          let storage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          // Getting the index of the tree which is expanded
          let idx = this.tree.currentExpanded.indexOf(this);
          // If the function indexOf works and return a good index
          if (idx > -1) {
            let ev;
            if (emit) {
              ev = new Event('beforeFold', {
                cancelable: true
              });
              this.tree.$emit('beforeFold', this, ev);
            }
            // Initializing and sending an event cancelable if emit is true
            // if the action has not been prevented
            if (!emit || !ev.defaultPrevented) {
              let path = [];
              if (!!this.uid) {
                // Getting all the nodes from root until this
                path = this.tree.getNodePath(this);
              }
              // Starting from the parent
              let parent = this.parent;
              // Going up until there is no parent anymore
              while (parent && parent !== this.tree) {
                // Getting the index of the first parent after tree
                let idx2 = parent.currentExpanded.indexOf(this);
                if (idx2 > -1) {
                  // If the return of the function allows it we remove it from the currentExpanded
                  parent.currentExpanded.splice(idx2, 1);
                }
                // Parent becomes the next parent tree if it exists otherwise it's null
                parent = parent.node ? parent.node.parent : null;
              }

              // And suppress the root currentExpanded
              this.tree.currentExpanded.splice(idx, 1);
              if (!!this.uid) {
                // uid of the last node
                let last = path[path.length - 1];
                // for each nodes which has the expanded property setted to true it's setted to false
                path.reduce((o, uid) => {
                  if (!uid || !o) {
                    return undefined;
                  }
                  if (o[uid]) {
                    if (uid === last) {
                      o[uid].expanded = false;
                      if (!o[uid].selected) {
                        delete o[uid];
                      }
                    }
                  }
                  return !!o[uid] ? o[uid].items : false;
                }, this.tree.currentState);
              }
              if (storage) {
                this.$nextTick(() => {
                  // Set the localStorage with the data we get
                  this.tree.setLocalStorage();
                });
              }
              if (emit) {
                // Call the fold event
                this.tree.$emit('fold', this);
              }
            }
            return true;
          }
          return false;
        },
        /**
         * Single click on the node
         * @method clickOnNode
         * @emits nodeclick
         * @memberof bbn-tree-node
         */
        clickOnNode(ev) {
          this.tree.$emit('nodeclick', this, ev);
        },
        /**
         * Double click on the node
         * @method dblClickOnNode
         * @emits nodedoubleclick
         * @memberof bbn-tree-node
         */
        dblClickOnNode(ev) {
          this.tree.$emit('nodedoubleclick', this, ev);
        },
        getIcon() {
          return this.source.icon || (!!this.numChildren ? this.isExpanded ? 'nf nf-fa-folder_open' : 'nf nf-fa-folder' : 'nf nf-fa-file');
        },
        remove() {
          if (!this.parent.isAjax) {
            this.parent.currentData.splice(this.idx, 1);
          }
        },
        getCls(source, tree) {
          return source.cls !== undefined ? source.cls : bbn.fn.isFunction(tree.cls) ? tree.cls(source, this.tree, this.parent) : tree.cls || '';
        },
        onMouseUp(e) {
          if (!this.tree.realDragging && this.tree.selectable) {
            this.isSelected = !this.isSelected;
          }
        }
      },
      /**
       * Defines the props tree and parent of the node
       * @event created
       * @memberof bbn-tree-node
       */
      created() {
        // Looking for the parent
        this.parent = this.closest('bbn-tree');
        // tree take the value of the parent tree or the parent
        this.tree = this.parent.tree || this.parent;
        // If we click a node we're calling the addToSelect function
        if (this.source.selected) {
          this.addToSelected();
        }
        if (!this.parent.nodes.includes(this)) {
          this.parent.nodes.push(this);
        }
        // If the tree is opened we're calling the addToExpanded function
        if (this.tree.opened || this.level < this.tree.minExpandLevel) {
          this.$set(this.source, 'expanded', true);
          this.addToExpanded();
        }
      },
      /**
       * @event mounted
       * @fires checkPath
       * @fires resize
       */
      mounted() {
        this.$nextTick(() => {
          if (!this.animation) {
            setTimeout(() => {
              this.animation = true;
            }, 500);
          }
          this.$set(this.source, 'visible', this.isVisible);
          this.isMounted = true;
          this.$nextTick(() => {
            if (this.isExpanded && this.numChildren) {
              let tree = this.getRef('tree');
              if (tree && !tree.isLoaded && !tree.isLoading) {
                tree.updateData();
              }
            }
            setTimeout(() => {
              this.ready = true;
            }, 50);
          });
          this.resize();
        });
      },
      beforeDestroy() {
        if (this.isSelected) {
          this.removeFromSelected(true, false);
        }
        if (this.isExpanded) {
          this.removeFromExpanded(true, false);
        }
        if (this.isActive && this.tree.activeNode === this) {
          this.tree.activeNode = false;
        }
        if (this.parent.nodes.includes(this)) {
          this.parent.nodes.splice(this.parent.nodes.indexOf(this), 1);
        }
      },
      watch: {
        /**
        * Beware it's a computed, use tree.currentData[idx].expanded to change it.
        *
        * @watch isExpanded
        * @fires tree.updateData
        * @fires getRef
        * @fires resize
        * @fires addToExpanded
        * @fires removeFromExpanded
        * @fires tree.isNodeOf
        * @memberof bbn-tree-node
        */
        isExpanded(newVal) {
          if (newVal) {
            if (this.addToExpanded()) {
              let tree = this.getRef('tree');
              if (this.numChildren && tree && !tree.isLoaded) {
                tree.updateData();
              } else {
                this.resize();
              }
            }
          } else {
            if (this.removeFromExpanded()) {
              if (this.tree.selectedNode && this.tree.isNodeOf(this.tree.selectedNode, this)) {
                this.isActive = true;
              }
              this.resize();
            }
          }
        },
        /**
         * @watch isSelected
         * @param {Boolean} newVal
         * @fires addToSelected
         * @fires removeFromSelected
         * @memberof bbn-tree-node
         */
        isSelected(newVal) {
          //bbn.fn.log(["WATCH UNSELECT", newVal]);
          if (newVal) {
            this.addToSelected();
          } else {
            //bbn.fn.log("REMOVING FROM SELECTED - UNSE")
            this.removeFromSelected();
          }
        },
        /**
         * @watch isActive
         * @param {Boolean} newVal
         * @emits tree.activate
         * @emits tree.deactivate
         * @memberof bbn-tree-node
         */
        isActive(newVal) {
          if (newVal) {
            if (this.tree.activeNode && this.tree.activeNode !== this) {
              this.tree.activeNode.isActive = false;
            }
            this.tree.activeNode = this;
          } else if (this.tree.activeNode === this) {
            this.tree.activeNode = false;
          }
          this.tree.$emit(newVal ? 'activate' : 'deactivate', this);
        },
        isVisible(newVal) {
          this.$set(this.source, 'visible', !!newVal);
        }
      }
    }
  }
};
import cpHtml from './tree.html';
import cpStyle from './tree.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./tree.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-tree',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-tree-oinput component
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 * 
 * @created 15/02/2017
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.events
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.events],
  props: {
    /**
     * @prop {Array} extensions
     */
    extensions: {
      type: Array
      // default: ["dnd"]
    },

    /**
     * @prop {Number} autoExpandMS
     */
    autoExpandMS: {
      type: Number
    },
    /**
     * @prop {(String|Array|Object)} source
     */
    source: {
      type: [String, Array, Object]
    },
    /**
     * @prop {Object} [extensions: ['dnd'], autoExpandedMS: 400, source: [], disabled: false] cfg
     */
    cfg: {
      type: Object,
      default() {
        return {
          extensions: ["dnd"],
          auoExpandedMS: 400,
          source: [],
          disabled: false
        };
      }
    }
  },
  data() {
    return {
      widgetName: "fancytree",
      ivalue: this.currentSelection ? this.currentSelection : ''
    };
  },
  methods: {},
  mounted() {
    this.ready = true;
  }
};
import cpHtml from './tree-input.html';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./tree-input.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-tree-input',
  definition: cpDef,
  template: cpHtml,
  lang: cpLang
};
/**
 * @file bbn-dropdown component
 *
 * @description The easy-to-implement bbn-dropdown component allows you to choose a single value from a user-supplied list.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 10/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.list
   * @mixin bbn.cp.mixins.keynav
   * @mixin bbn.cp.mixins.url
    */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.events, bbn.cp.mixins.input, bbn.cp.mixins.list, bbn.cp.mixins.keynav, bbn.cp.mixins.url],
  props: {
    /**
     * @prop {String} [''] textValue
     */
    textValue: {
      type: String,
      default: ''
    },
    /**
     * @prop {Number} [0] minLength
     */
    minLength: {
      type: Number,
      default: 0
    },
    /**
     * A component for each element of the list.
     *
     * @prop component
     */
    component: {},
    /**
     * The template to costumize the dropdown menu.
     *
     * @prop template
     */
    template: {},
    /**
     * @todo description
     *
     * @prop valueTemplate
     */
    valueTemplate: {},
    /**
     * Defines the groups for the dropdown menu.
     * @prop {String} group
     */
    group: {
      type: String
    },
    /**
     * Set to true so that the dropdown is not autofilled if empty
     * @prop {Boolean} nullable
     */
    nullable: {
      default: null
    },
    /**
     * The placeholder of the dropdown.
     *
     * @prop {String} placeholder
     */
    placeholder: {
      type: String
    },
    /**
     * @prop {String} ['selection'] mode
     */
    mode: {
      type: String,
      default: 'selection'
    },
    /**
     * @prop {Boolean} [false] autocomplete
     */
    autocomplete: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Number} [500] delay
     */
    delay: {
      type: Number,
      default: 500
    },
    /**
     * @prop {(Number|String)} maxHeight
     */
    maxHeight: {
      type: [Number, String]
    }
  },
  data() {
    let isNullable = !!this.nullable;
    if (this.nullable === null) {
      isNullable = this.required ? false : !!this.placeholder;
    }
    let cp = this.component || null;
    if (!cp && this.template) {
      cp = {
        props: ['source'],
        data() {
          return this.source;
        },
        template: this.template
      };
    }
    let autobind = true;
    if (this.autobind === false || this.isAjax && this.autocomplete && this.filterString.length < this.minLength) {
      autobind = false;
    }
    return {
      /**
       * @data {String} [''] filterString
       */
      filterString: this.textValue || '',
      /**
       * @data {Boolean} [false] isOpened
       */
      isOpened: false,
      /**
       * @data {String} [''] currentText
       */
      currentText: this.textValue || '',
      /**
       * @data {Number} [0] currentWidth
       */
      currentWidth: 0,
      /**
       * @data {Number} [0] currentHeight
       */
      currentHeight: 0,
      isFilterable: true,
      filterTimeout: false,
      isActive: false
    };
  },
  computed: {
    currentTextValue() {
      if (this.value && this.mode === 'free') {
        return this.value;
      }
      if (this.value && this.sourceText && this.currentData.length) {
        let idx = bbn.fn.search(this.currentData, a => {
          return a.data[this.uid || this.sourceValue] === this.value;
        });
        if (idx > -1) {
          return this.currentData[idx].data[this.sourceText];
        }
      } else if (this.textValue) {
        return this.textValue;
      }
      return '';
    }
  },
  methods: {
    selectText() {
      let filter = this.getRef('filter');
      if (filter) {
        filter.setSelectionRange(0, filter.value.length);
      }
    },
    /**
     * Handles the resize of the component
     * @method onResize
     */
    onResize() {
      this.currentWidth = this.$el.offsetWidth;
      this.currentHeight = this.$el.offsetHeight;
    },
    /**
     * @method enter
     * @param element 
     */
    enter(element) {
      const height = bbn.fn.calculateHeight(element);
      element.style.height = 0;
      setTimeout(() => {
        element.style.height = height;
      });
    },
    click() {
      if (!this.isDisabled && this.filteredData.length) {
        this.isOpened = !this.isOpened;
        if (this.autocomplete) {
          this.getRef('filter').focus();
        } else {
          this.getRef('input').focus();
        }
      }
    },
    /**
     * @method leave
     * @param element 
     */
    leave() {
      if (this.isOpened && !this.getRef('list').isOver) {
        this.isOpened = false;
        //this.getRef('list').close();
      }
      /*
      if ( this.filterString && (this.filterString !== this.currentText) ){
        this.filterString = '';
      }
      */
    },

    /**
     * Emits the event 'select' 
     * @method select
     * @param {} item 
     * @emit change
     */
    select(item) {
      if (item && item[this.uid || this.sourceValue] !== undefined) {
        this.emitInput(item[this.uid || this.sourceValue]);
        this.$emit('change', item[this.uid || this.sourceValue]);
        if (this.autocomplete && this.isAjax) {
          this.$nextTick(() => {
            this.currentData = [{
              index: 0,
              data: item,
              selected: true
            }];
            this.currentText = item[this.sourceText];
            this.filterString = item[this.sourceText];
            this.$nextTick(() => {
              this.getRef('filter').focus();
              this.selectText();
            });
          });
        }
      }
      this.isOpened = false;
    },
    commonKeydown(e) {
      if (!this.filteredData.length || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }
      if (e.key === 'Tab') {
        let list = this.find('bbn-list');
        if (list.overIdx > -1) {
          if (this.mode === 'free') {
            this.filterString = list.filteredData[list.overIdx].data[this.uid || this.sourceValue];
            return true;
          }
          if (!this.value) {
            this.emitInput(list.filteredData[list.overIdx].data[this.uid || this.sourceValue]);
            return true;
          }
        }
        this.resetDropdown();
        return true;
      } else if (this.isOpened && (bbn.var.keys.confirm.includes(e.which) || !this.autocomplete && e.key === ' ')) {
        e.preventDefault();
        let list = this.find('bbn-list');
        if (list.overIdx > -1) {
          this.select(list.filteredData[list.overIdx].data);
        } else if (this.isNullable) {
          this.selfEmit('');
        }
        return true;
      }
      return false;
    },
    resetDropdown() {
      this.currentText = this.currentTextValue;
      if (this.autocomplete) {
        this.filterString = this.currentTextValue;
      }
      this.unfilter();
      if (this.isOpened) {
        this.isOpened = false;
      }
    },
    /**
     * States the role of the enter key on the dropdown menu.
     *
     * @method _pressEnter
     * @fires widget.select
     * @fires widget.open
     *
     */
    keydownInput(e) {
      if (this.commonKeydown(e)) {
        return;
      } else if (e.key === 'Escape' || bbn.var.keys.dels.includes(e.which)) {
        this.resetDropdown();
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      } else if (e.key === ' ') {
        this.isOpened = !this.isOpened;
      } else if (e.key.match(/^[A-z0-9]{1}$/)) {
        this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
          field: this.sourceText,
          operator: 'startswith',
          value: e.key
        });
        if (!this.isOpened) {
          this.isOpened = true;
        }
      }
    },
    keydownFilter(e) {
      if (this.commonKeydown(e)) {
        return;
      } else if (e.key === 'Escape') {
        this.resetDropdown();
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        this.keynav(e);
      }
    },
    afterUpdate() {
      if (!this.ready) {
        this.ready = true;
      }
      this.onResize();
      let floater = this.getRef('list');
      if (floater.currentSelected === -1) {
        floater.currentSelected = 0;
      }
    },
    unfilter() {
      this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length);
    }
  },
  /**
   *
   * @event created
   */
  created() {
    this.$on('dataloaded', () => {
      if (this.value !== undefined) {
        let row = bbn.fn.getRow(this.currentData, a => {
          return a.data[this.sourceValue] === this.value;
        });
        if (row) {
          this.currentText = row.data[this.sourceText];
        }
      }
      if (!this.currentText && !this.isNullable && this.filteredData.length) {
        this.emitInput(this.filteredData[0][this.sourceValue]);
      }
    });
    if (this.filterString && this.filterString.length >= this.minLength) {
      this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
        field: this.sourceText,
        operator: 'startswith',
        value: this.filterString
      });
    }
  },
  watch: {
    /**
     * @watch value
     * @param newVal
     */
    value() {
      this.$nextTick(() => {
        this.currentText = this.currentTextValue;
      });
    },
    /**
     * @watch filterString
     * @param {String} v
     */
    filterString(v) {
      if (!this.autocomplete) {
        return;
      }
      if (!this.ready) {
        this.ready = true;
      }
      if (this.mode === 'free') {
        this.emitInput(v);
      }
      clearTimeout(this.filterTimeout);
      // if (v !== this.currentText) {
      this.isOpened = false;
      this.filterTimeout = setTimeout(() => {
        this.filterTimeout = false;
        if (this.isActive) {
          if (v && v.length >= this.minLength) {
            this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length ? 1 : 0, {
              field: this.sourceText,
              operator: 'startswith',
              value: v
            });
            this.$nextTick(() => {
              if (!this.isOpened) {
                this.isOpened = true;
              } else {
                let list = this.find('bbn-scroll');
                if (list) {
                  list.onResize();
                }
              }
            });
          } else {
            this.unfilter();
          }
        }
      }, this.delay);
      // }
      // else if ( !v ){
      //   this.unfilter();
      // }
    },

    source() {
      this.$once('dataloaded', () => {
        if (this.filteredData.length) {
          this.onResize();
        }
      });
      this.updateData();
    }
  }
};
import cpHtml from './treedown.html';
import cpStyle from './treedown.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./treedown.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-treedown',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-treemenu component
 *
 * @description The bbn-treemenu component is a vertical menu that shows a hierarchical list of elements, with the possibility of searching for the desired element.
 * Very useful, it allows you to quickly find what the user is looking for, making it dynamic in the presentation, containing the items that satisfy the research.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 15/02/2017
 */
const cpDef = {
  name: 'bbn-treemenu',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.position, bbn.cp.mixins.resizer],
  props: {
    /**
     * The placeholder on the search input of the tree.
     * @prop {String} ['Search'] placeholder
     */
    placeholder: {
      type: String,
      default: bbn._('Search')
    },
    /**
     * The source of the tree.
     * @prop {String|Array|Function} [[]] source
     */
    source: {
      type: [String, Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop {Boolean} [true] autobind
     */
    autobind: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] shortcuts
     */
    shortcuts: {
      type: Boolean,
      default: false
    },
    /**
     * Set to false hide the search input.
     * @prop {Boolean} [true] search
     */
    search: {
      type: Boolean,
      default: true
    },
    /**
     * The array of menus.
     * @prop {Array} [[]] menus
     */
    menus: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The initial menu
     * @prop {String} current
     */
    current: {
      type: String
    },
    /**
     * The name used for the storage
     * @prop {String} storageName
     */
    storageName: {
      type: String
    }
  },
  data() {
    let isAjax = !Array.isArray(this.source);
    return {
      /**
       * @data {String} [''] searchExp
       */
      searchExp: '',
      /**
       * @data {Number} posTop
       */
      posTop: this.top,
      /**
       * @data {Number} posBottom
       */
      posBottom: this.bottom,
      /**
       * True if the type of the prop source is not Array.
       * @data {Boolean} isAjax
       */
      isAjax: isAjax,
      /**
       * The menu's items.
       * @data {Array} items
       */
      items: isAjax ? [] : this.source,
      /**
       * The current menu.
       * @data {String} current
       */
      currentMenu: this.current || null,
      /**
       * The last menu.
       * @data [null] lastMenu
       */
      lastMenu: null
    };
  },
  computed: {
    /**
     * Defines position and width of the component.
     * @computed elementStyle
     * @return {Object}
     */
    elementStyle() {
      let o = {
        top: '0px',
        bottom: '0px'
      };
      let prop = this.position === 'right' ? 'right' : 'left';
      o[prop] = 0;
      if (!this.ready) {
        o.opacity = 0;
      } else if (!this.isOpened) {
        o[prop] = -(this.$el.clientWidth + 40) + 'px';
      }
      return o;
    }
  },
  methods: {
    /**
     * Creates the menu of the given node.
     * @method getMenu
     * @param {Object} node
     * @returns {Array}
     */
    getMenu(node) {
      if (!this.shortcuts || !node || node !== null && node !== void 0 && node.numChildren) {
        return [];
      }
      let obj = {
        url: node.data.link,
        icon: node.data.icon,
        text: node.data.text,
        id: node.data.id
      };
      return [{
        text: bbn._('Create a shortcut'),
        icon: 'nf nf-fa-external_link',
        action: () => {
          this.$emit('shortcut', obj);
        }
      }];
    },
    /**
     * Maps the source of the tree.
     * @method mapSrc
     * @param {Object} data
     * @param {Number} level
     * @return {Object}
     */
    mapSrc(data, level) {
      if (!data) {
        return;
      }
      data.cls = 'bbn-treemenu-' + (level > 6 ? x : level);
      if (level < 3) {
        data.cls += ' bbn-bottom-sspace';
      }
      if (data.items && data.items.length) {
        data.cls += ' bbn-b';
        data.selectable = false;
      }
      return data;
    },
    /**
     * Links to the prop link or url of the given item.
     * @method go
     * @param {Object} node
     * @param {Event} event
     * @emits select
     */
    go(node, event) {
      bbn.fn.log("GO", node);
      event.preventDefault();
      this.searchExp = '';
      if (node && node.data && (node.data.link || node.data.url)) {
        bbn.fn.link(node.data.link || node.data.url);
        this.$emit('select', node, event);
      }
    },
    /**
     * Handles the resize of the scroll
     * @method resizeScroll
     * @fires $nextTick
     * @fires focusSearch
     */
    resizeScroll() {
      if (this.$refs.scroll) {
        this.$refs.scroll.onResize();
      }
      let code = bbn.fn.md5(JSON.stringify(this.currentMenu));
      if (code !== this.lastMenu) {
        this.lastMenu = code;
        this.$nextTick(() => {
          this.focusSearch();
        });
      }
    },
    /**
     * Reload the tree
     * @method reset
     * @fires getRef
     */
    reset() {
      let tree = this.getRef('tree');
      if (bbn.cp.isComponent(tree)) {
        tree.reset();
      }
    },
    /**
     * Gets the data of the component
     * @method getData
     * @returns {Object}
     */
    getData() {
      return {
        menu: this.currentMenu
      };
    },
    /**
     * Method triggered at '@ready' of the component to set the current menu.
     * @method readyTree
     * @fires $nextTick
     * @fires getRef
     * @fires reset
     */
    readyTree() {
      this.$nextTick(() => {
        let dd = this.getRef('dropdown');
        if (bbn.cp.isComponent(dd) && dd.value && bbn.fn.getRow(this.menus, {
          value: dd.value
        }) && dd.value !== this.currentMenu) {
          this.currentMenu = dd.value;
        } else {
          this.reset();
        }
      });
    },
    /**
     * Focuses the search input.
     * @method focusSearch
     * @focus getRef
     */
    focusSearch() {
      if (!bbn.fn.isMobile()) {
        let search = this.getRef('search');
        if (search) {
          search.focus();
        }
      }
    }
  },
  /**
   * Resizes the tree-menu and sets its prop 'ready' to true.
   * @event mounted
   * @fires onResize
   */
  mounted() {
    this.onResize();
    //this._position();
    this.ready = true;
  },
  watch: {
    /**
     * Resets the tree-menu when the current menu changes.
     * @watch currentMenu
     * @fires reset
     * @fires getRef
     */
    currentMenu(val) {
      if (val !== null) {
        this.reset();
      }
    }
  }
};
import cpHtml from './treemenu.html';
import cpStyle from './treemenu.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./treemenu.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-treemenu',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
  * @file bbn-upload component
  *
  * @description bbn-upload is a component that allows users to send files from their file system by selecting it, using drag and drop or with a keyboard shortcut.
  *
  * @author Mirko Argentino
  *
  * @copyright BBN Solutions
  *
  * @cretaed 13/06/2017
  */

const cpDef = {
  /**
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input],
  props: {
    /**
     * @prop {Boolean} [true] showList
     */
    showList: {
      type: Boolean,
      default: true
    },
    /**
     * The value of the component.
     * @prop {Array|String} [[]] value
     */
    value: {
      type: [Array, String],
      default() {
        return [];
      }
    },
    /**
     * The URL for the action 'save'.
     * @prop {String} [null] saveUrl
     */
    saveUrl: {
      type: String,
      default: null
    },
    /**
     * The URL for the action 'delete'.
     * @prop {String} [null] removeUrl
     */
    removeUrl: {
      type: String,
      default: null
    },
    /**
     * The URL for the action 'download'.
     * @prop {String} [null] downloadUrl
     */
    downloadUrl: {
      type: String,
      default: null
    },
    /**
     * Set to true to automatically upload selected files.
     * @prop {Boolean} [true] autoUpload
     */
    autoUpload: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true to allow the upload of multiple files.
     * @prop {Boolean} [true] multiple
     */
    multiple: {
      type: Boolean,
      default: true
    },
    /**
     * Tha maximum number of files. 0 for infinite.
     * @prop {Number} [0] max
     */
    max: {
      type: Number,
      default: 0
    },
    /**
     * Set to true to disable the component.
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Set it to true if you want to be able to edit the filename.
     * @prop {Boolean} [false] editable
     */
    editable: {
      type: Boolean,
      default: false
    },
    /**
     * True if you want the possibility to download a file.
     * @prop {Boolean} [false] downloadable
     */
    downloadable: {
      type: Boolean,
      default: false
    },
    /**
     * True if you want the possibility to delete a file.
     * @prop {Boolean} [true] eliminable
    */
    eliminable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] uploadable
     */
    uploadable: {
      type: Boolean,
      default: true
    },
    /**
     * Shows the file's icon.
     * @prop {Boolean} [true] icons
     */
    icons: {
      type: Boolean,
      default: true
    },
    /**
     * Shows the preview image of the file uploaded.
     * @prop {Boolean} [false] thumbs
     */
    thumbs: {
      type: Boolean,
      default: false
    },
    /**
     * The maximum size of the thumb.
     * @prop {Number} [60] maxSize
     */
    maxSize: {
      type: Number,
      default: 60
    },
    /**
     * The text shown during the file's transfer.
     * @prop {String} thumbWaiting
     */
    thumbWaiting: {
      type: String
    },
    /**
    * Set to true to convert the value as JSON.
     * @prop {Boolean} [false] json
     */
    json: {
      type: Boolean,
      default: false
    },
    /**
     * An object to customize the default text.
     * @prop {Object} text
     */
    text: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * The icon displayed on the upload button.
     * @prop {String} ['nf nf-fa-upload'] icon
     */
    icon: {
      type: String,
      default: 'nf nf-fa-upload'
    },
    /**
     * The array of accepted extensions.
     * @prop {Array} [[]] extensions
     */
    extensions: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * The  accepted types of files.
     * @prop {String} [*] accept
     */
    accept: {
      type: String,
      default: '*'
    },
    /**
     * Set to false to disable the 'paste' function.
     *
     * @prop {Boolean} [true] paste
     */
    paste: {
      type: Boolean,
      default: false
    },
    /**
     * Set to false to disable the 'drang&drop' function.
     *
     * @prop {Boolean} [true] dragDrop
     */
    dragDrop: {
      type: Boolean,
      default: true
    },
    /**
     * Additional data sent with the ajax call.
     *
     * @prop {Object} data
     */
    data: {
      type: Object
    },
    /**
     * Shows or not the files' size on the list.
     * @prop {Boolean} [true] showFilesize
     */
    showFilesize: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * The current files.
       *  @data {Array} [[]] currentData
       */
      currentData: [],
      /**
       * Indicates if an uploading is running.
       *  @data {Boolean} [false] uploading
       */
      uploading: false
    };
  },
  computed: {
    /**
     * An object of default text.
     *
     * @computed text
     * @return Object
     */
    currentText() {
      return bbn.fn.extend({
        uploadButton: bbn._('Choose files'),
        dropHere: bbn._('Drop files here'),
        pasteContainer: bbn._('Click on the container and then press CTRL+V keys to paste the file'),
        uploadOrDrop: bbn._('Choose files or drop files here'),
        retry: bbn._('Retry'),
        editFilename: bbn._('Edit filename'),
        remove: bbn._('Delete'),
        removeConfirm: bbn._('Are you sure you want to delete this file?'),
        empty: bbn._('no files'),
        download: bbn._('Download'),
        save: bbn._('Save'),
        cancel: bbn._('Cancel'),
        filename: bbn._('Write the filename without the extension'),
        upload: bbn._('Upload')
      }, this.text);
    },
    /**
     * Shows you can add more files.
     * @computed canAddFile
     * @return Boolean
     */
    canAddFile() {
      return this.uploadable && !this.uploading && this.multiple && (!this.max || this.filesCount < this.max) || !this.multiple && !this.filesCount;
    },
    /**
     * A list of files with the status 'ready'.
     * @computed filesReady
     * @return Array
     */
    filesReady() {
      return this.currentData.filter(d => {
        return d.status === 'ready';
      });
    },
    /**
     * A list of files with the status 'progress'.
     * @computed filesProgress
     * @return Array
     */
    filesProgress() {
      return this.currentData.filter(d => {
        return d.status === 'progress';
      });
    },
    /**
     * A list of files with the status 'error'.
     * @computed filesError
     * @return Array
     */
    filesError() {
      return this.currentData.filter(d => {
        return d.status === 'error';
      });
    },
    /**
     * A list of files with the status 'success'.
     * @computed filesSuccess
     * @return Array
     */
    filesSuccess() {
      return this.currentData.filter(d => {
        return d.status === 'success';
      });
    },
    /**
     * The sum of the files withe the statuses 'ready, 'progress' and 'success'.
     * @computed filesCount
     * @return Number
     */
    filesCount() {
      return this.filesReady.length + this.filesProgress.length + this.filesSuccess.length;
    },
    /**
     * Shows if it is not disabled and not readonly.
     * @computed isEnabled
     * @return Boolean
     */
    isEnabled() {
      return !this.isDisabled && !this.readonly;
    }
  },
  methods: {
    /**
     * Sets the given status to the file with the given id.
     * @method _setStatus
     * @param {Number} id
     * @param {String} status
     * @return Boolean
     */
    _setStatus(id, status) {
      if (id) {
        let idx = bbn.fn.search(this.currentData, {
          id: id
        });
        if (idx > -1) {
          this.$set(this.currentData[idx], 'status', status);
          return true;
        }
      }
      return false;
    },
    /**
     * Makes an object with the file's info.
     * @method _makeFile
     * @param {Object|File} file
     * @param {Boolean} fromUser
     * @param {String} status
     * @param {Boolean} fromPaste
     * @return Object
     */
    _makeFile(file, fromUser, status, fromPaste) {
      return {
        id: bbn.fn.randomInt(1000, 9999),
        data: file,
        status: status || 'ready',
        fromUser: fromUser,
        fromPaste: !!fromPaste,
        edit: false,
        progress: 0
      };
    },
    /**
     * The method used to makes the files and to upload them if necessary.
     * @method _makeFiles
     * @param {Array} files
     * @param {Boolean} fromUser
     * @param {String} status
     * @fires _filterFiles
     * @fires _makeFile
     * @fires _addFile
     * @fires upload
     */
    _makeFiles(files, fromUser, status) {
      if (!this.ready || !this.isDisabled) {
        if (files instanceof FileList) {
          files = Object.values(files);
        }
        files = this._filterFiles(bbn.fn.map(files, file => {
          return this._makeFile(file, fromUser, status);
        }));
        bbn.fn.each(files, file => {
          if (!this.ready || this.canAddFile) {
            this._addFile(file);
          }
        });
        if (this.ready && this.autoUpload) {
          this.$nextTick(() => {
            this.upload();
          });
        }
      }
      if (this.getRef('fileInput')) {
        this.getRef('fileInput').value = null;
      }
    },
    /**
     * Adds a file to the currentData property.
     * @method _addFile
     * @param {Object} file
     */
    _addFile(file) {
      this.currentData.push(file);
    },
    /**
     * Removes the given file from the currentData property.
     * @method _remove
     * @param {Object} file
     * @emits remove
     * @fires setValue
     */
    _remove(file, res) {
      let idx = bbn.fn.search(this.currentData, {
        id: file.id
      });
      if (idx > -1) {
        this.currentData.splice(idx, 1);
        this.$emit('remove', file.id, res, false);
        this.$nextTick(() => {
          this.setValue();
        });
      }
    },
    /**
     * Filters the give files.
     * @method _filterFiles
     * @param {Array} files
     * @emits error
     * @return Array
     */
    _filterFiles(files) {
      return bbn.fn.filter(files, file => {
        if (!file.data.name || file.data.size !== undefined && !file.data.size) {
          return false;
        }
        if (bbn.fn.getRow(this.currentData, {
          'data.name': file.data.name
        })) {
          if (file.fromUser) {
            this.$emit('error', {
              file: file.data.name,
              message: bbn._('The file exists!')
            });
            this.alert(bbn._('The file') + ` "${file.data.name}" ` + bbn._('exists') + '!');
          }
          return false;
        }
        if (bbn.fn.isArray(this.extensions) && this.extensions.length) {
          let ext = file.data.name.substring(file.data.name.lastIndexOf('.') + 1).toLowerCase(),
            extensions = bbn.fn.map(this.extensions, e => {
              return e.toLowerCase();
            });
          if (!extensions.includes(ext)) {
            if (file.fromUser) {
              this.$emit('error', {
                file: file.data.name,
                message: bbn._('The extension') + ` "${ext}" ` + bbn._('is not allowed') + '!'
              });
              this.alert(bbn._('The extension') + ` "${ext}" ` + bbn._('is not allowed') + '!');
            }
            return false;
          }
        }
        return true;
      });
    },
    /**
     * Returns a knowed object structure of the given file.
     * @method _getData
     * @param {Object} file
     * @return Object
     */
    _getData(file) {
      if (file.data) {
        return {
          name: file.data.name,
          size: file.data.size,
          extension: file.data.name.substring(file.data.name.lastIndexOf('.'))
        };
      }
      return {};
    },
    /**
     * Returns the current value. If it is in the JSON format, it's converted.
     * @method getValue
     * @return Array
     */
    getValue() {
      let res;
      if (typeof this.value === 'string' && this.json) {
        res = JSON.parse(this.value);
      } else if (bbn.fn.isArray(this.value)) {
        res = this.value;
      }
      return bbn.fn.isArray(res) ? res : [];
    },
    /**
     * The method called when the user select or drop files.
     * @method filesChanged
     * @fires _makeFiles
     */
    filesChanged(e) {
      if (e.target.files.length) {
        this._makeFiles(e.target.files, true);
      }
    },
    /**
     * Uploads the file with the given id or all files with the status 'ready'.
     * @method upload
     * @param {Number} id
     * @fires setStatusProgress
     * @fires setName
     * @fires setStatusSuccess
     * @fires setStatusError
     * @emits success
     * @emits failure
     */
    upload(id) {
      if (this.uploadable && this.filesReady.length) {
        this.uploading = true;
        if (id) {
          this.setStatusProgress(id);
        } else {
          bbn.fn.each(this.filesReady, fr => {
            this.setStatusProgress(fr.id);
          });
        }
        this.$nextTick(() => {
          bbn.fn.each(this.filesProgress, fr => {
            if (id === undefined || fr.id === id) {
              let ev = new Event('beforeUpload', {
                cancelable: true
              });
              this.$emit('beforeUpload', ev, fr);
              if (!ev.defaultPrevented) {
                if (this.saveUrl) {
                  bbn.fn.upload(this.saveUrl, bbn.fn.extend(true, {}, this.data ? this.data : {}, {
                    file: fr.data
                  }), res => {
                    let f = false;
                    if (res.data.file || res.data.fichier) {
                      f = res.data.file || res.data.fichier;
                    } else if (res.data.data && (res.data.data.file || res.data.data.fichier)) {
                      f = res.data.data.file || res.data.data.fichier;
                    }
                    if (f && f.name !== fr.data.name) {
                      this.setName(fr.id, f.name, false);
                    }
                    if (this.setStatusSuccess(fr.id)) {
                      this.$nextTick(() => {
                        this.$emit('success', fr.id, f.name || fr.data.name, res.data, res);
                      });
                    }
                  }, err => {
                    if (this.setStatusError(fr.id)) {
                      this.$emit('error', fr.id, err);
                      bbn.fn.log('bbn-upload error', fr.id, err);
                    }
                  }, prog => {
                    this.setProgress(fr.id, prog);
                  });
                } else {
                  if (this.setStatusSuccess(fr.id)) {
                    this.$nextTick(() => {
                      this.$emit('success', fr.id, fr.data.name, fr.data);
                    });
                  }
                }
              }
            }
          });
        });
      }
    },
    /**
     * Sets the name to the file with the given id.
     * @method setName
     * @param {Number} id
     * @param {String} name
     * @return Boolean
     */
    setName(id, name) {
      let setVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (id && name) {
        let idx = bbn.fn.search(this.currentData, {
          id: id
        });
        if (idx > -1) {
          if (this.currentData[idx].fromUser) {
            const newFile = new File([this.currentData[idx].data], name, {
              type: this.currentData[idx].data.type
            });
            this.$set(this.currentData[idx], 'data', newFile);
          } else {
            this.$set(this.currentData[idx].data, 'name', name);
          }
          if (setVal) {
            this.$nextTick(() => {
              this.setValue();
            });
          }
          return true;
        }
      }
      return false;
    },
    /**
     * Sets the status 'ready' to the file with the given id.
     * @method setStatusReady
     * @param id
     * @fires _setStatus
     * @return Boolean
     */
    setStatusReady(id) {
      return this._setStatus(id, 'ready');
    },
    /**
     * Sets the status 'error' to the file with the given id.
     * @method setStatusError
     * @param id
     * @fires _setStatus
     * @return Boolean
     */
    setStatusError(id) {
      return this._setStatus(id, 'error');
    },
    /**
     * Sets the status 'success' to the file with the given id.
     * @method setStatusSuccess
     * @param id
     * @fires _setStatus
     * @return Boolean
     */
    setStatusSuccess(id) {
      return this._setStatus(id, 'success');
    },
    /**
     * Sets the status 'progress' to the file with the given id.
     * @method setStatusProgress
     * @param id
     * @fires _setStatus
     * @return Boolean
     */
    setStatusProgress(id) {
      return this._setStatus(id, 'progress');
    },
    /**
     * Sets the value.
     * @method setValue
     * @emits input
     * @emits change
     */
    setValue() {
      let value = bbn.fn.map(this.filesSuccess, f => {
        if (f.data instanceof File) {
          return {
            name: f.data.name,
            size: f.data.size,
            extension: bbn.fn.substr(f.data.name, f.data.name.lastIndexOf('.'))
          };
        }
        return bbn.fn.extend(true, {}, f.data, {
          size: f.data.size,
          extension: bbn.fn.substr(f.data.name, f.data.name.lastIndexOf('.'))
        });
      });
      this.emitInput(this.json ? JSON.stringify(value) : value);
      this.$nextTick(() => this.$emit('change', this.value));
    },
    /**
     * Sets the given progress value to to the file with the given id.
     * @method setProgress
     * @param {String} id
     * @param {Number} [0] progress
     */
    setProgress(id) {
      let progress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (bbn.fn.isArray(this.currentData) && this.currentData.length) {
        let file = bbn.fn.getRow(this.currentData, {
          id: id
        });
        if (bbn.fn.isObject(file)) {
          this.$set(file, 'progress', progress);
        }
      }
    },
    /**
     * Sets the given file to edit mode.
     * @method edit
     * @param {Object} file
     */
    edit(file) {
      file.edit = bbn.fn.substr(file.data.name, 0, file.data.name.lastIndexOf('.'));
    },
    /**
     * Saves the change did to the filename.
     * @method saveEdit
     * @param {Object} file
     * @fires upload
     * @emits edit
     */
    saveEdit(file) {
      const name = `${file.edit}.${this.getFileExt(file)}`;
      if (file.edit && file.name !== name) {
        let old = bbn.fn.extend(true, {}, file.data);
        if (file.fromUser) {
          const newFile = new File([file.data], name, {
            type: file.data.type
          });
          this.$set(file, 'data', newFile);
        } else {
          this.$set(file.data, 'name', name);
        }
        if (file.fromPaste && file.status === 'ready') {
          this.upload(file.id);
        } else {
          this.$emit('edit', file.id, name, old.name);
        }
        this.$nextTick(() => {
          this.setValue();
        });
      }
      file.edit = false;
    },
    /**
     * Exits from the edit mode.
     * @method cancelEdit
     * @param {Object} file
     */
    cancelEdit(file) {
      if (file.fromPaste && file.status === 'ready') {
        this.currentData.splice(bbn.fn.search(this.currentData, {
          id: file.id
        }), 1);
      } else {
        file.edit = false;
      }
    },
    /**
     * Retries to upload the given file.
     * @method retry
     * @param {Object} file
     * @fires setStatusReady
     * @fires upload
     */
    retry(file) {
      if (this.setStatusReady(file.id)) {
        this.upload(file.id);
      }
    },
    /**\
     * Deletes the given file.
     * @method remove
     * @param {Object} file
     * @fires _remove
     */
    remove(file, force) {
      let ev = new Event('beforeRemove', {
        cancelable: true
      });
      this.$emit('beforeRemove', ev, file);
      if (force || !ev.defaultPrevented) {
        this.confirm(this.currentText.removeConfirm, () => {
          if (this.removeUrl) {
            this.post(this.removeUrl, bbn.fn.extend(true, {}, this.data ? this.data : {}, {
              file: file.data.name
            }), d => {
              this._remove(file, d);
            });
          } else {
            this._remove(file);
          }
        });
      }
    },
    /**
     * The method called on the paste event.
     * @method pasteEvent
     * @param {Event} event
     * @fires _makeFile
     * @fires _addFile
     */
    pasteEvent(event) {
      if (event.clipboardData.files.length && this.canAddFile) {
        let file = this._makeFile(event.clipboardData.files[0], true, 'ready', true);
        file.edit = '';
        this._addFile(file);
        this.$nextTick(() => {
          this.getRef('filenameInput').focus();
        });
      }
    },
    dropEvent(event) {
      if (!this.dragDrop) {
        event.preventDefault();
      }
    },
    /**
     * Downloads the given file.
     * @method download
     * @param {Object} file
     */
    download(file) {
      if (!!this.downloadable && !!this.downloadUrl) {
        this.postOut(this.downloadUrl, bbn.fn.extend(true, {}, this.data ? this.data : {}, {
          file: file.data.name
        }));
      }
    },
    /**
     * Gets the formatted file' size.
     * @method getFileSize
     * @param {Object} file
     * @return String
     */
    getFileSize(file) {
      return bbn.fn.formatBytes(file.data.size);
    },
    /**
     * Gets the icon class by the file's extension.
     * @method getFileIcon
     * @param {Object} file
     * @return String
     */
    getFileIcon(file) {
      switch (this.getFileExt(file)) {
        case 'pdf':
          return 'nf nf-fa-file_pdf_o';
        case 'zip':
          return 'nf nf-fa-file_zip_o';
        case 'rar':
        case 'tar':
        case 'bz2':
        case 'gz':
        case '7z':
        case 'cab':
        case 'cab':
          return 'nf nf-fa-file_archive_o';
        case 'jpg':
        case 'jpeg':
        case 'png':
        case 'gif':
        case 'bmp':
        case 'svg':
          return 'nf nf-fa-file_image_o';
        case 'avi':
        case 'mov':
        case 'mkv':
        case 'mpg':
        case 'mpeg':
        case 'wmv':
        case 'mp4':
          return 'nf nf-fa-file_movie_o';
        case 'mp3':
        case 'wav':
          return 'nf nf-fa-file_sound_o';
        case 'php':
        case 'js':
        case 'html':
        case 'htm':
        case 'css':
        case 'less':
          return 'nf nf-fa-file_code_o';
        case 'txt':
        case 'rtf':
          return 'nf nf-fa-file_text_o';
        case 'doc':
        case 'docx':
        case 'odt':
          return 'nf nf-fa-file_word_o';
        case 'xls':
        case 'xlsx':
        case 'ods':
        case 'csv':
          return 'nf nf-fa-file_excel_o';
        case 'ppt':
        case 'pptx':
        case 'odp':
          return 'nf nf-fa-file_powerpoint_o';
        default:
          return 'nf nf-fa-file';
      }
    },
    /**
     * Gets the extension of the given file.
     * @method getFileExt
     * @param {Object} file
     * @return String
     */
    getFileExt(file) {
      if (file.fromUser || file.data.extension === undefined || !file.data.extension.length) {
        return file.data.name.substring(file.data.name.lastIndexOf('.') + 1);
      } else {
        return bbn.fn.substr(file.data.extension, 1);
      }
    },
    /**
     * Gets the thumb url of the given file
     * @method getThumbURL
     * @param {Object} file
     * @return String
     */
    getThumbURL(file) {
      return this.isFile(file) ? URL.createObjectURL(file.data) : !!file.data.thumb && bbn.fn.isURL(file.data.thumb) ? file.data.thumb : '';
    },
    /**
     * Check if the data property of the given file is an instance of File object
     * @method isFile
     * @param {Object} file
     * @return Boolean
     */
    isFile(file) {
      return file.data instanceof File;
    }
  },
  /**
   * @event mounted
   * @fires _makeFiles
   * @fires getValue
   */
  mounted() {
    this.$nextTick(() => {
      if (this.value) {
        this._makeFiles(this.getValue(), false, 'success');
      }
      this.ready = true;
    });
  },
  watch: {
    /**
     * @watch value
     * @fires _makeFiles
     * @fires getValue
     */
    value: {
      deep: true,
      handler(newVal, oldVal) {
        if (!bbn.fn.isSame(newVal, oldVal)) {
          this.currentData.splice(0);
        }
        this.$nextTick(() => {
          this._makeFiles(this.getValue(), false, 'success');
        });
      }
    },
    /**
     * @watch filesSProgress
     * @emits complete
     * @fires setValue
     */
    filesProgress(newVal, oldVal) {
      if (!bbn.fn.isSame(newVal, oldVal) && !newVal.length) {
        this.uploading = false;
        if (!this.filesError.length) {
          this.$emit('complete', this.filesSuccess, this.filesError);
          this.$nextTick(() => {
            this.setValue();
          });
        }
      }
    }
  }
};
import cpHtml from './upload.html';
import cpStyle from './upload.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./upload.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-upload',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-context component
 *
 * @description bbn-keyvalue is a dynamic list of keys and values
 * The source of the menu can have a tree structure.
 * 
 * @copyright BBN Solutions
 *
 * @created 15/02/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.dropdown
   * @mixin bbn.cp.mixins.keynav
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.dropdown, bbn.cp.mixins.keynav],
  props: {
    /**
     * @prop {Array} source
     */
    source: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {(Array|String)} value
     */
    value: {
      type: [Array, String]
    },
    /**
     * @prop {Number} max
     */
    max: {
      type: Number
    },
    /**
     * @prop {Number} min
     */
    min: {
      type: Number
    },
    /**
     * @prop {(String|Function)} validator
     */
    validator: {
      type: [String, Function]
    },
    mode: {
      type: String,
      default: 'input',
      validator: v => ['input', 'dropdown'].includes(v)
    },
    sourceText: {
      type: String,
      default: 'text'
    },
    sourceValue: {
      type: String,
      default: 'value'
    }
  },
  data() {
    let isJSON = this.value && bbn.fn.isString(this.value);
    let value = this.value ? isJSON ? JSON.parse(this.value) : bbn.fn.clone(this.value) : [];
    if (!bbn.fn.isArray(value)) {
      throw new Error("The value of bbn-values must be an array");
    }
    return {
      isJSON: isJSON,
      currentValue: value,
      oldValue: bbn.fn.clone(value),
      currentInput: ''
    };
  },
  computed: {
    filteredData() {
      return bbn.fn.filter(this.source, a => {
        if (this.currentInput.length) {
          let ci = bbn.fn.removeAccents(this.currentInput).toLowerCase();
          let tmp = bbn.fn.removeAccents(a).toLowerCase();
          if (tmp.indexOf(ci) === -1) {
            return false;
          }
        }
        return !this.currentValue.includes(a);
      });
    }
  },
  methods: {
    keydown(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        if (this.$refs.list && this.$refs.list.overIdx > -1) {
          this.currentInput = this.filteredData[this.$refs.list.overIdx];
        }
        this.add();
      } else if (e.key === ';') {
        e.preventDefault();
        this.add();
      } else if (this.commonKeydown(e)) {
        return;
      } else if (e.key === 'Escape') {
        e.preventDefault();
        this.isOpened = false;
      } else if (bbn.var.keys.upDown.includes(e.keyCode)) {
        e.preventDefault();
        if (!this.isOpened) {
          this.isOpened = true;
        } else {
          this.keynav(e);
        }
      }
    },
    select(value) {
      this.currentInput = value.value;
      this.add();
    },
    isValidValue() {
      return bbn.fn.isArray(this.currentValue);
    },
    add() {
      if (!this.isDisabled && !this.readonly && this.currentInput.length && this.currentValue.indexOf(this.currentInput) === -1) {
        this.currentValue.push(this.currentInput);
        this.emitInput(this.isJSON ? JSON.stringify(this.currentValue) : this.currentValue);
        this.currentInput = '';
        this.$refs.input.focus();
      }
    },
    remove(idx) {
      if (!this.isDisabled && !this.readonly) {
        this.currentValue.splice(idx, 1);
        this.emitInput(this.isJSON ? JSON.stringify(this.currentValue) : this.currentValue);
      }
    },
    getText(val) {
      if (this.mode === 'dropdown') {
        return bbn.fn.getField(this.source, this.sourceText, this.sourceValue, val);
      } else if (this.mode === 'input') {
        return val;
      }
    }
  }
};
import cpHtml from './values.html';
import cpStyle from './values.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./values.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-values',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-video component
 * @description bbn-video allows the execution and visualization of video files.
 * @copyrigth BBN Soutions
 * @author Mirko Argentino
 * @created 10/08/2020.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   */
  mixins: [bbn.cp.mixins.basic],
  props: {
    /**
     * The video's URL or the video's code (YouTube)
     * @prop {String} source
    */
    source: {
      type: String,
      required: true
    },
    /**
     * The video's title
     * @prop {String} [''] title
     */
    title: {
      type: String,
      default: ''
    },
    /**
     * The title's position(top or bottom)
     * @prop {String} ['top'] titlePosition
     */
    titlePosition: {
      type: String,
      default: 'top',
      validator: p => ['top', 'bottom'].includes(p)
    },
    /**
     * The title's background
     * @prop {String} titleBackground
     */
    titleBackground: {
      type: String
    },
    /**
     * The title's color
     * @prop {String} titleColor
     */
    titleColor: {
      type: String
    },
    /**
     * Additional classes for the title
     * @prop {String} titleCls
     */
    titleCls: {
      type: String
    },
    /**
     * The video's width
     * @prop {String} ['100%'] width
     */
    width: {
      type: String,
      default: '100%'
    },
    /**
     * The video's height
     * @prop {String} ['100%'] height
     */
    height: {
      type: String,
      default: '100%'
    },
    /**
     * Specifies that the video will start playing as soon as it is ready
     * @prop {Boolean} [false] autoplay
     */
    autoplay: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies that video controls should be displayed
     * @prop {Boolean} [false] controls
     */
    controls: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies that the video will start over again, every time it is finished
     * @prop {Boolean} [false] loop
     */
    loop: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies that the audio output should be muted
     * @prop {Boolean} [false] muted
     */
    muted: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies an image to be shown while the video is downloading, or until the user hits the play button
     * @prop {String} [''] poster
     */
    poster: {
      type: String,
      default: ''
    },
    /**
     * Set it to true if yuo want to use a skinned player
     * @prop {Boolean} [false] skin
     */
    skin: {
      type: Boolean,
      default: false
    },
    /**
     * A custom background for the player
     * @prop {String} background
     */
    background: {
      type: String
    },
    /**
     * Additional classes for the player
     * @prop {String} cls
     */
    cls: {
      type: String
    },
    /**
     * Force an aspect ratio
     * @prop {String} aspectRatio
     */
    aspectRatio: {
      type: String,
      validator: ar => ['1/1', '16/9', '4/3', '3/2', '8/5'].includes(ar)
    }
  },
  data() {
    return {
      /**
       * This text will only be displayed in browsers that do not support the <video> element.
       * @data {String} ['To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video.'] browserMessage
       */
      browserMessage: bbn._('To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video.'),
      /**
       * @data {RegExp} [/^https?:\/\/w{0,3}\.?youtu\.?be(-nocookie)?(\.com)?\//gm] youtubeReg
       */
      youtubeReg: /^https?:\/\/w{0,3}\.?youtu\.?be(-nocookie)?(\.com)?\//gm,
      /**
       * @data {RegExp} [/^https?:\/\/vimeo(-nocookie)?(\.com)?\//gm] vimeoReg
       */
      vimeoReg: /^https?:\/\/vimeo(-nocookie)?(\.com)?\//gm,
      /**
       * @data {Boolean} [true] showPoster
       */
      showPoster: true
    };
  },
  computed: {
    /**
     * Returns the correct media type
     * @computed type
     * @return {String|Boolean}
     */
    type() {
      if (this.source) {
        switch (bbn.fn.substr(this.source, this.source.lastIndexOf('.') + 1).toLowerCase()) {
          case 'mp4':
            return 'video/mp4';
          case 'webm':
            return 'video/webm';
          case 'ogg':
            return 'video/ogg';
          default:
            return '';
        }
      }
      return false;
    },
    /**
     * @computed isYoutube
     * @return {Boolean}
     */
    isYoutube() {
      return !!this.source.match(this.youtubeReg);
    },
    /**
     * @computed isVimeo
     * @return {Boolean}
     */
    isVimeo() {
      return !!this.source.match(this.vimeoReg);
    },
    /**
     * Returns the correct url for embeded video
     * @computed videoSource
     * @return {String}
     */
    videoSource() {
      if (this.isYoutube) {
        let url = this.source.replace(this.youtubeReg, '');
        if (url.startsWith('watch?v=')) {
          url = bbn.fn.substr(url, 8);
        }
        return `${document.location.protocol}//youtube.com/embed/${url}?rel=0&autoplay=${this.autoplay ? 1 : 0}&controls=${this.controls ? 1 : 0}&mute=${this.muted || this.autoplay ? 1 : 0}&loop=${this.loop ? 1 : 0}`;
      } else if (this.isVimeo) {
        let url = this.source.replace(this.vimeoReg, '');
        return `${document.location.protocol}//player.vimeo.com/video/${url}?autoplay=${this.autoplay ? 1 : 0}&controls=${this.controls ? 1 : 0}&mute=${this.muted ? 1 : 0}&loop=${this.loop ? 1 : 0}&playlist=${url}`;
      }
      return this.source;
    }
  },
  watch: {
    source() {
      this.showPoster = true;
    }
  }
};
import cpHtml from './video.html';
import cpStyle from './video.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./video.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-video',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-vlist component
 *
 * @description bbn-vlist represents a vertical list of possible actions to be performed.This list can be nested hierarchically.
 *
 * @copyrigth BBN Soutions
 *
 * @author BBN Soutions
 *
 * @created 15/52/2017.
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.position
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.position],
  statics() {
    return {
      isClicked: false
    };
  },
  props: {
    /**
     * @prop {(Function|Array)} source
     */
    source: {
      type: [Function, Array]
    },
    /**
     * @prop {String} ['100%'] maxHeight
     */
    maxHeight: {
      type: String,
      default: '100%'
    },
    /**
     * @prop {Boolean} [false] unique
     */
    unique: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} ['free'] mode
     */
    mode: {
      type: String,
      default: "free"
    },
    /**
     * @prop [false] parent
     */
    parent: {
      default: false
    },
    /**
     * @prop [false] noIcon
     */
    noIcon: {
      default: false
    },
    // The hierarchy level, root is 0, and for each generation 1 is added to the level
    /**
     * @prop {Number} [0] level
     */
    level: {
      type: Number,
      default: 0
    },
    /**
     * @prop {Funtion} mapper
     */
    mapper: {
      type: Function
    },
    /**
     * itemComponent
     */
    itemComponent: {}
  },
  data() {
    let items = [],
      hasIcons = false;
    if (this.source) {
      items = bbn.fn.isFunction(this.source) ? this.source() : this.source.slice();
      if (this.mapper) {
        bbn.fn.map(items, a => {
          return this.mapper(a);
        });
      }
      bbn.fn.each(items, a => {
        if (a.icon) {
          hasIcons = true;
        }
      });
    }
    return {
      items: items,
      currentIndex: 0,
      currentHeight: 0,
      currentWidth: 0,
      focused: bbn.env.focused,
      hasIcons: hasIcons
    };
  },
  methods: {
    getStyles() {
      let left = this.left ? bbn.fn.isNumber(this.left) ? this.left : parseInt(this.left) : '',
        right = this.right ? bbn.fn.isNumber(this.right) ? this.right : parseInt(this.right) : '',
        top = this.top ? bbn.fn.isNumber(this.top) ? this.top : parseInt(this.top) : '',
        bottom = this.bottom ? bbn.fn.isNumber(this.bottom) ? this.bottom : parseInt(this.bottom) : '';
      if (this.currentHeight) {
        let tW = bbn.env.width,
          tH = bbn.env.height;
        if (right && right + this.currentWidth >= tW) {
          left = '';
          right = bbn.env.width - this.currentWidth;
        } else if (left && left + this.currentWidth >= tW) {
          right = '';
          left = tW < this.currentWidth ? 0 : tW - this.currentWidth;
        }
        if (bottom && bottom + this.currentHeight >= tH) {
          top = '';
          bottom = tH - this.currentHeight;
        } else if (top && top + this.currentHeight >= tH) {
          bottom = '';
          top = tH - this.currentHeight;
        }
      }
      return {
        left: left ? left + 'px' : null,
        right: right ? right + 'px' : null,
        top: top ? top + 'px' : null,
        bottom: bottom ? bottom + 'px' : null,
        maxHeight: this.maxHeight
      };
    },
    pressKey(e) {
      switch (e.key) {
        case "Enter":
        case "Space":
          this.select(this.currentIndex);
          break;
        case "Escape":
          this.closeAll();
          break;
        case "ArrowLeft":
          this.close();
          break;
        case "ArrowRight":
          //this.close();
          break;
        case "ArrowDown":
          if (this.items.length) {
            if (this.currentIndex > this.items.length - 2) {
              this.currentIndex = 0;
            } else {
              this.currentIndex++;
            }
          }
          break;
        case "ArrowUp":
          if (this.items.length) {
            if (this.currentIndex > 0) {
              this.currentIndex--;
            } else {
              this.currentIndex = this.items.length - 1;
            }
          }
          break;
      }
    },
    leaveList: function (e) {
      if (!bbnVlistCp.isClicked) {
        this.close();
      }
    },
    beforeClick() {
      bbnVlistCp.isClicked = true;
    },
    afterClick() {
      setTimeout(function () {
        bbnVlistCp.isClicked = false;
      });
    },
    over(idx) {
      if (this.currentIndex !== idx) {
        this.currentIndex = idx;
        if (this.items[idx].items) {
          let $item = $(this.$el).find(" > ul > li").eq(idx),
            offset = $item.offset(),
            h = $(this.$root.$el).height(),
            w = $(this.$root.$el).width();
          this.items[idx].right = offset.left > w * 0.6 ? Math.round(w - offset.left) : null;
          this.items[idx].left = offset.left <= w * 0.6 ? Math.round(offset.left + $item[0].clientWidth) : null;
          this.items[idx].bottom = offset.top > h * 0.6 ? Math.round(h - offset.top - $item[0].clientHeight) : null;
          this.items[idx].top = offset.top <= h * 0.6 ? Math.round(offset.top) : null;
          this.items[idx].maxHeight = (offset.top > h * 0.6 ? Math.round(offset.top + $item[0].clientHeight) : Math.round(h - offset.top)) + 'px';
          bbn.fn.log('over', this.items[idx]);
        }
      }
    },
    close(e) {
      this.currentIndex = false;
      if (!this.level && this.focused) {
        $(this.focused).focus();
      }
    },
    closeAll() {
      this.close();
      if (this.level) {
        this.$emit("closeall");
      } else {
        if (this.focused) {
          $(this.focused).focus();
        }
        this.$emit('close');
        this.focus = false;
      }
    },
    select(idx) {
      if (!this.items[idx].disabled && !this.items[idx].items) {
        if (this.mode === 'options') {
          this.items[idx].selected = !this.items[idx].selected;
        } else if (this.mode === 'selection' && !this.items[idx].selected) {
          let prev = bbn.fn.search(this.items, "selected", true);
          if (prev > -1) {
            this.items[prev].selected = false;
          }
          this.items[idx].selected = true;
        }
        if (this.items[idx].action) {
          if (typeof this.items[idx].action === 'string') {
            bbn.fn.log("CLICK IS STRING", this);
          } else if (bbn.fn.isFunction(this.items[idx].action)) {
            bbn.fn.log("CLICK IS FUNCTION ???", this);
            this.items[idx].action(idx, JSON.parse(JSON.stringify(this.items[idx])));
          }
        }
        if (this.mode !== 'options') {
          this.closeAll();
        }
      }
    }
  },
  created() {
    this.focused = bbn.env.focused;
  },
  mounted() {
    this.$nextTick(() => {
      if (!this.focused) {
        this.focused = bbn.env.focused;
      }
      this.currentHeight = $(this.$el).children().height();
      this.currentWidth = $(this.$el).children().width();
      this.$el.children[0].focus();
      this.ready = true;
      /*
      let style = {},
        h = $(this.$el).children().height();
      if ( this.bottom ){
      if ( this.bottom - h < 0 ){
        style.top = '0px';
      }
      else{
        style.top = Math.round(this.bottom - h) + 'px';
      }
      style.height = Math.round(h + 2) + 'px';
      $(this.$el).css(style)
      }
      */
    });
  },

  beforeDestroy() {
    bbn.fn.log("beforeDestroy");
    if (this.focused) {
      bbn.fn.log("foc", this.focused);
      this.focused.focus();
    }
  },
  watch: {
    currentIndex(newVal) {
      if (newVal === false && !this.parent) {
        this.$emit("close");
      }
    },
    items() {
      let hasIcons = false;
      bbn.fn.each(this.items, a => {
        if (a.icon) {
          hasIcons = true;
        }
      });
      if (this.hasIcons !== hasIcons) {
        this.hasIcons = hasIcons;
      }
    }
  }
};
import cpHtml from './vlist.html';
import cpStyle from './vlist.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./vlist.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-vlist',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-wheel component
 * @description bbn-wheel
 * @author Mirko Argentino
 * @copyright BBN Solutions
 */
const cpDef = {
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.input
   * @mixin bbn.cp.mixins.list
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.input, bbn.cp.mixins.list],
  data() {
    return {
      /**
       * @data {Boolean} [false] scrollReady
       */
      scrollReady: false,
      /**
       * @data {HTMLElement} [undefined] barElement
       */
      barElement: null,
      /**
       * @data {Boolean} [false] isScrolling
       */
      isScrolling: false
    };
  },
  computed: {
    /**
     * @computed isReady
     */
    isReady() {
      return this.scrollReady && this.isLoaded;
    },
    /**
     * @computed upButtonDisabled
     * @fires isNull
     * @fires getIndexByValue
     * @return {Boolean}
     */
    upButtonDisabled() {
      if (this.isNull(this.value)) {
        return false;
      }
      let index = this.getIndexByValue(this.value),
        idx = bbn.fn.search(this.filteredData, 'index', index);
      if (idx > -1) {
        return !this.filteredData[idx - 1];
      }
    },
    /**
     * @computed downButtonDisabled
     * @fires isNull
     * @fires getIndexByValue
     * @return {Boolean}
     */
    downButtonDisabled() {
      if (this.isNull(this.value)) {
        return false;
      }
      let index = this.getIndexByValue(this.value),
        idx = bbn.fn.search(this.filteredData, 'index', index);
      if (idx > -1) {
        return !this.filteredData[idx + 1];
      }
    }
  },
  methods: {
    /**
     * Alias of bbn.fn.isNull
     * @method isNull
     */
    isNull: bbn.fn.isNull,
    /**
     * @method setValue
     * @param val
     * @fires isNull
     * @fires getScrollPosByVal
     * @fires scrollTo
     * @fires emitInput
     */
    setValue(val) {
      if (!this.isNull(val) && val !== this.value) {
        let pos = this.getScrollPosByVal(val);
        if (pos !== false) {
          this.scrollTo(pos).then(() => {
            this.emitInput(val);
          });
        }
      }
      this.isScrolling = false;
    },
    /**
     * @method scrollTo
     * @param pos
     * @fires getRef
     * @return {Promise}
     */
    scrollTo(pos) {
      return new Promise(resolve => {
        let scroll = this.getRef('scroll');
        scroll.scrollTo(0, pos).then(() => {
          setTimeout(() => {
            this.isScrolling = false;
            resolve();
          }, scroll.latency + 1);
        });
      });
    },
    /**
     * @method getScrollPosByVal
     * @param val
     * @fires getRefByValue
     * @fires getIndexByValue
     * @return {Number}
     */
    getScrollPosByVal(val) {
      let r = this.getRefByValue(val),
        index = this.getIndexByValue(val),
        idx = bbn.fn.search(this.filteredData, 'index', index);
      if (r && idx > -1) {
        return r.clientHeight * idx;
      }
      return false;
    },
    /**
     * @method getIndexByValue
     * @param val
     * @return {Number}
     */
    getIndexByValue(val) {
      let index = bbn.fn.getField(this.filteredData, 'index', {
        ['data.' + this.sourceValue]: val
      });
      if (index !== undefined) {
        return index;
      }
      return false;
    },
    /**
     * @method getRefByValue
     * @param val
     * @fires getIndexByValue
     * @fires getRef
     * @return {Boolean|HTMLElement}
     */
    getRefByValue(val) {
      let index = this.getIndexByValue(val);
      if (index !== false) {
        return this.getRef('v-' + index);
      }
      return false;
    },
    /**
     * @method onReady
     * @fires isNull
     * @fires getScrollPosByVal
     * @fires scrollTo
     */
    onReady() {
      setTimeout(() => {
        if (!this.isNull(this.value)) {
          let pos = this.getScrollPosByVal(this.value);
          if (pos !== false) {
            this.scrollTo(pos).then(() => {
              this.ready = true;
            });
          } else {
            this.ready = true;
          }
        } else {
          this.ready = true;
        }
      }, 300);
    },
    /**
     * @method onScroll
     * @fires getRef
     */
    onScroll() {
      if (this.ready) {
        let barElement = this.getRef('bar');
        this.barElement = barElement || null;
        this.isScrolling = true;
      }
    },
    /**
     * @method onAfterScroll
     * @fires getRef
     * @fires isNull
     * @fires setValue
     */
    onAfterScroll() {
      let contRect = this.getRef('container').getBoundingClientRect();
      let ele = document.elementFromPoint(contRect.x + contRect.width / 2, contRect.y + contRect.height / 2);
      if (ele && ele.hasAttribute('index')) {
        let index = parseInt(ele.getAttribute('index')),
          item = this.currentData[index];
        if (item && !this.isNull(item.data[this.sourceValue])) {
          this.setValue(item.data[this.sourceValue]);
        }
      }
      this.isScrolling = false;
    },
    /**
     * @method goUp
     * @fires isNull
     * @fires getIndexByValue
     * @fires setValue
     */
    goUp() {
      if (!this.isNull(this.value)) {
        let index = this.getIndexByValue(this.value),
          idx = bbn.fn.search(this.filteredData, 'index', index);
        if (idx > -1 && !!this.filteredData[idx - 1]) {
          this.setValue(this.filteredData[idx - 1].data[this.sourceValue]);
        }
      }
    },
    /**
     * @method goDown
     * @fires isNull
     * @fires getIndexByValue
     * @fires setValue
     */
    goDown() {
      if (!this.isNull(this.value)) {
        let index = this.getIndexByValue(this.value),
          idx = bbn.fn.search(this.filteredData, 'index', index);
        if (idx > -1 && !!this.filteredData[idx + 1]) {
          this.setValue(this.filteredData[idx + 1].data[this.sourceValue]);
        }
      }
    }
  },
  watch: {
    /**
     * @watch isReady
     * @param {Boolean} val
     * @fires onReady
     */
    isReady(val) {
      if (val) {
        this.onReady();
      }
    }
  }
};
import cpHtml from './wheel.html';
import cpStyle from './wheel.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./wheel.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-wheel',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-widget component
 *
 * @description bbn-widget designed to be used in the bbn-dashboard component, it represents a information container. This component can contain, for example: a list of information or a component. The usefulness of this easy-to-implement component is to group the information. Together with other  bbn-widget used in the "bbn-dashboard", provides the overview of the information the user wants to see.
 *
 * @copyrigth BBN Soutions
 *
 * @author BBN Solutions
 *
 * @created 15/02/2017.
 */
const cpDef = {
  name: 'bbn-widget',
  /**
   * @mixin bbn.cp.mixins.basic,
   * @mixin bbn.cp.mixins.localStorage,
   * @mixin bbn.cp.mixins.observer,
   * @mixin bbn.cp.mixins.resizer
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.localStorage, bbn.cp.mixins.observer, bbn.cp.mixins.resizer],
  statics() {
    return {
      limits: [5, 10, 15, 20, 25, 30, 40, 50]
    };
  },
  props: {
    /**
     * @prop {(String|Number)} uid
     */
    uid: {
      type: [String, Number]
    },
    /**
     * @prop {String} content
     */
    content: {
      type: String
    },
    /**
     * @prop {(String|Boolean)} [false] url
     */
    url: {
      type: [String, Boolean],
      default: false
    },
    /**
     * @prop {Number} [0] limit
     */
    limit: {
      type: Number,
      default: 0
    },
    /**
     * @prop {Number} index
     */
    index: {
      type: Number
    },
    /**
     * @prop {Boolean} [false] hidden
     */
    hidden: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Number} [0] start
     */
    start: {
      type: Number,
      default: 0
    },
    /**
     * @prop {Number} [0] total
     */
    total: {
      type: Number,
      default: 0
    },
    /**
     * @prop {Boolean} [false] hideEmpty
     */
    hideEmpty: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {(String|Object)} component
     */
    component: {
      type: [String, Object]
    },
    /**
     * @prop {(String|Object)} itemComponent
     */
    itemComponent: {
      type: [String, Object]
    },
    /**
     * @prop {(String|Object)} [''] itemStyle
     */
    itemStyle: {
      type: [String, Object],
      default: ''
    },
    /**
     * @prop {(String|Object)} [''] itemClass
     */
    itemClass: {
      type: [String, Object],
      default: ''
    },
    /**
     * @prop {String} title
     */
    title: {
      type: String
    },
    /**
     * @prop {String} icon
     */
    icon: {
      type: String
    },
    /**
     * @prop {(Array|Fucntion)} buttonsLeft
     */
    buttonsLeft: {
      type: [Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop {(Array|Fucntion)} buttonsRight
     */
    buttonsRight: {
      type: [Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop {Booleann} [false] zoomable
     */
    zoomable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Booleann} [true] closable
     */
    closable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Booleann} [true] sortable
     */
    sortable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Booleann} [true] pageable
     */
    pageable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Object} [{}] source
     */
    source: {
      type: Object,
      default: function () {
        return {};
      }
    },
    /**
     * @prop {Object} [[]] items
     */
    items: {
      type: Array
    },
    /**
     * @prop {String} ['There is no available data'] noData
     */
    noData: {
      type: String,
      default: bbn._("There is no available data")
    },
    /**
     * @prop {Array} [[]] menu
     */
    menu: {
      type: Array,
      default: function () {
        return [];
      }
    },
    /**
     * @prop {String} position
     */
    position: {
      type: String
    },
    /**
     * @prop top
     */
    top: {},
    /**
     * @prop bottom
     */
    bottom: {},
    /**
     * @prop {Boolean} [false] full
     */
    full: {
      type: Boolean,
      default: false
    },
    /**
     * @prop opened
     */
    opened: {},
    /**
     * @prop [{}] options
     */
    options: {
      default() {
        return {};
      }
    },
    /**
     * @prop {String} [''] separator
     */
    separator: {
      type: String,
      default: ''
    },
    /**
     * @prop {Boolean} [true] showable
     */
    showable: {
      type: Boolean,
      default: true
    },
    /**
     * The padding value to assign to the content element.
     * If "true" the class "bbn-padded" will be assigned
     * @prop {Boolean|Number|String} [false] padding
     */
    padding: {
      type: [Boolean, Number, String],
      default: false
    },
    /**
     * The additional data to send with the ajax call
     * @prop {Object} [{}] data
     */
    data: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * A component to show if items is empty
     * @prop {String|Object} noDataComponent
     */
    noDataComponent: {
      type: [String, Object]
    }
  },
  data() {
    var _this$source;
    return {
      /**
       * @data {Boolean} _1stRun
       */
      _1stRun: false,
      /**
       * @data {Boolean} isLoading
       */
      isLoading: false,
      /**
       * @data dashboard
       */
      dashboard: false,
      /**
       * @data currentItems
       */
      currentItems: this.items || [],
      /**
       * @data currentStart
       */
      currentStart: this.start,
      /**
       * @data currentTotal
       */
      currentTotal: this.total,
      /**
       * @data currentContent
       */
      currentContent: this.content || false,
      /**
       * @data currentSource
       */
      currentSource: (_this$source = this.source) !== null && _this$source !== void 0 && _this$source.length ? this.source : [],
      /**
       * @data {Array} [[]] realButtonsRight
       */
      realButtonsRight: [],
      /**
       * @data {Array} [[]] realButtonsLeft
       */
      realButtonsLeft: []
    };
  },
  computed: {
    /**
     * @computed contentPadding
     * @return {String|Boolean}
     */
    contentPadding() {
      if (bbn.fn.isNumber(this.padding)) {
        return this.padding + 'px';
      }
      return this.padding;
    },
    /**
     * @computed isClosable
     * @return {Boolean}
     */
    isClosable() {
      return this.dadhboard && this.dashboard.closable && this.closable;
    },
    /**
     * @computed currentPage
     * @return {Number}
     */
    currentPage() {
      if (this.currentTotal > this.limit) {
        return (this.currentStart + this.limit) / this.limit;
      }
      return 0;
    },
    /**
     * @computed totalPages
     * @return {Number}
     */
    totalPages() {
      if (this.currentTotal > this.limit) {
        return Math.ceil(this.currentTotal / this.limit);
      }
      return 1;
    },
    /**
     * @computed hasMenu
     * @return {Boolean}
     */
    hasMenu() {
      return !!this.finalMenu.length;
    },
    /**
     * @computed finalMenu
     * @return {Array}
     */
    finalMenu() {
      let tmp = this.menu.slice();
      if (this.url) {
        tmp.unshift({
          text: bbn._("Reload"),
          icon: "nf nf-fa-refresh",
          action: () => {
            this.reload();
          }
        });
      }
      if (this.limit) {
        let items = [];
        bbn.fn.each(bbnWidgetCp.limits, (a, i) => {
          items.push({
            text: a.toString() + " " + bbn._("Items"),
            selected: a === this.limit,
            action: () => {
              this.dashboard.updateWidget(this.uid, {
                limit: a
              });
            }
          });
        });
        tmp.push({
          text: bbn._("Limit"),
          icon: 'nf nf-mdi-numeric',
          items: items,
          mode: "selection"
        });
      }
      return tmp;
    }
  },
  methods: {
    /**
     * @method updateButtons
     */
    updateButtons() {
      bbn.fn.log("UPDATE BUTTONS");
      this.realButtonsLeft = bbn.fn.isFunction(this.buttonsLeft) ? this.buttonsLeft() : this.buttonsLeft;
      this.realButtonsRight = bbn.fn.isFunction(this.buttonsRight) ? this.buttonsRight() : this.buttonsRight;
    },
    /**
     * @method close
     * @emits close
     */
    close() {
      bbn.fn.log("CLOSE", this.uid);
      this.$emit("close", this.uid, this);
    },
    /**
     * @method zoom
     */
    zoom() {},
    /**
     * @method reload
     * @fires $nextTick
     * @fires load
     */
    reload() {
      bbn.fn.log("RELOAD");
      this.currentItems = [];
      this.$nextTick(() => {
        this.load();
      });
    },
    /**
     * @method load
     * @fires $forceUpdate
     * @fires post
     * @fires dashboard.updateWidget
     * @fires observerWatch
     * @fires $nextTick
     * @fires onResize
     * @fires $set
     * @emits loaded
     * @return {Promise}
     */
    load() {
      if (this.url) {
        let params = {
          key: this.uid
        };
        this.isLoading = true;
        this.$forceUpdate();
        bbn.fn.log("LOADING", this.url, this.data);
        if (this.limit && this.pageable) {
          params.limit = this.limit;
          params.start = this.currentStart;
        }
        return this.post(this.url, bbn.fn.extend(true, params, this.data), d => {
          if (d.data !== undefined) {
            this.currentItems = d.data;
            if (d.limit && this.limit !== d.limit) {
              this.dashboard.updateWidget(this.uid, {
                limit: d.limit
              });
            }
            if (d.start !== undefined) {
              this.currentStart = d.start;
            }
            if (d.total !== undefined && this.currentTotal !== d.total) {
              this.currentTotal = d.total;
            }
            if (d.observer && this.observerCheck()) {
              this.observerID = d.observer.id;
              this.observerValue = d.observer.value;
              if (!this._1stRun) {
                this.observerWatch();
                this._1stRun = true;
              }
            }
            if (d.optional !== undefined) {
              this.optionalData = d.optional;
            }
          } else if (typeof d === 'object') {
            this.currentSource = d;
          }
          return this.$nextTick(() => {
            this.isLoading = false;
            if (this.ready) {
              this.$emit("loaded");
              this.onResize();
            }
          });
        });
      } else {
        return new Promise(resolve => {
          if (this.items !== undefined) {
            let items = this.items.slice();
            if (this.limit && items.length > this.currentStart && items.length > this.limit) {
              items = items.splice(this.currentStart, this.limit);
            }
            this.currentItems = items;
          }
          return this.$nextTick(() => {
            resolve();
            this.isLoading = false;
            if (this.ready) {
              this.$emit("loaded");
              this.onResize();
            }
          });
        });
      }
    },
    /**
     * @method nav
     * @param {String} arg
     * @fires load
     */
    nav(arg) {
      let newStart = false;
      switch (arg) {
        case 'first':
          newStart = 0;
          break;
        case 'prev':
          newStart = this.currentStart >= this.limit ? this.currentStart - this.limit : 0;
          break;
        case 'next':
          newStart = this.currentStart + this.limit;
          break;
        case 'last':
          newStart = (this.totalPages - 1) * this.limit;
          break;
      }
      if (newStart !== false && newStart !== this.currentStart) {
        this.currentStart = newStart;
        this.load();
      }
    },
    /**
     * @method actionButton
     * @param name
     */
    actionButton(name) {
      let tmp = this;
      let comp = this.component || this.itemComponent;
      if (!bbn.fn.isString(comp)) {
        comp = false;
      } else {
        comp = this.find(comp);
      }
      if (comp && bbn.fn.isFunction(comp[name])) {
        return comp[name]();
      }
      if (bbn.fn.isFunction(name)) {
        return name(this, this.items);
      }
      while (tmp) {
        if (bbn.fn.isFunction(tmp[name])) {
          return tmp[name]();
        }
        tmp = tmp.$parent;
      }
    },
    /**
     * @method setConfig
     * @fires dashboard.setConfig
     */
    setConfig() {
      if (this.dashboard) {
        this.dashboard.setConfig(this.uid, {
          uid: this.uid,
          limit: this.limit,
          hidden: this.hidden,
          index: this.index
        });
      }
    }
  },
  /**
   * @event created
   * @fires updateButtons
   */
  created() {
    this.updateButtons();
  },
  /**
   * @event beforeMount
   */
  beforeMount() {
    this.dashboard = this.closest("bbn-dashboard");
  },
  /**
   * @event mounted
   * @fires setResizeEvent
   * @fires load
   */
  mounted() {
    this.setResizeEvent();
    this.load().then(() => {
      this.ready = true;
    });
  },
  /**
   * @event updated
   * @fires dadhboard.selfEmit
   */
  updated() {
    if (this.dashboard) {
      this.dashboard.selfEmit(true);
    }
  },
  watch: {
    /**
     * @watch limit
     * @fires load
     */
    limit() {
      bbn.fn.log("LIMIT", this.limit);
      this.load();
    },
    /**
    * @watch observerDirty
    * @param {Boolean} newVal
    * @fires load
    */
    observerDirty(newVal) {
      bbn.fn.log("observerDirty", newVal);
      if (newVal && !this.editedRow) {
        this.observerDirty = false;
        this.load();
      }
    },
    /**
     * @watch source
     * @param {Object} newVal
     */
    source: {
      deep: true,
      handler(newVal) {
        bbn.fn.log("SOURCE", newVal);
        this.currentSource = newVal;
      }
    },
    /**
     * @watch url
     * @param {Boolean|String} newVal
     * @fires reload
     */
    url(newVal) {
      bbn.fn.log("URL", newVal);
      this.reload();
    }
  }
};
import cpHtml from './widget.html';
import cpStyle from './widget.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./widget.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-widget',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * @file bbn-window component
 *
 * @description The bbn-window is a component that represents a modal window in which it is possible to show the content.
 *
 * @copyright BBN Solutions
 *
 * @author BBN Solutions
 *
 * @created 15/02/2017
 */
const cpDef = {
  name: 'bbn-window',
  /**
   * @mixin bbn.cp.mixins.basic
   * @mixin bbn.cp.mixins.resizer
   * @mixin bbn.cp.mixins.dimensions
   */
  mixins: [bbn.cp.mixins.basic, bbn.cp.mixins.resizer, bbn.cp.mixins.dimensions],
  props: {
    /**
     * @prop {Boolean} [true] maximazable
     */
    maximizable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] closable
     */
    closable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [true] scrollable
     */
    scrollable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] draggable
     */
    draggable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [true] resizable
     */
    resizable: {
      type: Boolean,
      default: true
    },
    /**
     * @prop {Boolean} [false] maximized
     */
    maximized: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Function} onOpen
     */
    onOpen: {
      type: Function
    },
    /**
     * @prop {Function} beforeClose
     */
    beforeClose: {
      type: Function
    },
    /**
     * @prop {Function} onClose
     */
    onClose: {
      type: Function
    },
    /**
     * @prop {Function} afterClose
     */
    afterClose: {
      type: Function
    },
    /**
     * @prop {Function|String|Object} footer
     */
    footer: {
      type: [Function, String, Object]
    },
    /**
     * @prop {Array} [[]] buttons
     */
    buttons: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * @prop {Function|Array|Object} [{}] source
     */
    source: {
      type: [Function, Array, Object],
      default() {
        return {};
      }
    },
    /**
     * @prop {String|Function|Object} component
     */
    component: {
      type: [String, Function, Object]
    },
    /**
     * @prop {String|Boolean} ['Untitled'] title
     */
    title: {
      type: [String, Boolean],
      default: bbn._("Untitled")
    },
    /**
     * @prop {String} uid
     */
    uid: {
      type: String
    },
    /**
     * @prop {String} content
     */
    content: {
      type: String
    },
    /**
     * @prop {String} mode
     */
    mode: {
      type: String,
      default: "free",
      validator: mode => ['free', 'options', 'selection'].includes(mode)
    }
  },
  data() {
    let fns = [];
    if (this.onClose) {
      fns.push(this.onClose);
    }
    return {
      /**
       * @data {Boolean} isMaximized
       */
      isMaximized: this.maximized,
      /**
       * @data {String} widthUnit
       */
      widthUnit: typeof this.width === 'string' && bbn.fn.substr(this.width, -1) === '%' ? '%' : 'px',
      /**
       * @data {Number|String|Boolean} currentWidth
       */
      currentWidth: this.width,
      /**
       * @data {String} heightUnit
       */
      heightUnit: typeof this.height === 'string' && bbn.fn.substr(this.height, -1) === '%' ? '%' : 'px',
      /**
       * @data {Number|String|Boolean} currentHeight
       */
      currentHeight: this.height,
      /**
       * @data {Array} closingFunctions
       */
      closingFunctions: fns,
      /**
       * @data {Boolean} [false] showContent
       */
      showContent: false,
      /**
       * @data {Boolean|bbnCp} [false] popup
       */
      popup: false,
      /**
       * @data {Object} [{opacity: 0}] containerCss
       */
      containerCSS: {
        opacity: 0
      }
    };
  },
  computed: {
    /**
     * @computed realWidth
     * @returns {String}
     */
    realWidth() {
      if (!this.currentWidth) {
        return 'auto';
      }
      if (typeof this.currentWidth === 'number') {
        return this.currentWidth.toString() + 'px';
      }
      return this.currentWidth;
    },
    /**
     * @computed realHeight
     * @returns {String}
     */
    realHeight() {
      if (!this.currentHeight) {
        return 'auto';
      }
      if (typeof this.currentHeight === 'number') {
        return this.currentHeight.toString() + 'px';
      }
      return this.currentHeight;
    }
  },
  methods: {
    /**
     * @method getContainerPosition
     * @returns {Object}
     */
    getContainerPosition() {
      return this.$el ? this.$el.parentNode.getBoundingClientRect() : {};
    },
    /**
     * @method onResize
     * @fires getContainerPosition
     */
    onResize() {
      let o = this.getContainerPosition();
      this.containerCSS = {
        opacity: 1,
        top: o.top + 'px',
        left: o.left + 'px',
        width: o.width + 'px',
        height: o.height + 'px'
      };
    },
    /**
     * @method addClose
     * @param {Function} fn
     */
    addClose(fn) {
      for (let i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === 'function') {
          this.closingFunctions.push(arguments[i]);
        }
      }
    },
    /**
     * @method removeClose
     * @param {Function} fn
     */
    removeClose(fn) {
      if (!fn) {
        this.closingFunctions = [];
      } else {
        this.closingFunctions = bbn.fn.filter(this.closingFunctions, f => {
          return fn !== f;
        });
      }
    },
    /**
     * @method floaterClose
     * @param {Event} e
     * @fires close
     */
    floaterClose(e) {
      this.close(false, e);
    },
    /**
     * @method close
     * @param {Boolean} force
     * @param {Event} ev
     * @emits {beforeClose}
     * @fires beforeClose
     * @fires $nextTick
     * @fires afterClose
     * @emits close
     */
    close(force, ev) {
      let ok = true;
      if (!ev) {
        ev = new Event('beforeClose', {
          cancelable: true
        });
      }
      if (!force) {
        if (this.popup) {
          this.popup.$emit('beforeClose', ev, this);
        } else {
          this.$emit('beforeClose', ev, this);
        }
        if (this.beforeClose && this.beforeClose(this) === false) {
          return;
        }
      }
      /*
      bbn.fn.each(this.closingFunctions, a => {
        if (!ev.defaultPrevented) {
          a(this, ev);
        }
      });
      */
      if (!force && bbn.fn.isObject(ev) && ev.defaultPrevented) {
        return;
      }
      let closeEvent = new Event('close', {
        cancelable: true
      });
      this.$el.style.display = 'block';
      this.$nextTick(() => {
        this.$emit("close", this, closeEvent);
        if (this.afterClose) {
          this.afterClose(this);
        }
      });
    }
  },
  /**
   * @event created
   * @fires closest
   */
  created() {
    this.popup = this.closest('bbn-popup');
  },
  /**
   * @event mounted
   * @fires onResize
   */
  mounted() {
    this.ready = true;
    this.onResize();
  },
  watch: {
    /**
     * @watch isMaximized
     * @fires $nextTick
     * @fires selfEmit
     */
    isMaximized() {
      this.$nextTick(() => {
        this.selfEmit(true);
      });
    }
  }
};
import cpHtml from './window.html';
import cpStyle from './window.less';
let cpLang = {};
if (bbn.env.lang) {
  try {
    cpLang = await import(`./window.${bbn.env.lang}.lang`);
    if (cpLang.default) {
      cpLang = cpLang.default;
    }
  } catch (err) {}
}
export default {
  name: 'bbn-window',
  definition: cpDef,
  template: cpHtml,
  style: cpStyle,
  lang: cpLang
};
/**
 * Adds a new component to the static global #components property
 */
export default function addComponent(ele) {
  const cid = ele.bbnCid;
  if (!cid) {
    throw new Error("The component doesn't have a component ID");
  }
  const cp = this.componentsIndex.get(cid);
  if (cp) {
    if (cp !== ele) {
      bbn.fn.log(ele, cp);
      throw new Error("The component already exists");
    }
  } else {
    this.componentsIndex.set(cid, ele);
  }
}
/**
 * @method addPrefix
 * @memberof bbn.cp
 * @param {String} prefix 
 * @param {Function} handler
 * @param {Array} mixins
 */
export default function addPrefix(prefix, handler, mixins) {
  bbn.fn.checkType(prefix, String, bbn._("Prefix must be a string"));
  if (handler) {
    bbn.fn.checkType(handler, Function, bbn._("The addPrefix handler must be a function"));
  }
  if (bbn.fn.substr(prefix, -1) !== '-') {
    prefix += '-';
  }

  //bbn.fn.log("ADD PREFIX", prefix, mixins);

  bbn.cp.knownPrefixes.push({
    prefix,
    handler,
    mixins: mixins || []
  });
  // Ordering by length descending so going from more precise to less
  bbn.cp.knownPrefixes.sort((a, b) => {
    if (a.prefix.length > b.prefix.length) {
      return -1;
    }
    if (a.prefix.length < b.prefix.length) {
      return 1;
    }
    // a must be equal to b
    return 0;
  });
}
const eventInstructions = ['stop', 'prevent', 'passive'];
const parser = new DOMParser();

/**
 * Create an object of the HTML element with all the VUE prefixes
 * replaced by BBN prefixes
 * @return {Object} res
 */
export default function analyzeElement(ele, map, inlineTemplates, idx) {
  if (!ele.getAttributeNames) {
    throw new Error("Only tags can be analyzed");
  }
  const attr = ele.getAttributeNames().sort();
  if (!map) {
    map = bbn.fn.createObject();
  }
  if (!inlineTemplates) {
    inlineTemplates = bbn.fn.createObject();
  }
  let res = bbn.fn.createObject({
    id: idx,
    tag: ele.tagName.toLowerCase(),
    attr: bbn.fn.createObject(),
    events: bbn.fn.createObject(),
    items: []
  });
  if (res.tag === 'component' && attr.indexOf(':is') > -1) {
    let is = ele.getAttribute(':is').trim();
    const bits = is.split('.');
    if (bits[0] === '$options' && bits[1] === 'components' && bits.length === 3) {
      res.tag = bits[2];
      attr.splice(attr.indexOf(':is'), 1);
    }
  }
  attr.forEach(attrName => {
    const main = attrName.indexOf(':') > 0 ? attrName.split(':') : [attrName];
    const modifiers = main[0].split('.');
    const modelValue = main.length > 1 ? main[1] : '_default_';
    if (main[1] === '_default_') {
      throw new Error("The name '_default_' is reserved for the default value of the model");
    }
    let a = bbn.fn.camelToCss(modifiers.splice(0, 1)[0]);
    // replaces v- by bbn-
    if (a.indexOf('v-') === 0) {
      a = 'bbn-' + a.substr(2);
    }
    // replaces else-if by elseif
    if ('bbn-else-if' === a) {
      a = 'bbn-elseif';
    }
    if (a === 'bbn-on') {
      a = '@' + main[1];
    }
    let value = ele.getAttribute(attrName).trim();

    // Events
    if (a.indexOf('@') === 0) {
      let o = bbn.fn.createObject({
        modifiers: []
      });
      bbn.fn.each(modifiers, modifier => {
        if (eventInstructions.includes(modifier)) {
          o[modifier] = true;
        } else {
          o.modifiers.push(modifier);
        }
      });
      o.action = value;
      let eventName = a.substr(1);
      if (main[1]) {
        eventName += ':' + main[1];
      }
      res.events[eventName] = o;
      return;
    }

    /** @var {String} name The attribute's real name */
    let tmp = a.indexOf(':') === 0 ? a.substr(1) : a;
    const name = tmp.indexOf('bbn-') === 0 ? tmp : bbn.fn.camelize(tmp);
    if (res.attr[name] !== undefined) {
      bbn.fn.warning(bbn._("The attribute %s can't be defined more than once", name));
      return;
    }
    // create the attribute object
    if (!['bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget', 'bbn-model'].includes(a)) {
      res.attr[name] = bbn.fn.createObject({
        id: idx + '-' + name
      });
    }

    // Dynamic attributes
    if (a.indexOf(':') === 0) {
      res.attr[name].exp = value;
      res.attr[name].hash = bbn.fn.hash(value);
    }
    // Special attributes
    else if (a.indexOf('bbn-') === 0) {
      switch (a) {
        case 'bbn-for':
          if (attr['bbn-elseif'] || attr['bbn-else']) {
            throw new Error(bbn._("bbn-for can't be used with bbn-else-if or bbn-else"));
          }

          // Retrieving the expression used by loop
          const match = value.match(/\s(in|of)\s/);
          if (!match) {
            throw new Error(bbn._("Invalid loop expression"));
          }
          const itemExp = value.substr(0, match.index).trim();
          const valueExp = value.substr(match.index + match[0].length).trim();
          /** @var {Object} args An object with the name of the loop argument(s) used by the function */
          let args = bbn.fn.createObject();
          /** @todo Could do better! */
          // The first part of the expression is between parenthesis
          // which should mean there are 2 variables
          if (itemExp.indexOf(')') > -1) {
            /** @var {Array} tmp first part of the expression without the parenthesis and split by coma */
            let tmp = bbn.fn.substr(itemExp, 1, -1).split(',');
            // There's at least one expression
            if (!tmp.length) {
              throw new Error(bbn._("Invalid loop expression"));
            }

            // That would be the value's name'
            args.value = tmp[0].trim();
            // There is a second expression
            if (tmp.length === 2) {
              // The index name variable used by the function
              args.index = tmp[1].trim();
            }
          }
          // No parenthesis, there is just the value's name
          else {
            args.value = itemExp;
          }

          // No value no chocolate
          if (!args.value) {
            throw new Error(bbn._("Invalid loop expression"));
          }
          res.loop = bbn.fn.createObject({
            exp: valueExp,
            item: args.value,
            index: args.index || null,
            hash: bbn.fn.hash(valueExp),
            original: value
          });
          break;
        case 'bbn-if':
        case 'bbn-elseif':
        case 'bbn-else':
          if (res.condition) {
            throw new Error(bbn._("There can't be more than one conditional expressions on the same tag"));
          }
          let type = a.substr(4);
          let hash = bbn.fn.hash(value);
          res.condition = bbn.fn.createObject({
            type,
            exp: value,
            // Adding prefix as conditions can be set to false even when the expression is not
            hash: 'CONDITION' + idx.toString() + '-' + hash
          });
          break;
        case 'bbn-model':
          if (!res.model) {
            res.model = bbn.fn.createObject();
          }
          res.model[modelValue] = bbn.fn.createObject({
            exp: value,
            hash: bbn.fn.hash(value),
            modifiers: modifiers
          });
          break;
        case 'bbn-cloak':
          res.cloak = bbn.fn.createObject({
            exp: value,
            hash: bbn.fn.hash(value)
          });
          break;
        case 'bbn-pre':
          res.pre = ele.innerHTML;
          break;
        case 'bbn-forget':
          res.forget = bbn.fn.createObject({
            exp: value,
            hash: bbn.fn.hash(value)
          });
          break;
        default:
          if (bbn.cp.directives[a]) {
            if (!res.directives) {
              res.directives = bbn.fn.createObject();
            }
            let directiveArg = attrName.match(new RegExp(/\:{1}([a-z]+)/g));
            let directiveMod = attrName.match(new RegExp(/\.{1}([a-z]+)/g));
            res.directives[a] = bbn.fn.createObject({
              exp: value,
              hash: bbn.fn.hash(value),
              modifiers: !!directiveMod ? bbn.fn.map(directiveMod, m => bbn.fn.substr(m, 1)) : [],
              arg: !!directiveArg ? bbn.fn.substr(directiveArg[0], 1) : null,
              oldValue: undefined,
              lastUpdate: null
            });
          } else {
            res.attr[name].exp = value;
            res.attr[name].hash = bbn.fn.hash(value);
          }
      }
    }
    // Regular attributes
    else {
      res.attr[name].hash = bbn.fn.hash(value);
      res.attr[name].value = value;
    }
  });
  let childNodes;
  if (Object.hasOwn(res.attr, 'inlineTemplate')) {
    if (!inlineTemplates[res.tag]) {
      inlineTemplates[res.tag] = ele.innerHTML;
      delete res.attr.inlineTemplate;
    }
    childNodes = [];
  } else if (res.tag === 'svg') {
    childNodes = [];
    res.content = ele.innerHTML;
  } else if (res.pre) {
    childNodes = [];
  } else {
    childNodes = ele.childNodes;
  }
  if (!res.pre && ele.tagName === 'TEMPLATE') {
    let before = '<body>';
    let after = '</body>';
    let target = 'body';
    let tpl = bbn.cp.removeSelfClosing(ele.innerHTML);
    let tag1 = tpl.match(/<([a-zA-Z-]+)(>|.*?[^?]>)/s);
    if (tag1 && tag1[1]) {
      switch (tag1[1].toLowerCase()) {
        case 'thead':
        case 'tbody':
        case 'tfoot':
        case 'tr':
          before += '<table>';
          after = '</table>' + after;
          target = 'table';
          break;
        case 'td':
        case 'th':
          before += '<table><tr>';
          after = '</tr></table>' + after;
          target = 'tr';
          break;
        case 'li':
          before += '<ul>';
          after = '</ul>' + after;
          target = 'ul';
          break;
      }
    }
    const doc = parser.parseFromString(
    // There shouldn't be self-closing in the embedded HTML except if in template
    before + tpl + after, "text/html");
    childNodes = doc.documentElement.querySelector(target).childNodes;
  }
  let num = 0;
  let lastEmpty = false;
  Array.from(childNodes).forEach(node => {
    if (node instanceof Comment) {
      return;
    }
    if (node && node.getAttributeNames) {
      let tmp = bbn.cp.analyzeElement(node, map, inlineTemplates, idx + '-' + num);
      res.items.push(tmp.res);
      num++;
      lastEmpty = false;
    }
    // No text nodes in the slots
    else if (node.textContent) {
      const checkEmpty = bbn.fn.removeExtraSpaces(node.textContent);
      const txt = node.textContent
      // escaping dollars
      //.replace(/\$/g, (_, g) => '\\$')
      // replacing double curly braces by dollar and single
      .replace(/{{(.+?)}}/gs, (_, g1) => '${' + g1 + '}');
      let isDynamic = txt.indexOf('${') > -1;
      let hash = bbn.fn.hash(txt);
      if (checkEmpty || !lastEmpty) {
        lastEmpty = !checkEmpty;
        const item = bbn.fn.createObject({
          id: idx + '-' + num,
          text: txt,
          hash: hash,
          empty: !checkEmpty
        });
        if (isDynamic) {
          item.exp = txt;
        }
        res.items.push(item);
        map[idx + '-' + num] = item;
        num++;
      } else {
        lastEmpty = false;
      }
    } else {
      bbn.fn.log("Unknown node", node);
      lastEmpty = false;
    }
  });
  let isIf = false;
  let conditionId = null;
  for (let i = 0; i < res.items.length; i++) {
    let item = res.items[i];
    if (item.condition) {
      if (item.condition.type === 'if') {
        conditionId = bbn.fn.randomString(32);
        item.conditionId = conditionId;
        isIf = true;
      } else if (!isIf) {
        throw new Error(bbn._("There can't be an elseif or an else without an if"));
      } else {
        item.conditionId = conditionId;
      }
      if (item.condition.type === 'else') {
        isIf = false;
      }
    } else if (isIf) {
      if (item.empty) {
        res.items.splice(i, 1);
        i--;
      } else {
        isIf = false;
      }
    }
  }
  if (res.condition) {
    res.conditionId = bbn.fn.randomString(32);
  }
  map[idx] = bbn.fn.clone(res);
  delete map[idx].items;
  return {
    res,
    map,
    inlineTemplates
  };
}
export default function attributeChangedCallback(cp, name, oldValue, newValue) {
  if (oldValue !== newValue && cp.bbn) {
    cp.bbn.$attributeChange(name, oldValue, newValue);
  }
}
export default function connectedCallback(cp) {
  if (cp.bbnId && !cp.bbn) {
    cp.bbn = new (cp.bbnFn || cp.constructor.bbnFn)(cp);
    cp.bbn.$connectedCallback();
  }
}
/**
 * Convert the classes into a string
 */
export default function convertClasses() {
  let arr = [];
  for (let i = 0; i < arguments.length; i++) {
    let css = arguments[i];
    if (!css) {
      continue;
    }
    if (bbn.fn.isString(css)) {
      arr.push(...css.split(' '));
    } else if (bbn.fn.isObject(css)) {
      for (let n in css) {
        if (css[n]) {
          arr.push(n);
        }
      }
    } else if (bbn.fn.isArray(css)) {
      bbn.fn.each(css, cs => arr.push(...bbn.cp.convertClasses(cs).split(' ')));
    } else {
      bbn.fn.log(css);
      throw new Error(bbn._("Can't understand classes"));
    }
  }
  return bbn.fn.removeEmpty(bbn.fn.unique(arr)).join(' ');
}
const treatArguments = function () {
  const final = bbn.fn.createObject();
  bbn.fn.each(arguments, arg => {
    if (bbn.fn.isArray(arg)) {
      bbn.fn.extend(final, treatArguments(...arg));
    } else if (bbn.fn.isObject(arg) && bbn.fn.numProperties(arg)) {
      bbn.fn.extend(final, arg);
    } else if (bbn.fn.isString(arg)) {
      let arr = arg.split(';').map(a => a.trim().split(':').map(b => b.trim()));
      let css = bbn.fn.createObject();
      bbn.fn.each(arr, a => {
        if (a[0] && a[1] !== undefined && a[1] !== '') {
          css[bbn.fn.camelize(a[0])] = a[1];
        }
      });
      bbn.fn.extend(final, css);
    }
  });
  return final;
};
/**
 * Convert styles into a string
 */
export default function convertStyles() {
  let st = '';
  const css = treatArguments(...arguments);
  if (bbn.fn.isObject(css)) {
    for (let n in css) {
      let prop = bbn.fn.camelToCss(n);
      let value = css[n];
      if (![undefined, null, ''].includes(value)) {
        if (bbn.fn.isNumber(css[n]) && bbn.fn.isPropSize(prop)) {
          value = css[n] + 'px';
        } else if (!bbn.fn.isString(value) && value.toString) {
          value = value.toString();
        }
        st += ` ${prop}: ${value};`;
      }
    }
  } else if (css) {
    bbn.fn.log("convertStyles", css);
    throw new Error(bbn._("Can't understand style"));
  }
  return st;
}
import { bbn } from "@bbn/bbn/dist/index.js";

/**
* Init anon component
*/
export default async function createApp(ele, obj) {
  await import('@bbn/bbn-css/dist/css/bbn-css-' + (bbn.env.theme || 'default') + '.css');
  //bbn.fn.log("CP?", bbn.cp);
  bbn.cp.startTick();
  bbn.cp.addPrefix('bbn-', async components => {
    const res = bbn.fn.createObject({
      components: []
    });
    //bbn.fn.log("COMPONENTS", components);
    for (let cp of components) {
      if (cp === 'bbn-anon') {
        continue;
      }
      // Request needs to be done as a string explicitly
      // @see https://stackoverflow.com/questions/42908116/webpack-critical-dependency-the-request-of-a-dependency-is-an-expression
      const definition = await import( /* webpackChunkName: "components/[request]" */
      `../components/${cp.substr(4)}/${cp.substr(4)}.js`);
      //bbn.fn.log(["DEFINITION", definition]);
      for (let n in definition) {
        if (n === 'default') {
          res.components.push(definition.default);
        } else if (!window[n]) {
          window[n] = definition[n];
        }
      }
    }
    return res;
  });
  bbn.cp.addPrefix('appui-', async components => {
    const urlPrefix = 'components/';
    const url = urlPrefix + components.join('/') + '?v=3280&test=1&lang=fr';
    // Request
    const d = await bbn.fn.ajax(url, 'text');
    let tmp;
    try {
      if (bbn.fn.isString(d.data)) {
        tmp = eval('(() => {return ' + d.data + '})()');
      }
    } catch (e) {
      throw new Error(e);
    }
    const res = bbn.fn.createObject({
      components: []
    });
    if (tmp.components) {
      bbn.fn.each(tmp.components, obj => {
        res.components.push(bbn.fn.createObject({
          name: obj.name,
          definition: eval(obj.script),
          template: obj.content,
          css: obj.css || null
        }));
      });
    }
    return res;
  });
  if (bbn.fn.isString(ele)) {
    ele = document.body.querySelector(ele);
  }

  /*
  bbn.cp.addPrefix('bbn', async tag => {
    const pUrl = bbn.env.cdn + 'lib/bbn-vue/master/src/components/?components=';
    const url = pUrl + tag.substr(4) + '&v=3280&test=1&lang=fr';
    // Request
    const d = await bbn.fn.ajax(url, 'text').then(r => r);
    return d;
  });
  */

  // ele must be an HTMLElement
  bbn.fn.checkType(ele, HTMLElement, "The createApp function should be given a HTMLElement");
  // Its content is its template
  let tmp = bbn.cp.stringToTemplate(ele.outerHTML, true);
  const cpTpl = tmp.res;
  const cpMap = tmp.map;
  const schema = bbn.fn.clone(cpTpl[0]);
  delete schema.slots;
  const placeholder = document.createComment("bbn-component placeholder");
  const parent = ele.parentNode;
  let cls = ele.style.cssText;
  if (cls) {
    cls = cls.trim();
  }
  parent.replaceChild(placeholder, ele);
  // Adding basicComponent mixin
  if (!obj.mixins) {
    obj.mixins = [];
  }
  if (!obj.mixins.includes(bbn.cp.mixins.basic)) {
    obj.mixins.push(bbn.cp.mixins.basic);
  }

  // The component config (= Vue-like object) that we freeze
  const cpCfg = Object.freeze(bbn.cp.normalizeComponent(obj, 'bbnCpRoot'));

  // If subcomponents are defined we init them too
  if (cpCfg.components) {
    for (let n in cpCfg.components) {
      bbn.cp.define(cpCfg.componentNames[n], cpCfg.components[n], cpCfg.components[n].template);
    }
  }
  const slots = bbn.cp.retrieveSlots(cpTpl);
  if (!slots.default) {
    slots.default = [];
  }
  const cp = Object.assign(document.createElement("bbn-anon"), {
    bbnId: '0',
    bbnCfg: cpCfg,
    bbnTpl: cpTpl,
    bbnSlots: slots,
    bbnMap: cpMap,
    bbnSchema: schema
  });
  if (cls) {
    cp.style.cssText = cls;
  }
  parent.replaceChild(cp, placeholder);
  /*
  bbn.fn.each(ele.childNodes, node => {
    cp.appendChild(node);
  });*/
  return cp.bbn;
}
/**
 * Creates a unique ID for a component
 */
export default function createCid() {
  let cid = 'bbncp-' + bbn.fn.randomString(24, 32).toLowerCase();
  while (this.componentsIndex.has(cid)) {
    cid = 'bbncp-' + bbn.fn.randomString(24, 32).toLowerCase();
  }
  return cid;
}
/**
* Defines a component with the Object config and the HTML template
* @param name The tag name of the component
* @param obj The Vue-like configuration object
* @param tpl The template as string or array from stringToTemplate
*/
export default function define(name, obj, tpl, css) {
  if (bbn.cp.known.includes(name)) {
    return;
  }
  if (!name) {
    bbn.fn.warning("BOO");
    bbn.fn.log(obj);
    throw new Error("The name of the component is mandatory");
  }

  // Template string becomes a DOM array
  let tmp = bbn.cp.stringToTemplate(tpl, true);
  if (name === 'bbn-checkbox') {
    bbn.fn.warning("CHECKBOX");
    bbn.fn.log(obj.model);
  }
  // Name of the class based on the tag name
  const publicName = bbn.fn.camelize(name);
  // The component config (= Vue-like object) that we freeze
  bbn.fn.iterate(tmp.inlineTemplates, (tpl, tag) => {
    if (!obj.components[tag]) {
      bbn.fn.log(Object.keys(cpCfg.components).join(", "));
      throw new Error("Impossible to find the sub component %s", tag);
    }
    obj.components[tag].template = tpl;
  });
  const cpCfg = bbn.cp.normalizeComponent(obj, publicName);
  Object.freeze(cpCfg);
  const cls = cpCfg.tag && bbn.cp.tagExtensions[cpCfg.tag] ? bbn.cp.tagExtensions[cpCfg.tag] : 'bbnHTML';
  bbn.cp.statics[name] = bbnData.immunizeValue(bbn.fn.createObject({
    tpl: tmp.res,
    map: tmp.map,
    cls: publicName + 'HTML',
    fn: publicName + 'Cp',
    cfg: cpCfg,
    models: bbn.cp.retrieveModels(tmp.res),
    slots: bbn.cp.retrieveSlots(tmp.res),
    tag: cpCfg.tag
  }), true);
  if (!bbn.cp.statics[name].slots.default) {
    bbn.cp.statics[name].slots.default = [];
  }
  if (css) {
    const styleSheet = document.createElement('style');
    const old = document.getElementById(name + "-bbn-css");
    if (old) {
      document.head.removeChild(old);
    }
    styleSheet.setAttribute("id", name + "-bbn-css");
    styleSheet.textContent = css;
    document.head.append(styleSheet);
  }

  // If subcomponents are defined we init them too
  if (cpCfg.components) {
    for (let n in cpCfg.components) {
      bbn.cp.define(cpCfg.componentNames[n], cpCfg.components[n], cpCfg.components[n].template || '');
      //cpProto.$options.components[n] = cpCfg.components[n];
    }
  }
  // Generating a basic HTML class based on the component config
  //bbn.fn.log('generateHTMLClass', publicName, cls, '-------');
  bbn.cp.generateHTMLClass(publicName, cls);
  // Generating the code for the private class based on the component config
  //const privateClassCode = makePrivateClass(privateName, cpCfg);
  //bbn.fn.log('generateCpClass', publicName);
  bbn.cp.generateCpClass(publicName, cpCfg);
  //bbn.fn.log("fnCode", fnCode);
  //bbn.fn.log(makePrivateFunction(privateName, cpCfg));
  // Evaluating that code: defining the private class
  // Retrieving the class object

  // Getting the class object from the Window (seems impossible otherwise)
  //bbn.fn.log(publicName);
  const args = [name, eval(publicName)];
  if (cpCfg.tag) {
    args.push({
      extends: cpCfg.tag
    });
  }

  // Adding the newly defined component to the known array
  bbn.cp.known.push(name);
  // Assigning the public class to the component's tag
  customElements.define(...args);
}
export default function () {
  var isDragging = false;
  var currentEle = false;
  const fnClick = e => {
    e.stopImmediatePropagation();
    e.preventDefault();
  };
  const fnDrag = e => {
    drag(e, currentEle);
  };
  const fnEnd = e => {
    endDrag(e, currentEle);
    document.removeEventListener('mousemove', fnDrag);
    setTimeout(() => {
      document.removeEventListener('click', fnClick, {
        once: true,
        capture: true
      });
    }, 100);
    isDragging = false;
  };
  const fnUp = () => {
    isDragging = false;
  };
  const startDrag = (e, ele) => {
    if (!!ele.bbnDirectives.draggable.active && !isDragging) {
      isDragging = true;
      currentEle = ele;
      var options = ele.bbnDirectives.draggable.options;
      let ev = new CustomEvent('dragstart', {
        cancelable: true,
        bubbles: true,
        detail: options
      });
      ele.dispatchEvent(ev);
      if (!ev.defaultPrevented) {
        ev.stopImmediatePropagation();
        let isMove = !!options.mode && options.mode === 'move',
          isSelf = !!options.mode && options.mode === 'self',
          helper = isMove ? false : isSelf ? ele : ele.cloneNode(true),
          rect = ele.getBoundingClientRect();
        options.originalElement = ele;
        options.originalParent = ele.parentElement;
        options.originalNextElement = ele.nextElementSibling;
        options.helper = options.helperElement || ele;
        if (!options.container) {
          options.container = bbn.fn.isDom(options.originalParent) ? options.originalParent : document.body;
        }
        if (!isMove) {
          if (options.component) {
            helper = document.createElement('component');
            helper.setAttribute(bbn.fn.isString(options.component) ? 'is' : ':is', options.component);
            if (bbn.fn.isObject(options) && bbn.fn.isObject(options.componentOptions)) {
              helper.setAttribute('v-bind', JSON.stringify(options.componentOptions));
            }
          }
          if (!!options.helperElement) {
            rect = options.helperElement.getBoundingClientRect();
            helper = isSelf ? options.helperElement : options.helperElement.cloneNode(true);
          }
          options.helper = document.createElement('div');
          options.helper.setAttribute('id', 'bbn-draggable-current');
          options.helper[isSelf ? 'appendChild' : 'append'](helper);
          options.helper.style.left = e.pageX + 'px';
          options.helper.style.top = e.pageY + 'px';
          options.helper.style.position = 'fixed';
          options.helper.style.zIndex = '1000';
          options.helper.style.opacity = 0.7;
          options.helper.style.width = rect.width + 'px';
          options.helper.style.height = rect.height + 'px';
          options.container[isSelf ? 'appendChild' : 'append'](options.helper);
          //bbn.cp.createApp(document.querySelector('#bbn-draggable-current > *'));
        }

        ele.bbnDirectives.draggable.pointerEvents = window.getComputedStyle(options.helper).pointerEvents;
        options.helper.style.pointerEvents = 'none';
        document.addEventListener('click', fnClick, {
          once: true,
          capture: true
        });
        document.addEventListener('mouseup', fnEnd, {
          once: true
        });
        document.addEventListener('mousemove', fnDrag);
      }
    }
  };
  const drag = (e, ele) => {
    if (!!ele.bbnDirectives.draggable.active) {
      // we prevent default from the event
      e.stopImmediatePropagation();
      e.preventDefault();
      var options = ele.bbnDirectives.draggable.options;
      if (options.mode === 'move') {
        let rectContainer = options.container.getBoundingClientRect(),
          rectHelper = options.helper.getBoundingClientRect(),
          rectEle = ele.getBoundingClientRect(),
          x = bbn.fn.roundDecimal(e.x, 0),
          y = bbn.fn.roundDecimal(e.y, 0),
          minLeft = bbn.fn.roundDecimal(-rectHelper.width + (rectHelper.right - rectEle.right) + 20, 0),
          minLeftPos = bbn.fn.roundDecimal(rectContainer.left + minLeft - (rectEle.left - rectHelper.left), 0),
          maxLeft = bbn.fn.roundDecimal(rectContainer.width - (rectEle.left - rectHelper.left) - 20, 0),
          maxLeftPos = bbn.fn.roundDecimal(rectEle.left + rectEle.width - rectHelper.left + rectContainer.left + maxLeft, 0),
          minTop = bbn.fn.roundDecimal(-rectHelper.height + (rectHelper.bottom - rectEle.bottom) + 20, 0),
          minTopPos = bbn.fn.roundDecimal(rectContainer.top + minTop - (rectEle.top - rectHelper.top), 0),
          maxTop = bbn.fn.roundDecimal(rectContainer.height - (rectEle.top - rectHelper.top) - 20, 0),
          maxTopPos = bbn.fn.roundDecimal(rectEle.top + rectEle.height - rectHelper.top + rectContainer.top + maxTop, 0),
          left = options.helper.offsetLeft - (ele.bbnDirectives.draggable.mouseX - x),
          top = options.helper.offsetTop - (ele.bbnDirectives.draggable.mouseY - y);
        if (x < minLeftPos || options.helper.offsetLeft < minLeft) {
          left = minLeft;
        } else if (options.helper.offsetLeft > maxLeft || x > maxLeftPos - 20 && options.helper.offsetLeft === maxLeft) {
          left = maxLeft;
        }
        if (y < minTopPos || options.helper.offsetTop < minTop) {
          top = minTop;
        } else if (options.helper.offsetTop > maxTop || y > maxTopPos - 20 && options.helper.offsetTop === maxTop) {
          top = maxTop;
        }
        if (options.helper.offsetLeft === minLeft) {
          if (ele.bbnDirectives.draggable.mouseMinX === undefined) {
            ele.bbnDirectives.draggable.mouseMinX = x;
          } else if (x >= minLeftPos) {
            if (x >= ele.bbnDirectives.draggable.mouseMinX) {
              delete ele.bbnDirectives.draggable.mouseMinX;
            } else {
              left = minLeft;
            }
          }
        }
        if (options.helper.offsetLeft === maxLeft) {
          if (ele.bbnDirectives.draggable.mouseMaxX === undefined) {
            ele.bbnDirectives.draggable.mouseMaxX = x;
          } else if (x <= maxLeftPos) {
            if (x <= ele.bbnDirectives.draggable.mouseMaxX) {
              delete ele.bbnDirectives.draggable.mouseMaxX;
            } else {
              left = maxLeft;
            }
          }
        }
        if (options.helper.offsetTop === minTop) {
          if (ele.bbnDirectives.draggable.mouseMinY === undefined) {
            ele.bbnDirectives.draggable.mouseMinY = y;
          } else if (y >= minTopPos) {
            if (y >= ele.bbnDirectives.draggable.mouseMinY) {
              delete ele.bbnDirectives.draggable.mouseMinY;
            } else {
              top = minTop;
            }
          }
        }
        if (options.helper.offsetTop === maxTop) {
          if (ele.bbnDirectives.draggable.mouseMaxY === undefined) {
            ele.bbnDirectives.draggable.mouseMaxY = y;
          } else if (y <= maxTopPos) {
            if (y <= ele.bbnDirectives.draggable.mouseMaxY) {
              delete ele.bbnDirectives.draggable.mouseMaxY;
            } else {
              top = maxTop;
            }
          }
        }
        if (left < minLeft) {
          left = minLeft;
        }
        if (top < minTop) {
          top = minTop;
        }
        if (left > maxLeft) {
          left = maxLeft;
        }
        if (top > maxTop) {
          top = maxTop;
        }
        options.helper.style.left = left + 'px';
        options.helper.style.top = top + 'px';
        let style = window.getComputedStyle(options.helper);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
          options.helper.style.position = 'absolute';
        }
        ele.bbnDirectives.draggable.mouseX = x;
        ele.bbnDirectives.draggable.mouseY = y;
      } else {
        options.helper.style.left = e.pageX + 'px';
        options.helper.style.top = e.pageY + 'px';
      }
      let scroll = e.target.closest('.bbn-scroll');
      options.scroll = !!scroll && scroll.bbn !== undefined ? scroll.bbn : false;
      if (!!options.scroll && (options.scroll.hasScrollY || options.scroll.hasScrollX) && !options.scroll.isScrolling) {
        let getDiff = axis => {
          let coord = options.scroll.$el.getBoundingClientRect(),
            client = 'client' + axis.toUpperCase(),
            dim = axis === 'y' ? 'height' : 'width',
            step = Math.ceil(coord[dim] / 20),
            margin = step * 4,
            diff = 0;
          if (e[client] < coord[axis] + margin) {
            diff = e[client] - coord[axis] - margin;
          } else if (e[client] > coord[axis] + coord[dim] - margin) {
            diff = e[client] - (coord[axis] + coord[dim] - margin);
          }
          if (diff) {
            let approachLevel = Math.round(diff / step);
            return Math.round(options.scroll.$el['offset' + dim.charAt(0).toUpperCase() + dim.slice(1)] / 5) * approachLevel + 1;
          }
        };
        if (options.scroll.hasScrollY) {
          let diff = getDiff('y');
          if (diff) {
            options.scroll.addVertical(diff);
          }
        }
        if (options.scroll.hasScrollX) {
          let diff = getDiff('x');
          if (diff) {
            options.scroll.addHorizontal(diff);
          }
        }
      }
      if (options.mode !== 'move') {
        var _target$bbnDirectives;
        let target = e.target;
        if (target.dataset.bbn_droppable !== 'true') {
          target = target.closest('[data-bbn_droppable=true]');
        }
        if (target && target !== ele && !target.classList.contains('bbn-undroppable') && !!((_target$bbnDirectives = target.bbnDirectives) !== null && _target$bbnDirectives !== void 0 && (_target$bbnDirectives = _target$bbnDirectives.droppable) !== null && _target$bbnDirectives !== void 0 && _target$bbnDirectives.active)) {
          let ev = new CustomEvent('dragoverdroppable', {
            cancelable: true,
            bubbles: true,
            detail: options
          });
          target.dispatchEvent(ev);
        }
      }
    }
  };
  const endDrag = (e, ele) => {
    if (!!ele.bbnDirectives.draggable.active && isDragging) {
      var _target$bbnDirectives2;
      e.preventDefault();
      e.stopImmediatePropagation();
      var options = ele.bbnDirectives.draggable.options;
      options.helper.style.pointerEvents = ele.bbnDirectives.draggable.pointerEvents;
      let target = options.mode !== 'move' ? e.target : false;
      if (bbn.fn.isDom(target) && target.dataset.bbn_droppable_over !== 'true') {
        target = target.closest('[data-bbn_droppable_over=true]');
      }
      if (bbn.fn.isDom(target) && !target.classList.contains('bbn-undroppable') && !!((_target$bbnDirectives2 = target.bbnDirectives) !== null && _target$bbnDirectives2 !== void 0 && (_target$bbnDirectives2 = _target$bbnDirectives2.droppable) !== null && _target$bbnDirectives2 !== void 0 && _target$bbnDirectives2.active)) {
        let ev = new CustomEvent('beforedrop', {
          cancelable: true,
          bubbles: true,
          detail: options
        });
        target.dispatchEvent(ev);
      } else {
        let ev = new CustomEvent('dragend', {
          cancelable: true,
          bubbles: true,
          detail: options
        });
        ele.dispatchEvent(ev);
        if (!ev.defaultPrevented) {
          if (!!options.mode && options.mode === 'self') {
            options.originalParent.insertBefore(options.originalElement, options.originalNextElement);
          }
        }
      }
      document.removeEventListener('click', fnClick, {
        once: true,
        capture: true
      });
      document.removeEventListener('mouseup', fnEnd, {
        once: true
      });
      document.removeEventListener('mousemove', fnDrag);
      document.removeEventListener('mouseup', fnUp, {
        once: true
      });
      if (options.mode !== 'move') {
        options.helper.remove();
      } else {
        delete ele.bbnDirectives.draggable.mouseX;
        delete ele.bbnDirectives.draggable.mouseY;
        delete ele.bbnDirectives.draggable.mouseMinX;
        delete ele.bbnDirectives.draggable.mouseMaxX;
        delete ele.bbnDirectives.draggable.mouseMinY;
        delete ele.bbnDirectives.draggable.mouseMaxY;
      }
    }
  };
  const inserted = (el, binding) => {
    //bbn.fn.warning("DRAGGABLE INSERTED");
    if (analyzeValue(el, binding)) {
      // Add the events listener to capture the long press click and start the drag
      let clickTimeout = 0,
        holdClick = false;
      el.bbnDirectives.draggable.onmousedown = ev => {
        if (!!el.bbnDirectives.draggable.active) {
          el.bbnDirectives.draggable.mouseX = ev.x;
          el.bbnDirectives.draggable.mouseY = ev.y;
          if (clickTimeout) {
            clearTimeout(clickTimeout);
          }
          if (ev.button === 0) {
            holdClick = true;
            clickTimeout = setTimeout(() => {
              if (holdClick) {
                startDrag(ev, el);
              }
            }, 150);
          }
        }
      };
      el.addEventListener('mousedown', el.bbnDirectives.draggable.onmousedown);
      el.bbnDirectives.draggable.onmouseup = ev => {
        if (!!el.bbnDirectives.draggable.active) {
          holdClick = false;
        }
      };
      el.addEventListener('mouseup', el.bbnDirectives.draggable.onmouseup);
    }
  };
  const analyzeValue = (el, binding) => {
    if (el.bbnDirectives === undefined) {
      el.bbnDirectives = bbn.fn.createObject();
    }
    if (el.bbnDirectives.draggable === undefined) {
      el.bbnDirectives.draggable = bbn.fn.createObject();
    }
    if (binding.value !== false && !el.classList.contains('bbn-undraggable')) {
      el.dataset.bbn_draggable = true;
      el.bbnDirectives.draggable = bbn.fn.createObject({
        active: true
      });
      if (!el.classList.contains('bbn-draggable')) {
        el.classList.add('bbn-draggable');
      }
      let options = bbn.fn.createObject(),
        asArg = !!binding.arg && binding.arg.length,
        asMods = bbn.fn.isArray(binding.modifiers) && binding.modifiers.length,
        asComponentFromMods = asMods && binding.modifiers.includes('component'),
        asContainerFromMods = asMods && binding.modifiers.includes('container'),
        asModeFromMods = asMods && binding.modifiers.includes('mode'),
        asDataFromMods = asMods && binding.modifiers.includes('data'),
        asHelperFromMods = asMods && binding.modifiers.includes('helper'),
        component = false,
        container = false,
        mode = 'clone',
        data = bbn.fn.createObject(),
        helper = false;
      if (asArg) {
        switch (binding.arg) {
          case 'component':
            component = binding.value;
            break;
          case 'container':
            container = binding.value;
            break;
          case 'data':
            data = binding.value;
            break;
          case 'mode':
            mode = binding.value;
            break;
          case 'helper':
            helper = binding.value;
            break;
        }
      } else {
        if (bbn.fn.isObject(binding.value)) {
          options = binding.value;
          if (asComponentFromMods) {
            if (options.component === undefined || bbn.fn.isObject(options.component) && !bbn.fn.numProperties(options.component) || bbn.fn.isString(options.component) && !options.component.length) {
              bbn.fn.error(bbn._('No "component" property found'));
              throw bbn._('No "component" property found');
            }
            component = options.component;
          }
          if (asContainerFromMods) {
            if (options.container === undefined || !bbn.fn.isDom(options.container)) {
              bbn.fn.error(bbn._('No "container" property found or not a DOM element'));
              throw bbn._('No "container" property found or not a DOM element');
            }
            container = options.container;
          }
          if (asDataFromMods) {
            if (options.data === undefined || !bbn.fn.isObject(options.data)) {
              bbn.fn.error(bbn._('No "data" property found or not an object'));
              throw bbn._('No "data" property found or not an object');
            }
            data = options.data;
          }
          if (asModeFromMods) {
            if (options.mode === undefined || !bbn.fn.isString(options.mode)) {
              bbn.fn.error(bbn._('No "mode" property found or not a string'));
              throw bbn._('No "mode" property found or not a string');
            }
            mode = options.mode;
          }
          if (asHelperFromMods) {
            if (options.helper === undefined || !bbn.fn.isString(options.helper) && !bbn.fn.isDom(options.helper)) {
              bbn.fn.error(bbn._('No "helper" property found or not a string or not a DOM element'));
              throw bbn._('No "helper" property found or not a string or not a DOM element');
            }
            helper = options.helper;
          }
        } else if (bbn.fn.isString(binding.value)) {
          switch (binding.value) {
            case 'clone':
            case 'move':
            case 'self':
              mode = binding.value;
              break;
            default:
              // The helper is a component name
              component = binding.value;
              break;
          }
        }
      }
      if (component) {
        options.component = component;
      }
      options.container = container;
      options.data = data;
      options.mode = mode;
      if (helper) {
        options.helperElement = helper;
      }
      el.bbnDirectives.draggable.options = options;
      return true;
    } else {
      el.dataset.bbn_draggable = false;
      el.bbnDirectives.draggable = bbn.fn.createObject({
        active: false
      });
      return false;
    }
  };
  const setOff = el => {
    el.dataset.bbn_draggable = false;
    if (el.bbnDirectives.draggable === undefined) {
      el.bbnDirectives.draggable = bbn.fn.createObject();
    }
    if (!!el.bbnDirectives.draggable.active) {
      if (bbn.fn.isFunction(el.bbnDirectives.draggable.onmousedown)) {
        el.removeEventListener('mousedown', el.bbnDirectives.draggable.onmousedown);
      }
      if (bbn.fn.isFunction(el.bbnDirectives.draggable.onmouseup)) {
        el.removeEventListener('mouseup', el.bbnDirectives.draggable.onmouseup);
      }
    }
    el.bbnDirectives.draggable = bbn.fn.createObject({
      active: false
    });
    if (el.classList.contains('bbn-draggable')) {
      el.classList.remove('bbn-draggable');
    }
  };
  bbn.cp.directives['bbn-draggable'] = bbn.fn.createObject({
    inserted: inserted,
    update: (el, binding) => {
      bbn.fn.warning("DRAGGABLE UPDATED");
      if (binding.value !== false && !el.classList.contains('bbn-undraggable')) {
        if (binding.oldValue === false) {
          inserted(el, binding);
        } else if (!isDragging) {
          analyzeValue(el, binding);
        }
      } else {
        setOff(el);
      }
    }
  });
}
;
export default function () {
  var dragOver = false;
  var mouseOver = false;
  const inserted = (el, binding) => {
    if (analyzeValue(el, binding)) {
      el.bbnDirectives.droppable.onmouseenter = e => {
        if (!!el.bbnDirectives.droppable.active) {
          mouseOver = true;
        }
      };
      el.addEventListener('mouseenter', el.bbnDirectives.droppable.onmouseenter);
      el.bbnDirectives.droppable.onmouseleave = e => {
        if (!!el.bbnDirectives.droppable.active) {
          let ev = new CustomEvent('dragleave', {
            cancelable: true,
            bubbles: true,
            detail: dragOver
          });
          mouseOver = false;
          dragOver = false;
          el.dispatchEvent(ev);
          if (!ev.defaultPrevented) {
            if (el.classList.contains('bbn-droppable-over')) {
              el.classList.remove('bbn-droppable-over');
            }
            delete el.dataset.bbn_droppable_over;
          }
        }
      };
      el.addEventListener('mouseleave', el.bbnDirectives.droppable.onmouseleave);
      el.bbnDirectives.droppable.ondragoverdroppable = e => {
        if (!!el.bbnDirectives.droppable.active && !e.defaultPrevented && !dragOver && !!mouseOver) {
          dragOver = bbn.fn.createObject({
            from: e.detail,
            to: el.bbnDirectives.droppable.options
          });
          let ev = new CustomEvent('dragover', {
            cancelable: true,
            bubbles: true,
            detail: dragOver
          });
          el.dispatchEvent(ev);
          if (!ev.defaultPrevented) {
            if (!el.classList.contains('bbn-droppable-over')) {
              el.classList.add('bbn-droppable-over');
            }
            el.dataset.bbn_droppable_over = true;
          }
        }
      };
      el.addEventListener('dragoverdroppable', el.bbnDirectives.droppable.ondragoverdroppable);
      el.bbnDirectives.droppable.onbeforedrop = e => {
        if (!!el.bbnDirectives.droppable.active) {
          if (el.classList.contains('bbn-droppable-over')) {
            el.classList.remove('bbn-droppable-over');
          }
          if (!e.defaultPrevented && !!dragOver) {
            let ev = new CustomEvent('drop', {
              cancelable: true,
              bubbles: true,
              detail: dragOver
            });
            el.dispatchEvent(ev);
            if (!ev.defaultPrevented) {
              el.appendChild(e.detail.originalElement);
            } else {
              let ev = new CustomEvent('dragend', {
                cancelable: true,
                bubbles: true,
                detail: dragOver
              });
              e.detail.originalElement.dispatchEvent(ev);
              if (!ev.defaultPrevented) {
                if (!!e.detail.mode && e.detail.mode === 'self') {
                  e.detail.originalParent.insertBefore(e.detail.originalElement, e.detail.nextElement);
                }
              }
            }
          }
        }
      };
      el.addEventListener('beforedrop', el.bbnDirectives.droppable.onbeforedrop);
    }
  };
  const analyzeValue = (el, binding) => {
    if (el.bbnDirectives === undefined) {
      el.bbnDirectives = bbn.fn.createObject();
    }
    if (el.bbnDirectives.droppable === undefined) {
      el.bbnDirectives.droppable = bbn.fn.createObject();
    }
    if (binding.value !== false && !el.classList.contains('bbn-undroppable')) {
      el.dataset.bbn_droppable = true;
      el.bbnDirectives.droppable = bbn.fn.createObject({
        active: true
      });
      if (!el.classList.contains('bbn-droppable')) {
        el.classList.add('bbn-droppable');
      }
      let options = bbn.fn.createObject(),
        asArg = !!binding.arg && binding.arg.length,
        asMods = bbn.fn.isArray(binding.modifiers) && binding.modifiers.length,
        asDataFromMods = asMods && binding.modifiers.includes('data'),
        data = bbn.fn.createObject();
      if (asArg) {
        if (binding.arg === 'data') {
          data = binding.arg;
        }
      } else if (bbn.fn.isObject(binding.value)) {
        options = binding.value;
        if (asDataFromMods) {
          if (options.data === undefined || !bbn.fn.isObject(options.data)) {
            bbn.fn.error(bbn._('No "data" property found or not an object'));
            throw bbn._('No "data" property found or not an object');
          }
          data = options.data;
        }
      }
      options.data = data;
      el.bbnDirectives.droppable.options = options;
      return true;
    } else {
      el.dataset.bbn_droppable = false;
      el.bbnDirectives.droppable = bbn.fn.createObject({
        active: false
      });
      return false;
    }
  };
  const setOff = el => {
    el.dataset.bbn_droppable = false;
    if (el.bbnDirectives === undefined) {
      el.bbnDirectives = bbn.fn.createObject();
    }
    if (el.bbnDirectives.droppable === undefined) {
      el.bbnDirectives.droppable = bbn.fn.createObject();
    }
    if (!!el.bbnDirectives.droppable.active) {
      if (bbn.fn.isFunction(el.bbnDirectives.droppable.onmouseenter)) {
        el.removeEventListener('mouseenter', el.bbnDirectives.droppable.onmouseenter);
      }
      if (bbn.fn.isFunction(el.bbnDirectives.droppable.onmouseleave)) {
        el.removeEventListener('mouseleave', el.bbnDirectives.droppable.onmouseleave);
      }
      if (bbn.fn.isFunction(el.bbnDirectives.droppable.ondragoverdroppable)) {
        el.removeEventListener('dragoverdroppable', el.bbnDirectives.droppable.ondragoverdroppable);
      }
      if (bbn.fn.isFunction(el.bbnDirectives.droppable.onbeforedrop)) {
        el.removeEventListener('beforedrop', el.bbnDirectives.droppable.onbeforedrop);
      }
    }
    el.bbnDirectives.droppable = bbn.fn.createObject({
      active: false
    });
    if (el.classList.contains('bbn-droppable')) {
      el.classList.remove('bbn-droppable');
    }
  };
  bbn.cp.directives['bbn-droppable'] = bbn.fn.createObject({
    inserted: inserted,
    update: (el, binding) => {
      if (binding.value !== false && !el.classList.contains('bbn-undroppable')) {
        if (binding.oldValue === false) {
          inserted(el, binding);
        } else if (!el.dataset.bbn_droppable_over) {
          analyzeValue(el, binding);
        }
      } else {
        setOff(el);
      }
    }
  });
}
;
export default function () {
  bbn.cp.directives['bbn-focused'] = bbn.fn.createObject({
    inserted(el, binding) {
      if (binding.value === false) {
        return;
      }
      setTimeout(() => {
        el.focus();
        bbn.env.focused = el;
        if (binding.modifiers.includes('selected')) {
          bbn.fn.selectElementText(el);
        }
      }, 250);
    }
  });
}
export default function () {
  const moveToTarget = (el, target) => {
    if (el.parentNode !== target) {
      target.appendChild(el);
    }
  };
  const treatBinding = (el, binding, force) => {
    if (!force && binding.value === binding.oldValue) {
      return;
    }
    if (bbn.fn.isString(binding.value)) {
      const target = document.querySelector(binding.value);
      if (target) {
        return moveToTarget(el, target);
      }
    } else if (bbn.fn.isDom(binding.value)) {
      return moveToTarget(el, binding.value);
    } else {
      return moveToTarget(el, document.body);
    }
  };
  bbn.cp.directives['bbn-portal'] = bbn.fn.createObject({
    inserted: (el, binding) => {
      el.bbnDirectives.portal = bbn.fn.createObject({
        originalParent: el.parentNode
      });
      if (binding.value) {
        treatBinding(el, binding, true);
      }
    },
    update: (el, binding) => {
      if (binding.value) {
        treatBinding(el, binding);
      } else {
        moveToTarget(el, el.bbnDirectives.portal.originalParent);
      }
    }
  });
}
export default function () {
  var isDragging = false;
  var currentEle = false;
  const fnDrag = e => {
    drag(e, currentEle);
  };
  const fnEnd = e => {
    endDrag(e, currentEle);
    document.removeEventListener('mousemove', fnDrag);
    isDragging = false;
  };
  const startDrag = (e, ele) => {
    if (!isDragging && !!ele.bbnDirectives.resizable.active && !ele.bbnDirectives.resizable.resizing && !!ele.bbnDirectives.resizable.modes && bbn.fn.numProperties(ele.bbnDirectives.resizable.modes)) {
      isDragging = true;
      currentEle = ele;
      ele.bbnDirectives.resizable.resizing = true;
      let cursor = '';
      modes = ele.bbnDirectives.resizable.modes;
      if (!!modes.left) {
        cursor = !!modes.top ? 'nwse-resize' : !!modes.bottom ? 'nesw-resize' : 'ew-resize';
      } else if (!!modes.right) {
        cursor = !!modes.top ? 'nesw-resize' : !!modes.bottom ? 'nwse-resize' : 'ew-resize';
      } else if (!!modes.top) {
        cursor = !!modes.right ? 'nesw-resize' : !!modes.left ? 'nwse-resize' : 'ns-resize';
      } else if (!!modes.bottom) {
        cursor = !!modes.right ? 'nwse-resize' : !!modes.left ? 'nesw-resize' : 'ns-resize';
      }
      ele.bbnDirectives.resizable.cursor = window.getComputedStyle(document.body).cursor;
      document.body.style.cursor = cursor;
      ele.classList.add('bbn-resizable-resizing');
      ele.bbnDirectives.resizable.mouseX = bbn.fn.roundDecimal(e.x, 0);
      ele.bbnDirectives.resizable.mouseY = bbn.fn.roundDecimal(e.y, 0);
      if (!ele.bbnDirectives.resizable.container) {
        ele.bbnDirectives.resizable.container = bbn.fn.isDom(ele.parentElement) ? ele.parentElement : document.body;
      }
      let ev = new CustomEvent('userresizestart', {
        cancelable: true,
        bubbles: true,
        detail: ele.bbnDirectives.resizable
      });
      ele.dispatchEvent(ev);
      if (ele.bbn !== undefined) {
        ele.bbn.$emit('userresizestart', ev);
      }
      if (!ev.defaultPrevented) {
        ev.stopImmediatePropagation();
        document.addEventListener('mouseup', fnEnd, {
          once: true
        });
        document.addEventListener('mousemove', fnDrag);
      }
    }
  };
  const drag = (e, ele) => {
    if (!!ele.bbnDirectives.resizable.active && !!ele.bbnDirectives.resizable.resizing) {
      // we prevent default from the event
      e.stopImmediatePropagation();
      e.preventDefault();
      let rectCont = ele.bbnDirectives.resizable.container.getBoundingClientRect(),
        rectEle = ele.getBoundingClientRect(),
        styleEle = window.getComputedStyle(ele),
        styleContainer = window.getComputedStyle(ele.bbnDirectives.resizable.container),
        x = bbn.fn.roundDecimal(e.x, 0),
        y = bbn.fn.roundDecimal(e.y, 0),
        modes = ele.bbnDirectives.resizable.modes,
        xMovement = bbn.fn.roundDecimal(ele.bbnDirectives.resizable.mouseX - x, 0),
        yMovement = bbn.fn.roundDecimal(ele.bbnDirectives.resizable.mouseY - y, 0),
        width = rectEle.width + (!!modes.left ? xMovement : -xMovement),
        height = rectEle.height + (!!modes.top ? yMovement : -yMovement),
        isAbs = styleEle.position === 'absolute',
        isFixed = styleEle.position === 'fixed',
        toSetAbs = false,
        element = {
          minWidth: (parseFloat(styleEle.paddingLeft) || 0) + (parseFloat(styleEle.paddingRight) || 0) + (parseFloat(styleEle.borderLeft) || 0) + (parseFloat(styleEle.borderRight) || 0) || 1,
          maxWidth: rectCont.width,
          minHeight: (parseFloat(styleEle.paddingTop) || 0) + (parseFloat(styleEle.paddingBottom) || 0) + (parseFloat(styleEle.borderTop) || 0) + (parseFloat(styleEle.borderBottom) || 0) || 1,
          maxHeight: rectCont.height,
          margin: {
            top: parseFloat(styleEle.marginTop) || 0,
            right: parseFloat(styleEle.marginRight) || 0,
            bottom: parseFloat(styleEle.marginBottom) || 0,
            left: parseFloat(styleEle.marginLeft) || 0
          },
          padding: {
            top: parseFloat(styleEle.paddingTop) || 0,
            right: parseFloat(styleEle.paddingRight) || 0,
            bottom: parseFloat(styleEle.paddingBottom) || 0,
            left: parseFloat(styleEle.paddingLeft) || 0
          },
          border: {
            top: parseFloat(styleEle.borderTop) || 0,
            right: parseFloat(styleEle.borderRight) || 0,
            bottom: parseFloat(styleEle.borderBottom) || 0,
            left: parseFloat(styleEle.borderLeft) || 0
          }
        },
        container = {
          margin: {
            top: parseFloat(styleContainer.marginTop) || 0,
            right: parseFloat(styleContainer.marginRight) || 0,
            bottom: parseFloat(styleContainer.marginBottom) || 0,
            left: parseFloat(styleContainer.marginLeft) || 0
          },
          padding: {
            top: parseFloat(styleContainer.paddingTop) || 0,
            right: parseFloat(styleContainer.paddingRight) || 0,
            bottom: parseFloat(styleContainer.paddingBottom) || 0,
            left: parseFloat(styleContainer.paddingLeft) || 0
          },
          border: {
            top: parseFloat(styleContainer.borderTop) || 0,
            right: parseFloat(styleContainer.borderRight) || 0,
            bottom: parseFloat(styleContainer.borderBottom) || 0,
            left: parseFloat(styleContainer.borderLeft) || 0
          }
        };
      element.margin.totalX = element.margin.left + element.margin.right;
      element.margin.totalY = element.margin.top + element.margin.bottom;
      container.margin.totalX = container.margin.left + container.margin.right;
      container.margin.totalY = container.margin.top + container.margin.bottom;
      container.padding.totalX = container.padding.left + container.padding.right;
      container.padding.totalY = container.padding.top + container.padding.bottom;
      if (element.maxWidth > rectCont.width - container.padding.totalX - element.margin.totalX) {
        element.maxWidth = rectCont.width - container.padding.totalX - element.margin.totalX;
      }
      if (element.maxHeight > rectCont.height - container.padding.totalY - element.margin.totalY) {
        element.maxHeight = rectCont.height - container.padding.totalY - element.margin.totalY;
      }
      width = width < element.minWidth ? element.minWidth : width > element.maxWidth ? element.maxWidth : width;
      height = height < element.minHeight ? element.minHeight : height > element.maxHeight ? element.maxHeight : height;
      if ((!!modes.left || !!modes.right) && xMovement) {
        if (!!modes.left) {
          const minLeft = rectCont.left + container.padding.left + container.border.left + element.margin.left;
          var tmpLeft = rectEle.left - xMovement;
          if (tmpLeft < minLeft) {
            xMovement = minLeft - tmpLeft;
            width -= xMovement;
            tmpLeft = minLeft;
          }
        }
        if (width !== rectEle.width) {
          let ev = makeEvent(!!modes.left ? 'left' : 'right', xMovement, width, rectEle.width);
          ele.dispatchEvent(ev);
          if (!ev.defaultPrevented) {
            if (!!modes.left && xMovement) {
              if (!isAbs && !isFixed) {
                toSetAbs = true;
                isAbs = true;
              }
              if (isAbs) {
                tmpLeft -= rectCont.left;
              }
              ele.style.left = tmpLeft - element.margin.left + 'px';
            }
            setSize(ele, styleEle.height, width + 'px', toSetAbs);
          }
        }
      }
      if ((!!modes.top || !!modes.bottom) && yMovement) {
        if (!!modes.top) {
          const minTop = rectCont.top + container.padding.top + container.border.top + element.margin.top;
          var tmpTop = rectEle.top - yMovement;
          if (tmpTop < minTop) {
            yMovement = minTop - tmpTop;
            height -= yMovement;
            tmpTop = minTop;
          }
        }
        if (height !== rectEle.height) {
          let ev = makeEvent(!!modes.top ? 'top' : 'bottom', yMovement, height, rectEle.height);
          ele.dispatchEvent(ev);
          if (!ev.defaultPrevented) {
            if (!!modes.top && yMovement) {
              if (!isAbs && !isFixed) {
                toSetAbs = true;
                isAbs = true;
              }
              if (isAbs) {
                tmpTop -= rectCont.top;
              }
              ele.style.top = tmpTop - element.margin.top + 'px';
            }
            setSize(ele, height + 'px', styleEle.width, toSetAbs);
          }
        }
      }
      ele.bbnDirectives.resizable.mouseX = x;
      ele.bbnDirectives.resizable.mouseY = y;
    }
  };
  const makeEvent = (from, movement, size, oldSize) => {
    return new CustomEvent('userresize', {
      cancelable: true,
      bubbles: true,
      detail: bbn.fn.createObject({
        from: from,
        movement: movement,
        size: size,
        oldSize: oldSize
      })
    });
  };
  const setSize = (ele, height, width, abs) => {
    ele.style.height = height;
    ele.style.width = width;
    if (abs) {
      ele.style.position = 'absolute';
    }
    if (ele.bbn !== undefined) {
      ele.bbn.$emit('userresize', ev, detail);
      if (!ev.defaultPrevented && ele.bbn.parentResizer !== undefined && bbn.fn.isFunction(ele.bbn.parentResizer.onResize)) {
        ele.bbn.parentResizer.onResize();
      }
    }
  };
  const endDrag = (e, ele) => {
    if (isDragging && !!ele.bbnDirectives.resizable.active && !!ele.bbnDirectives.resizable.resizing) {
      ele.bbnDirectives.resizable.resizing = false;
      ele.classList.remove('bbn-resizable-resizing');
      document.body.style.cursor = ele.bbnDirectives.resizable.cursor;
      e.preventDefault();
      e.stopImmediatePropagation();
      let ev = new CustomEvent('userresizeend', {
        cancelable: true,
        bubbles: true,
        detail: ele.bbnDirectives.resizable
      });
      ele.dispatchEvent(ev);
      if (ele.bbn !== undefined) {
        ele.bbn.$emit('userresizestart', ev);
      }
      document.removeEventListener('mouseup', fnEnd, {
        once: true
      });
      document.removeEventListener('mousemove', fnDrag);
      delete ele.bbnDirectives.resizable.mouseX;
      delete ele.bbnDirectives.resizable.mouseY;
    }
  };
  const inserted = (el, binding) => {
    if (analyzeValue(el, binding)) {
      el.bbnDirectives.resizable.onmousemove = ev => {
        if (!!el.bbnDirectives.resizable.active && !el.bbnDirectives.resizable.resizing) {
          let rect = el.getBoundingClientRect(),
            modes = el.bbnDirectives.resizable.enabledModes,
            m = bbn.fn.createObject();
          if (modes.left && ev.x >= rect.left - 2 && ev.x <= rect.left + 2) {
            m.left = true;
            el.classList.add('bbn-resizable-over-left');
          } else {
            el.classList.remove('bbn-resizable-over-left');
          }
          if (modes.right && ev.x >= rect.left + rect.width - 2 && ev.x <= rect.left + rect.width + 2) {
            m.right = true;
            el.classList.add('bbn-resizable-over-right');
          } else {
            el.classList.remove('bbn-resizable-over-right');
          }
          if (modes.top && ev.y >= rect.top - 2 && ev.y <= rect.top + 2) {
            m.top = true;
            el.classList.add('bbn-resizable-over-top');
          } else {
            el.classList.remove('bbn-resizable-over-top');
          }
          if (modes.bottom && ev.y >= rect.top + rect.height - 2 && ev.y <= rect.top + rect.height + 2) {
            m.bottom = true;
            el.classList.add('bbn-resizable-over-bottom');
          } else {
            el.classList.remove('bbn-resizable-over-bottom');
          }
          if (!el.bbnDirectives.resizable.resizing) {
            el.bbnDirectives.resizable.modes = m;
          }
        }
      };
      el.addEventListener('mousemove', el.bbnDirectives.resizable.onmousemove);

      // Add the events listener to capture the long press click and start the drag
      let clickTimeout = 0,
        holdClick = false;
      el.bbnDirectives.resizable.onmousedown = ev => {
        if (clickTimeout) {
          clearTimeout(clickTimeout);
        }
        if (!!el.bbnDirectives.resizable.active && !el.bbnDirectives.resizable.resizing && !!el.bbnDirectives.resizable.modes && bbn.fn.numProperties(el.bbnDirectives.resizable.modes)) {
          if (ev.button === 0) {
            holdClick = true;
            clickTimeout = setTimeout(() => {
              if (holdClick) {
                startDrag(ev, el);
              }
            }, 150);
          }
        }
      };
      el.addEventListener('mousedown', el.bbnDirectives.resizable.onmousedown);
      el.bbnDirectives.resizable.onmouseup = ev => {
        if (!!el.bbnDirectives.resizable.active) {
          holdClick = false;
        }
      };
      el.addEventListener('mouseup', el.bbnDirectives.resizable.onmouseup);
    }
  };
  const analyzeValue = (el, binding) => {
    if (el.bbnDirectives.resizable === undefined) {
      el.bbnDirectives.resizable = bbn.fn.createObject();
    }
    if (binding.value !== false && !el.classList.contains('bbn-unresizable')) {
      let options = bbn.fn.createObject(),
        asMods = bbn.fn.isArray(binding.modifiers) && binding.modifiers.length,
        asContainerFromMods = asMods && binding.modifiers.includes('container'),
        asArg = !!binding.arg && binding.arg.length,
        modes = bbn.fn.createObject({
          top: !asMods || binding.modifiers.includes('top'),
          right: !asMods || binding.modifiers.includes('right'),
          bottom: !asMods || binding.modifiers.includes('bottom'),
          left: !asMods || binding.modifiers.includes('left')
        }),
        container = false;
      el.dataset.bbn_resizable = true;
      el.bbnDirectives.resizable = bbn.fn.createObject({
        active: true,
        resizing: false,
        enabledModes: modes
      });
      if (!el.classList.contains('bbn-resizable')) {
        el.classList.add('bbn-resizable');
      }
      if (asArg) {
        switch (binding.arg) {
          case 'container':
            container = binding.value;
            break;
        }
      } else {
        if (bbn.fn.isObject(binding.value)) {
          options = binding.value;
          if (asContainerFromMods) {
            if (options.container === undefined || !bbn.fn.isDom(options.container)) {
              bbn.fn.error(bbn._('No "container" property found or not a DOM element'));
              throw bbn._('No "container" property found or not a DOM element');
            }
            container = options.container;
          }
        }
      }
      el.bbnDirectives.resizable.container = container;
      el.bbnDirectives.resizable.options = options;
      return true;
    } else {
      el.dataset.resizable = false;
      el.bbnDirectives.resizable = bbn.fn.createObject({
        active: false
      });
      return false;
    }
  };
  const setOff = el => {
    el.dataset.bbn_resizable = false;
    if (el.bbnDirectives === undefined) {
      el.bbnDirectives = bbn.fn.createObject();
    }
    if (el.bbnDirectives.resizable === undefined) {
      el.bbnDirectives.resizable = bbn.fn.createObject();
    }
    if (!!el.bbnDirectives.resizable.active) {
      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmousedown)) {
        el.removeEventListener('mousedown', el.bbnDirectives.resizable.onmousedown);
      }
      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmouseup)) {
        el.removeEventListener('mouseup', el.bbnDirectives.resizable.onmouseup);
      }
      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmousemove)) {
        el.removeEventListener('mousemove', el.bbnDirectives.resizable.onmousemove);
      }
    }
    el.bbnDirectives.resizable = bbn.fn.createObject({
      active: false
    });
    if (el.classList.contains('bbn-resizable')) {
      el.classList.remove('bbn-resizable');
    }
  };
  bbn.cp.directives['bbn-resizable'] = bbn.fn.createObject({
    inserted: inserted,
    update: (el, binding) => {
      if (binding.value !== false && !el.classList.contains('bbn-unresizable')) {
        if (binding.oldValue === false) {
          inserted(el, binding);
        } else if (!isDragging) {
          analyzeValue(el, binding);
        }
      } else {
        setOff(el);
      }
    }
  });
}
export default function disconnectedCallback(cp) {
  if (cp.bbn) {
    cp.bbn.$disconnectedCallback();
  }
}
/**
 * @method executeQueueItem
 * @memberof bbn.cp
 * @param {Object} item
 */
export default function executeQueueItem(item) {
  if (item.url) {
    return axios.get(item.url, {
      responseType: 'json'
    }).then(r => {
      if (r.data) {
        r = r.data;
        const fnName = bbn.fn.camelize(item.name) + 'Cp';
        if (this.realDefineComponent(item.name, r, item.mixins) && window[fnName]) {
          item.resolve(true);
          return;
        }
      }
      item.reject();
    });
  }
  return false;
}
/**
 * @method executeQueueItems
 * @memberof bbn.cp
 * @param {Array} items
 */
export default function executeQueueItems(items) {
  if (items.length) {
    let url = 'components/';
    let i = 0;
    while (items[i] && url.length < maxUrlLength) {
      if (i) {
        url += '/';
      }
      url += items[i].name;
      i++;
    }
    url += '?v=' + bbn.version;
    let prom = axios.get(url, {
      responseType: 'json'
    }).then(d => {
      d = d.data;
      if (d && d.success && d.components) {
        bbn.fn.iterate(items, a => {
          let cp = bbn.fn.getRow(d.components, {
            name: a.name
          });
          const fnName = bbn.fn.camelize(a.name) + 'Cp';
          if (cp && this.realDefineComponent(a.name, cp, a.mixins) && window[fnName]) {
            a.resolve(true);
          } else {
            bbn.fn.log("PROMISE REJECT OF" + a.name, a);
            a.reject();
            throw new Error(bbn._("Impossible to load the component") + ' ' + a.name);
          }
        });
      }
    });
    if (i < items.length - 1) {
      items.splice(0, i);
      this.executeQueueItems(items);
    }
    return prom;
  }
  return false;
}
const forbidden = ['bbn-forget', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else'];
const treatCondition = (cp, node, arr, hashName) => {
  const c = x();
  let tmp = arr.filter(a => a.conditionId === node.conditionId);
  if (!tmp.length || !node.conditionId) {
    bbn.fn.log("FINISHING HERE ", node.conditionId, node.condition);
    return c.text;
  }
  x(c, sp, `_isCondTrue = false;`);
  x(c, sp, '// Checking the set of conditions (if any other) on the first condition');
  bbn.fn.each(tmp, (cond, j) => {
    x(c, sp, `$_go['${cond.id}'] = false;`);
    // No need to check thge first as _isCondTrue has just been defined
    if (j) {
      x(c, sp, `if (!_isCondTrue) {`);
      sp += 2;
    }
    x(c, sp, `_isCondTrue = _sIr("${cond.condition.hash}", ${cond.condition.type === 'else' ? 'true' : cond.condition.exp}, ${hashName});`);
    if (j) {
      sp -= 2;
      x(c, sp, `}`);
      x(c, sp, `else {`);
      x(c, sp, `  _sIr("${cond.condition.hash}", false, ${hashName});`);
      x(c, sp, `}`);
    }
    x(c, sp, `if (_gIs("${cond.condition.hash}", ${hashName}) !== "OK") {`);
    x(c, sp, `  $_go['${cond.id}'] = true;`);
    x(c, sp, `  let _tmp = _gIv("${cond.condition.hash}", ${hashName});`);
    x(c, sp, `  let _e;`);
    x(c, sp, `  if (!_tmp) {`);
    if (['template', 'transition', 'slot'].includes(cond.tag)) {
      if (cond.items) {
        bbn.fn.each(cond.items, it => {
          x(c, sp, `    _e = _t.$retrieveElement("${it.id}", ${hashName});`);
          x(c, sp, `    if (_e && !bbn.fn.isComment(_e)) {`);
          x(c, sp, `      _t.$removeDOM(_e);`);
          x(c, sp, `    }`);
        });
      }
    } else {
      x(c, sp, `    _e = _t.$retrieveElement("${cond.id}", ${hashName});`);
      x(c, sp, `    if (_e && !bbn.fn.isComment(_e)) {`);
      //x(c, sp, `      bbn.fn.log("REMOVING ${cond.id} from node2fn")`);
      x(c, sp, `      let _cp = bbn.cp.getComponent(_e.bbnComponentId)?.bbn || _t;`);
      //x(c, sp, `      bbn.fn.log("this is my moment", _e.tagName, _t.$options.name);`);
      x(c, sp, `      _t.$removeDOM(_e);`);
      x(c, sp, `      _e = false;`);
      x(c, sp, `    }`);
      x(c, sp, `    if (!_e) {`);
      x(c, sp, `      _eles['${cond.id}'] = await _t.$createElement({`);
      x(c, sp, `        id: "${cond.id}",`);
      x(c, sp, `        hash: "${cond.condition.hash}",`);
      x(c, sp, `        loopHash: ${hashName},`);
      x(c, sp, `        conditionId: "${cond.conditionId}",`);
      x(c, sp, `        comment: true`);
      x(c, sp, `      }, _parents.at(-1));`);
      x(c, sp, `    }`);
    }
    x(c, sp, `  }`);
    x(c, sp, `}`);
  });
  return c.text;
};
/**
 * Generates the code recursively for a loop
 * @param {Object} node 
 * @param {String} rv 
 * @param {String} hashName   
 * @param {Number} sp 
 * @param {Array} done 
 * @returns 
 */
const treatLoop = (cp, node, hashName) => {
  var _node$attr;
  const clone = bbn.fn.clone(node);
  delete clone.loop;
  const c = x();
  const md5 = bbn.fn.md5(node.id);
  const hash = 'bbnLoopHash_' + md5;
  const isNumber = 'bbnLoopIsNumber_' + md5;
  const isArray = 'bbnLoopIsArray_' + md5;
  const varName = 'bbnLoopName_' + md5;
  const listName = 'bbnLoopList_' + md5;
  const parentName = 'bbnLoopParent_' + md5;
  const indexName = node.loop.index || 'bbnLoopIndex_' + md5;
  // Starting the loop

  x(c, sp, `let ${varName} = _sIr('${node.loop.hash}', ${node.loop.exp}, ${hashName});`);
  x(c, sp, `let ${isNumber} = bbn.fn.isNumber(${varName});`);
  x(c, sp, `let ${parentName} = _parents.at(-1);`);
  x(c, sp, `let ${listName} = [];`);
  x(c, sp, `let ${isArray} = bbn.fn.isArray(${varName});`);
  x(c, sp, `if (${isNumber}) {`);
  x(c, sp, `  ${varName} = Object.keys((new Array(${varName})).fill(0)).map(a=>parseInt(a));`);
  x(c, sp, `  //bbn.fn.log("LOOP VALUE", ${varName});`);
  x(c, sp, `}`);
  x(c, sp, `for (let ${indexName} in ${varName}) {`);
  x(c, sp, `  if (${isArray}) {`);
  x(c, sp, `    ${indexName} = parseInt(${indexName});`);
  x(c, sp, `  }`);
  x(c, sp, `  let ${node.loop.item} = ${isNumber} ? ${indexName} : ${varName}[${indexName}];`);
  x(c, sp, `  const ${hash} = (${hashName} || '') + '${node.loop.hash}-${indexName}-' + (${(_node$attr = node.attr) !== null && _node$attr !== void 0 && (_node$attr = _node$attr.key) !== null && _node$attr !== void 0 && _node$attr.exp ? node.attr.key.exp : indexName});`);
  x(c, sp, `  ${listName}.push(${hash});`);
  x(c, sp, `  _sIr('${node.loop.item}', ${node.loop.item}, ${hash});`);
  x(c, sp, `  //bbn.fn.log(${node.loop.item});`);
  sp += 2;
  c.text += nodesToFunction(cp, [clone], hash);
  x(c, sp, `delete $_go['${node.id}'];`);
  sp -= 2;
  // Ending the loop
  x(c, sp, `}`);
  x(c, sp, `Array.from(${parentName}.childNodes).forEach(a => {`);
  x(c, sp, `  if ((!a.bbnHash || (a.bbnHash.indexOf(${hashName}) === 0)) && (a.bbnId === "${node.id}") && (${listName}.indexOf(a.bbnHash) === -1)) {`);
  x(c, sp, `    _t.$removeDOM(a);`);
  x(c, sp, `  }`);
  x(c, sp, `});`);
  return c.text;
};
const setProperties = function (node, hashName) {
  const c = x();
  x(c, sp, `_props = bbn.fn.createObject();`);
  // Will GO if the element is new or modified and not forgotten
  if (bbn.fn.numProperties(node.attr)) {
    if (node.attr['bbn-bind']) {
      x(c, sp, `_tmp = _sIr('${node.attr['bbn-bind'].hash}', ${node.attr['bbn-bind'].exp}, ${hashName}) || bbn.fn.createObject();`);
      x(c, sp, `if (!$_go['${node.id}'] && (_gIs('${node.attr['bbn-bind'].hash}', ${hashName}) !== "OK")) {`);
      x(c, sp, `  $_go['${node.id}'] = true;`);
      x(c, sp, `}`);
      x(c, sp, `_tmp2 = bbn.fn.createObject();`);
      for (let n in node.attr) {
        if (['bbn-bind', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget'].includes(n)) {
          continue;
        }
        if (node.attr[n].exp) {
          x(c, sp, `_tmp2['${n}'] = _sIr('${node.attr[n].hash}', ${node.attr[n].exp}, ${hashName});`);
        } else {
          x(c, sp, `_tmp2['${n}'] = '${bbn.fn.escapeSquotes(node.attr[n].value)}';`);
        }
      }
      x(c, sp, `bbn.fn.each(bbn.fn.unique(Object.keys(_tmp).concat(Object.keys(_tmp2))), n => {`);
      x(c, sp, `  let val = _tmp2[n] === undefined ? _tmp?.[n] : _tmp2[n];`);
      x(c, sp, `  if (val === undefined) {`);
      x(c, sp, `    return;`);
      x(c, sp, `  }`);
      x(c, sp, `  if (n === 'class') {`);
      x(c, sp, `    _props[n] = bbn.cp.convertClasses(val);`);
      x(c, sp, `  }`);
      x(c, sp, `  else if (n === 'style') {`);
      x(c, sp, `    _props[n] = bbn.cp.convertStyles(val);`);
      x(c, sp, `  }`);
      x(c, sp, `  else {`);
      x(c, sp, `    _props[n] = val;`);
      x(c, sp, `  }`);
      x(c, sp, `  if (!$_go['${node.id}'] && _node.attr[n] && !Object.hasOwn(_node.attr[n], 'value') && _node.attr[n].hash && (_gIs(_node.attr[n].hash, ${hashName}) !== "OK")) {`);
      x(c, sp, `    $_go['${node.id}'] = true;`);
      x(c, sp, `  }`);
      x(c, sp, `});`);
      //x(c, sp, `bbn.fn.log(["PROPS", _props, _tmp, _tmp2, bbn.fn.unique(Object.keys(_tmp).concat(Object.keys(_tmp2)))]);`);
    }
    // Simpler version
    else {
      for (let n in node.attr) {
        if (['bbn-bind', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget'].includes(n)) {
          continue;
        }
        if (node.attr[n].exp) {
          x(c, sp, `_tmp = _sIr('${node.attr[n].hash}', ${node.attr[n].exp}, ${hashName});`);
          x(c, sp, `if (_tmp !== undefined) {`);
          if (n === 'class') {
            x(c, sp, `  _props['${n}'] = bbn.cp.convertClasses(_tmp);`);
          } else if (n === 'style') {
            x(c, sp, `  _props['${n}'] = bbn.cp.convertStyles(_tmp);`);
          } else {
            x(c, sp, `  _props['${n}'] = _tmp;`);
          }
          x(c, sp, `}`);
          x(c, sp, `if (!$_go['${node.id}'] && _node.attr['${n}'] && !Object.hasOwn(_node.attr['${n}'], 'value') && _node.attr['${n}'].hash && (_gIs(_node.attr['${n}'].hash, ${hashName}) !== "OK")) {`);
          x(c, sp, `  $_go['${node.id}'] = true;`);
          x(c, sp, `}`);
        } else {
          x(c, sp, `_props['${n}'] = '${bbn.fn.escapeSquotes(node.attr[n].value)}';`);
        }
      }
    }
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};

/*
const setDirectives = function(node, hashName) {
  const c = x();
  if (bbn.fn.numProperties(node.directives)) {
    for (let n in node.directives) {
      if (node.directives[n].exp) {
        x(c, sp, `_node.directives['${n}'].value = _sIr('${node.directives[n].hash}', ${node.directives[n].exp}, ${hashName});`);

      }
    }
  }

  return c.text;
}
*/

const treatElement = function (cp, node, hashName) {
  const c = x();
  if (node.tag) {
    if (node.model) {
      bbn.fn.iterate(node.model, m => {
        x(c, sp, `_sIr('${m.hash}', ${m.exp}, ${hashName});`);
        x(c, sp, `if (!$_go['${node.id}'] && (_gIs('${m.hash}', ${hashName}) !== "OK")) {`);
        x(c, sp, `  $_go['${node.id}'] = true;`);
        x(c, sp, `}`);
      });
      x(c, sp, ``);
      x(c, sp, ``);
    }
    if (bbn.fn.numProperties(node.directives)) {
      for (let n in node.directives) {
        if (node.directives[n].exp) {
          x(c, sp, `_sIr('${node.directives[n].hash}', ${node.directives[n].exp}, ${hashName});`);
          x(c, sp, `if (!$_go['${node.id}'] && (_gIs('${node.directives[n].hash}', ${hashName}) !== "OK")) {`);
          x(c, sp, `  $_go['${node.id}'] = true;`);
          x(c, sp, `}`);
        }
      }
    }

    // Start if ($_go)
    x(c, sp, `if ($_go['${node.id}'] && !_forgotten['${node.id}']?.[${hashName} || '_root']) {`);
    sp += 2;
    x(c, sp, `//  bbn.fn.log("IN TODO " + _t.$options.name);`);
    x(c, sp, `//  bbn.fn.log("DOING ${node.id} ${node.tag}");`);
    x(c, sp, `_tmp = bbn.fn.clone(_node);`);
    x(c, sp, `if (${hashName}) {`);
    x(c, sp, `  _tmp.loopHash = ${hashName};`);
    x(c, sp, `}`);
    x(c, sp, `_tmp.props = _props;`);
    if (node.tag === 'component') {
      x(c, sp, `if (bbn.fn.isObject(_props.is)) {`);
      x(c, sp, `  _tmp.tag = _props.name ? bbn.fn.camelToCss(_props.name) : 'bbn-anon';`);
      x(c, sp, `  _tmp.cfg = bbn.cp.normalizeComponent(_props.is);`);
      x(c, sp, `}`);
      x(c, sp, `else {`);
      x(c, sp, `  _tmp.tag = bbn.fn.camelToCss(_props.is);`);
      x(c, sp, `}`);
    }
    x(c, sp, `isAnew = false;`);
    x(c, sp, `if ((_eles['${node.id}'] !== _t.$el) && !_forgotten['${node.id}']?.[${hashName} || '_root'] && (`);
    x(c, sp, `    !_eles['${node.id}']`);
    x(c, sp, `    || bbn.fn.isComment(_eles['${node.id}'])`);
    x(c, sp, `    || !bbn.cp.isTag(_tmp.tag, _eles['${node.id}'])`);
    x(c, sp, `  )`);
    x(c, sp, `) {`);
    x(c, sp, `  isAnew = true;`);
    x(c, sp, `}`);
    x(c, sp, `if (isAnew) {`);
    if (node.model) {
      for (let n in node.model) {
        x(c, sp, `  _tmp.model['${n}'].value = _tmp.props['${n}'] = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
      }
    }
    if (bbn.fn.numProperties(node.directives)) {
      for (let n in node.directives) {
        if (node.directives[n].exp) {
          x(c, sp, `_tmp.directives['${n}'].value = _gIv('${node.directives[n].hash}', ${hashName});`);
        }
      }
    }
    x(c, sp, `  _eles['${node.id}'] = await _t.$createElement(_tmp, _parents.at(-1));`);
    x(c, sp, `  if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `    $_final.push({ele: _eles['${node.id}'], position: $_num});`);
    x(c, sp, `  }`);
    x(c, sp, `}`);
    x(c, sp, `else {`);
    if (node.model) {
      x(c, sp, `  _tmp.model = _eles['${node.id}'].bbnSchema.model;`);
      for (let n in node.model) {
        if (n === '_default_') {
          x(c, sp, `  if (_t.$isComponent(_eles['${node.id}'])) {`);
          x(c, sp, `    let modelProp = _eles['${node.id}'].bbnCfg?.model?.prop || _eles['${node.id}'].constructor?.bbnCfg?.model?.prop || 'value';`);
          x(c, sp, `    _tmp.model[modelProp].value = _tmp.props[modelProp] = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
          x(c, sp, `  }`);
          x(c, sp, `  else {`);
          x(c, sp, `    _tmp.model.value.value = _tmp.props.value = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
          x(c, sp, `  }`);
        } else {
          x(c, sp, `  _tmp.model['${n}'].value = _tmp.props['${n}'] = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
        }
      }
    }
    if (bbn.fn.numProperties(node.directives)) {
      for (let n in node.directives) {
        if (node.directives[n].exp) {
          x(c, sp, `if (_gIs('${node.directives[n].hash}', ${hashName}) !== "OK") {`);
          x(c, sp, `  _node.directives['${n}'].value = _gIv('${node.directives[n].hash}', ${hashName});`);
          x(c, sp, `  _eles['${node.id}'].bbnSchema.directives['${n}'].value = _gIv('${node.directives[n].hash}', ${hashName});`);
          x(c, sp, `  bbn.cp.updateDirectives({"${n}": _node.directives['${n}']}, _eles['${node.id}']);`);
          x(c, sp, `}`);
        }
      }
    }
    x(c, sp, `  _t.$updateElementFromProps(_tmp, _eles['${node.id}']);`);
    x(c, sp, `}`);
    x(c, sp, `if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `  $_num++;`);
    x(c, sp, `}`);
    let hasEvents = Object.keys(node.events || {}).length > 0;
    if (node.model || hasEvents) {
      x(c, sp, `if (isAnew) {`);
      sp += 2;
      x(c, sp, `let _bbnCurrentElement = _eles['${node.id}'];`);
      if (node.model) {
        for (let name in node.model) {
          let m = node.model[name];
          const modelVarName = m.exp;
          const modelVarBits = bbn.fn.removeEmpty(modelVarName.replace(/\[([^\[\]]*)\]/g, '.$1.').split('.').filter(t => t !== ''));
          const modelVarRoot = modelVarBits[0];
          const eventName = m.modifiers.includes('lazy') ? 'change' : 'input';
          x(c, sp, `let _bbnEventName = '${eventName}';`);
          x(c, sp, `let _bbnRealName = '${name}';`);
          if (name === '_default_') {
            x(c, sp, `let _bbnModelCfg = _t.$isComponent(_eles['${node.id}']) ? _eles['${node.id}'].bbnCfg?.model || _eles['${node.id}'].constructor?.bbnCfg?.model : {prop: 'value', event: _bbnEventName};`);
            x(c, sp, `_bbnRealName = _bbnModelCfg.prop;`);
            x(c, sp, `_bbnEventName = _bbnModelCfg.event;`);
            x(c, sp, `_bbnCurrentElement.bbnSchema.model[_bbnRealName] = _bbnCurrentElement.bbnSchema.model._default_;`);
            x(c, sp, `delete _bbnCurrentElement.bbnSchema.model._default_;`);
            if (node.tag === 'bbn-checkbox') {
              x(c, sp, `bbn.fn.warning(_bbnRealName)`);
            }
          }
          x(c, sp, `_bbnCurrentElement.addEventListener(_bbnEventName, _bbnEventObject => {`);
          x(c, sp, `  let $event = _bbnEventObject;`);
          x(c, sp, `  let _bbnEventValue = $event.detail?.args ? $event.detail.args[0] : $event.target?.value;`);
          x(c, sp, `  let oldValue = bbn.fn.isPrimitive(${modelVarName}) ? _sIr("${m.hash}", ${modelVarName}, ${hashName}) : ${modelVarName};`);
          //x(c, sp, `  bbn.fn.log(["ON MODEL CHANGE", _bbnEventName, oldValue, "${modelVarRoot}", _bbnEventValue, _t.$options.name]);`);
          x(c, sp, `  if (oldValue !== _bbnEventValue) {`);
          if (modelVarRoot === modelVarName) {
            x(c, sp, `    if (Object.hasOwn(_t.$props, "${modelVarRoot}")) {`);
            x(c, sp, `      bbn.fn.log("IS A PROP " + _bbnRealName, _t.$options.name, "${modelVarRoot}", _bbnEventValue);`);
            x(c, sp, `      _t.$setProp("${modelVarRoot}", _bbnEventValue);`);
            x(c, sp, `    }`);
            x(c, sp, `    else {`);
            x(c, sp, `      _t["${modelVarRoot}"] = _bbnEventValue;`);
            x(c, sp, `    }`);
            x(c, sp, `    ${modelVarRoot} = _bbnEventValue;`);
            x(c, sp, `    bbn.fn.log("FROM MODEL " + _bbnRealName, _t.$options.name, _t.$cfg.props, _bbnEventValue, ${modelVarRoot}, "${modelVarRoot}", Object.hasOwn(_t.$cfg.props, "${modelVarRoot}"));`);
          } else {
            x(c, sp, `    ${modelVarName} = _bbnEventValue;`);
          }
          x(c, sp, `    if (_bbnCurrentElement?.bbn) {`);
          x(c, sp, `      _bbnCurrentElement?.bbn.$forceUpdate();`);
          x(c, sp, `    }`);
          x(c, sp, `    _t.$forceUpdate();`);
          x(c, sp, `  }`);
          x(c, sp, `});`);
        }
      }
      if (hasEvents) {
        for (let n in node.events) {
          let ev = node.events[n];
          //x(c, sp, `bbn.fn.log("SETTING EVENT ${n} ON " + _t.$options.name, _ele, ${isAnew});`);
          x(c, sp, `_eles['${node.id}'].addEventListener("${n}", _bbnEventObject => {`);
          //x(c, sp, `  bbn.fn.log("EXECUTING EVENT ${n} ${ev.action} ON ${node.tag}", _bbnEventObject.detail);`);
          x(c, sp, `  let $event = _bbnEventObject;`);
          if (ev.modifiers.length) {
            x(c, sp, `bbn.fn.log($event, "${n}");`);
            if (n.indexOf('key') === 0) {
              x(c, sp, `  if (!_bbnEventObject.key || !${JSON.stringify(ev.modifiers)}.includes(_bbnEventObject.key.toLowerCase())) {`);
              x(c, sp, `    return;`);
              x(c, sp, `  }`);
            } else if (n.indexOf('mouse') === 0) {
              if (ev.modifiers.includes('right')) {
                x(c, sp, `  if (_bbnEventObject.button !== 2) {`);
                x(c, sp, `    return;`);
                x(c, sp, `  }`);
              } else if (ev.modifiers.includes('left')) {
                x(c, sp, `  if (_bbnEventObject.button !== 0) {`);
                x(c, sp, `    return;`);
                x(c, sp, `  }`);
              }
            }
          }
          if (ev.prevent) {
            x(c, sp, `  $event.preventDefault();`);
          }
          if (ev.stop) {
            x(c, sp, `  $event.stopImmediatePropagation();`);
          }
          if (ev.action) {
            if (ev.action.indexOf(';') > -1 || ev.action.indexOf('if') === 0) {
              x(c, sp, `  ${ev.action};`);
            } else {
              x(c, sp, `  let $_action = (${ev.action});`);
              x(c, sp, `  if (bbn.fn.isFunction($_action)) {`);
              x(c, sp, `    const args = _bbnEventObject.detail?.args || [$event];`);
              x(c, sp, `    args.push(_bbnEventObject);`);
              x(c, sp, `    $_action.bind(_t.$origin)(...args);`);
              x(c, sp, `  }`);
            }
            x(c, sp, `  bbn.fn.iterate(_bbnCurrentData, (_bbnCurrentDataValue, _bbnCurrentDataIndex) => {`);
            x(c, sp, `    //bbn.fn.log('_bbnCurrentDataValue, _bbnCurrentDataIndex', _bbnCurrentDataValue, _bbnCurrentDataIndex, eval(_bbnCurrentDataIndex), _t[_bbnCurrentDataIndex], '++++');`);
            x(c, sp, `    if (_bbnCurrentDataValue !== eval(_bbnCurrentDataIndex)) {`);
            x(c, sp, `      if (_t[_bbnCurrentDataIndex] !== undefined) {`);
            x(c, sp, `        _t[_bbnCurrentDataIndex] = eval(_bbnCurrentDataIndex);`);
            x(c, sp, `      }`);
            x(c, sp, `      _bbnCurrentData[_bbnCurrentDataIndex] = _t[_bbnCurrentDataIndex];`);
            x(c, sp, `    }`);
            x(c, sp, `  });`);
          }
          x(c, sp, `  _t.$tick();`);
          let eventEnd = '}';
          if (ev.once || ev.passive || ev.capture) {
            eventEnd += ', {';
            if (ev.once) {
              eventEnd += `once: true,`;
            }
            if (ev.passive) {
              eventEnd += `passive: true,`;
            }
            if (ev.capture) {
              eventEnd += `capture: true,`;
            }
            eventEnd += '}';
          }
          eventEnd += ');';
          x(c, sp, eventEnd);
        }
      }
      sp -= 2;
      x(c, sp, `}`);
      x(c, sp, ``);
      x(c, sp, ``);
    }
    sp -= 2;
    // End if ($_go)
    x(c, sp, `}`);
  }
  return c.text;
};
const treatSlot = function (cp, node, hashName) {
  const c = x();
  if (node.tag === 'slot') {
    var _node$attr2;
    let slot = "'default'";
    if ((_node$attr2 = node.attr) !== null && _node$attr2 !== void 0 && _node$attr2.name) {
      slot = node.attr.name.exp ? `${node.attr.name.exp}` : `'${node.attr.name.value}'`;
    }
    x(c, sp, `_eles['${node.id}'] = _parents.at(-1);`);
    x(c, sp, `if (_t.$el.bbnSlots?.[${slot}]?.length) {`);
    // Iterating the elements going in the slot
    x(c, sp, `  bbn.fn.each(_t.$el.bbnSlots[${slot}], a => {`);
    //x(c, sp, `    bbn.fn.log("This is a slot element", a)`);
    x(c, sp, `    let search = {bbnId: a.bbnId};`);
    x(c, sp, `    if (a.bbnHash) {`);
    x(c, sp, `      search.bbnHash = a.bbnHash;`);
    x(c, sp, `    }`);
    // Case where the slot is inside another component
    x(c, sp, `    if ((_parents.at(-1) !== _t.$el) && bbn.cp.isComponent(_parents.at(-1))) {`);
    x(c, sp, `      let idx = bbn.fn.search(_parents.at(-1).bbnSlots[${slot}], search);`);
    x(c, sp, `      _parents.at(-1).bbnSlots.default.splice(idx > -1 ? idx : _parents.at(-1).bbnSlots.default.length, idx > -1 ? 1 : 0, a);`);
    x(c, sp, `      if (_parents.at(-1).bbn) {`);
    x(c, sp, `        _parents.at(-1).bbn.$tick();`);
    x(c, sp, `      }`);
    x(c, sp, `    }`);
    // Else if only the element is not mounted (otherwise it's already there)
    x(c, sp, `    else if (!a.parentNode) {`);
    x(c, sp, `      if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `        $_final.push({ele: a, position: $_num});`);
    x(c, sp, `      }`);
    x(c, sp, `      else {`);
    x(c, sp, `        let idx = bbn.fn.search(_parents.at(-1).childNodes, search);`);
    x(c, sp, `        if (idx > -1) {`);
    x(c, sp, `          _parents.at(-1).replaceChild(a, _parents.at(-1).childNodes[idx]);`);
    x(c, sp, `        }`);
    x(c, sp, `        else {`);
    x(c, sp, `          _parents.at(-1).appendChild(a);`);
    x(c, sp, `        }`);
    x(c, sp, `      }`);
    x(c, sp, `    }`);
    x(c, sp, `    if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `      $_num++;`);
    x(c, sp, `    }`);
    x(c, sp, `  });`);
    x(c, sp, `}`);
    c.text += treatItems(cp, node, hashName);
  }
  return c.text;
};
const treatText = function (node, hashName) {
  const c = x();
  if (node.text) {
    x(c, sp, `_sIr('${node.hash}', \`${bbn.fn.escapeTicks(node.text)}\`, ${hashName});`);
    x(c, sp, `if ($_go['${node.id}'] || (_gIs('${node.hash}', ${hashName}) !== "OK")) {`);
    x(c, sp, `  if (_eles['${node.id}'] && (_eles['${node.id}'].textContent !== _gIv('${node.hash}', ${hashName}))) {`);
    x(c, sp, `    _eles['${node.id}'].textContent = _gIv('${node.hash}', ${hashName});`);
    x(c, sp, `  }`);
    x(c, sp, `  else {`);
    x(c, sp, `    _eles['${node.id}'] = _t.$createText({`);
    x(c, sp, `      id: '${node.id}',`);
    x(c, sp, `      hash: '${node.hash}',`);
    x(c, sp, `      text: _gIv('${node.hash}', ${hashName}),`);
    x(c, sp, `      loopHash: ${hashName},`);
    x(c, sp, `    }, _parents.at(-1));`);
    x(c, sp, `    if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `      $_final.push({ele: _eles['${node.id}'], position: $_num});`);
    x(c, sp, `    }`);
    x(c, sp, `  }`);
    x(c, sp, `}`);
    x(c, sp, `if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `  $_num++;`);
    x(c, sp, `}`);
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};
const treatItems = function (cp, node, hashName) {
  var _node$items;
  const c = x();
  if ((_node$items = node.items) !== null && _node$items !== void 0 && _node$items.length) {
    x(c, sp, `if (_eles['${node.id}']) {`);
    sp += 2;
    x(c, sp, `_parents.push(_eles['${node.id}']);`);
    c.text += nodesToFunction(cp, node.items, hashName);
    x(c, sp, `_parents.pop();`);
    sp -= 2;
    x(c, sp, `}`);
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};
const endCondition = function (node) {
  const c = x();
  if (node.condition) {
    sp -= 2;
    x(c, sp, `//Ending condition`);
    x(c, sp, `}`);
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};

/**
 * Recursive function that takes an array of objects representing nodes in an 
 * HTML-like structure and generates JavaScript code based on those nodes. 
 * 
 * @param {Array} arr the nodes array
 * @param {String} varName variable name that is used to reference the data object that corresponds to the current node
 * @param {Number} sp number of spaces to use for indentation in the generated code
 * @param {Array} done array that keeps track of variables that have already been defined to avoid re-definition
 * @returns {String}
 */
const nodesToFunction = function (cp, arr, hashName) {
  const c = x();
  let conditions = [];
  let conditionId = null;
  bbn.fn.each(arr, (node, i) => {
    var _node$loop, _node$forget;
    x(c, sp, '');
    x(c, sp, `// Taking care of the node ${node.tag || 'with no tag'} ${node.id}`);
    if ((_node$loop = node.loop) !== null && _node$loop !== void 0 && _node$loop.exp) {
      c.text += treatLoop(cp, node, hashName);
      return;
    }

    // Launching condition (MUST be before the rest)
    if (node.condition) {
      if (node.conditionId !== conditionId && !conditions.includes(node.conditionId)) {
        conditions.push(node.conditionId);
        conditionId = node.conditionId;
        c.text += treatCondition(cp, node, arr, hashName);
      }
      let condText = node.condition.type === 'elseif' ? 'else if' : node.condition.type;
      if (node.condition.type !== 'else') {
        condText += ' (_gIv("' + node.condition.hash + '", ' + hashName + '))';
      }
      // New level
      condText += ' {';
      x(c, sp, condText);
      sp += 2;
    }
    x(c, sp, `oldEle = _t.$retrieveElement("${node.id}", ${hashName});`);
    x(c, sp, `_node = _t.$currentMap['${node.id}'];`);
    x(c, sp, `_eles['${node.id}'] = oldEle;`);
    x(c, sp, `if (!Object.hasOwn($_go, '${node.id}')) {`);
    x(c, sp, `  $_go['${node.id}'] = !oldEle;`);
    x(c, sp, `}`);

    // Setting _forgotten variable
    if ((_node$forget = node.forget) !== null && _node$forget !== void 0 && _node$forget.exp) {
      x(c, sp, `_sIr('${node.forget.hash}', ${node.forget.exp}, ${hashName});`);
      x(c, sp, `if (!_forgotten['${node.id}']) {`);
      x(c, sp, `  _forgotten['${node.id}'] = bbn.fn.createObject();`);
      x(c, sp, `}`);
      x(c, sp, `_forgotten['${node.id}'][${hashName} || '_root'] = _gIv('${node.forget.hash}', ${hashName});`);
      x(c, sp, `if (_forgotten['${node.id}'][${hashName} || '_root']) {`);
      x(c, sp, `  _eles['${node.id}'] = _parents.at(-1);`);
      x(c, sp, `  $_go['${node.id}'] = false;`);
      x(c, sp, `}`);
      x(c, sp, `else if (['NEW', 'MOD'].includes(_gIs('${node.forget.hash}', ${hashName}))) {`);
      x(c, sp, `  $_go['${node.id}'] = true;`);
      x(c, sp, `}`);
      x(c, sp, ``);
      x(c, sp, ``);
    }
    let treatEle = true;
    if (!node.pre && node.tag === 'template' || 'transition' === node.tag) {
      x(c, sp, `_eles['${node.id}'] = _parents.at(-1);`);
      x(c, sp, `$_go['${node.id}'] = false;`);
      treatEle = false;
    } else {
      x(c, sp, `if (!$_go['${node.id}'] && !_eles['${node.id}']) {`);
      x(c, sp, `  $_go['${node.id}'] = true;`);
      x(c, sp, `}`);
    }
    //x(c, sp, `bbn.fn.log(["nodesToFunction", "${node.tag || 'no'}", $_go['${node.id}']]);`);

    if (node.text) {
      c.text += treatText(node, hashName);
    } else if (node.tag === 'slot') {
      c.text += treatSlot(cp, node, hashName);
    } else if (node.tag) {
      var _node$forget2;
      c.text += setProperties(node, hashName);
      //c.text += setDirectives(node, hashName);
      if (treatEle) {
        c.text += treatElement(cp, node, hashName);
      }
      if ((_node$forget2 = node.forget) !== null && _node$forget2 !== void 0 && _node$forget2.exp) {
        x(c, sp, `if (_gIs('${node.forget.hash}', ${hashName}) === 'MOD') {`);
        x(c, sp, `  if (_forgotten['${node.id}']?.[${hashName} || '_root']) {`);
        x(c, sp, `    if (oldEle) {`);
        x(c, sp, `      oldEle.childNodes.forEach(o => {`);
        x(c, sp, `        _parents.at(-1).appendChild(o);`);
        x(c, sp, `      });`);
        x(c, sp, `      bbn.fn.log("From here");`);
        x(c, sp, `      _t.$removeDOM(oldEle);`);
        x(c, sp, `    }`);
        x(c, sp, `    // Ele is the current parent`);
        x(c, sp, `    _eles['${node.id}'] = _parents.at(-1);`);
        x(c, sp, `  }`);
        x(c, sp, `  else {`);
        x(c, sp, `    _parents.at(-1).childNodes.forEach(o => {`);
        x(c, sp, `      if (o.bbnId.indexOf('${node.id}' + "-") === 0) {`);
        x(c, sp, `        _eles['${node.id}'].appendChild(o);`);
        x(c, sp, `      }`);
        x(c, sp, `    });`);
        x(c, sp, `  }`);
        x(c, sp, `}`);
        x(c, sp, `else if (_forgotten['${node.id}']?.[${hashName} || '_root']) {`);
        x(c, sp, `  _eles['${node.id}'] = _parents.at(-1);`);
        x(c, sp, `}`);
        x(c, sp, ``);
        x(c, sp, ``);
      }
      if (node.pre) {
        x(c, sp, `if (_eles['${node.id}']) {`);
        x(c, sp, `  _eles['${node.id}'].innerHTML = \`${bbn.fn.escapeTicks(node.pre)}\`;`);
        x(c, sp, `}`);
        x(c, sp, ``);
        x(c, sp, ``);
      } else {
        c.text += treatItems(cp, node, hashName);
      }
      x(c, sp, `if ((_t.$el === _parents.at(-1)) && _eles['${node.id}'] && (_eles['${node.id}'] !== _t.$el)) {`);
      x(c, sp, `  $_num++;`);
      x(c, sp, `}`);
    }
    c.text += endCondition(node);
  });
  return c.text;
};

/**
 * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not
 * - Updates the component element based on its own schema ($el.bbnSchema)
 * - Updates the schema
 * - Generates/update the DOM when needed
 * 
 * @param {Boolean} shadow The content will go to the shadow DOM if true
 * @returns {Promise}
 */
export default function templateToFunction(cp, tpl) {
  var _tpl$0$attr, _tpl$0$attr2, _tpl$0$attr3, _tpl$0$attr4;
  let sp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let hashName = '_bbnHash';
  let c = x();
  x(c, sp, `async (_t, _d) => {`);
  sp += 2;
  let code2 = '';
  x(c, sp, `const _r = _t.$currentResult;`);
  x(c, sp, `let ${hashName} = '';`);
  x(c, sp, `bbn.fn.iterate(_r, a => {`);
  x(c, sp, `  bbn.fn.iterate(a, b => {`);
  x(c, sp, `    if (b.state !== 'DEL') {`);
  x(c, sp, `      b.state = 'TMP';`);
  x(c, sp, `    }`);
  x(c, sp, `  });`);
  x(c, sp, `});`);
  x(c, sp, `const _bbnCurrentData = bbn.fn.createObject();`);
  for (let n in cp.$namespaces) {
    if (cp.$namespaces[n] === 'props') {
      continue;
    }
    if (cp.$namespaces[n] === 'method') {
      x(c, sp, `const ${n} = _t.${n}.bind(_t);`);
    } else if (n.indexOf('$') === 0) {
      x(c, sp, `const ${n} = _t.${n};`);
    } else {
      x(c, sp, `let ${n} = _t["${n}"];`);
      if (n !== 'internal') {
        x(c, sp, `_bbnCurrentData["${n}"] = ${n};`);
      }
    }
  }
  for (let n in cp.$cfg.props) {
    x(c, sp, `let ${n} = _t["${n}"];`);
    x(c, sp, `_bbnCurrentData["${n}"] = ${n};`);
  }
  x(c, sp, `let ownProps = Object.getOwnPropertyNames(_t);`);
  x(c, sp, `let n;`);
  x(c, sp, `for (let i = 0; n = ownProps[i]; i++) {`);
  x(c, sp, `  if ((n.indexOf('$') !== 0) && !_t.$namespaces[n]) {`);
  //x(c, sp, `    bbn.fn.warning('var ' + n + ' = _t["' + n + '"];');`);
  x(c, sp, `    eval('var ' + n + ' = _t["' + n + '"];');`);
  x(c, sp, `  }`);
  x(c, sp, `}`);
  x(c, sp, `// _setInternalResult`);
  x(c, sp, `const _sIr = (_name, _exp, _hash) => {`);
  x(c, sp, `  return _t.$_setInternalResult(_r, _name, _exp, _hash);`);
  x(c, sp, `};`);
  x(c, sp, `// _getInternalState`);
  x(c, sp, `const _gIs = (_name, _hash) => {`);
  x(c, sp, `  return _t.$_getInternalState(_r, _name, _hash);`);
  x(c, sp, `};`);
  x(c, sp, `// _getInternalValue`);
  x(c, sp, `const _gIv = (_name, _hash) => {`);
  x(c, sp, `  let val = undefined;`);
  x(c, sp, `  try {`);
  x(c, sp, `    val = _t.$_getInternalValue(_r, _name, _hash);`);
  x(c, sp, `  } catch (e) {`);
  x(c, sp, `    bbn.fn.log("THERE SHOULD BE AN ERROR", _name, _t);`);
  x(c, sp, `  }`);
  x(c, sp, `  return val;`);
  x(c, sp, `};`);
  x(c, sp, `const _eles = bbn.fn.createObject({"-": _t.$el});`);
  x(c, sp, `let _isCondTrue = false;`);
  x(c, sp, `let _props = bbn.fn.createObject();`);
  x(c, sp, `let _lastId = '';`);
  x(c, sp, `let _tmp;`);
  x(c, sp, `let _tmp2;`);
  x(c, sp, `let _node;`);
  x(c, sp, `let isAnew;`);
  x(c, sp, `let oldEle;`);
  x(c, sp, `const _cps = [];`);
  x(c, sp, `const _parents = [_t.$el];`);
  x(c, sp, `let $_ct = _t.$el;`);
  x(c, sp, `const _forgotten = bbn.fn.createObject();`);
  x(c, sp, `const $_go = bbn.fn.createObject();`);
  x(c, sp, `let $_num = 0;`);
  x(c, sp, `const $_final = [];`);
  x(c, sp, `_r._num++;`);
  if (tpl.length === 1 && tpl[0].items && !((_tpl$0$attr = tpl[0].attr) !== null && _tpl$0$attr !== void 0 && _tpl$0$attr['bbn-if']) && !((_tpl$0$attr2 = tpl[0].attr) !== null && _tpl$0$attr2 !== void 0 && _tpl$0$attr2['bbn-for']) && !((_tpl$0$attr3 = tpl[0].attr) !== null && _tpl$0$attr3 !== void 0 && _tpl$0$attr3['bbn-model']) && !((_tpl$0$attr4 = tpl[0].attr) !== null && _tpl$0$attr4 !== void 0 && _tpl$0$attr4['bbn-forget']) && !bbn.cp.isComponent(tpl[0]) && (['div', 'span'].includes(tpl[0].tag) || tpl[0].tag === cp.$cfg.tag)) {
    //x(c, sp, `_eles['0-0'] = _t.$el;`);
    if (tpl[0].attr) {
      for (let n in tpl[0].attr) {
        x(c, sp, `_props["${n}"] = `);
        if (tpl[0].attr[n].exp) {
          x(c, sp, `_sIr("${tpl[0].attr[n].hash}", ${tpl[0].attr[n].exp}, ${hashName});`);
        } else {
          x(c, sp, `"${bbn.fn.escapeDquotes(tpl[0].attr[n].value)}";`);
        }
      }
      if (bbn.fn.numProperties(tpl[0].directives)) {
        for (let n in tpl[0].directives) {
          x(c, sp, `if (!_t.$el.bbnSchema.directives) {_t.$el.bbnSchema.directives = bbn.fn.createObject();}`);
          x(c, sp, `if (!_t.$el.bbnSchema.directives['${n}']) {_t.$el.bbnSchema.directives['${n}'] = bbn.fn.clone(_t.$tpl[0].directives['${n}']);}`);
          if (tpl[0].directives[n].exp) {
            x(c, sp, `  _t.$el.bbnSchema.directives['${n}'].value = _sIr('${tpl[0].directives[n].hash}', ${tpl[0].directives[n].exp}, ${hashName});`);
          }
          x(c, sp, `if (!_t.$el.bbnDirectives) {Object.defineProperty(_t.$el, 'bbnDirectives', {value: bbn.fn.createObject(), writable: false, configurable: false});}`);
          x(c, sp, `if (!_t.$el.bbnDirectives['{$n}']) {_t.$el.bbnDirectives['${n}'] = bbn.fn.createObject();}`);
        }
        x(c, sp, `if (!_t.$numBuild) {`);
        x(c, sp, `  bbn.cp.insertDirectives(_t.$el.bbnSchema.directives, _t.$el);`);
        x(c, sp, `}`);
        for (let n in tpl[0].directives) {
          x(c, sp, `if (_t.$numBuild) {`);
          x(c, sp, `  bbn.cp.updateDirectives({"${n}": _t.$el.bbnSchema.directives['${n}']}, _t.$el);`);
          x(c, sp, `}`);
        }
      }
      x(c, sp, `_t.$updateFromSchema(_props);`);
      if (tpl[0].events) {
        x(c, sp, `if (_r._num === 1) {`);
        sp += 2;
        for (let n in tpl[0].events) {
          let ev = tpl[0].events[n];
          x(c, sp, `if (!_eles['-'].bbnSchema?.events?.["${n}"]) {`);
          sp += 2;
          //x(c, sp, `bbn.fn.log("SETTING EVENT ${n} ON " + _t.$options.name, _ele, ${isAnew});`);
          x(c, sp, `_eles['-'].addEventListener("${n}", _bbnEventObject => {`);
          //x(c, sp, `  bbn.fn.log("EXECUTING EVENT ${n} ${ev.action} ON ${node.tag}", _bbnEventObject.detail);`);
          if (ev.modifiers.length) {
            x(c, sp, `  if (!_bbnEventObject.key || !${JSON.stringify(ev.modifiers)}.includes(_bbnEventObject.key.toLowerCase())) {`);
            x(c, sp, `    return;`);
            x(c, sp, `  }`);
          }
          x(c, sp, `  let $event = _bbnEventObject;`);
          if (ev.prevent) {
            x(c, sp, `  $event.preventDefault();`);
          }
          if (ev.stop) {
            x(c, sp, `  $event.stopImmediatePropagation();`);
          }
          if (ev.action) {
            if (ev.action.indexOf(';') > -1 || ev.action.indexOf('if') === 0) {
              x(c, sp, `  ${ev.action};`);
            } else {
              x(c, sp, `  let $_action = (${ev.action});`);
              x(c, sp, `  if (bbn.fn.isFunction($_action)) {`);
              x(c, sp, `    const args = _bbnEventObject.detail?.args || [$event];`);
              x(c, sp, `    args.push(_bbnEventObject);`);
              x(c, sp, `    $_action.bind(_t.$origin)(...args);`);
              x(c, sp, `  }`);
            }
            x(c, sp, `  bbn.fn.iterate(_bbnCurrentData, (_bbnCurrentDataValue, _bbnCurrentDataIndex) => {`);
            x(c, sp, `    //bbn.fn.log('_bbnCurrentDataValue, _bbnCurrentDataIndex', _bbnCurrentDataValue, _bbnCurrentDataIndex, eval(_bbnCurrentDataIndex), _t[_bbnCurrentDataIndex], '++++');`);
            x(c, sp, `    if (_bbnCurrentDataValue !== eval(_bbnCurrentDataIndex)) {`);
            x(c, sp, `      if (_t[_bbnCurrentDataIndex] !== undefined) {`);
            x(c, sp, `        _t[_bbnCurrentDataIndex] = eval(_bbnCurrentDataIndex);`);
            x(c, sp, `      }`);
            x(c, sp, `      _bbnCurrentData[_bbnCurrentDataIndex] = _t[_bbnCurrentDataIndex];`);
            x(c, sp, `    }`);
            x(c, sp, `  });`);
          }
          x(c, sp, `  _t.$forceUpdate();`);
          let eventEnd = '}';
          if (ev.once || ev.passive || ev.capture) {
            eventEnd += ', {';
            if (ev.once) {
              eventEnd += `once: true,`;
            }
            if (ev.passive) {
              eventEnd += `passive: true,`;
            }
            if (ev.capture) {
              eventEnd += `capture: true,`;
            }
            eventEnd += '}';
          }
          eventEnd += ');';
          x(c, sp, eventEnd);
          sp -= 2;
          x(c, sp, '}');
        }
        sp -= 2;
        x(c, sp, `}`);
      }
    } else {
      x(c, sp, `_t.$updateFromSchema();`);
    }
    c.text += nodesToFunction(cp, tpl[0].items, hashName);
  } else {
    x(c, sp, `_t.$updateFromSchema();`);
    c.text += nodesToFunction(cp, tpl, hashName);
  }
  //x(c, sp, `bbn.fn.warning("KKKKK"); bbn.fn.log($_final);`);
  x(c, sp, `bbn.fn.each($_final, a => {`);
  x(c, sp, `  if (_t.$el.childNodes[a.position]) {`);
  x(c, sp, `    _t.$insertElement(a.ele, _t.$el, _t.$el.childNodes[a.position]);`);
  x(c, sp, `  }`);
  x(c, sp, `  else {`);
  x(c, sp, `    _t.$insertElement(a.ele, _t.$el);`);
  x(c, sp, `  }`);
  x(c, sp, `})`);
  c.text += code2;
  x(c, sp, `bbn.fn.iterate(_r, a => {`);
  x(c, sp, `  bbn.fn.iterate(a, b => {`);
  x(c, sp, `    if (b.state === 'TMP') {`);
  x(c, sp, `      b.state = 'DEL';`);
  x(c, sp, `    }`);
  x(c, sp, `  });`);
  x(c, sp, `});`);
  x(c, sp, `return _r;`);
  sp -= 2;
  x(c, sp, `}`);
  return eval(c.text);
}
import { bbn } from "@bbn/bbn/dist/index.js";
export default async function fetchComponents(toDefine) {
  bbn.fn.checkType(toDefine, Array, bbn._("fetchComponents must be called with an array of component names to fetch"));
  // Returning a promise allows the loading for new components definition
  // No component definitions needed no wait
  if (!toDefine.length) {
    return;
  }
  const groups = bbn.fn.createObject();
  bbn.fn.each(toDefine, tag => {
    bbn.fn.checkType(tag, String);
    let idx = -1;
    let handlerIdx = -1;
    let mixins = [];
    bbn.fn.each(bbn.cp.knownPrefixes, (a, i) => {
      if (a.prefix && tag.indexOf(a.prefix) === 0) {
        // Taking the longest (most precise) prefix's rule
        if (a.mixins) {
          bbn.fn.each(a.mixins, m => {
            if (mixins.indexOf(m) === -1) {
              mixins.push(m);
            }
          });
        }
        if (idx > -1) {
          if (a.prefix.length > bbn.cp.knownPrefixes[idx].prefix.length) {
            if (bbn.fn.isFunction(a.handler)) {
              handlerIdx = i;
            }
            idx = i;
          } else if (handlerIdx === -1 && bbn.fn.isFunction(a.handler)) {
            handlerIdx = i;
          }
        } else {
          if (bbn.fn.isFunction(a.handler)) {
            handlerIdx = i;
          }
          idx = i;
        }
      }
    });
    if (handlerIdx === -1) {
      throw new Error("Impossible to find a handler for " + tag);
    }
    if (!groups[bbn.cp.knownPrefixes[idx].prefix]) {
      groups[bbn.cp.knownPrefixes[idx].prefix] = bbn.fn.createObject({
        components: [],
        prefix: bbn.cp.knownPrefixes[idx].prefix
      });
      groups[bbn.cp.knownPrefixes[idx].prefix].handler = bbn.cp.knownPrefixes[handlerIdx].handler;
      groups[bbn.cp.knownPrefixes[idx].prefix].mixins = mixins;
    }
    if (mixins) {
      bbn.fn.each(mixins, m => {
        if (groups[bbn.cp.knownPrefixes[idx].prefix].mixins.indexOf(m) === -1) {
          groups[bbn.cp.knownPrefixes[idx].prefix].mixins.push(m);
        }
      });
    }
    groups[bbn.cp.knownPrefixes[idx].prefix].components.push(tag);
  });

  //bbn.fn.log("GROUPS", groups);
  for (let prefix in groups) {
    //bbn.fn.log("PREFIX");
    const rule = groups[prefix];
    //bbn.fn.log("GROUPS2", prefix);
    let res = await rule.handler(rule.components);
    //bbn.fn.log("RES", res);
    if (bbn.fn.isArray(res.components)) {
      bbn.fn.each(res.components, obj => {
        if (!obj.definition || !obj.name) {
          throw new Error(bbn._("Impossible to find a definition or a name in %s", rule.prefix));
        }
        if (rule.mixins) {
          if (!bbn.fn.isArray(obj.definition.mixins)) {
            obj.definition.mixins = [];
          }
          bbn.fn.each(rule.mixins, m => {
            if (obj.definition.mixins.indexOf(m) === -1) {
              obj.definition.mixins.push(m);
            }
          });
        }

        //bbn.fn.log(obj.name, obj);
        bbn.cp.define(obj.name, obj.definition, obj.template, obj.css);
      });
    }
  }
}
/**
* Create the bbn component private class based on the bbnComponentPrivate
*/
export default function generateCpClass(publicClass, obj) {
  var _obj$data;
  const tag = bbn.fn.camelToCss(publicClass);
  const proto = publicClass + 'Cp';
  const methods = {};
  let originalProto = 'bbnCp';
  if (obj.tag && bbn.cp.tagExtensions[obj.tag]) {
    originalProto = bbn.cp.tagExtensions[obj.tag] + 'Cp';
  }
  const sc = document.createElement('script');
  sc.setAttribute('type', 'text/javascript');
  sc.setAttribute('id', proto + 'Definition');
  let code = `
class ${proto} extends bbnCp {
constructor(ele) {
super(ele);
Object.defineProperty(this, '\$options', {
  value: {
    name: '${tag}',
    _componentTag: '${tag}',
    components: bbn.fn.createObject(),` + (obj.tag ? `
    tag: '${obj.tag}',` : '') + `
    get propsData() {
      if (this.\$el) {
        return this.\$el.bbnSchema?.props || {};
      }

      return {};
    }
  },
  writable: false,
  configurable: false
});
Object.defineProperty(this, '\$methods', {
  value: bbn.fn.createObject({`;
  if (obj.methods) {
    for (let n in obj.methods) {
      methods[n] = bbn.fn.analyzeFunction(obj.methods[n]);
      let fn = methods[n];
      code += `
      ${n}: ${fn.isAsync ? 'async ' : ''} function(${fn.argString}) ${fn.body},`;
    }
  }
  code += `
  }),
  writable: false,
  configurable: false
});
}

\$init(el) {
bbnCp.prototype.\$init.apply(this, [el]);
const data = [`;
  if ((_obj$data = obj.data) !== null && _obj$data !== void 0 && _obj$data.length) {
    code += `
  function() ` + obj.data.map(a => a.toString().trim().substr(a.toString().trim().indexOf('{'))).join(`,\n      () => `);
  }
  code += `
];`;
  code += `
return this;
}

\$setUpProps() {`;
  if (obj.props) {
    code += `
let cp = this;`;
    for (let n in obj.props) {
      const cfg = obj.props[n];
      code += `
this.$setUpProp("${bbn.fn.escapeDquotes(n)}", {`;
      if (cfg.required) {
        code += `
  required: true,`;
      }
      if (cfg.validator) {
        const src = cfg.validator.toString();
        let parenthesisPos = src.indexOf('(');
        let bracePos = src.indexOf('{');
        if (bracePos > -1 && parenthesisPos > -1 && bracePos > parenthesisPos) {
          let fn = src.substr(parenthesisPos);
          code += `
  validator` + fn + `,`;
        } else {
          code += `
  validator: ` + src + `,`;
        }
      }
      if (cfg.default !== undefined) {
        if (bbn.fn.isFunction(cfg.default)) {
          const fn = bbn.fn.analyzeFunction(cfg.default);
          code += `
  default: () => ` + fn.body + `,`;
        } else {
          code += `
  default: `;
          if (cfg.default === null) {
            code += 'null';
          } else {
            code += bbn.fn.isString(cfg.default) ? `"` + bbn.fn.escapeDquotes(cfg.default) + `"` : cfg.default.toString().trim();
          }
          code += `,`;
        }
      }
      if (cfg.type) {
        code += `
  type: [` + cfg.type.map(a => {
          if (a === HTMLElement) {
            return 'HTMLElement';
          }
          return a.name;
        }).join(', ') + `],`;
      }
      code += `
});`;
    }
    code += `
}`;
  }
  if (obj.props) {
    for (let n in obj.props) {
      const cfg = obj.props[n];
      code += `
get ${n}() {
return this.$props["${n}"];
}
`;
    }
  }
  for (let n in methods) {
    let fn = methods[n];
    // for debug
    //let body = fn.body.replace('{', '{bbn.fn.log("' + n + '");');
    let body = fn.body;
    code += `
get ${n}() {
return this.$methods['${n}'].bind(this);
};`;
  }
  if (obj.computed) {
    for (let name in obj.computed) {
      const getter = bbn.fn.analyzeFunction(obj.computed[name].get);
      code += `
get ${name}() {
if (!this.$isDataSet) {
  return undefined;
}

if (!Object.hasOwn(this.$computed, "${name}")) {
  this.$computed["${name}"] = bbn.fn.createObject({
    old: undefined,
    val: undefined,
    hash: undefined,
    num: 0,
    update: () => {
      this.$updateComputed(
        "${name}",
        (function () ${getter.body}).bind(this)()
      );
    }
  });
}

if (this.$computed["${name}"].num <= this.$numBuild) {
  this.$computed["${name}"].update();
}

return bbnData.getValue(this.$computed["${name}"].val);
}
`;
      const setter = obj.computed[name].set ? bbn.fn.analyzeFunction(obj.computed[name].set) : null;
      if (setter) {
        code += `
set ${name}(${setter.argString}) ${setter.body}

`;
      }
    }
  }
  const acceptedAttr = bbn.cp.possibleAttributes.concat(bbn.cp.possibleAttributes.map(a => ':' + a)).concat(Object.keys(obj.props)).concat(Object.keys(obj.props).map(a => ':' + a));
  code += `
static \$acceptedAttributes = ${JSON.stringify(acceptedAttr)};`;

  //bbn.fn.log(["NO IFACE?", obj])
  if (obj.statics.length) {
    let iface = '""';
    if (obj.iface) {
      if (bbn.fn.isObject(obj.iface)) {
        iface = JSON.stringify(obj.iface, null, 2);
      } else if (bbn.fn.isFunction(obj.iface)) {
        let fn = bbn.fn.analyzeFunction(obj.iface);
        iface = '(function(){' + fn.body + '})()';
      } else {
        throw new Error(bbn._("The interface property must be an object or a function"));
      }
    }
    code += `
static {
let res;
let iface = ${iface};`;
    bbn.fn.each(obj.statics, f => {
      let fn = bbn.fn.analyzeFunction(f);
      let stFn = fn.toString().trim();
      stFn = bbn.fn.substr(stFn, stFn.indexOf('('));
      code += `
res = ((${fn.argString}) => ` + fn.body + `)(iface);
if (res) {
  if (!bbn.fn.isObject(res)) {
    throw new Error(bbn._("If the static method returns it must be an object"));
  }
  bbn.fn.iterate(res, (v, n) => {
    if (this[n] === undefined) {
      this[n] = bbnData.immunizeValue(v);
    }
    else {
      throw new Error(bbn._("The static method cannot override an existing property"));
    }
  });
}`;
    });
    code += `
}
`;
  }
  code += `
}
`;

  /*
    code += `
    ${fnName} = function(el, a) {
    Object.setPrototypeOf(a, ${proto});
  ${fnName}.name = '` + fnName + `';
  ${fnName}.bbnCls = ` + publicClass + `;
  ${fnName}.availableSlots = bbn.fn.createObject();
  ${fnName}.dataModels = bbn.fn.createObject();
  ${fnName}.proto = "${proto}";
  Object.assign(${fnName}.availableSlots, bbn.cp.retrieveSlots(` + publicClass + `.constructor.bbnTpl))
  Object.assign(${fnName}.dataModels, bbn.cp.retrieveModels(` + publicClass + `.constructor.bbnTpl))
  let iface`;
  
    if (obj.iface) {
      code += ` = `;
      if (bbn.fn.isObject(obj.iface)) {
        code += JSON.stringify(obj.iface);
      }
      else if (bbn.fn.isFunction(obj.iface)) {
        code += `(function() {` + obj.iface.toString().trim().substr(obj.iface.toString().trim().indexOf('{')) + `})()`;
      }
      else {
        throw new Error(bbn._("The interface property must be an object or a function"));
      }
  
    }
    code += `;`;
  
    if (obj.statics.length) {
      bbn.fn.each(obj.statics, fn => {
        code += `
  bbn.fn.iterate(`;
        if (bbn.fn.isObject(fn)) {
          code += JSON.stringify(fn);
        }
        else if (bbn.fn.isFunction(fn)) {
          let func = 'function' + fn.toString().trim().substr(fn.toString().trim().indexOf('('));
          let arrowPos = func.indexOf('=>');
          let hasArrow = arrowPos > -1;
          if (hasArrow && (func.indexOf('{') > arrowPos)) {
            func = func.substr(0, arrowPos) + func.substr(arrowPos + 2);
          }
  
          code += `(` + func + `)(iface)`;
        }
        else {
          bbn.fn.log(fn);
          throw new Error(bbn._("The statics property must be an object or a function"));
        }
  
        code += `, (v, n) => {
    ${fnName}[n] = bbn.fn.isFunction(v) ? v.bind(${fnName}) : v;
  });`;
      });
    }
  
      code += `
  })();
  }
  catch (e) {
  bbn.fn.log("ERROR", e);
  throw new Error(e);
  }
  
  `;
  */

  sc.innerHTML = code;
  window.document.head.appendChild(sc);
  //bbn.fn.log("ENDING GENERATE CP CLASS", proto);
  return code;
}
/**
 * Generates the code for creating the public class
 * Be careful that cpTpl, cpCfg and cpCls are defined
 *
 */
export default function generateHTMLClass(name) {
  let clsExtends = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bbnHTML';
  const eleName = bbn.fn.camelToCss(name);
  const sc = document.createElement('script');
  sc.setAttribute('type', 'text/javascript');
  sc.setAttribute('id', name + 'Definition');
  sc.innerHTML = `class ${name} extends ${clsExtends}
{
  static get bbnTpl() {
    return bbn.cp.statics['${eleName}'].tpl;
  }
  static get bbnCfg() {
    return bbn.cp.statics['${eleName}'].cfg;
  }
  static get bbnCls() {
    return bbn.cp.statics['${eleName}'].cls;
  }
  static get bbnMap() {
    return bbn.cp.statics['${eleName}'].map;
  }
  static get bbnTag() {
    return bbn.cp.statics['${eleName}'].tag;
  }
  static get bbnSlots() {
    return bbn.cp.statics['${eleName}'].slots;
  }
  static get bbnFn() {
    return ${name}Cp;
  }

  constructor() {
    super();
  }
};`;
  window.document.head.appendChild(sc);
}
/**
 * Retrieves a component in the document based on its id.
 * Every instance of bbnComponentObject is registered through its
 * unique ID in the static #components property
 * @param {Symbol} id 
 * @returns 
 */
export default function getComponent(id) {
  return this.componentsIndex.get(id) || null;
}
/**
 * Sets default object for a component, accessible through bbn.vue.defaults[__COMPONENT_NAME__].
 * 
 * @method initDefaults
 * @memberof bbn.cp
 * @param Object defaults 
 */
export default function initDefaults(defaults) {
  if (typeof defaults !== 'object') {
    throw new Error("The default object sent for defaults is not an object");
  }
  bbn.fn.extend(true, bbn.cp.defaults, defaults);
}
/**
 * Inserts the given directives to the target element
 * @param {Object} directives
 * @param {HTMLElement} target
 */
export default function insertDirectives(directives, target) {
  if (bbn.fn.isObject(directives) && Object.keys(directives).length) {
    bbn.fn.iterate(directives, (dir, name) => {
      // Check if the directive has not already been initialized on target element
      if (!dir.inserted) {
        // Check if the "inserted" function exists on this directive
        if (bbn.fn.isFunction(bbn.cp.directives[name].inserted)) {
          // Set the directive as initialized
          dir.inserted = true;
          // Initialize the directive
          bbn.cp.directives[name].inserted(target, dir);
        }
      }
    });
  }
}
export default function isComponent(node) {
  var _node$props, _node$attr;
  if (!node) {
    return false;
  }
  if (node.$options && node.$options._componentTag) {
    return true;
  }

  // HTMLElement
  if (node.bbnCid) {
    return true;
  }
  if (bbn.fn.isObject(node) && node._bbnComponent) {
    return true;
  }

  // Node object
  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.is) {
    if (bbn.fn.isObject(node.props.is)) {
      return true;
    }
    return node.props.is.indexOf('-') > -1;
  }
  if ((_node$attr = node.attr) !== null && _node$attr !== void 0 && (_node$attr = _node$attr.is) !== null && _node$attr !== void 0 && _node$attr.value) {
    return node.attr.is.value.indexOf('-') > -1;
  }
  if (node.tag) {
    if (node.tag.indexOf('bbns-') === 0) {
      return false;
    }
    return node.tag.indexOf('-') > -1;
  }
  return false;
}
export default function isTag(tag, ele) {
  bbn.fn.checkType(tag, 'string', bbn._("Tags must be strings"));
  bbn.fn.checkType(ele, HTMLElement);
  if (ele.tagName.toLowerCase() === tag) {
    return true;
  }
  if (ele.getAttribute("is") === tag) {
    return true;
  }
  return false;
}
export default function mapAttributes(tpl, map) {
  if (map === undefined) {
    map = bbn.fn.createObject();
  }
  const originalMap = map;
  for (node of tpl) {
    map = originalMap;
    if (node.loop) {
      map[node.loop.hash] = bbn.fn.createObject({
        res: undefined,
        loopData: bbn.fn.createObject(),
        elements: []
      });
      map = map[node.loop.hash].loopData;
    }
    if (node.text) {
      if (!map[node.hash]) {
        map[node.hash] = bbn.fn.createObject({
          res: undefined,
          elements: []
        });
      }
    } else if (node.attr) {
      for (attrName in node.attr) {
        if (node.attr[attrName].exp && !map[node.attr[attrName].hash]) {
          map[node.attr[attrName].hash] = bbn.fn.createObject({
            res: undefined,
            elements: []
          });
        }
      }
    }
    if (node.items) {
      bbn.cp.mapAttributes(node.items, map);
    }
    if (node.slots) {
      for (n in node.slots) {
        bbn.cp.mapAttributes(node.slots[n], map);
      }
    }
  }
  return map;
}
export default function mapTemplate(tpl, map) {
  bbn.fn.checkType(tpl, 'array', bbn._("Template must be an array"));
  if (!map) {
    map = [];
  }
  bbn.fn.each(tpl, el => {
    el.index = map.length;
    map.push(el);
    if (el.items) {
      bbn.cp.mapTemplate(el.items, map);
    }
    if (el.slots) {
      bbn.cp.mapTemplate(el.slots, map);
    }
  });
  return map;
}
const basic = {
  data() {
    bbn.cp.uid++;
    let o = {
      /**
       * The change of value of this prop to true emits the event 'ready'.
       * @data {Boolean} [false] ready
       * @memberof basicComponent
       */
      ready: false,
      /**
       * Each basic component will have a unique UID.
       * @data {Number} uid
       * @memberof basicComponent
       */
      bbnUid: bbn.cp.uid,
      /**
       * The classes added to the component.
       * @data {Array} [['bbn-basic-component']] componentClass
       * @memberof basicComponent
       */
      componentClass: ['bbn-basic-component'],
      /**
       * Indicates if we're on a mobile device.
       * @data {Boolean} isMobile
       * @memberof basicComponent
       */
      isMobile: bbn.fn.isMobile(),
      /**
       * Indicates if we're on a tablet device.
       * @data {Boolean} isTablet
       * @memberof basicComponent
       */
      isTablet: bbn.fn.isTabletDevice(),
      _currentPopup: null
    };
    if (this.$options.name && bbn.cp.defaults[this.$options.name.slice(4)]) {
      bbn.fn.extend(o, bbn.cp.defaults[this.$options.name.slice(4)]);
    }
    return o;
  },
  computed: {
    currentPopup() {
      if (this._currentPopup === null) {
        let e = this._retrievePopup(this);
        if (e) {
          this._currentPopup = e;
        } else {
          this._currentPopup = false;
        }
      }
      if (this._currentPopup) {
        return this._currentPopup;
      }
      return null;
    }
  },
  methods: {
    /**
     * Retrieves the closest popup component in the Vue tree
     * @param vm Vue
     * @returns Vue|false
     */
    _retrievePopup(vm) {
      vm = vm || this;
      if (vm.$options && vm.$options.name === 'bbn-popup') {
        return vm;
      } else if (vm.getRef('popup')) {
        return vm.getRef('popup');
      }
      return vm.$parent ? (vm.$parent._retrievePopup ? vm.$parent : this)._retrievePopup(vm.$parent) : false;
    },
    /**
     * Creates a HTML string for recreating the component.
     * @method exportComponent
     * @memberof basicComponent
     * @param  {Boolean}   full 
     * @param  {Number}    level 
     */
    exportComponent(full, level) {
      let lv = level || 0;
      let st = bbn.fn.repeat('  ', lv) + '<' + this.$options._componentTag;
      bbn.fn.iterate(this.$options.propsData, (a, n) => {
        if (n === 'value') {
          st += ' v-model=""';
        } else if (!bbn.fn.isFunction(a) && !bbn.fn.isObject(a) && !bbn.fn.isArray(a)) {
          st += ' ';
          if (typeof a !== 'string') {
            st += ':';
          }
          st += bbn.fn.camelToCss(n) + '=' + '"' + a + '"';
        }
      });
      st += '>' + "\n";
      if (full) {
        bbn.fn.each(this.$children, a => {
          if (a.exportComponent !== undefined) {
            st += a.exportComponent(true, lv + 1);
          }
        });
      }
      st += bbn.fn.repeat('  ', lv) + '</' + this.$options._componentTag + '>' + "\n";
      return st;
    },
    /**
    * Opens the closest object popup.
    * @method getPopup
    * @return {Object}
    */
    getPopup() {
      let popup = this.currentPopup;
      if (arguments.length && popup) {
        let cfg = arguments[0];
        let args = [];
        if (bbn.fn.isObject(cfg)) {
          cfg.opener = this;
        }
        args.push(cfg);
        for (let i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        return popup.open.apply(popup, args);
      }
      return popup;
    },
    /**
    * Opens a confirmation from the closest popup
    * @method confirm
    */
    confirm() {
      let popup = this.getPopup();
      if (arguments.length && popup) {
        let cfg = arguments[0];
        let args = [];
        if (bbn.fn.isObject(cfg)) {
          cfg.opener = this;
        }
        args.push(cfg);
        for (let i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        if (!bbn.fn.isObject(cfg)) {
          args.push(this);
        }
        return popup.confirm.apply(popup, args);
      }
    },
    /**
    * Opens an alert from the closest popup
    * @method alert
    */
    alert() {
      let popup = this.getPopup();
      if (arguments.length && popup) {
        let cfg = arguments[0];
        let args = [];
        if (bbn.fn.isObject(cfg)) {
          cfg.opener = this;
        }
        args.push(cfg);
        for (let i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        if (!bbn.fn.isObject(cfg)) {
          args.push(this);
        }
        return popup.alert.apply(popup, args);
      }
    },
    /**
    * Executes bbn.fn.post
    * @method post
    * @see {@link https://bbn.io/bbn-js/doc/ajax/post|bbn.fn.post} documentation
    * @todo Stupid idea, it should be removed.
    * @return {Promise}
    */
    post() {
      let ct = this.closest('bbn-container');
      let referer = ct ? ct.getFullCurrentURL() : document.location.pathName;
      let cfg = bbn.fn.treatAjaxArguments(arguments);
      if (!referer && bbn.env.path) {
        referer = bbn.env.path;
      }
      cfg.obj = bbn.fn.extend({}, cfg.obj || {}, {
        _bbn_referer: referer,
        _bbn_key: bbn.fn.getRequestId(cfg.url, cfg.obj, 'json')
      });
      return bbn.fn.post(cfg);
    },
    /**
    * Executes bbn.fn.postOut
    * @method postOut
    * @see {@link https://bbn.io/bbn-js/doc/ajax/postOut|bbn.fn.postOut} documentation
    * @todo Stupid idea, it should be removed.
    * @return {void}
    */
    postOut(url, obj, onSuccess, target) {
      let ct = this.closest('bbn-container');
      let referer = ct ? ct.getFullCurrentURL() : document.location.pathName;
      let cfg = bbn.fn.treatAjaxArguments(arguments);
      if (!referer && bbn.env.path) {
        referer = bbn.env.path;
      }
      obj = bbn.fn.extend({}, obj || {}, {
        _bbn_referer: referer,
        _bbn_key: bbn.fn.getRequestId(url, obj, 'json')
      });
      return bbn.fn.postOut(url, obj, onSuccess, target);
    }
  },
  /**
   * If not defined, defines component's template
   * @memberof basicComponent
   * @event beforeCreate
   */
  beforeCreate() {
    if (!this.$options.render && !this.$options.template && this.$options.name) {
      this.$options.template = '#bbn-tpl-component-' + (this.$options.name.indexOf('bbn-') === 0 ? this.$options.name.slice(4) : this.$options.name);
    }
  },
  /**
   * Gives to the component the class bbn-basic-component
   * @event created
   * @memberof basicComponent
   */
  created() {
    if (this.$options.name && !this.componentClass.includes(this.$options.name)) {
      this.componentClass.push(this.$options.name);
    }
  },
  watch: {
    /**
     * Emits the event 'ready' when the value is true.
     * @watch ready
     * @emit ready
     * @memberof basicComponent
     */
    ready(newVal) {
      if (newVal) {
        let ev = new CustomEvent('subready', {
          bubbles: true,
          detail: {
            cp: this
          }
        });
        this.$el.dispatchEvent(ev);
        this.$emit('ready', this);
      }
    }
  }
};
export default basic;
const browserNotification = {
  /**
   * @mixin bbn.cp.mixins.serviceWorker
   * @memberof browserNotificationComponent
   */
  props: {
    /**
     * @prop {Boolean} [false] browserNotification
     */
    browserNotification: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      /**
       * @data {Boolean} [false] hasBrowserPermission
       * @memberof browserNotificationComponent
       */
      hasBrowserPermission: false,
      /**
       * @data {Object} [{}] browserNotifications
       * @memberof browserNotificationComponent
       */
      browserNotifications: {},
      /**
       * @data {String} [''] browserNotificationURL
       * @memberof browserNotificationComponent
       */
      browserNotificationURL: '',
      /**
       * @data {Boolean} [false] browserNotificationSW
       * @memberof browserNotificationComponent
       */
      browserNotificationSW: false
    };
  },
  methods: {
    /**
       * @method browserNotify
       * @memberof browserNotificationComponent
       * @param {String} title
       * @param {String} text,
       * @param {Object} options
       * @fires _postMessage
       * @fires $set
       */
    browserNotify(title, text, options) {
      if (this.ready && this.browserNotification && this.hasBrowserPermission && title && text) {
        if (bbn.fn.isObject(text)) {
          options = text;
        } else if (bbn.fn.isString(text)) {
          if (!bbn.fn.isObject(options)) {
            options = {};
          }
          if (!options.body || options.body !== text) {
            options.body = text;
          }
        }
        let date = bbn.fn.date();
        options.tag = options.tag || options.timestamp || date.getTime();
        options.timestamp = options.timestamp || date.getTime();
        if (this.browserNotificationSW && bbn.fn.isFunction(this._postMessage)) {
          this._postMessage({
            type: 'notification',
            data: {
              title: title,
              options: options
            }
          });
        } else {
          options.onclick = this.browserNotificationClick;
          let n = new Notification(title, options);
          this.$set(this.browserNotifications, options.tag, n);
        }
      }
    },
    /**
     * @method browserNotificationClick
     * @memberof browserNotificationComponent
     * @param {Object} options
     * @fires post
     * @fires removeBrowserNotification
     * @fires messageToChannel
     */
    browserNotificationClick(options) {
      if (this.browserNotificationURL) {
        this.post(this.browserNotificationURL + '/actions/read', {
          id: options.tag
        }, d => {
          if (d.success) {
            this.removeBrowserNotification(options.tag);
            this.messageToChannel({
              method: 'removeBrowserNotification',
              params: [options.tag]
            });
          }
        });
      } else {
        this.removeBrowserNotification(options.tag);
      }
    },
    /**
     * @method removeBrowserNotification
     * @memberof browserNotificationComponent
     * @param {String} id
     * @fires $delete
     */
    removeBrowserNotification(id) {
      if (id && id in this.browserNotifications) {
        this.$delete(this.browserNotifications, id);
      }
    }
  },
  /**
   * Adds the class 'bbn-browser-notification-component' to the component.
   * @event created
   * @memberof browserNotificationComponent
   */
  created() {
    this.componentClass.push('bbn-browser-notification-component');
  },
  /**
   * @event mounted
   */
  mounted() {
    if (this.browserNotification) {
      Notification.requestPermission(perms => {
        this.hasBrowserPermission = perms === 'granted';
      });
    }
  }
};
export default browserNotification;
const close = {
  /**
   * Adds the class 'bbn-close-component' to the component.
   * @event created
   * @memberof closeComponent
   */
  created() {
    this.componentClass.push('bbn-close-component');
  },
  data() {
    return {
      /**
       * Defines if the component's source has been modified. 
       * @data {Boolean}  [false] dirty
       * @memberof closeComponent
       */
      dirty: false
    };
  },
  computed: {
    /**
     * If the prop 'dirty' is false the component can be closed. 
     * @computed {Boolean} canClose
     * @memberof closeComponent
     */
    canClose() {
      return !this.dirty;
    }
  },
  methods: {}
};
export default close;
import bbnCp from '../../classes/Cp.js';
const componentInside = {
  props: {
    /**
     * The component that will be rendered inside the main component.
     * @prop {String|Object|bbnCp} component
     * @memberof componentInsideComponent
     */
    component: {
      type: [String, Object, bbnCp]
    },
    /**
     * The component's props.
     * @prop {Object} componentOptions
     * @memberof componentInsideComponent
     */
    componentOptions: {
      type: Object,
      default() {
        return {};
      }
    }
  }
};
export default componentInside;
const config = {
  statics(iface) {
    if (!iface.config || !iface.config.name || !iface.config.props || !iface.config.data) {
      throw new Error(bbn._("The component must have a configName and a configSource returned by its interface function"));
    }
    bbn.cp.define(iface.config.name, {
      props: iface.config.props
    }, '', iface.config.name + ' { display: none; }');
    return iface;
  },
  beforeCreate() {
    if (this.$slots.default) {
      bbn.fn.each(this.$slots.default, a => {
        if (a.tagName === this.constructor.config.name.toUpperCase() && a.bbnSchema) {
          this[this.constructor.config.data].push(a.bbnSchema.props);
        }
      });
    }
  }
};
export default config;
const data = {
  methods: {
    /**
     * Defines how to render the data.
     * @method renderData
     * @param {Object} data
     * @param {Object} cfg
     * @memberof dataComponent
     * @returns {String}
     */
    renderData(data, cfg) {
      var _bbn$env, _bbn$env2;
      if (!cfg || !cfg.field || !bbn.fn.isString(cfg.field) && !bbn.fn.isNumber(cfg.field) || !data) {
        return '';
      }
      let v = data[cfg.field] || '';
      if (cfg.icon) {
        return '<i class="' + cfg.icon + '"> </i>';
      } else if (cfg.type) {
        switch (cfg.type) {
          case "datetime":
            if (window.dayjs && cfg.format) {
              return v ? new window.dayjs(v).format(cfg.format) : '-';
            } else {
              return bbn.fn.fdatetime(v, '-');
            }
          case "date":
            if (window.dayjs && cfg.format) {
              return v ? new window.dayjs(v).format(cfg.format) : '-';
            } else {
              return bbn.fn.fdate(v, '-');
            }
          case "time":
            if (cfg.format && window.dayjs) {
              return v ? new window.dayjs(v).format(cfg.format) : '-';
            } else {
              return v ? bbn.fn.ftime(v) : '-';
            }
          case "email":
            return v ? '<a href="mailto:' + v + '">' + v + '</a>' : '-';
          case "url":
            return v ? '<a href="' + v + '">' + v + '</a>' : '-';
          case "percent":
            return v ? bbn.fn.money(v * 100, false, "%", '-', '.', ' ', 2) : '-';
          case "number":
            return bbn.fn.money(v, cfg.precision === -4 || cfg.format && cfg.format.toLowerCase() === 'k', cfg.unit || "", '-', '.', ' ', cfg.precision === -4 ? 3 : cfg.precision || cfg.decimals || 0);
          case "money":
            //bbn.fn.log(cfg)
            return bbn.fn.money(v, cfg.precision === -4 || cfg.format && cfg.format.toLowerCase() === 'k', cfg.currency || cfg.unit || "", !!cfg.novalue ? bbn.fn.isFunction(cfg.novalue) ? cfg.novalue(data[cfg.field], cfg) : cfg.novalue : '-', ((_bbn$env = bbn.env) === null || _bbn$env === void 0 || (_bbn$env = _bbn$env.money) === null || _bbn$env === void 0 ? void 0 : _bbn$env.decimal) || ',', ((_bbn$env2 = bbn.env) === null || _bbn$env2 === void 0 || (_bbn$env2 = _bbn$env2.money) === null || _bbn$env2 === void 0 ? void 0 : _bbn$env2.thousands) || ' ', cfg.precision === -4 ? 3 : cfg.precision || cfg.decimals || 0);
          case "bool":
          case "boolean":
            return '<i class="nf nf-fa-' + (v && v !== 'false' && v !== '0' && (cfg.yesvalue === undefined || v === cfg.yesvalue) ? 'check' : 'times') + '" title="' + (v && v !== 'false' && v !== '0' && (cfg.yesvalue === undefined || v === cfg.yesvalue) ? bbn._("Yes") : bbn._("No")) + '"></i>';
        }
      } else if (cfg.source) {
        if (cfg.source.length) {
          if (!bbn.fn.isObject(cfg.source[0])) {
            let idx = cfg.source.indexOf(v);
            return idx > -1 ? cfg.source[idx] : '-';
          } else {
            let filter = {};
            filter[this.sourceValue || 'value'] = v;
            let idx = bbn.fn.search(bbn.fn.isFunction(cfg.source) ? cfg.source() : cfg.source, filter);
            return idx > -1 ? cfg.source[idx][this.sourceText || 'text'] : '-';
          }
        }
      } else {
        if (bbn.fn.isString(v) && v && cfg.maxVisible) {
          return bbn.fn.shorten(v, cfg.maxVisible);
        }
        return v || '';
      }
    }
  }
};
export default data;
const dataEditor = {
  statics() {
    const editorOperators = {
      string: {
        contains: bbn._('Contains'),
        eq: bbn._('Is'),
        neq: bbn._('Is not'),
        startswith: bbn._('Starts with'),
        doesnotcontain: bbn._('Does not contain'),
        endswith: bbn._('To end by'),
        isempty: bbn._('Is empty'),
        isnotempty: bbn._('Is not empty')
      },
      number: {
        eq: bbn._('Is equal to'),
        neq: bbn._('Is not equal to'),
        gte: bbn._('Est suprieur ou gal Is greater than or equal to'),
        gt: bbn._('Is greater than'),
        lte: bbn._('Is less than or equal to'),
        lt: bbn._('Is inferior to')
      },
      date: {
        eq: bbn._('Is equal to'),
        neq: bbn._('Is not equal to'),
        gte: bbn._('Is greater than or equal to'),
        gt: bbn._('Is after'),
        lte: bbn._('Is prior to or equal to'),
        lt: bbn._('Is older than')
      },
      enums: {
        eq: bbn._('Is equal to'),
        neq: bbn._('Is not equal to')
      },
      boolean: {
        istrue: bbn._('Is true'),
        isfalse: bbn._('Is false')
      }
    };
    const editorNullOps = {
      isnull: bbn._('Is null'),
      isnotnull: bbn._('Is not null')
    };
    const editorNoValueOperators = ['', 'isnull', 'isnotnull', 'isempty', 'isnotempty', 'istrue', 'isfalse'];
    return {
      editorOperators,
      editorNullOps,
      editorNoValueOperators
    };
  },
  methods: {
    /**
     * not used
     * @memberof dataEditorComponent
     *  editorOperatorType
     * @param {Object} col 
     */
    editorOperatorType(col) {
      if (col.field) {}
    },
    /**
     * Returns if true if the editor has no value.
     * @memberof dataEditorComponent
     * @method editorHasNoValue
     * @param {String} operator 
     * @returns {Boolean}
     */
    editorHasNoValue(operator) {
      return this.editorNoValueOperators.indexOf(operator) > -1;
    },
    /**
     * Defines the correct editor for the given col.
     * @method editorGetComponentOptions
     * @param {Object} col
     * @memberof dataEditorComponent
     * @returns {Object}
     */
    editorGetComponentOptions(col) {
      let o = {
        type: 'string',
        component: 'bbn-input',
        multi: false,
        componentOptions: {}
      };
      if (col && col.field) {
        o.field = col.field;
        if (col.filter) {
          o.component = col.filter;
        } else if (col.source) {
          o.type = 'enums';
          o.component = 'bbn-dropdown';
          o.componentOptions.source = col.source;
          o.componentOptions.placeholder = bbn._('Choose');
        } else if (col.type === 'boolean') {
          o.type = 'enums';
          o.component = 'bbn-dropdown';
          o.componentOptions.source = [0, 1];
          o.componentOptions.placeholder = bbn._('Choose');
        } else if (col.type) {
          switch (col.type) {
            case 'number':
            case 'money':
              o.type = 'number';
              o.component = 'bbn-numeric';
              break;
            case 'date':
              o.type = 'date';
              o.component = 'bbn-datepicker';
              break;
            case 'time':
              o.type = 'date';
              o.component = 'bbn-timepicker';
              break;
            case 'datetime':
              o.type = 'date';
              o.component = 'bbn-datetimepicker';
              break;
          }
        }
        if (col.componentOptions) {
          bbn.fn.extend(o.componentOptions, col.componentOptions);
        }
        if (o.type && this.editorOperators[o.type]) {
          o.operators = this.editorOperators[o.type];
        }
        o.fields = [col];
      }
      return o;
    }
  },
  computed: {
    /**
     * The object containing the text for the different operator values.
     * @computed editorOperators 
     * @memberof dataEditorComponent
     * @returns{Object}
     */
    editorOperators() {
      return this.constructor.editorOperators;
    },
    /**
     * The object containing the text for the case null or not null values.
     * @computed editorNullOps
     * @memberof dataEditorComponent
     * 
     */
    editorNullOps() {
      return this.constructor.editorNullOps;
    },
    /**
     * The array containing the values of operators when the value of the editor is not defined.
     * @computed editorNoValueOperators 
     * @memberof dataEditorComponent
     * @returns {Array}
     */
    editorNoValueOperators() {
      return this.constructor.editorNoValueOperators;
    }
  },
  /**
   * Adds the class 'bbn-data-editor-component' to the component.
   * @event created
   * @memberof dataEditorComponent
   */
  created() {
    this.componentClass.push('bbn-data-editor-component');
  }
};
export default dataEditor;
const dimensions = {
  props: {
    /**
    * The maximum width of the component.
    * @prop {Number|String} maxWidth
    * @memberof dimensionsComponent
    */
    maxWidth: {
      type: [Number, String]
    },
    /**
    * The maximum height of the component.
    * @prop {Number|String} maxHeight
    * @memberof dimensionsComponent
    */
    maxHeight: {
      type: [Number, String]
    },
    /**
    * The minimum width of the component.
    * @prop {Number|String} minWidth
    * @memberof dimensionsComponent
    */
    minWidth: {
      type: [Number, String]
    },
    /**
    * The minimum height of the component.
    * @prop {Number|String} maxHeight
    * @memberof dimensionsComponent
    */
    minHeight: {
      type: [Number, String]
    },
    /**
    * The width of the component.
    * @memberof dimensionsComponent
    * @prop {String|Number|Boolean} width
    */
    width: {
      type: [String, Number, Boolean]
    },
    /**
    * The height of the component.
    * @memberof dimensionsComponent
    * @prop {String|Number|Boolean} height
    */
    height: {
      type: [String, Number, Boolean]
    }
  },
  data() {
    return {
      /**
      * The current height of the component.
      * @memberof dimensionsComponent
      * @data [null] currentHeight
      */
      currentHeight: null,
      /**
      * The current width of the component.
      * @data [null] currentWidth
      */
      currentWidth: null,
      /**
      * The current min-height of the component.
      * @memberof dimensionsComponent 
      * @data [null] currentMinHeight
      */
      currentMinHeight: null,
      /**
      * The current min-width of the component.
      * @memberof dimensionsComponent
      * @data [null] currentMinWidth
      */
      currentMinWidth: null,
      /**
      * The current max-height of the component.
      * @memberof dimensionsComponent
      * @data [null] currentMaxHeight
      */
      currentMaxHeight: null,
      /**
      * The current max-width of the component.
      * @memberof dimensionsComponent
      * @data [null] currentMaxWidth
      */
      currentMaxWidth: null
    };
  }
};
export default dimensions;
import bbnCp from '../../classes/Cp.js';
const dropdown = {
  props: {
    /**
     * @prop {Boolean} [true] writable
     * */
    writable: {
      type: Boolean,
      default: false
    },
    /**
     * The text corresponding to the value of the component.
     * @memberof dropdownComponent
     * @prop {String} [''] textValue
     */
    textValue: {
      type: String,
      default: ''
    },
    /**
     * @todo description
     * @memberof dropdownComponent
     * @prop valueTemplate
     */
    valueTemplate: {},
    /**
     * Defines the groups for the dropdown menu.
     * @memberof dropdownComponent
     * @prop {String} group
     */
    group: {
      type: String
    },
    /**
     * Defines the mode of the dopdown menu.
     * @memberof dropdownComponent
     * @prop {String} ['selection'] mode
     */
    mode: {
      type: String,
      default: 'selection'
    },
    /**
     * The max-height of the component.
     * @memberof dropdownComponent
     * @prop {Number|String} maxHeight
     */
    maxHeight: {
      type: [Number, String]
    },
    /**
     * Defines whether or not the component has to suggest a value when start typing.
     * @memberof dropdownComponent
     * @prop {Boolean} [false] suggest
     */
    suggest: {
      type: Boolean,
      default: false
    },
    /**
     * Defines whether or not the floater has to be set mobile view.
     * @memberof dropdownComponent
     * @prop {Boolean} [false] mobile
     */
    mobile: {
      type: Boolean,
      default: true
    },
    /**
     * Preloads the floater
     * @memberof dropdownComponent
     * @prop {Boolean} [false] preload
     */
    preload: {
      type: Boolean,
      default: false
    },
    /**
     * Adds the close button to floater header
     * @memberof dropdownComponent
     * @prop {Boolean} [false] closable
     */
    closable: {
      type: Boolean,
      default: false
    },
    /**
     * The floater bottom buttons
     * @memberof dropdownComponent
     * @prop {Array} buttons
     */
    buttons: {
      type: Array
    },
    /**
     * The floater title
     * @memberof dropdownComponent
     * @prop {String} floaterTitle
     */
    floaterTitle: {
      type: String
    },
    /**
     * Using an external popup component to open the floater
     * @memberof dropdownComponent
     * @prop {Boolean|bbnCp} popup
     */
    popup: {
      type: [Boolean, bbnCp],
      default: false
    },
    /**
     * Using the browser native render
     * @memberof dropdownComponent
     * @prop {Boolean} native
     */
    native: {
      type: Boolean,
      default: false
    },
    /**
     * The icon representing the arrow up.
     * @prop {String} ['nf nf-fa-caret_up'] iconUp
     * @memberof dropdownComponent
     */
    iconUp: {
      type: String,
      default: 'nf nf-fa-caret_up'
    },
    /**
     * The icon representing the arrow down.
     * @prop {String} ['nf nf-fa-caret_down'] iconDown
     * @memberof dropdownComponent
     */
    iconDown: {
      type: String,
      default: 'nf nf-fa-caret_down'
    },
    /**
     * Convertes the current text from HTML code to pure text.
     * @prop {Boolean} [false] clearHtml
     * @memberof dropdownComponent
     */
    clearHtml: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] groupable
     * @memberof dropdownComponent
     */
    groupable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {String} ['group'] sourceGroup
     * @memberof dropdownComponent
     */
    sourceGroup: {
      type: String,
      default: 'group'
    },
    /**
     * @prop {(String|Object|bbnCp)} groupComponent
     * @memberof dropdownComponent
     */
    groupComponent: {
      type: [String, Object, bbnCp]
    },
    /**
     * @prop {String} groupStyle
     * @memberof dropdownComponent
     */
    groupStyle: {
      type: String
    },
    /**
     * @prop {Number} closeDelay The time it will take for the floater/menu to close when the mouse leaves
     * @memberof dropdownComponent
     * This  allows to cancel if the mouse comes back
     */
    closeDelay: {
      type: Number,
      default: 1000
    },
    /**
     * @prop {String} ['disabled'] sourceDisabled
     * @memberof dropdownComponent
     */
    sourceDisabled: {
      type: String,
      default: 'disabled'
    }
  },
  data() {
    return {
      /**
       * True when the user's mouse is over the dropdown element or its list
       * @data {Bool} [false] isOverDropdown
       * @memberof dropdownComponent
       */
      isOverDropdown: false,
      /**
       * The timeout before closing the floater
       * @data {int} [0] closeTimeout
       * @memberof dropdownComponent
       */
      closeTimeout: 0,
      /**
       * True if the floating menu of the component is opened.
       * @data {Boolean} [false] isOpened
       * @memberof dropdownComponent
       */
      isOpened: false,
      /**
       * The text corresponding to the value of the component.
       * @data {String} [''] currentText
       * @memberof dropdownComponent
       */
      currentText: this.textValue || '',
      /**
       * The current width of the component.
       * @data {Number} [0] currentWidth
       * @memberof dropdownComponent
       */
      currentWidth: 0,
      /**
       * The current height of the component.
       * @data {Number} [0] currentHeight
       * @memberof dropdownComponent
       */
      currentHeight: 0,
      /**
       * Whether or not the component is active.
       * @data {Boolean} false isActive
       * @memberof dropdownComponent
       */
      isActive: false,
      /**
       * The floater buttons
       * @data {Array} [[]] realButtons
       * @memberof dropdownComponent
       */
      realButtons: [],
      /**
       * The value of the native select elemenet
       * @data {String|Number|Boolean} currentSelectValue
       * @memberof dropdownComponent
       */
      currentSelectValue: this.value,
      /**
       * The floater component
       * @data {bbnCp} list
       * @memberof dropdownComponent
       */
      list: null,
      portalSelector: null,
      isInsideFloater: false
    };
  },
  computed: {
    popupComponent() {
      if (this.popup) {
        if (this.popup === true) {
          return this.getPopup();
        } else {
          return this.popup;
        }
      }
    },
    /**
     * Returns the current 'text' corresponding to the value of the component.
     * @computed currentTextValue
     * @memberof dropdownComponent
     * @returns {String}
     */
    currentTextValue() {
      var _this$currentData;
      if (this.value !== undefined && !bbn.fn.isNull(this.value) && this.sourceValue && this.sourceText && (_this$currentData = this.currentData) !== null && _this$currentData !== void 0 && _this$currentData.length) {
        let idx = bbn.fn.search(this.currentData, a => {
          return a.data[this.sourceValue] === this.value;
        });
        if (idx > -1) {
          if (this.clearHtml) {
            return bbn.fn.html2text(this.currentData[idx].data[this.sourceText]);
          }
          return this.currentData[idx].data[this.sourceText];
        }
      } else if (this.value && this.textValue) {
        return this.textValue;
      }
      return '';
    },
    /**
     * @computed isSerching
     * @memberof dropdownComponent
     * @return {Boolean}
     */
    isSearching() {
      return this.currentText !== this.currentTextValue;
    },
    /**
     * @computed asMobile
     * @memberof dropdownComponent
     * @return {Boolean}
     */
    asMobile() {
      return this.isMobile && this.mobile;
    },
    /**
     * @computed currentIcon
     * @memberof dropdownComponent
     * @return {String}
     */
    currentIcon() {
      return this.isOpened && !this.isDisabled && !this.readonly && this.filteredData.length ? this.iconUp : this.iconDown;
    }
  },
  methods: {
    /**
     * Select the string of text inside of the input.
     * @method selectText
     * @memberof dropdownComponent
     */
    selectText() {
      this.getRef('input').selectText();
    },
    /**
    * Handles the resize of the component
    * @method onResize
    * @memberof dropdownComponent
    */
    onResize() {
      this.currentWidth = this.$el.offsetWidth;
      this.currentHeight = this.$el.offsetHeight;
    },
    /**
     * Manages the click
     * @method click
     * @memberof dropdownComponent
     */
    click() {
      if (!this.disabled && !this.readonly && !this.native && this.filteredData.length && bbn.fn.isDom(this.$el)) {
        const popup = this.getRef('list');
        if (popup) {
          if (popup.isVisible) {
            popup.hide();
          } else {
            popup.show();
          }
        } else {
          this.isOpened = !this.isOpened;
        }
        this.$forceUpdate();
        if (this.writable) {
          this.$el.querySelector('input:not([type=hidden])').focus();
        }
        //this.getRef('input').getRef('element').focus();
      }
    },

    /**
     * Emits the event 'select' 
     * @method select
     * @param {Object} item 
     * @param {Number} idx 
     * @param {Number} dataIndex 
     * @param {Event} e 
     * @emit change
     * @memberof dropdownComponent
     */
    select(item, idx, dataIndex, e) {
      bbn.fn.log(["SLECT DD", e.defaultPrevented, item, item[this.sourceAction], item[this.uid || this.sourceValue]]);
      if (item && (!e || !e.defaultPrevented)) {
        if (this.sourceAction && item[this.sourceAction] && bbn.fn.isFunction(item[this.sourceAction])) {
          item[this.sourceAction](item);
        } else if (item[this.uid || this.sourceValue] !== undefined) {
          this.emitInput(item[this.uid || this.sourceValue]);
          this.$emit('change', item[this.uid || this.sourceValue], idx, dataIndex, e);
        }
      }
      this.isOpened = false;
    },
    attachList() {
      let list = this.getRef('list');
      if (list) {
        this.list = list;
      }
    },
    /**
     * Defines the behavior of component when the key 'alt' or a common key defined in the object bbn.var.keys is pressed. 
     * @method commonKeydown
     * @memberof dropdownComponent
     * @param {Event} e 
     * @return {Boolean}
     */
    selectOver() {
      if (this.list) {
        let lst = this.list.getRef('list');
        if (lst && lst.overIdx > -1) {
          this.select(lst.filteredData[lst.overIdx].data);
        }
      }
    },
    /**
     * Defines the behavior of component when the key 'alt' or a common key defined in the object bbn.var.keys is pressed. 
     * @method commonKeydown
     * @memberof dropdownComponent
     * @param {Event} e 
     * @return {Boolean}
     */
    commonKeydown(e) {
      var _e$key;
      if (e.altKey || e.ctrlKey || e.metaKey) {
        return true;
      }
      if (((_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.length) >= 2 && e.key[0] === 'F') {
        return true;
      }
      if (e.key === 'Tab') {
        if (this.isOpened) {
          this.selectOver();
          return true;
        }
        this.resetDropdown();
        this.isOpened = false;
        return true;
      } else if (this.isOpened && (bbn.var.keys.confirm.includes(e.which) || e.key === ' ' && !this.isSearching)) {
        e.preventDefault();
        this.selectOver();
        return true;
      }
      return false;
    },
    /**
     * Resets the dropdow to its inizial conditions.
     * @method resetDropdown
     * @memberof dropdownComponent
     */
    resetDropdown() {
      this.currentText = this.currentTextValue;
      this.unfilter();
      if (this.isOpened) {
        this.isOpened = false;
      }
    },
    /**
     * Forces the prop 'ready' to be true.
     * @method afterUpdate
     * @memberof dropdownComponent
     */
    afterUpdate() {
      if (!this.ready) {
        this.ready = true;
      }
    },
    /**
     * Resets the filters of the dropdown to the initial conditions.
     * @method unfilter
     * @memberof dropdownComponent
     */
    unfilter() {
      this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length);
      if (this.currentFilters.logic && this.currentFilters.logic.toLowerCase() === 'or') {
        this.currentFilters.logic = 'AND';
      }
    },
    /**
     * Gets the buttons list
     * @method getRealButtons
     * @memberof dropdownComponent
     * @return {Array}
     */
    getRealButtons() {
      let btns = [];
      if (bbn.fn.isArray(this.buttons)) {
        bbn.fn.each(this.buttons, btn => {
          if (bbn.fn.isString(btn)) {
            if (btn === 'close') {
              btns.push({
                text: bbn._('Close'),
                icon: 'nf nf-fa-times_circle',
                action: () => {
                  this.isOpened = false;
                }
              });
            }
          } else {
            btns.push(btn);
          }
        });
      }
      return btns;
    },
    /**
     * Updates the buttons
     * @method updateButtons
     * @memberof dropdownComponent
     */
    updateButtons() {
      this.realButtons.splice(0, this.realButtons.length, ...this.getRealButtons());
    },
    onFocusOut() {
      this.isActive = false;
      if (this.native) {
        this.isOpened = false;
      }
    }
  },
  beforeMount() {
    let ct = this.closest('bbn-container');
    this.portalSelector = ct ? ct.$el : document.body;
    this.isInsideFloater = !!this.closest('bbn-floater');
    this.updateButtons();
  },
  watch: {
    /**
     * @watch value
     * @memberof dropdownComponent
     */
    value() {
      this.currentText = this.currentTextValue;
    },
    /**
     * Closes the floater menu of the component.
     * @method leave
     * @param element 
     * @memberof dropdownComponent
     */
    isOverDropdown(v) {
      bbn.fn.log("IS OVER DROPDOWN : " + (v ? "YES" : "NO"));
      if (v) {
        clearTimeout(this.closeTimeout);
      } else {
        this.closeTimeout = setTimeout(() => {
          let lst = this.getRef('list');
          if (lst) {
            bbn.fn.log("SHOULD CLOSE");
            lst.close(true);
          }
        }, this.closeDelay);
      }
    },
    /**
      * @watch ready
      * @memberof dropdownComponent
      */
    ready(v) {
      if (v && this.suggest && !this.value && this.filteredData.length) {
        this.emitInput(this.filteredData[0].data[this.sourceValue]);
      }
    },
    /**
      * @watch source
      * @memberof dropdownComponent
      */
    source() {
      this.updateData().then(() => {
        /*
        if ( this.filteredData.length ) {
          this.onResize();
        }
        */
      });
    },
    /**
      * @watch buttons
      * @memberof dropdownComponent
      */
    buttons: {
      deep: true,
      handler() {
        this.updateButtons();
      }
    }
  }
};
export default dropdown;
import bbnCp from '../../classes/Cp.js';
const editableList = {
  props: {
    /**
     * If defined, the form created for the edit of the table will have this URL as action.
     * @prop {String} url
     */
    url: {
      type: String
    },
    /**
     * Defines the editor to use when a item is in edit mode.
     * @prop {String|Object} editor
     */
    editor: {
      type: [String, Object, Function]
    },
    /**
     * Defines the editor options when editor defined.
     * @prop {Object} editorOptions
     */
    editorOptions: {
      type: Object
    },
    /**
     * The popup that will be used for the editor
     */
    popup: {
      type: Object
    },
    /**
     * Set to true allows to edit inline the fields if no buttons are defined for the table.
     * @prop {Boolean|String|Function} editable
     */
    editable: {
      type: [Boolean, String, Function],
      default: false,
      validator: e => bbn.fn.isFunction(e) || typeof e === 'boolean' || ['inline', 'popup', 'nobuttons'].includes(e)
    },
    /**
     * Auto saves the row when edit-mode is 'inline'
     * @prop {Boolean} [false] autoSave
     */
    autoSave: {
      type: Boolean,
      default: false
    },
    /**
     * Automatically resets the original values when edit-mode is 'inline'
     * @prop {Boolean} [false] autoReset
     */
    autoReset: {
      type: Boolean,
      default: false
    }
  },
  data() {
    let editable = bbn.fn.isFunction(this.editable) ? this.editable() : this.editable;
    return {
      /**
       * @data {String} editMode
       */
      editMode: editable === true ? this.editor ? 'popup' : 'inline' : editable === 'popup' ? 'popup' : 'inline',
      /**
       * @data {Boolean|Object} [false] tmpRow
       */
      tmpRow: false,
      /**
       * @data {Boolean|Object} [false] originalRow
       */
      originalRow: false,
      /**
       * @data {Boolean|Object} [false] editedRow
       */
      editedRow: false,
      /**
       * @data {Boolean|Number} [false] editedIndex
       */
      editedIndex: false
    };
  },
  computed: {
    /**
     * Return true if the table isn't ajax, is editable and the edit mode is 'inline'.
     * @computed isBatch
     * @returns {Boolean}
     */
    isBatch() {
      return this.editable && this.editMode === 'inline' && !this.isAjax;
    },
    /**
     * If the computed isBatch is true, return an array of modified rows.
     * @computed modifiedRows
     * @returns {Array}
     */
    modifiedRows() {
      let res = [];
      if (this.isBatch) {
        bbn.fn.each(this.currentData, (d, i) => {
          if (!bbn.fn.isSame(d.data, this.originalData[i])) {
            res.push(d);
          }
        });
      }
      return res;
    }
  },
  methods: {
    _defaultRow(data) {
      return data || {};
    },
    /**
     * Creates the object tmpRow.
     *
     * @method _addTmp
     * @param data
     * @returns {bbnCp}
     */
    _addTmp(data) {
      this._removeTmp().tmpRow = this._defaultRow(data);
      this.$emit('addTmp', this.tmpRow);
      return this;
    },
    /**
     * Changes the values of tmpRow to false.
     * @method _removeTmp
     * @returns {bbnCp}
     */
    _removeTmp() {
      if (this.tmpRow) {
        this.tmpRow = false;
      }
      return this;
    },
    /**
     * Returns true if the row corresponding to the given index has changed respect to originalData.
     * @method isModified
     * @param {Number} idx
     * @returns {Boolean}
     */
    isModified(idx) {
      if (!this.originalData) {
        return false;
      }
      let data = [],
        orig;
      if (idx === undefined) {
        data = bbn.fn.map(this.currentData, d => d.data);
        orig = this.originalData;
      } else {
        data = bbn.fn.getField(this.currentData, 'data', {
          index: idx
        }), orig = this.originalData[idx];
      }
      return JSON.stringify(data) !== JSON.stringify(orig);
    },
    /**
     * Adds the given data to the object tmpRow and opens the popup with the form to insert the row.
     * @method insert
     * @param {Object} data
     * @param {Object} options
     * @param {Number} index
     * @fires _addTmp
     * @fires edit
     */
    insert(data, options, index) {
      let d = data ? bbn.fn.clone(data) : {};
      if (this.uid && d[this.uid]) {
        delete d[this.uid];
      }
      this._addTmp(d, index);
      this.edit(this.tmpRow, options, index);
    },
    /**
     * Adds the given data to the object tmpRow and opens the popup with the form to copy the row.
     * @method copy
     * @param {Object} data
     * @param {Object} options
     * @param {Number} index
     * @fires _addTmp
     * @fires edit
     */
    copy(data, options, index) {
      let r = bbn.fn.clone(data);
      if (this.uid && r[this.uid]) {
        delete r[this.uid];
      }
      this._addTmp(r);
      this.edit(this.tmpRow, options, index);
    },
    /**
     * Opens the popup containing the form to edit the row.
     * @method edit
     * @param {Object} row
     * @param {String|Object} winOptions
     * @param {Number} index
     * @fires _addTmp
     */
    edit(row, winOptions, index) {
      if (!this.editable) {
        throw new Error(_("The component is not editable, you cannot use the edit function"));
      }
      if (!winOptions) {
        winOptions = {};
      }
      if (!row) {
        this._addTmp();
        row = this.tmpRow;
      }
      this.originalRow = bbn.fn.clone(row);
      // EditedRow exists from now on the time of the edition
      this.editedRow = row;
      this.editedIndex = bbn.fn.isFunction(this.getDataIndex) ? this.getDataIndex(index) : index;
      if (this.editMode === 'popup') {
        if (typeof winOptions === 'string') {
          winOptions = {
            title: winOptions
          };
        }
        if (!winOptions.height) {
          //winOptions.height = (this.cols.length * 2) + 'rem'
        }
        if (winOptions.maximizable === undefined) {
          winOptions.maximizable = true;
        }
        let popup = bbn.fn.extend({
          source: {
            row: row,
            data: bbn.fn.isFunction(this.data) ? this.data() : this.data
          }
        }, {
          title: this.tmpRow ? bbn._('Row insertion') : bbn._('Row edition')
        }, winOptions ? winOptions : {});
        // A component is given as global editor (form)
        if (this.editor) {
          popup.component = bbn.fn.isFunction(this.editor) ? this.editor(row, index) : this.editor;
          if (this.editorOptions) {
            popup.componentOptions = bbn.fn.extend({
              source: row
            }, this.editorOptions);
          }
        }
        // A URL is given and in this case the form will be created automatically with this URL as action
        else if (this.url) {
          let table = this;
          let o = bbn.fn.extend({}, this.data, {
            action: table.tmpRow ? 'insert' : 'update'
          });
          popup.component = {
            data() {
              let fields = [];
              table.cols.map(a => {
                let o = bbn.fn.extend(true, {}, a);
                if (o.ftitle) {
                  o.title = o.ftitle;
                }
                fields.push(o);
              });
              return {
                // Table's columns are used as native form config
                fields: fields,
                data: row,
                obj: o
              };
            },
            template: `
<bbn-form action="` + table.url + `"
        :schema="fields"
        :scrollable="false"
        :source="data"
        :data="obj"
        @success="success"
        @failure="failure"
        @cancel="cancel">
</bbn-form>`,
            methods: {
              success(d, e) {
                e.preventDefault();
                if (table.successEdit && table.successEdit(d)) {
                  table.getPopup().close();
                }
              },
              failure(d) {
                table.$emit('editFailure', d);
              },
              cancel() {
                if (table && table.cancel) {
                  table.cancel();
                }
              }
            }
          };
        } else {
          throw new Error(bbn._("Impossible to open a window if either an editor or a URL is not set"));
        }
        popup.onClose = () => {
          bbn.fn.log("AFTER CLOSER");
          //  this.currentData.push(bbn.fn.clone( this.tmpRow)); // <-- Error. This add a new row into table when it's in edit mode
          this._removeTmp();
          this.editedRow = false;
          this.editedIndex = false;
        };
        this.getPopup(popup);
      }
    },
    /**
     * Cancels the changes made on the row data.
     * @method cancel
     * @fires _removeTmp
     */
    cancel() {
      if (this.tmpRow) {
        this._removeTmp();
      } else if (this.editedRow && this.originalRow) {
        if (this.currentData[this.editedIndex]) {
          this.currentData[this.editedIndex].data = this.originalRow;
        }
      }
      this.originalRow = false;
      this.editedRow = false;
      this.editedIndex = false;
    },
    /**
     * Insert or update a row in originalData.
     * @method saveRow
     * @emit saverow
     */
    saveRow() {
      // New insert
      let ev = new Event('saverow', {
        cancelable: true
      });
      this.$emit('saverow', this.tmpRow || this.editedRow, ev);
      if (!ev.defaultPrevented) {
        if (this.tmpRow) {
          let row = bbn.fn.clone(this.tmpRow);
          this.currentData.push({
            data: row,
            index: this.currentData.length
          });
          if (this.originalData) {
            this.originalData.push(bbn.fn.clone(row));
          }
          if (bbn.fn.isArray(this.source)) {
            this.source.push(row);
          }
          this.tmpRow = false;
        }
        // Update
        else if (this.editedRow) {
          let row = bbn.fn.clone(this.editedRow);
          this.$set(this.currentData[this.editedIndex], 'data', row);
          if (this.originalData) {
            let or = this.originalData.splice(this.editedIndex, 1, bbn.fn.clone(row));
            if (bbn.fn.isArray(this.source)) {
              let idx = bbn.fn.search(this.source, or[0]);
              if (idx > -1) {
                this.source.splice(idx, 1, row);
              }
            }
          } else if (bbn.fn.isArray(this.source) && this.uid && this.source[this.uid]) {
            let idx = bbn.fn.search(this.source, {
              [this.uid]: this.source[this.uid]
            });
            if (idx > -1) {
              this.source.splice(idx, 1, row);
            }
          }
          this.editedRow = false;
        }
        return true;
      }
      return false;
    },
    /**
     * If the prop url of the table is defined makes a post to the url to update or insert the row, else fires the method saveRow to insert or update the row in originalData.
     * @method saveInline
     * @fires saveRow
     *
     */
    saveInline() {
      if (this.tmpRow || this.editedRow) {
        if (this.url) {
          let o = bbn.fn.extend({}, this.data, this.tmpRow || this.editedRow, {
            action: this.tmpRow ? 'insert' : 'update'
          });
          this.post(this.url, o, d => {
            this.successEdit(d);
          });
        } else {
          let d = bbn.fn.clone(this.tmpRow || this.editedRow);
          if (this.saveRow()) {
            this.$emit(this.tmpRow ? 'insert' : 'edit', d);
          }
        }
      }
    },
    /**
     * After the post in case of edit of the row, update the row in originalData.
     *
     * @method successEdit
     * @param {Object} d
     * @emit editSuccess
     * @fires saveRow
     * @returns {Boolean}
     */
    successEdit(d) {
      if (bbn.fn.isObject(d)) {
        if (d.success !== undefined && !d.success) {
          if (window.appui) {
            let ev = new Event('editFailure', {
              cancelable: true
            });
            this.$emit('editFailfure', d, ev);
            if (!ev.defaultPrevented) {
              appui.error();
            }
          }
        } else {
          let ev = new Event('editSuccess', {
            cancelable: true
          });
          this.$emit('editSuccess', d, ev);
          if (!ev.defaultPrevented) {
            if (d.data) {
              bbn.fn.iterate(d.data, (o, n) => {
                this.editedRow[n] = o;
              });
            }
            this.saveRow();
            return true;
          }
        }
      }
      return false;
    },
    /**
     * @ignore
     * @method saveTmp
     */
    saveTmp() {},
    saveEditedRow() {},
    cancelEditedRow() {}
  },
  /**
   * Adds the class 'bbn-editable-list-component' to the component.
   * @event created
   * @memberof editableListComponent
   */
  created() {
    this.componentClass.push('bbn-editable-list-component');
  },
  watch: {
    /**
     * @watch editedRow
     */
    editedRow(newVal) {
      if (newVal === false) {
        this.editedIndex = false;
      }
    }
  }
};
export default editableList;
const empty = {
  template: '<template><slot></slot></template>',
  /**
   * Adds the class 'bbn-empty-component' to the component's template.
   * @event created
   * @memberof emptyComponent
   */
  created() {
    this.componentClass.push('bbn-empty-component');
  }
};
export default empty;
const events = {
  props: {
    /**
     * @memberof eventsComponent
     * @prop {Number} [1000] touchHoldTolerance
     */
    touchHoldTolerance: {
      type: Number,
      default: 1000
    },
    /**
     * @memberof eventsComponent
     * @prop {Number} [10] touchTapTolerance
     */
    touchTapTolerance: {
      type: Number,
      default: 10
    },
    /**
     * @memberof eventsComponent
     * @prop {Number} [30] touchSwipeolerance
     */
    touchSwipeTolerance: {
      type: Number,
      default: 30
    }
  },
  data() {
    return {
      /**
       * Defines if the component has been changed since its mount.
       * @memberof eventsComponent
       * @data {Boolean} [false] isTouched
       */
      isTouched: false,
      /**
       * True if the component is focused.
       * @memberof eventsComponent
       * @data {Boolean} [false] isFocused
       */
      isFocused: false,
      /**
       * @memberof eventsComponent
       * @data {Boolean|Event} [false] touchStarted
       */
      touchStarted: false,
      /**
       * @memberof eventsComponent
       * @data {Boolean|Event} [false] touchMoved
       */
      touchMoved: false,
      /**
       * @memberof eventsComponent
       * @data {Number} [0] touchHoldTimer
       */
      touchHoldTimer: 0
    };
  },
  methods: {
    /**
     * Emits the click event.
     * @method click
     * @param {Event} e 
     * @emit click
     * @memberof eventsComponent
     */
    click(e) {
      if (bbn.fn.isEvent(e)) {
        e.stopImmediatePropagation();
      }
      this.$emit('click', e);
    },
    /**
     * Emits the blur event.
     * @method blur
     * @param {Event} e
     * @emit blur
     * @memberof eventsComponent
     */
    blur(e) {
      this.isFocused = false;
      if (bbn.fn.isEvent(e)) {
        e.stopImmediatePropagation();
      }
      this.$emit('blur', e);
    },
    /**
     * Emits the event focus
     * @method focus
     * @param {Event} e
     * @return {Function}
     * @memberof basicComponent
     */
    focus(e) {
      let ele = this.getRef('element');
      if (ele && !this.isFocused) {
        ele.focus();
        this.isFocused = true;
      }
      if (bbn.fn.isEvent(e)) {
        e.stopImmediatePropagation();
      }
      this.$emit('focus', e);
    },
    /**
     * Emits the keyup event.
     * @method keyup
     * @param {Event} e
     * @memberof eventsComponent
     * @emit keyup
     */
    keyup(e) {
      if (bbn.fn.isEvent(e)) {
        e.stopImmediatePropagation();
      }
      this.$emit('keyup', e);
    },
    /**
     * Emits the keydown event.
     * @method keydown
     * @param {Event} e
     * @memberof eventsComponent
     * @emit keydown
     */
    keydown(e) {
      if (bbn.fn.isEvent(e)) {
        e.stopImmediatePropagation();
      }
      this.$emit('keydown', e);
    },
    /**
     * Emits the over event.
     * @method over
     * @param {Event} e
     * @memberof eventsComponent
     * @emit over
     */
    over(e) {
      this.$emit('over', e);
      this.$emit('hover', true, e);
    },
    /**
     * Emits the out event.
     * @method out
     * @param {Event} e
     * @emit out
     * @memberof eventsComponent
     * @emit over
     */
    out(e) {
      this.$emit('out', e);
      this.$emit('hover', false, e);
    },
    /**
     * Sets the prop isTouched to true
     * @method touchstart
     * @memberof eventsComponent
     */
    touchstart(ev) {
      this.$emit('touchstart', ev, this);
      if (!ev.defaultPrevented) {
        this.isTouched = true;
        this.touchStarted = ev;
        clearTimeout(this.touchHoldTimer);
        this.touchHoldTimer = setTimeout(() => {
          if (this.isTouched && !this.touchMoved && !ev.defaultPrevented) {
            ev.preventDefault();
            let event = new Event('contextmenu');
            this.$el.dispatchEvent(event);
            this.isTouched = false;
          }
        }, this.touchHoldTolerance);
      }
    },
    /**
     * Sets the prop isTouched to false.
     * @method touchmove
     * @memberof eventsComponent
     */
    touchmove(ev) {
      this.$emit('touchmove', ev, this);
      if (!ev.defaultPrevented) {
        //this.isTouched = false;
        if (Math.abs(this.touchStarted.touches[0].clientX - ev.touches[0].clientX) > this.touchTapTolerance || Math.abs(this.touchStarted.touches[0].clientY - ev.touches[0].clientY) > this.touchTapTolerance) {
          clearTimeout(this.touchHoldTimer);
          this.touchMoved = ev;
        }
      }
    },
    /**
     * Sets the prop isTouched to false.
     * @method touchend
     * @memberof eventsComponent
     */
    touchend(ev) {
      this.$emit('touchend', ev, this);
      if (!ev.defaultPrevented) {
        if (this.touchStarted && this.touchMoved) {
          let direction = false,
            diffY = Math.abs(this.touchStarted.touches[0].clientY - this.touchMoved.touches[0].clientY),
            diffX = Math.abs(this.touchStarted.touches[0].clientX - this.touchMoved.touches[0].clientX),
            axisX = diffX > diffY;
          if (axisX && diffX > this.touchSwipeTolerance) {
            direction = this.touchStarted.touches[0].clientX > this.touchMoved.touches[0].clientX ? 'left' : 'right';
          } else if (!axisX && diffY > this.touchSwipeTolerance) {
            direction = this.touchStarted.touches[0].clientY > this.touchMoved.touches[0].clientY ? 'top' : 'bottom';
          }
          if (!!direction) {
            this.$emit('swipe', ev, this, direction);
            this.$emit('swipe' + direction, ev, this);
          }
        }
        this.isTouched = false;
        this.touchMoved = false;
        this.touchStarted = false;
      }
    },
    /**
     * Sets the prop isTouched to false.
     * @method touchcancel
     * @memberof eventsComponent
     */
    touchcancel(ev) {
      clearTimeout(this.touchHoldTimer);
      this.isTouched = false;
      this.touchStarted = false;
      this.touchMoved = false;
      this.$emit('touchcancel', ev, this);
    }
  },
  /**
   * Adds the class 'bbn-events-component' to the component.
   * @event created
   * @memberof eventsComponent
   */
  created() {
    this.componentClass.push('bbn-events-component');
  }
};
export default events;
const field = {
  props: {
    /**
     * The width of the component.
     * @prop {String|Number} width
     * @memberof fieldComponent
     */
    width: {
      type: [String, Number]
    },
    /**
     * The min-width of the component.
     * @prop {String|Number} minWidth
     * @memberof fieldComponent
     */
    minWidth: {
      type: [String, Number]
    },
    /**
     * The max-width of the component.
     * @prop {String|Number} maxWidth
     * @memberof fieldComponent
     */
    maxWidth: {
      type: [String, Number]
    },
    /**
     * The render of the component.
     * @prop {String|Function} render
     * @memberof fieldComponent
     */
    render: {
      type: [String, Function]
    },
    /**
     * The title of the component.
     * @prop {String|Number} title
     * @memberof fieldComponent
     */
    title: {
      type: [String, Number]
    },
    /**
     * The full title of the component.
     * @prop {String} ftitle
     * @memberof fieldComponent
     */
    ftitle: {
      type: String
    },
    /**
     * @prop {String|Object} tcomponent
     * @memberof fieldComponent
     */
    tcomponent: {
      type: [String, Object]
    },
    /**
     * The icon of the component.
     * @prop {String} icon
     * @memberof fieldComponent
     */
    icon: {
      type: String
    },
    /**
     * The classes added to the component.
     * @prop {String|Function} cls
     * @memberof fieldComponent
     */
    cls: {
      type: [String, Function]
    },
    /**
     * The component's type.
     * @prop {String} type
     * @memberof fieldComponent
     */
    type: {
      type: String
    },
    /**
     * The component's field.
     * @prop {String} field
     * @memberof fieldComponent
     */
    field: {
      type: String
    },
    /**
     * Defines if the component has to be fixed.
     * @prop {Boolean|String} [false] fixed
     * @memberof fieldComponent
     */
    fixed: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Defines if the component has to be hidden.
     * @prop {Boolean} hidden
     * @memberof fieldComponent
     */
    hidden: {
      type: Boolean
    },
    /**
     * Defines if the componenent has to be encoded.
     * @prop {Boolean} [false] encoded
     * @memberof fieldComponent
     */
    encoded: {
      type: Boolean,
      default: false
    },
    /**
     * Defines if the componenent has to be sortable.
     * @prop {Boolean|Function} [true] sortable 
     * @memberof fieldComponent
     */
    sortable: {
      type: [Boolean, Function],
      default: true
    },
    /**
     * Defines if the componenent has to be editable.
     * @prop {Boolean|Function} [true] editable 
     * @memberof fieldComponent
     */
    editable: {
      type: [Boolean, Function],
      default: true
    },
    /**
     * Defines if the componenent has to be filterable.
     * @prop {Boolean|Function} [true] filterable 
     * @memberof fieldComponent
     */
    filterable: {
      type: [Boolean, Function],
      default: true
    },
    /**
     * Defines if the componenent has to be resizable.
     * @prop {Boolean|Function} [true] resizable 
     * @memberof fieldComponent
     */
    resizable: {
      type: [Boolean, Function],
      default: true
    },
    /**
     * Defines if the componenent has to be showable.
     * @prop {Boolean|Function} [true] showable 
     * @memberof fieldComponent
     */
    showable: {
      type: [Boolean, Function],
      default: true
    },
    /**
     * Defines if the componenent can have a null value.
     * @prop {Boolean|Function} nullable 
     * @memberof fieldComponent
     */
    nullable: {
      type: [Boolean, Function]
    },
    /**
     * The buttons of the component.
     * @prop {Array|Function} buttons 
     * @memberof fieldComponent
     */
    buttons: {
      type: [Array, Function]
    },
    /**
     * The source of the component.
     * @prop {Array|Object|String|Function} source 
     * @memberof fieldComponent
     */
    source: {
      type: [Array, Object, String, Function]
    },
    /**
     * Defines if the the value of the component is required.
     * @prop {Boolean|Function} required 
     * @memberof fieldComponent
     */
    required: {
      type: [Boolean, Function]
    },
    /**
     * Defines the precision of the component.
     * @prop {Number} [0] precision 
     * @memberof fieldComponent
     */
    precision: {
      type: Number
    },
    /**
     * Defines the number of decimals for the component.
     * @prop {Number} [0] decimals 
     * @memberof fieldComponent
     */
    decimals: {
      type: Number
    },
    /**
     * Defines the precision of the component.
     * @prop {Number} [0] precision 
     * @memberof fieldComponent
     */
    unit: {
      type: String
    },
    /**
     * Defines the options of the component.
     * @prop {Object|Function} options
     * @memberof fieldComponent
     */
    options: {
      type: [Object, Function],
      default() {
        return {};
      }
    },
    /**
     * Defines the editor of the component.
     * @prop {String|Object} editor
     * @memberof fieldComponent
     */
    editor: {
      type: [String, Object]
    },
    /**
     * Defines the maxLength of the component.
     * @prop {Number} maxLength 
     * @memberof fieldComponent
     */
    maxLength: {
      type: Number
    },
    /**
     * Defines the max number of chars visible in reading.
     * @prop {Number} maxVisible 
     * @memberof fieldComponent
     */
    maxVisible: {
      type: Number
    },
    /**
     * Defines the sqlType of the component.
     * @prop {String} sqlType 
     * @memberof fieldComponent
     */
    sqlType: {
      type: String
    },
    /**
     * @prop {String|Array} aggregate
     * @memberof fieldComponent
     */
    aggregate: {
      type: [String, Array]
    },
    /**
     * Define a component to use.
     * @prop {String|Object} component
     * @memberof fieldComponent
     */
    component: {
      type: [String, Object]
    },
    /**
     * A function to map the data of the component.
     * @prop {Function} mapper
     * @memberof fieldComponent
     */
    mapper: {
      type: Function
    },
    /**
     * Defines the group of the component.
     * @prop {String} group
     * @memberof fieldComponent
     */
    group: {
      type: String
    }
  }
};
export default field;
import bbnCp from '../../classes/Cp.js';
const input = {
  props: {
    /**
     * The value of the component.
     * @prop value
     * @memberof inputComponent
     */
    value: {
      default() {
        return this.defaultValue !== undefined ? this.defaultValue : '';
      }
    },
    /**
     * The component's name.
     * @prop {String} name 
     * @memberof inputComponent
     */
    name: {
      type: String,
      default() {
        return bbn.fn.randomString(10, 20);
      }
    },
    /**
     * The component's placeholder.
     * @prop {String} placeholder
     * @memberof inputComponent
     */
    placeholder: {
      type: String
    },
    /**
     * Defines if the component has a required value.
     * @prop {Boolean|Function} [false] required
     * @memberof inputComponent
     */
    required: {
      type: [Boolean, Function, String],
      default: false
    },
    /**
     * Defines if the component has to be disabled.
     * @prop {Boolean|Function} [false] disabled
     * @memberof inputComponent
     */
    disabled: {
      type: [Boolean, Function],
      default: false
    },
    /**
     * Defines if the component has to be readonly.
     * @prop {Boolean|Function} [false] readonly
     * @memberof inputComponent
     */
    readonly: {
      type: [Boolean, Function, String],
      default: false
    },
    /**
     * Defines the size of the component.
     * @prop {Number|String} size
     * @memberof inputComponent
     */
    size: {
      type: [Number, String]
    },
    /**
    * Defines the maxlength of the value.
    * @prop {Number|String} maxlength 
    * @memberof inputComponent
    */
    maxlength: {
      type: [String, Number]
    },
    /**
     * A function to validate the value before submit.
     * @prop {Function} validation
     * @memberof inputComponent
     */
    validation: {
      type: [Function]
    },
    /**
     * The attribute tabindex of the input component.
     * @prop {Number} tabindex
     * @memberof inputComponent
     */
    tabindex: {
      type: [String, Number],
      default: '0'
    },
    /**
     * @prop {Boolean} [false] nullable
     * @memberof inputComponent
     */
    nullable: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean|String|Object} [''] nullValue
     * @memberof inputComponent
     */
    nullValue: {
      type: [Boolean, String, Object],
      default: null
    },
    /**
     * Set it to true if you want to auto-resize the input's width based on its value (in characters).
     * @prop {Boolean} [false] autosize
     */
    autosize: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Number|String} defaultValue
     * @memberof inputComponent
     */
    defaultValue: {
      type: [String, Number]
    },
    /**
     * Defines the input mode of this elemenet
     * @prop {String} inputmode
     */
    inputmode: {
      type: String
    },
    /**
     * If true the element will focus on insert
     * @prop {Boolean} autofocus
     */
    autofocus: {
      type: Boolean,
      default: false
    },
    /**
     * @prop {Boolean} [false] ellipsis
     */
    ellipsis: {
      type: Boolean,
      default: false
    },
    autocapitalize: {
      type: [Boolean, String]
    },
    autocorrect: {
      type: [Boolean, String]
    },
    spellcheck: {
      type: [Boolean, String]
    }
  },
  data() {
    let original = this.value;
    if (bbn.fn.isObject(this.value) || bbn.fn.isArray(this.value)) {
      original = bbn.fn.clone(this.value);
    }
    return {
      /**
       * True if the component has a value.
       * @data {Boolean} hasVale
       */
      hasValue: !!this.value,
      originalValue: original
    };
  },
  computed: {
    /**
     * Returns true if the component can have a null value.
     * @computed isNullable
     * @returns {Boolean}
     */
    isNullable() {
      let isNullable = !!this.nullable;
      if (this.nullable === null) {
        isNullable = !this.required;
      }
      return isNullable;
    },
    /**
     * Returns true if the component is disabled
     * @computed isDisabled
     * @fires closest
     * @returns {Boolean}
     */
    isDisabled() {
      let form = this.closest('bbn-form');
      return this.disabled || bbn.cp.isComponent(form) && form.disabled;
    }
  },
  methods: {
    resetValue() {
      if (bbn.fn.isObject(this.value) || bbn.fn.isArray(this.value)) {
        this.originalValue = bbn.fn.clone(this.value);
      } else {
        this.originalValue = this.value;
      }
    },
    /**
     * Select the text of the component.
     * @method selectText
     * @memberof inputComponent
     */
    selectText() {
      let ele = this.getRef('element');
      if (ele) {
        bbn.fn.selectElementText(ele);
      }
    },
    /**
     * Emits the event input.
     * @method emitInput
     * @emit input
     * @param {Number|String} val 
     * @memberof inputComponent
     */
    emitInput(val, name) {
      let eventName = 'input' + (name ? ':' + name : '');
      //bbn.fn.log(`Emitting ${eventName} from ${this.$options.name}`, this);
      this.$emit(eventName, val);
    },
    /**
     * Emits the event change.
     * @method change
     * @emit change
     * @param {Event} e 
     * @memberof inputComponent
     */
    change(e) {
      this.$emit('change', e, this.value);
    },
    /**
     * Check the validity of the inserted value.
     * @method isValid
     * @param {bbnCp} e 
     * @return {Boolean}
     * @memberof inputComponent
     */
    isValid(e) {
      let setError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      const $this = bbn.cp.isComponent(e) ? e : this,
        ele = $this.$refs.element || false,
        inp = $this.$refs.input || false,
        customMessage = $this.$el.hasAttribute('validationMessage') ? $this.$el.getAttribute('validationMessage') : false;
      let check = elem => {
        if (elem && elem.validity) {
          let validity = elem.validity,
            $elem = $this.$el,
            // Default message
            mess = bbn._('The value you entered for this field is invalid.'),
            specificCase = false;
          // If valid or disabled, return true
          if (elem.disabled || validity.valid) {
            //if ( (!!elem.required || !!elem.readOnly) && !elem.value ){
            if (elem.required && !elem.value) {
              specificCase = true;
            } else {
              if (this.$el.classList.contains('bbn-state-invalid')) {
                this.$el.classList.remove('bbn-state-invalid');
              }
              return true;
            }
          }
          if (!validity.valid || specificCase) {
            // If field is required and empty
            if (validity.valueMissing || specificCase) {
              mess = bbn._('Please fill out this field.');
            }
            // If not the right type
            else if (validity.typeMismatch) {
              switch (elem.type) {
                // Email
                case 'email':
                  mess = bbn._('Please enter a valid email address.');
                  break;
                // URL
                case 'url':
                  mess = bbn._('Please enter a valid URL.');
                  break;
              }
            }
            // If too short
            else if (validity.tooShort) {
              mess = bbn._('Please lengthen this text to %d characters or more. You are currently using %d characters.', parseInt(elem.getAttribute('minLength')), elem.value.length);
            }
            // If too long
            else if (validity.tooLong) {
              mess = bbn._('Please shorten this text to no more than %d characters. You are currently using %d characters.', parseInt(elem.getAttribute('maxLength')), elem.value.length);
            }
            // If number input isn't a number
            else if (validity.badInput) {
              mess = bbn._('Please enter a number.');
            }
            // If a number value doesn't match the step interval
            else if (validity.stepMismatch) {
              mess = bbn._('Please select a valid value.');
            }
            // If a number field is over the max
            else if (validity.rangeOverflow) {
              mess = bbn._('Please select a value that is no more than %d.', parseInt(elem.getAttribute('max')));
            }
            // If a number field is below the min
            else if (validity.rangeUnderflow) {
              mess = bbn._('Please select a value that is no less than %d.', parseInt(elem.getAttribute('min')));
            }
            // If pattern doesn't match
            else if (validity.patternMismatch) {
              // If pattern info is included, return custom error
              mess = bbn._('Please match the requested format.');
            }
            if (setError) {
              this.setInvalid(customMessage || mess, $this);
            }
            return false;
          }
        }
      };
      let getLastElement = elem => {
        if (bbn.cp.isComponent(elem) && elem.$refs && elem.$refs.element) {
          return getLastElement(elem.$refs.element);
        }
        return elem;
      };
      if (inp) {
        return check(getLastElement(inp)) || false;
      }
      if (ele) {
        return check(getLastElement(ele)) || false;
      }
      return true;
    },
    setInvalid(message, elem) {
      this.$emit('error', message);
      this.validationID = bbn.fn.randomString();
      if (!!message && message.length && (!elem || !bbn.fn.isDom(elem.$el))) {
        elem = this;
      }
      if (!this.$el.classList.contains('bbn-state-invalid')) {
        this.$el.classList.add('bbn-state-invalid');
        if (!!message && message.length && !!elem && bbn.fn.isDom(elem.$el)) {
          /*
          let style = document.createElement('style');
          style.id = this.validationID + '_style';
          style.innerHTML = `
            #${this.validationID} .bbn-floater {
              background-color: var(--red) !important;
              color: var(--white) !important;
            }
            #${this.validationID} .bbn-floater-arrow:after {
              background-color: var(--red) !important;
            }`;
          window.document.head.appendChild(style)
          let cont = document.createElement('div');
          cont.id = this.validationID;
          cont.innerHTML = `
            <bbn-tooltip source="${message}"
                          ref="tooltip"
                          @hook:mounted="showContent"
                          :icon="false"
                          position="bottomLeft"
                          @close="removeEle"
                          :element="element"/>
          `;
          this.$el.appendChild(cont);
          new Vue({
            el: `#${this.validationID}`,
            data(){
              return {
                element: elem.$el
              }
            },
            methods: {
              showContent(){
                this.getRef('tooltip').show();
              },
              removeEle(){
                style.remove();
                this.$el.remove();
              }
            }
          })
          */
        }
      }
      /*
      this.$once('blur', () => {
        this.$emit('removevalidation');
        if (elem && elem.$el) {
          elem.$el.focus();
        }
      });
      */
    }
  },

  /**
   * Adds the class 'bbn-input-component' to the component.
   * @event created
   * @memberof inputComponent
   */
  created() {
    this.componentClass.push('bbn-input-component');
    if (this.autosize) {
      this.componentClass.push('bbn-auto-width');
    }
  },
  mounted() {
    if (this.autofocus) {
      const ele = this.$refs.element || this.$refs.input || this.$el;
      ele.focus();
    }
    this.$on('removevalidation', () => {
      if (!!this.validationID && this.$el.classList.contains('bbn-state-invalid')) {
        this.$el.classList.remove('bbn-state-invalid');
        if (document.getElementById(this.validationID)) {
          document.getElementById(this.validationID).remove();
        }
        this.validationID = false;
      }
    });
    // I think this code is not necessary, the events are already called. Mirko
    /* const input = this.getRef('element');
    if (input && bbn.fn.isFunction(input.addEventListener)) {
      input.addEventListener('input', e => {
        e.stopImmediatePropagation();
        if (this.value !== input.value) {
          Object.defineProperty(this, 'value', {
            value: input.value,
            writable: false,
            configurable: true
          });
          this.currentValue = input.value;
          this.$emit('input', this.value);
        }
      })
      input.addEventListener('change', e => {
        this.$emit('change', this.value);
      })
    } */
  },

  watch: {
    /**
     * @watch value
     * @param newVal 
     * @memberof inputComponent
     */
    value(newVal) {
      if (newVal !== this.currentValue) {
        this.currentValue = newVal;
      }
      if (this.widget && this.widget.value !== undefined) {
        if (bbn.fn.isFunction(this.widget.value)) {
          if (this.widget.value() !== newVal) {
            this.widget.value(newVal);
          }
        } else {
          if (this.widget.value !== newVal) {
            this.widget.value = newVal;
          }
        }
      }
      if (!!newVal !== this.hasValue) {
        this.hasValue = !!newVal;
      }
    },
    currentValue(newVal) {
      if (newVal !== this.currentValue) {
        this.currentValue = newVal;
      }
    }
  }
};
export default input;
import bbnData from '../../classes/Data.js';
const keepCool = {
  data() {
    return {
      /**
       * The obejct containing the cool's timers.
       * @data {Number} [0] coolTimer
       * @memberof keepCoolComponent
       */
      coolTimers: bbnData.immunizeValue({}),
      /**
       * The interval.
       * @data {Number} [40] coolInterval
       * @memberof keepCoolComponent
       */
      coolInterval: 40
    };
  },
  methods: {
    /**
     * It will prevent the same action to be executed too many times in a row
     * On the first go the timer will be defined and the action will be executed
     * On the second go the promise will be created and returned
     * On the consecutive goes the promise will be returned
     * Once the promise is executed (after timeout) the promise will be recreated
     * @method keepCool
     * @param {Function} fn 
     * @param {Number} idx 
     * @param {Number} timeout 
     * @memberof keepCoolComponent
     */
    keepCool(fn, idx, timeout) {
      if (!idx) {
        idx = 'default';
      }
      let t = new Date().getTime();
      let delay = timeout || this.coolInterval;
      // First go of the serie: nothing exists
      if (!this.coolTimers[idx]) {
        this.coolTimers[idx] = {
          time: 0,
          promise: false
        };
      }
      // If there is a promise it has not yet been executed
      if (this.coolTimers[idx].promise) {
        return this.coolTimers[idx].promise;
      }

      // Timeout passed, function will have to be executed immediately
      let diff = delay + this.coolTimers[idx].time - t;
      if (diff > 0 && diff <= delay) {
        delay = diff;
        this.coolTimers[idx].time = t + delay;
      } else {
        delay = 0;
        this.coolTimers[idx].time = t;
      }
      this.coolTimers[idx].promise = new Promise(resolve => {
        setTimeout(() => {
          let r = fn();
          this.coolTimers[idx].time = new Date().getTime();
          resolve(r);
          this.coolTimers[idx].promise = false;
        }, delay);
      });
      return this.coolTimers[idx].promise;
    }
  }
};
export default keepCool;
const keynav = {
  methods: {
    getKeyNavTarget() {
      let list = this.getRef('list');
      if (!list && this.$is('bbn-list')) {
        list = this;
      } else if (list && !list.$is('bbn-list')) {
        list = list.getRef('list');
      } else if (!list) {
        list = this.find('bbn-list');
      }
      return list;
    },
    /**
     * States the role of the enter button on the dropdown menu.
     * @memberof keynavComponent
     * @method keynav
     * @param {Event} e
     * @fires widget.select
     * @fires widget.open
     *
     */
    keynav(e) {
      if (this.filteredData.length && bbn.var.keys.upDown.includes(e.keyCode)) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        if (!this.isOpened) {
          this.isOpened = true;
          return;
        }
        let list = this.getKeyNavTarget();
        if (list) {
          list.isOver = false;
          let idx = -1;
          let d = list.filteredData;
          if (d.length === 1) {
            list.overIdx = 0;
            return;
          }
          if (list.overIdx > -1) {
            idx = list.overIdx;
          }
          switch (e.keyCode) {
            // Arrow down
            case 40:
              list.overIdx = d[idx + 1] !== undefined ? idx + 1 : 0;
              break;
            // Arrow Up
            case 38:
              list.overIdx = d[idx - 1] !== undefined ? idx - 1 : d.length - 1;
              break;
            // Page down (10)
            case 34:
              if (list.overIdx >= d.length - 1) {
                list.overIdx = 0;
              } else {
                list.overIdx = d[idx + 10] ? idx + 10 : d.length - 1;
              }
              break;
            // Page up (10)
            case 33:
              if (list.overIdx <= 0) {
                list.overIdx = d.length - 1;
              } else {
                list.overIdx = d[idx - 10] ? idx - 10 : 0;
              }
              break;
            // End
            case 35:
              list.overIdx = d.length - 1;
              break;
            // Home
            case 36:
              list.overIdx = 0;
              break;
          }
          list.$forceUpdate();
        }
      }
    }
  }
};
export default keynav;
import bbnCp from '../../classes/Cp.js';
const list = {
  props: {
    /**
     * A function to transform the data.
     * @prop {Function} map
     * @memberof listComponent
     */
    map: {
      type: Function
    },
    /**
     * The limit of rows to be shown in a page of the list.
     * @prop {Number} [25] limit
     * @memberof listComponent
     */
    limit: {
      type: Number,
      default: 25
    },
    /**
     * The array of predefined limits.
     * @data {Array} {[10, 25, 50, 100, 250, 500]} limits
     * @memberof listComponent
     */
    limits: {
      type: Array,
      default() {
        return [10, 25, 50, 100, 250, 500];
      }
    },
    /**
     * Set to true will automatically update the data before mount.
     * @prop {Boolean} [false] autobind
     * @memberof listComponent
     */
    autobind: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true allows the list to divide itself in different pages basing on the property limit.
     * @prop {Boolean} [false] pageable
     * @memberof listComponent
     */
    pageable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true allows list's columns to be sortable.
     * @prop {Boolean} [false] sortable
     * @memberof listComponent
     */
    sortable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true allows the columns of the list to be filtered. A filter icon will appear at the top of each column.The property can be given to each column to define different behaviour.
     * @prop {Boolean} [false] filterable
     * @memberof listComponent
     */
    filterable: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true enable the multifilter of the component. An icon will appear on the bottom right of the list. By clicking on the icon a popup with the multifilter will open.
     * @prop {Boolean} [false] multifilter
     * @memberof listComponent
     */
    multifilter: {
      type: Boolean,
      default: false
    },
    /**
     * In case of Ajax source, set to true will make an Ajax call for the data when changing page of the list.
     * @prop {Boolean} [true] serverPaging
     * @memberof listComponent
     */
    serverPaging: {
      type: Boolean,
      default: true
    },
    /**
     * In case of Ajax source, set to true will make an Ajax call for the sorting of the list.
     * @prop {Boolean} [true] serverSorting
     * @memberof listComponent
     */
    serverSorting: {
      type: Boolean,
      default: true
    },
    /**
     * In case of Ajax source, set to true will make an Ajax call for the filter of the list.
     * @prop {Boolean} [true] serverFiltering
     * @memberof listComponent
     */
    serverFiltering: {
      type: Boolean,
      default: true
    },
    /**
     * Defines the order of the columns in the component.
     * @prop {Array|Object} [[]] order
     * @memberof listComponent
     */
    order: {
      type: [Array, Object],
      default() {
        return [];
      }
    },
    /**
     * Defines the filters of the component.
     * @prop {Object} [{logic: 'AND',conditions: []}] filters
     * @memberof listComponent
     */
    filters: {
      type: Object,
      default() {
        return {
          logic: 'AND',
          conditions: []
        };
      }
    },
    /**
     * If the prop selection is set to true defines which items has to be selected.
     * @prop {Array} selected
     * @memberof listComponent
     */
    selected: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Set to true shows a checkbox in each rows in the first column of the list.
     * @prop {Boolean|Function} selection
     * @memberof listComponent
     */
    selection: {
      type: [Boolean, Function],
      default: false
    },
    /**
     * Set to true selecting an item will unselect any other selected item.
     * @prop {Boolean} multiple
     * @memberof listComponent
     */
    multiple: {
      type: Boolean,
      default: false
    },
    /**
     * Given to a column that has the property type set to 'money' defines the currency.
     * @prop {String} currency
     * @memberof listComponent
     */
    currency: {
      type: String
    },
    /**
     * The data sent in the ajax call.
     * @prop {String|Function} [{}] data
     * @memberof listComponent
     */
    data: {
      type: [Object, Function],
      default() {
        return {};
      }
    },
    /**
     * Defines the message to show when the list has no data.
     * @prop {String} ['No data...'] noData
     * @memberof listComponent
     */
    noData: {
      type: String,
      default: bbn._('No data') + '...'
    },
    /**
     * The uid of the list.
     * @prop {String} uid
     */
    uid: {
      type: String
    },
    /**
     * The source of the component.
     * @prop {Array|Object|String|Function} source
     * @memberof listComponent
     */
    source: {
      type: [Array, Object, String, Function],
      default() {
        return [];
      }
    },
    /**
     * The name of the property to be used as text.
     * @prop {String} ['text'] sourceText
     * @memberof listComponent
     */
    sourceText: {
      type: String,
      default: "text"
    },
    /**
     * The name of the property to be used as value.
     * @prop {String} ['value'] sourceValue
     * @memberof listComponent
     */
    sourceValue: {
      type: String,
      default: "value"
    },
    /**
     * If source is a function this index can be passed to the function.
     * @prop {Number} sourceIndex
     * @memberof listComponent
     */
    sourceIndex: {
      type: Number
    },
    /**
     * The name of the property to be used as icon.
     * @prop {String} sourceIcon
     * @memberof listComponent
     */
    sourceIcon: {
      type: String
    },
    /**
     * The name of the property to be used as image.
     * @prop {String} sourceImg
     * @memberof listComponent
     */
    sourceImg: {
      type: String
    },
    /**
     * The name of the property to be used as class.
     * @prop {String} sourceCls
     * @memberof listComponent
     */
    sourceCls: {
      type: String
    },
    /**
     * The name of the property to be used as action to execute when selected.
     * @prop {String} sourceAction
     * @memberof listComponent
     */
    sourceAction: {
      type: [String, Function]
    },
    /**
     * The name of the property to be used as URL to go to when selected.
     * @prop {String} sourceUrl
     * @memberof listComponent
     */
    sourceUrl: {
      type: [String, Function]
    },
    /**
     * The name of the property to use for children of hierarchical source
     * @prop {String} [items] children
     * @memberof listComponent
     */
    children: {
      type: String,
      default: 'items'
    },
    /**
     * The mode of the component.
     * Possible values: 'free', 'options', 'selection'.
     * @prop {String} ['free'] mode
     */
    mode: {
      type: String,
      default: "free",
      validator: m => ['free', 'options', 'selection'].includes(m)
    },
    /**
     * A component for each element of the list.
     * @memberof listComponent
     * @prop {String|Object|bbnCp} component
     */
    component: {
      type: [String, Object, bbnCp]
    },
    /**
     * The template to costumize the dropdown menu.
     * @memberof listComponent
     * @prop template
     */
    template: {},
    /**
     * @prop {String} query
     * @memberof listComponent
     */
    query: {
      type: String
    },
    /**
     * The query values object.
     * @prop {Object} queryValues
     * @memberof listComponent
     */
    queryValues: {
      type: Object
    },
    /**
     * @prop {Object} hierarchy
     * @memberof listComponent
     */
    hierarchy: {
      type: Boolean,
      default: false
    },
    /** 
     *  The tree will be shown on one level, with .. at the top, clicking an element with children will enter it
     */
    flat: {
      type: Boolean,
      default: false
    },
    /**
     * Enables the search mode
     * @prop {Boolean} [false] search
     */
    search: {
      type: Boolean,
      default: false
    },
    /**
     * @todo not used in the component
     */
    searchFields: {
      type: Array
    },
    /**
     * The operator used by filterString filter
     * @prop {String} ['startswith'] searchOperator
     */
    searchOperator: {
      type: String,
      default: 'startswith'
    }
  },
  data() {
    let order = this.order;
    if (this.sortable && this.order && typeof this.order === 'object' && !Array.isArray(this.order)) {
      order = [];
      for (let n in this.order) {
        order.push({
          field: n,
          dir: this.order[n]
        });
      }
    }
    return {
      /**
       * If true it's the first time the data is loaded.
       * @data {Boolean} [false] _1strun
       * @memberof listComponent
       */
      _1strun: false,
      /**
       * _dataPromise
       * @memberof listComponent
       * @data {Boolean, Promise} [false] _dataPromise
       */
      _dataPromise: false,
      /**
       * If source is a URL and auto is set to true, component will fetch data at mount.
       * @data {Boolean} [false] auto 
       * @memberof listComponent
       */
      auto: true,
      /**
       * The current template of the component.
       * @data {String} [false] currentTemplate
       * @memberof listComponent
       */
      currentTemplate: this.template,
      /**
       * The current component of the component.
       * @data {String|bbnCp|Object} [false] currentComponent
       * @memberof listComponent
       */
      currentComponent: this.component || null,
      /**
       * 
       * @data {Boolean} [false] currentIndex
       * @memberof listComponent
       */
      currentIndex: false,
      /**
       * @data {Boolean} [false] currentFilter
       * @memberof listComponent
       */
      currentFilter: false,
      /**
       * The current filters of the list.
       * @memberof listComponent
       * @data {Object} currentFilters
       */
      currentFilters: bbn.fn.clone(this.filters),
      /**
       * The current limit of items in the list.
       * @memberof listComponent
       * @data {Number} [25] currentLimit
       */
      currentLimit: this.limit,
      /**
       * The current start index of the list.
       * @memberof listComponent
       * @data {Number} [0] currentStart
       */
      currentStart: this.start,
      /**
       * The current order of the list.
       * @memberof listComponent
       * @data {Object} currentOrder
       */
      currentOrder: order,
      /**
       * The current data of the list.
       * @memberof listComponent
       * @data {Array} [[]] currentData
       */
      currentData: [],
      /**
       * The current total of items in the list.
       * @memberof listComponent
       * @data {Number} [0] currentTotal
       */
      currentTotal: 0,
      /**
       * The start index.
       * @data {Number} [0] start
       * @memberof listComponent
       */
      start: 0,
      /**
       * The total of items in the list. 
       * @data {Number} [0] total
       * @memberof listComponent
       */
      total: 0,
      /**
       * True if the list is loading data.
       * @data {Boolean} [false] isLoading
       * @memberof listComponent 
       */
      isLoading: false,
      /**
       * True if the list has been loaded.
       * @data {Boolean} [false] isLoaded
       * @memberof listComponent 
       */
      isLoaded: this.source !== 'string',
      /**
       * True if the source of the list is a string.
       * @data {Boolean} isAjax
       * @memberof listComponent 
       */
      isAjax: typeof this.source === 'string',
      /**
       * @todo change name
       * @data {Array} [[]] selectedRows
       */
      currentSelected: this.selected.slice(),
      /**
       * True if the list is filterable.
       * @data {Boolean} [false] isFilterable
       * @memberof listComponent
       */
      isFilterable: this.filterable,
      /**
       * True if the list has selection enabled.
       * @data {Boolean} [false] hasSelection
       */
      hasSelection: !!this.selection,
      /**
       * The original data of the list.
       * @data [null] originalData
       * @memberof listComponent
       */
      originalData: null,
      /**
       * @data {String} filterString
       * @memberof listComponent
       */
      filterString: this.textValue || '',
      /**
       * @memberof listComponent
       * @data {false, Number} filterTimeout
       */
      filterTimeout: false,
      /**
       * The current query.
       * @data {String} currentQuery
       * @memberof listComponent
       */
      currentQuery: this.query,
      /**
       * The current query values.
       * @data {Object} currentQueryValues
       * @memberof listComponent 
       */
      currentQueryValues: this.queryValues || {},
      /**
       * The id of the loading request.
       * @data{Boolean} [false] loadingRequestID
       * @memberof listComponent 
       */
      loadingRequestID: false,
      /**
       * If hirarchy and uid and flat will be set to the last entered node UID
       * @data {false|String} the UID of the last entered node
       */
      parentUid: false,
      /**
       * @data {null|String} An ID given with the search results
       */
      searchId: null,
      /**
       * @data {String} [''] searchValue
       */
      searchValue: ''
    };
  },
  computed: {
    /**
     * The current limits.
     * @computed currentLimits
     * @memberof listComponent
     */
    currentLimits() {
      if (!this.pageable) {
        return [];
      }
      let pass = false;
      return bbn.fn.filter(this.limits.slice().sort(), a => {
        if (a > this.total) {
          if (!pass) {
            pass = true;
            return true;
          }
          return false;
        }
        return true;
      });
    },
    /**
     * Returns true if a component has been defined for the list.
     * @computed hasComponent
     * @memberof listComponent
     */
    hasComponent() {
      return bbn.fn.isString(this.component) || bbn.fn.isObject(this.component) && Object.keys(this.component).length || this.currentTemplate ? true : false;
    },
    /**
     * Returns the component object. 
     * @computed realComponent
     * @memberof listComponent
     */
    realComponent() {
      let cp = bbn.fn.isString(this.component) || bbn.fn.isObject(this.component) && Object.keys(this.component).length ? this.component : null;
      if (!cp && this.currentTemplate) {
        cp = bbn.cp.normalizeComponent({
          props: ['source'],
          data() {
            return this.source;
          },
          template: this.currentTemplate
        });
      }
      return cp;
    },
    /**
     * Return the number of pages of the list.
     * @computed numPages
     * @memberof listComponent
     * @return {number}
     */
    numPages() {
      if (this.isAjax) {
        return Math.ceil(this.total / this.currentLimit);
      }
      return Math.ceil(this.filteredTotal / this.currentLimit);
    },
    /**
     * Return the current page of the list.
     * @computed currentPage
     * @memberof listComponent
     * @fires updateData
     * @return {Number}
     */
    currentPage: {
      get() {
        return Math.ceil((this.start + 1) / this.currentLimit);
      },
      set(val) {
        if (this.ready) {
          this.start = val > 1 ? (val - 1) * this.currentLimit : 0;
          this.updateData(!this.serverPaging);
        }
      }
    },
    filteredTotal() {
      return this.filteredData.length;
    },
    /** @todo Remove: no sense and not used in any component */
    valueIndex() {
      if (this.value || this.selected && this.selected.length) {
        let v = this.value || this.selected[0];
        if (this.uid) {
          return bbn.fn.search(this.filteredData, a => {
            return a.data[this.uid] === v;
          });
        } else if (this.sourceValue) {
          return bbn.fn.search(this.filteredData, a => {
            return bbn.fn.getProperty(a.data, this.sourceValue) === v;
          });
        }
      }
      return -1;
    },
    isAutobind() {
      if (this.autobind === false || this.isAjax && this.autocomplete && this.filterString.length < this.minLength) {
        return false;
      }
      return true;
    },
    hashCfg() {
      return bbn.fn.md5(JSON.stringify(this.currentFilters) + JSON.stringify(this.currentLimit) + JSON.stringify(this.start) + JSON.stringify(this.currentOrder));
    },
    /**
     * Returns the current item icon
     * @computed currentItemIcon
     * @memberof listComponent
     * @return {String}
     */
    currentItem() {
      if (this.value !== undefined && !bbn.fn.isNull(this.value) && this.sourceValue && this.currentData.length) {
        let idx = bbn.fn.search(this.currentData, a => {
          return bbn.fn.getProperty(a.data, this.sourceValue) === this.value;
        });
        if (idx > -1) {
          return this.currentData[idx].data;
        }
      }
      return null;
    },
    /**
     * Returns the current item icon
     * @computed currentItemIcon
     * @memberof listComponent
     * @return {String}
     */
    currentItemIcon() {
      if (this.currentItem && this.sourceIcon) {
        return this.currentItem[this.sourceIcon];
      }
      return '';
    },
    /**
     * Returns the current item image
     * @computed currentItemImg
     * @memberof listComponent
     * @return {String}
     */
    currentItemImg() {
      if (this.currentItem && this.sourceImg) {
        return this.currentItem[this.sourceImg];
      }
      return '';
    },
    /**
     * Returns the current item class
     * @computed currentItemCls
     * @memberof listComponent
     * @return {String}
     */
    currentItemCls() {
      if (this.currentItem && this.sourceCls) {
        return this.currentItem[this.sourceCls];
      }
      return '';
    },
    filteredData() {
      //bbn.fn.warning("FILTERING DATA")
      if (this.currentData.length && this.currentFilters && this.currentFilters.conditions && this.currentFilters.conditions.length && (!this.serverFiltering || !this.isAjax)) {
        return bbn.fn.filter(this.currentData, a => {
          return this._checkConditionsOnItem(this.currentFilters, a.data);
        });
      } else {
        return this.currentData;
      }
    }
  },
  methods: {
    /**
     * Returns the data changed using the function given in the prop map.
     * @method _map
     * @param data
     */
    _map(data) {
      if (bbn.fn.isArray(data)) {
        if (data.length && !bbn.fn.isObject(data[0]) && !bbn.fn.isArray(data[0]) && this.sourceValue && this.sourceText) {
          data = data.map(a => {
            let o = {};
            bbn.fn.setProperty(o, this.sourceValue, a);
            bbn.fn.setProperty(o, this.sourceText, a);
            return o;
          });
        }
        return (this.map ? data.map(this.map) : data).slice();
      }
      return [];
    },
    /**
     * Compares the values of the given row basing on the where operator and value.
     *  
     * @method _checkConditionsOnItem
     * @param {Object} where 
     * @param {Object} row 
     * @return {Boolean}
     */
    _checkConditionsOnItem(where, row) {
      let pass = false;
      if (where.conditions && where.logic && typeof row === 'object') {
        pass = where.logic !== 'OR';
        for (let i = 0; i < where.conditions.length; i++) {
          let cond = where.conditions[i],
            res = true;
          if (cond.conditions && cond.logic) {
            res = this._checkConditionsOnItem(cond, row);
          } else if (cond.field && cond.operator) {
            res = bbn.fn.compare(row[cond.field], cond.value !== undefined ? cond.value : null, cond.operator);
          }
          if (!res && where.logic !== 'OR') {
            pass = false;
            break;
          } else if (res && where.logic === 'OR') {
            pass = true;
            break;
          }
        }
      }
      return pass;
    },
    /**
     * Checks if the field's name is valid (0 must be accepted)
     *
     * @param {*} field
     * @return {*} 
     */
    isValidField(field) {
      return bbn.fn.isString(field) || bbn.fn.isNumber(field);
    },
    /**
      * @method select
      */
    select() {
      bbn.fn.log("SLECT LIST");
      //this.$emit('select', this.currentIndex);
    },

    /**
      * Pushes the given filter in the currentFilters of the list.
      * @method onSetFilter
      * @param {Object} filter 
      */
    onSetFilter(filter) {
      if (filter && filter.field && filter.operator) {
        if (this.multi) {
          this.currentFilters.conditions.push(filter);
        } else if (filter.field) {
          let idx = bbn.fn.search(this.currentFilters.conditions, {
            field: filter.field
          });
          if (idx > -1) {
            this.currentFilters.conditions.splice(idx, 1, filter);
          } else {
            this.currentFilters.conditions.push(filter);
          }
        }
      }
    },
    /**
      * Fires the method removeFilter to remove a group of conditions from currentFilters.
      * @method onUnsetFilter
      * @param {Object} filter
      * @fires removeFilter
      */
    onUnsetFilter(filter) {
      //bbn.fn.log("onUnset", filter);
      this.removeFilter(filter);
    },
    /**
      * Removes a group of conditions from currentFilters.
      * @method removeFilter
      * @param {Object} condition
      * @fires getPopup
      */
    removeFilter(condition) {
      if (condition.time) {
        //bbn.fn.log("There is the time", condition);
        let del = arr => {
          let idx = bbn.fn.search(arr, {
            time: condition.time
          });
          //bbn.fn.log("Is there the index?", idx);
          if (idx > -1) {
            if (arr[idx].conditions && arr[idx].conditions.length) {
              this.getPopup().confirm(bbn._("Are you sure you want to delete this group of conditions?"), () => {
                arr.splice(idx, 1);
                if (window.appui) {
                  window.appui.success();
                }
              });
            } else {
              arr.splice(idx, 1);
              if (window.appui) {
                window.appui.success();
              }
            }
            return true;
          }
          for (let i = 0; i < arr.length; i++) {
            if (arr[i].conditions) {
              if (del(arr[i].conditions)) {
                return true;
              }
            }
          }
        };
        if (del(this.currentFilters.conditions)) {
          this.$forceUpdate();
        }
      }
    },
    /**
      * Unsets the current filter.
      * @method unsetFilter
      */
    unsetFilter() {
      this.currentFilters = bbn.fn.clone(this.filters);
      this.currentFilter = false;
      this.editedFilter = false;
    },
    /**
      * Unsets the current filter.
      * @method unsetCurrentFilter
      * 
      */
    unsetCurrentFilter() {
      if (this.editedFilter) {
        let idx = bbn.fn.search(this.currentFilters.conditions, {
          time: this.editedFilter.time
        });
        if (idx > -1) {
          this.currentFilters.conditions.splice(idx, 1);
        }
      }
    },
    getPostData() {
      if (this.data) {
        return bbn.fn.isFunction(this.data) ? this.data() : this.data;
      }
      return {};
    },
    beforeUpdate() {
      let e = new Event('beforeupdate', {
        cancelable: true
      });
      this.$emit('beforeupdate', e);
      return e.defaultPrevented ? false : true;
    },
    afterUpdate() {
      return true;
    },
    getData() {
      let data = {
        limit: this.currentLimit,
        start: this.start,
        data: this.getPostData()
      };
      if (this.sortable) {
        data.order = this.currentOrder;
      }
      if (this.isFilterable) {
        data.filters = this.currentFilters;
      }
      if (this.showable) {
        data.fields = this.shownFields;
      }
      return data;
    },
    treatData(data) {
      if (this.parentUid && this.hierarchy && this.flat && this.uid) {
        data.unshift({
          [this.uid]: this.parentUid,
          [this.sourceText]: ".."
        });
      }
      data = this._map(data);
      return bbn.fn.map(data, (a, i) => {
        /** @todo Is it compatible with the fact of updating the source when given an array */
        let o = this.hierarchy ? bbn.fn.extend(true, a, {
          index: i,
          key: this.isAjax ? i + '-' + this.hashCfg : i,
          _bbn: true
        }) : {
          data: a,
          index: i,
          key: this.isAjax ? i + '-' + this.hashCfg : i,
          _bbn: true
        };
        if (this.children && a[this.children] && a[this.children].length) {
          o.opened = true;
        }
        if (this.hasSelection) {
          if (this.uid) {
            o.selected = this.selected.includes(a[this.uid]);
          } else if (this.sourceValue) {
            o.selected = this.selected.includes(bbn.fn.getProperty(a, this.sourceValue));
          }
        }
        return o;
      });
    },
    async updateData(preventLoad) {
      if (this.beforeUpdate() !== false) {
        this._dataPromise = new Promise(resolve => {
          let prom;
          let loadingRequestID;
          if (this.isAjax) {
            if (this.loadingRequestID) {
              bbn.fn.abort(this.loadingRequestID);
              setTimeout(() => {
                this.loadingRequestID = false;
                this.updateData().then(() => {
                  resolve();
                });
              }, 50);
              return;
            }
            if (this._1strun && preventLoad === true) {
              prom = new Promise(resolve => {
                setTimeout(() => {
                  resolve({
                    data: this.currentData,
                    total: this.currentTotal
                  });
                });
              });
            } else {
              this.isLoading = true;
              this.$emit('startloading');
              let data = this.getData();
              loadingRequestID = bbn.fn.getRequestId(this.source, data);
              this.loadingRequestID = loadingRequestID;
              prom = this.post(this.source, data);
            }
          } else {
            prom = new Promise(resolve2 => {
              let data = [];
              if (bbn.fn.isArray(this.source)) {
                data = this.source;
              } else if (bbn.fn.isFunction(this.source)) {
                data = this.source(this.sourceIndex, this.data);
              } else if (bbn.fn.isObject(this.source)) {
                bbn.fn.iterate(this.source, (a, n) => {
                  let o = {};
                  bbn.fn.setProperty(o, this.sourceValue, n);
                  bbn.fn.setProperty(o, this.sourceText, a);
                  data.push(o);
                });
              }
              resolve2({
                data: data,
                total: data.length
              });
            });
          }
          if (!prom) {
            return;
          }
          prom.then(d => {
            if (this.isAjax) {
              if (!this.loadingRequestID || this.loadingRequestID !== loadingRequestID) {
                this.isLoading = false;
                this.loadingRequestID = false;
                throw new Error("No loading request");
              }
              this.isLoading = false;
              this.loadingRequestID = false;
              if (!d) {
                return;
              }
              if (d.status !== 200) {
                d.data = undefined;
              } else {
                d = d.data;
              }
              this.$emit('datareceived', d);
            }
            if (d && bbn.fn.isArray(d.data)) {
              if (d.data.length && d.data[0]._bbn) {
                this.currentData = d.data;
                this.updateIndexes();
              } else {
                this.currentData = this.treatData(d.data);
              }
              if (d.query) {
                this.currentQuery = d.query;
                this.currentQueryValues = d.queryValues || {};
              }
              if (d.order) {
                this.currentOrder.splice(0, this.currentOrder.length);
                this.currentOrder.push({
                  field: d.order,
                  dir: (d.dir || '').toUpperCase() === 'DESC' ? 'DESC' : 'ASC'
                });
              }
              this.total = d.total || this.filteredData.length;
              /** @todo Observer part to dissociate */
              if (d.observer && bbn.fn.isFunction(this.observerCheck) && this.observerCheck()) {
                this._observerReceived = d.observer.value;
                this.observerID = d.observer.id;
                this.observerValue = d.observer.value;
                if (!this._1strun) {
                  this.observerWatch();
                }
              }
              if (!this._1strun) {
                this._1strun = true;
                this.$emit('firstrun');
              }
            }
            this.afterUpdate();
            resolve(this.currentData);
            if (!this.isLoaded) {
              this.isLoaded = true;
            }
            this.$forceUpdate();
            this.$emit('dataloaded', d);
          });
        }).catch(e => {
          bbn.fn.log("Better catching should be done here");
          this.isLoading = false;
          this.loadingRequestID = false;
        });
        return this._dataPromise;
      }
    },
    updateIndexes() {
      if (this.currentData.length) {
        bbn.fn.each(this.currentData, (a, i) => {
          if (a.index !== i) {
            this.$set(this.currentData[i], 'index', i);
            //a.index = i;
          }
        });
      }
    },

    /**
      * Deletes all the current data from the view.
      * @method realDelete
      * @emit delete
      * @param {Number} index
      */
    emptyData() {
      if (this.currentData) {
        this.currentData.splice(0, this.currentData.length);
      }
    },
    /**
      * Deletes the row defined by param index.
      * @method realDelete
      * @emit delete
      * @param {Number} index
      */
    realDelete(index) {
      if (this.currentData[index]) {
        let ev = new Event('delete');
        if (this.url) {
          this.post(this.url, bbn.fn.extend({}, this.data, this.currentData[index].data, {
            action: 'delete'
          }), d => {
            if (d.success) {
              let data = this.currentData[index].data;
              this.currentData.splice(index, 1);
              if (!this.isAjax && bbn.fn.isArray(this.source)) {
                let idx = bbn.fn.search(this.source, data);
                if (idx > -1) {
                  this.source.splice(idx, 1);
                }
              }
              this.total--;
              this.updateIndexes();
              this.$emit('delete', data, ev);
              if (window.appui) {
                window.appui.success(bbn._('Deleted successfully'));
              }
            } else {
              this.alert(bbn._("Impossible to delete the row"));
            }
          });
        } else {
          let data = this.currentData[index].data;
          this.currentData.splice(index, 1);
          if (!this.isAjax && bbn.fn.isArray(this.source)) {
            let idx = bbn.fn.search(this.source, data);
            if (idx > -1) {
              this.source.splice(idx, 1);
            }
          }
          this.total--;
          if (this.originalData) {
            this.originalData.splice(index, 1);
          }
          this.updateIndexes();
          this.$emit('delete', data, ev);
        }
      }
    },
    /**
      * Add the given row to currentData
      * @method add
      * @param {Object} data
      * @todo
      *
      */
    add(data) {
      this.currentData.push({
        data: data,
        index: this.currentData.length
      });
      if (!this.isAjax && bbn.fn.isArray(this.source)) {
        this.source.push(data);
      }
    },
    /**
      * Fires the method realDelete to delete the row.
      * @method delete
      * @param {Number} index
      * @param {Strimg} confirm
      * @fires realDelete
      * @emit beforedelete
      */
    deleteItem(index, confirm) {
      if (this.filteredData[index]) {
        let ev = new Event('delete', {
          cancelable: true
        });
        this.$emit('beforedelete', index, this.filteredData[index].data, this, ev);
        if (!ev.defaultPrevented) {
          if (confirm === undefined) {
            confirm = this.confirmMessage;
          }
          if (confirm) {
            this.confirm(confirm, () => {
              this.realDelete(this.filteredData[index].index);
            });
          } else {
            this.realDelete(this.filteredData[index].index);
          }
        }
      }
    },
    /**
      * Fires the metod updateData to refresh the current data set.
      * @method reload
      * @fires updateData
      */
    reload() {
      return this.updateData();
    },
    getIndex(filter) {
      if (!bbn.fn.isObject(filter) && this.uid) {
        filter = {
          [this.uid]: filter
        };
      }
      let fltr = bbn.fn.filterToConditions(filter);
      let idx = -1;
      bbn.fn.each(this.filteredData, (a, i) => {
        if (bbn.fn.compareConditions(a.data, fltr)) {
          idx = i;
          return false;
        }
      });
      return idx;
    },
    /**
      * Removes the row defined by the where param from currentData
      * @method remove
      * @param {Object} where
      */
    remove(where) {
      let idx;
      if (bbn.fn.isNumber(where)) {
        idx = where;
        this.realDelete(this.filteredData[idx].index, 1);
      } else {
        while ((idx = bbn.fn.search(this.filteredData, a => {
          return bbn.fn.compareConditions(a.data, where);
        })) > -1) {
          this.realDelete(this.filteredData[idx].index, 1);
        }
      }
      this.$forceUpdate();
    },
    listOnBeforeMount() {
      if (this.isAutobind) {
        this.updateData();
      }
    }
  },
  beforeMount() {
    this.listOnBeforeMount();
  },
  mounted() {
    var _this$$slots$default;
    if (!this.component && !this.template && (_this$$slots$default = this.$slots.default) !== null && _this$$slots$default !== void 0 && _this$$slots$default.length) {
      let tpl = this.getRef('slot');
      if (tpl) {
        this.currentTemplate = tpl.innerHTML;
        //bbn.fn.warning("BLOCK TEMPLATE FOUND");
        //bbn.fn.log(this.currentTemplate);
      }
    }

    this.currentComponent = this.realComponent;
  },
  watch: {
    filters: {
      handler(v) {
        this.$set(this, 'currentFilters', v);
      }
    },
    /**
      * @watch currentLimit
      * @fires setConfig
      */
    currentLimit() {
      if (this.ready && bbn.fn.isFunction(this.setConfig)) {
        this.setConfig(true);
      }
    },
    /**
      * @watch currentFilters
      * @fires updateData
      * @fires setConfig
      */
    currentFilters: {
      deep: true,
      handler() {
        if (this.ready) {
          this.currentFilter = false;
          if (this.pageable && this.start) {
            this.start = 0;
          }
          if (this.autobind) {
            this.updateData();
          }
          if (bbn.fn.isFunction(this.setConfig)) {
            this.setConfig(true);
          }
        }
      }
    },
    /**
      * @watch currentOrder
      * @fires setConfig
      */
    currentOrder: {
      deep: true,
      handler() {
        if (this.ready) {
          if (bbn.fn.isFunction(this.setConfig)) {
            this.setConfig(true);
          }
          this.$forceUpdate();
        }
      }
    },
    /**
      * 
      */
    searchValue(v) {
      if (this.search) {
        this.unsetFilter();
        if (v) {
          let cond = [];
          if (this.searchFields) {
            bbn.fn.each(this.searchFields, a => {
              cond.push({
                field: a,
                operator: 'contains',
                value: v
              });
            });
          } else {
            bbn.fn.each(this.cols, a => {
              if (a.field && !bbn.fn.getRow(cond, {
                field: a.field
              })) {
                cond.push({
                  field: a.field,
                  operator: 'contains',
                  value: v
                });
              }
            });
          }
          this.currentFilters.conditions.push({
            logic: 'OR',
            conditions: cond
          });
        }
      }
    }
  }
};
export default list;
const localStorage = {
  statics() {
    let _storage = false;
    if (window.localStorage) {
      _storage = {
        get(name) {
          let tmp = window.localStorage.getItem(name);
          if (tmp) {
            tmp = JSON.parse(tmp);
            return tmp.value;
          }
        },
        set(name, value) {
          return window.localStorage.setItem(name, JSON.stringify({
            value: value,
            time: new Date().getTime()
          }));
        },
        time(name) {
          let tmp = window.localStorage.getItem(name);
          if (tmp) {
            tmp = JSON.parse(tmp);
            return tmp.time;
          }
          return false;
        },
        remove(name) {
          return window.localStorage.removeItem(name);
        },
        clear() {
          return window.localStorage.clear();
        }
      };
    }
    return {
      _storage
    };
  },
  props: {
    /**
     * True if the component has to have storage.
     * @prop {Boolean} [false] storage
     * @memberof localStorageComponent
     */
    storage: {
      type: Boolean
    },
    /**
     * The name of the storage.
     * @prop {String} ['default'] storageName
     * @memberof localStorageComponent
     */
    storageName: {
      type: String,
      default: 'default'
    },
    /**
     * The fullname of the storage.
     * @prop {String} storageFullName
     * @memberof localStorageComponent
     */
    storageFullName: {
      type: String
    }
  },
  data() {
    return {
      storageChangeDate: '2019-01-01 00:00:00'
    };
  },
  computed: {
    /**
     *  _storage
     * @memberof localStorageComponent
     * 
     */
    _storage() {
      return this.constructor._storage;
      if (window.localStorage) {
        return {};
      }
      return false;
    },
    /**
     * Returns if the component has storage.
     * @memberof localStorageComponent
     * @computed {Boolean} hasStorage
     */
    hasStorage() {
      if (this.storage === false) {
        return false;
      }
      return (this.storage || this.storageFullName || this.storageName !== 'default') && !!this._storage;
    },
    /**
     * Returns the storage's default name.
     * @computed storageDefaultName 
     * @returns {String}
     */
    storageDefaultName() {
      return this._getStorageRealName();
    }
  },
  methods: {
    /**
     * Returns the complete path of the storage.
     * @method _getStorageRealName
     * @param {String} name 
     * @returns{String}
     * @memberof localStorageComponent
     */
    _getStorageRealName(name) {
      if (this.storageFullName) {
        return this.storageFullName;
      }
      let st = '';
      if (this.$options.name) {
        st += this.$options.name + '-';
      }
      if (name) {
        st += name;
      } else {
        st += bbn.fn.substr(window.location.pathname, 1) + '-' + this.storageName;
      }
      return st;
    },
    /**
     * Returns the computed _storage
     * @method getStorage
     * @param {String} name 
     * @param {Boolean} isFullName
     * @returns {Boolean|String}
     * @memberof localStorageComponent
     */
    getStorage(name, isFullName) {
      if (this.hasStorage) {
        return this._storage.get(isFullName ? name : this._getStorageRealName(name));
      }
      return false;
    },
    /**
     * Sets the computed _storage.
     * @method setStorage
     * @param value 
     * @param {String} name 
     * @param {Boolean} isFullName
     * @returns {Boolean}
     * @memberof localStorageComponent
     */
    setStorage(value, name, isFullName) {
      if (this.hasStorage) {
        return this._storage.set(isFullName ? name : this._getStorageRealName(name), value);
      }
      return false;
    },
    /**
     * Unsets the computed _storage.
     * @method unsetStorage
     * @param {String} name 
     * @param {Boolean} isFullName
     * @memberof localStorageComponent
     */
    unsetStorage(name, isFullName) {
      if (this.hasStorage) {
        return this._storage.remove(isFullName ? name : this._getStorageRealName(name));
      }
      return false;
    }
  },
  /**
   * Adds the class bbn-local-storage-component to the component.
   * @event created
   * @memberof localStorageComponent
   */
  created() {
    if (this.hasStorage) {
      this.componentClass.push('bbn-local-storage-component');
    }
  }
};
export default localStorage;
const memory = {
  props: {
    /**
     * The object memory or a function that returns the object.
     * @prop {Object|Function} memory
     * @memberof memoryComponent
     */
    memory: {
      type: [Object, Function]
    }
  },
  /**
   * Adds the class 'bbn-memory-component' to the component.
   * @event created
   * @memberof memoryComponent
   */
  created() {
    this.componentClass.push('bbn-memory-component');
  }
};
export default memory;
const observer = {
  props: {
    /**
     * True if the component has to have an observer.
     * @prop {Boolean} [true] observer
     * @memberof observerComponent
     */
    observer: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * Integration of the functionnality is done through a watcher on this property
       * @data {Array} [[]] observersCopy
       * @memberof observerComponent
       */
      observersCopy: [],
      /**
       * Integration of the functionnality is done through a watcher on this property
       * @data {Boolean} observersDirty
       * @memberof observerComponent
       */
      observerDirty: false,
      /**
       * The value of the observer.
       * @memberof observerComponent
       * @data observerValue
       */
      observerValue: null,
      /**
       * The array of observers.
       * @data {Array} observers
       * @memberof observerComponent
       */
      observers: [],
      /**
       * The id of the observer.
       * @data observerID
       * @memberof observerComponent
       */
      observerID: null,
      /**
       * The closest ancestor 'bbn-obsever';
       * @data {bbnCp} observationTower
       * @memberof observerComponent
       */
      observationTower: null,
      /**
       * The uid of the observer.
       * @data {String} observerUID
       * @memberof observerComponent
       */
      observerUID: bbn.fn.randomString().toLowerCase()
    };
  },
  methods: {
    /**
     * Returns true if the prop observer is set to true and an observerionTower is found.
     * @method observerCheck
     * @return {Boolean}
     * @memberof observerComponent
     */
    observerCheck() {
      return !!(this.observer && this.observationTower);
    },
    /**
     * Returns true if the observer has a value.
     * @method isObserved
     * @return {Boolean}
     * @memberof observerComponent
     */
    isObserved() {
      return this.observerCheck() && this.observerValue;
    },
    /**
     * Updates the observer.
     * @method observerWatch
     * @fires isObserved
     * @memberof observerComponent
     */
    observerWatch() {
      if (this.isObserved()) {
        //bbn.fn.log("----------------isObserved--------------", this.$el);
        this.observationTower.observerRelay({
          element: this.observerUID,
          id: this.observerID,
          value: this.observerValue
        });
        setTimeout(() => {
          this.observationTower.$on('bbnobserver' + this.observerUID + this.observerID, newVal => {
            //bbn.fn.log("NEW VALUE!");
            // Integration of the functionnality is done through a watcher on this property
            this.observerDirty = true;
            this.observerValue = newVal;
          });
        }, 100);
      }
    },
    /**
     * @method observerRelay
     * @memberof observerComponent
     */
    observerRelay(obs) {
      if (this.observer) {
        //bbn.fn.log("----------------observerRelay--------------", this.$el)
        let idx = bbn.fn.search(this.observers, {
          id: obs.id,
          element: obs.element
        });
        if (idx > -1) {
          if (this.observers[idx].value !== obs.value) {
            this.observers.splice(idx, 1, obs);
          }
        } else {
          this.observers.push(obs);
          if (this.observerCheck()) {
            this.observationTower.$on('bbnobserver' + obs.element + obs.id, newVal => {
              this.observerEmit(newVal, obs);
            });
          }
        }
        if (this.observerCheck()) {
          this.observationTower.observerRelay(bbn.fn.clone(obs));
        }
      }
    },
    /**
     * Emits the event bbnObs.
     * @method observerEmit
     * @param {String|Number} newVal 
     * @param {Object} obs 
     * @emit bbnObs
     * @memberof observerComponent
     */
    observerEmit(newVal, obs) {
      let row = bbn.fn.getRow(this.observers, {
        id: obs.id,
        element: obs.element
      });
      if (row && row.value !== newVal) {
        row.value = newVal;
        this.$emit('bbnObs' + obs.element + obs.id, newVal);
        return true;
      }
    },
    /**
     * The called method on the switching to false of the "observer Dirty" property value
     * @method observerClear
     * @param {Object} obs
     * @fires observationTower.observerClear
     */
    observerClear(obs) {
      if (this.observationTower) {
        this.observationTower.observerClear(obs);
      }
    }
  },
  /**
   * Adds the classes 'bbn-observer-component', 'bbn-observer', 'bbn-observer-' + this.observerUID to the component
   * @event created
   * @memberof observerComponent
   */
  created() {
    if (this.componentClass) {
      this.componentClass.push('bbn-observer-component', 'bbn-observer', 'bbn-observer-' + this.observerUID);
    }
  },
  /**
   * Defines the observationTower object.
   * @event mounted
   * @memberof observerComponent
   */
  mounted() {
    if (this.observer) {
      this.observationTower = this.closest('.bbn-observer');
      this.observerWatch();
    }
  },
  /**
   * Removes the observer.
   * @event beforeDestroy
   * @memberof observerComponent
   */
  beforeDestroy() {
    if (this.isObserved()) {
      let idx = bbn.fn.search(this.observationTower.observers, {
        element: this.observerUID
      });
      if (idx > -1) {
        this.observationTower.observers.splice(idx, 1);
      }
      this.observationTower.$off('bbnobserver' + this.observerUID + this.observerID);
    }
  },
  watch: {
    /**
     * @watch observerDirty
     * @param {Boolean} newVal
     * @fires observerClear
     */
    observerDirty(newVal) {
      if (!newVal) {
        this.observerClear({
          id: this.observerID,
          element: this.observerUID,
          value: this.observerValue
        });
      }
    }
  }
};
export default observer;
const pageable = {
  props: {
    /**
     * The total of items in the list.
     * @data {Number} [0] total
     * @memberof listComponent
     */
    total: {
      type: Number,
      default: 0
    },
    /**
     * The start index.
     * @data {Number} [0] start
     * @memberof pageableComponent
     */
    start: {
      type: Number,
      default: 0
    },
    /**
     * The limit of rows to be shown in a page of the list.
     * @prop {Number} [25] limit
     * @memberof pageableComponent
     */
    limit: {
      type: Number,
      default: 25
    },
    /**
     * The array of predefined limits.
     * @data {Array} {[10, 25, 50, 100, 250, 500]} limits
     * @memberof pageableComponent
     */
    limits: {
      type: Array,
      default() {
        return [10, 25, 50, 100, 250, 500];
      }
    },
    /**
     * Set to true allows the list to divide itself in different pages basing on the property limit.
     * @prop {Boolean} [false] pageable
     * @memberof pageableComponent
     */
    pageable: {
      type: Boolean,
      default: false
    },
    /**
     * The name of the `page` word as used in the pager interface.
     * @prop {String} ['Page'] pageName
     */
    pageName: {
      type: String,
      default: bbn._("Page")
    }
  },
  data() {
    return {
      /**
       * The current limit of items in the list.
       * @memberof pageableComponent
       * @data {Number} [25] currentLimit
       */
      currentLimit: this.limit,
      /**
       * The current start index of the list.
       * @memberof pageableComponent
       * @data {Number} [0] currentStart
       */
      currentStart: this.start,
      /**
       * The current total of items in the list.
       * @memberof pageableComponent
       * @data {Number} [0] currentTotal
       */
      currentTotal: 0
    };
  },
  computed: {
    /**
     * Return the number of pages of the list.
     * @computed numPages
     * @memberof listComponent
     * @return {number}
     */
    numPages() {
      return Math.ceil(this.total / this.currentLimit);
    },
    /**
     * Return the current page of the list.
     * @computed currentPage
     * @memberof listComponent
     * @fires updateData
     * @return {Number}
     */
    currentPage: {
      get() {
        return Math.ceil((this.start + 1) / this.currentLimit);
      },
      set(val) {
        if (this.ready) {
          this.start = val > 1 ? (val - 1) * this.currentLimit : 0;
          this.updateData();
        }
      }
    }
  },
  methods: {},
  watch: {
    /**
     * @watch currentLimit
     * @fires setConfig
     */
    currentLimit() {
      if (this.ready && bbn.fn.isFunction(this.setConfig)) {
        this.setConfig(true);
      }
    }
  }
};
export default pageable;
import bbnCp from '../../classes/Cp.js';
const popup = {
  props: {
    /**
     * The object popup of the table.
     * @prop {bbnCp}
     */
    popup: {
      type: bbnCp
    }
  },
  methods: {
    /**
     * Retuns the popup object.
     * @method getPopup
     * @returns {bbnCp}
     */
    /*
    getPopup(cfg){
      let popup = this.popup || bbn.cp.getPopup(this);
      // If no config we return the popup object
      if (!cfg) {
        return popup;
      }
       if (popup) {
        // Adding opener to the config
        cfg.opener = this;
        return popup.open(cfg);
      }
     },
    */
  }
};
export default popup;
const position = {
  props: {
    /**
    * The position 'left'.
    * @memberof positionComponent
    * @prop {Number} left
    */
    left: {
      type: Number
    },
    /**
    * The position 'right'.
    * @memberof positionComponent
    * @prop {Number} right
    */
    right: {
      type: Number
    },
    /**
    * The position 'top'.
    * @memberof positionComponent
    * @prop {Number} top
    */
    top: {
      type: Number
    },
    /**
    * The position 'bottom'.
    * @memberof positionComponent
    * @prop {Number} bottom
    */
    bottom: {
      type: Number
    }
  }
};
export default position;
const resizer = {
  data() {
    return {
      /**
       * The closest resizer parent.
       * @data {Boolean} [false] parentResizer
       * @memberof resizerComponent
       */
      parentResizer: false,
      /**
       * The listener on the closest resizer parent.
       * @data {Boolean} [false] onParentResizerEmit
       * @memberof resizerComponent
       */
      onParentResizerEmit: false,
      /**
       * The ResizeObserver
       * @data {ResizeObserver} [null] resizerObserver
       * @memberof resizerObserver
       */
      ResizerObserver: null,
      /**
       * The height.
       * @data {Boolean} [false] lastKnownHeight
       * @memberof resizerComponent
       */
      lastKnownHeight: false,
      /**
       * The width.
       * @data {Boolean} [false] lastKnownWidth
       * @memberof resizerComponent
       */
      lastKnownWidth: false,
      /**
       * The container height.
       * @data {Boolean} [false] lastKnownCtHeight
       * @memberof resizerComponent
       */
      lastKnownCtHeight: false,
      /**
       * The container width.
       * @data {Boolean} [false] lastKnownCtWidth
       * @memberof resizerComponent
       */
      lastKnownCtWidth: false,
      /**
       * Should be set to true during the resize execution.
       * @data {Boolean} [false] isResizing
       * @memberof resizerComponent
       */
      isResizing: false,
      /**
       * The live computedStyle object for the element.
       * @data {Object} [null] computedStyle
       * @memberof resizerComponent
       */
      computedStyle: null
    };
  },
  computed: {
    resizerObserved() {
      return this.$el;
    }
  },
  methods: {
    isActiveResizer() {
      let ct = this.closest('bbn-container');
      if (ct) {
        return ct.isVisible;
      }
      return true;
    },
    /**
     * A function that can be executed just before the resize event is emitted.
     * @method onResize
     * @emit resize
     * @memberof resizerComponent
     */
    onResize() {
      let res = false;
      //this.$forceUpdate();
      if (this.$el.style.display !== 'none') {
        // Setting initial dimensions
        let ms2 = this.setContainerMeasures();
        let ms1 = this.setResizeMeasures();
        if (ms1 || ms2) {
          //bbn.fn.log(["DEFAULT ONRESIZE FN FROM " + this.$options.name, ms1, ms2]);
          res = true;
          this.$tick();
        }
      }
      return res;
    },
    /**
     * Sets the value of lastKnownHeight and lastKnownWidth basing on the current dimensions of width and height.
     * @method setResizeMeasures 
     * @returns {Boolean}
     */
    setResizeMeasures() {
      let resize = false;
      let w = 0;
      let h = 0;
      const ele = this.resizerObserved;
      if (ele) {
        h = Math.round(ele.clientHeight);
        w = Math.round(ele.clientWidth);
        if (h && w) {
          this.setComputedStyle();
        }
      }

      //bbn.fn.log(ele, h, Math.round(ele.clientHeight), ele.clientHeight, '----');
      if (this.lastKnownHeight !== h) {
        this.lastKnownHeight = h;
        resize = true;
      }
      if (this.lastKnownWidth !== w) {
        this.lastKnownWidth = w;
        resize = true;
      }
      return resize;
    },
    setContainerMeasures() {
      let resize = false;
      let isAbsolute = this.computedStyle ? ['absolute', 'fixed'].includes(this.computedStyle.position) : false;
      let offsetParent = this.$el.offsetParent;
      let ctH;
      let ctW;
      if (this.parentResizer && this.parentResizer.lastKnownHeight) {
        ctH = this.parentResizer.lastKnownHeight;
        ctW = this.parentResizer.lastKnownWidth;
      } else if (offsetParent) {
        ctH = isAbsolute ? bbn.fn.outerHeight(offsetParent) : Math.round(offsetParent.clientHeight);
        ctW = isAbsolute ? bbn.fn.outerWidth(offsetParent) : Math.round(offsetParent.clientWidth);
      } else {
        ctH = bbn.env.height;
        ctW = bbn.env.width;
      }
      if (this.lastKnownCtHeight !== ctH) {
        this.lastKnownCtHeight = ctH;
        resize = true;
      }
      if (this.lastKnownCtWidth !== ctW) {
        this.lastKnownCtWidth = ctW;
        resize = true;
      }

      /*
      if (resize) {
        bbn.fn.log(["SET CONTAINER ONRESIZE MEASURES", this.$options.name, ctH, ctW, this.$parent]);
      }
      */

      return resize;
    },
    getParentResizer() {
      var _parentResizer;
      let parentResizer = this.closest(".bbn-resize-emitter");
      // In case we have 2 comnponents in one
      while (parentResizer && parentResizer.onResize === undefined) {
        parentResizer = parentResizer.$parent;
      }
      return ((_parentResizer = parentResizer) === null || _parentResizer === void 0 ? void 0 : _parentResizer.onResize) !== undefined ? parentResizer : false;
    },
    /**
     * Defines the resize emitter and launches process when it resizes.
     * @method setResizeEvent
     * @fires onParentResizerEmit
     * @memberof resizerComponent
     */
    setResizeEvent() {
      if (!this.resizerObserver && this.resizerObserved) {
        this.resizerObserver = new ResizeObserver(entries => {
          if (!this.isResizing) {
            for (const entry of entries) {
              var _entry$contentBoxSize;
              if ((_entry$contentBoxSize = entry.contentBoxSize) !== null && _entry$contentBoxSize !== void 0 && _entry$contentBoxSize[0]) {
                this.onResize();
              }
              //bbn.fn.log(bbn._("RESIZEOBS from %s", this.$options.name), entry.contentBoxSize, this.Cid);
            }
          }
        });

        this.resizerObserver.observe(this.resizerObserved);
      }
    },
    /**
     * Unsets the resize emitter.
     * @method unsetResizeEvent
     * @memberof resizerComponent
     */
    unsetResizeEvent() {
      if (this.resizerObserver) {
        this.resizerObserver.disconnect();
        this.resizerObserver = null;
      }
    },
    /**
     * Emits the event resize on the closest parent resizer.
     * @method selfEmit
     * @memberof resizerComponent
     * @param {Boolean} force 
     */
    selfEmit(force) {
      /*
      if ( this.parentResizer ){
        this.parentResizer.$emit("resize", force);
      }
      */
    },
    formatSize() {
      return bbn.fn.formatSize(...arguments);
    },
    setComputedStyle() {
      if (!this.computedStyle && this.$el && this.$el.clienttWidth) {
        this.computedStyle = window.getComputedStyle(this.$el);
      }
    }
  },
  /**
   * Adds the class 'bbn-resizer-component' to the component.
   * @event created
   * @memberof resizerComponent
   */
  created() {
    this.componentClass.push('bbn-resizer-component');
  },
  /**
   * Defines the resize emitter and emits the event ready.
   * @event mounted
   * @fires setResizeEvent
   * @emits ready
   * @memberof resizerComponent
   */
  mounted() {
    if (!this.ready) {
      this.$on('ready', this.setResizeEvent);
    } else {
      this.setResizeEvent();
    }
  },
  /**
   * Unsets the resize emitter.
   * @event beforeDestroy
   * @fires unsetResizeEvent
   * @memberof resizerComponent
   */
  beforeDestroy() {
    this.unsetResizeEvent();
  }
};
export default resizer;
const serviceWorker = {
  props: {},
  data() {
    return {
      /**
       * The registered channels list
       * @data {Array} [[]] registeredChannels
       * @memberof serviceWorkerComponent
       */
      registeredChannels: []
      /**
       * The primary channel
       * @data {String} [''] primaryChannel
       * @memberof serviceWorkerComponent
       */
    };
  },

  methods: {
    /**
     * Registers a channel
     * @method registerChannel
     * @memberof serviceWorkerComponent
     * @param {String} channel
     * @fires _postMessage
     * @return {Boolean}
     */
    registerChannel(channel, primary) {
      if (!this.registeredChannels.includes(channel) && this._postMessage({
        type: 'registerChannel',
        channel: channel
      })) {
        this.registeredChannels.push(channel);
        if (primary) {
          this.primaryChannel = channel;
        }
        return true;
      }
      return false;
    },
    /**
     * Unregisters a channel
     * @method unregisterChannel
     * @memberof serviceWorkerComponent
     * @param {String} channel
     * @fires _postMessage
     * @return {Boolean}
     */
    unregisterChannel(channel) {
      if (this.registeredChannels.includes(channel) && this._postMessage({
        type: 'unregisterChannel',
        channel: channel
      })) {
        this.registeredChannels.splice(this.registeredChannels.indexOf(channel), 1);
        return true;
      }
      return false;
    },
    /**
     * Sends a message to a channel
     * @method messageChannel
     * @memberof serviceWorkerComponent
     * @param {String} channel
     * @param {Object} data
     * @fires _postMessage
     * @return {Boolean}
     */
    messageChannel(channel, data) {
      if (this.registeredChannels.includes(channel) && this._postMessage({
        type: 'messageChannel',
        channel: channel,
        data: this._encodeMessageData(data)
      })) {
        return true;
      }
      return false;
    },
    /**
     * Receives data from a channel
     * @method messageFromChannel
     * @memberof serviceWorkerComponent
     * @param {Object} data
     */
    messageFromChannel(data) {
      data = this._decodeMessageData(data);
      if (data.function) {
        if (bbn.fn.isFunction(data.function)) {
          data.function(...(data.params || []));
        } else if (bbn.fn.isFunction(this[data.function])) {
          this[data.function](...(data.params || []));
        }
      }
    },
    /**
     * Emits messageToChannel event
     * @method messageToChannel
     * @memberof serviceWorkerComponent
     * @param {Object} data
     * @param {String} channel
     * @emit messageToChannel
     */
    messageToChannel(data, channel) {
      this.$emit('messageToChannel', data, channel);
    },
    /**
     * @method _checkSW
     * @memberof serviceWorkerComponent
     * @return {Boolean}
     */
    _checkSW() {
      if ('serviceWorker' in navigator) {
        if (navigator.serviceWorker.controller) {
          return navigator.serviceWorker.controller.state !== 'redundant';
        } else {
          bbn.fn.info("NO CONTROLLER FOR SW");
        }
      } else {
        bbn.fn.info("NO SW");
      }
      return false;
    },
    /**
     * Postes the message to the service worker
     * @method _postMessage
     * @memberof serviceWorkerComponent
     * @param {Object}
     * @fires _checkSW
     * @return {Boolean}
     */
    _postMessage(obj) {
      if (this._checkSW()) {
        navigator.serviceWorker.controller.postMessage(obj);
        return true;
      }
      return false;
    },
    /**
     * Encodes the data of the message
     * @method _encodeMessageData
     * @memberof serviceWorkerComponent
     * @param {Object} data
     * @return {String}
     */
    _encodeMessageData(data) {
      return JSON.stringify(data, (k, d) => bbn.fn.isFunction(d) ? '/Function(' + d.toString() + ')/' : d);
    },
    /**
     * Decodes the data of the message
     * @method _decodeMessageData
     * @memberof serviceWorkerComponent
     * @param {String} data
     * @return {Object}
     */
    _decodeMessageData(data) {
      return JSON.parse(data, (k, d) => {
        if (bbn.fn.isString(d) && d.startsWith('/Function(') && d.endsWith(')/')) {
          d = d.substring(10, d.length - 2);
          return (0, eval)('(' + d + ')');
        }
        return d;
      });
    }
  },
  /**
   * Adds the class 'bbn-service-worker-component' to the component.
   * @event created
   * @memberof serviceWorkerComponent
   */
  created() {
    this.componentClass.push('bbn-service-worker-component');
  }
};
export default serviceWorker;
const toggle = {
  props: {
    /**
     * True if the component has to be visible.
     * @memberof toggleComponent
     * @prop {Boolean} [false] true
     */
    visible: {
      type: Boolean,
      default: true
    },
    /**
     * True to focus the component.
     * @memberof toggleComponent
     * @prop {Boolean} [true] focused
     */
    focused: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * If an element is focused it returns it.
       * @data {Element} prevFocused
       * @memberof toggleComponent
       */
      prevFocused: bbn.env.focused,
      /**
       * Whether or not the component is currently visible.
       * @memberof toggleComponent
       * @data{Boolean} currentVisible
       */
      currentVisible: this.visible,
      /**
       * The focusable element.
       * @memberof toggleComponent
       * @data {HTMLElement} [null] focusable
       */
      focusable: null,
      /**
       * True when the component has been opened.
       * @memberof toggleComponent
       * @data hasBeenOpened {Boolean} [false]
       */
      hasBeenOpened: false
    };
  },
  methods: {
    /**
     * Shows the slider.
     * @method show
     * @fires onResize
     * @emits show      
     */
    show() {
      let e = new Event('beforeShow', {
        cancelable: true
      });
      this.$emit('beforeShow', e);
      if (!e.defaultPrevented) {
        this.currentVisible = true;
      }
    },
    /**
     * Hides the slider.
     * @method hide
     * @emits hide      
     */
    hide() {
      let e = new Event('beforeHide', {
        cancelable: true
      });
      this.$emit('beforeHide', e);
      if (!e.defaultPrevented) {
        this.currentVisible = false;
      }
    },
    /**
     * Toggles the slider.
     * @method toggle
     */
    toggle() {
      if (this.currentVisible) {
        this.hide();
      } else {
        this.show();
      }
    },
    /**
     * Change the focused element.
     * @param{boolean} v
     * @memberof toggleComponent 
     */
    switchFocus(v) {
      if (this.focused) {
        if (v) {
          if (this.focusable && this.focusable.focus) {
            this.focusable.focus();
          } else if (this.$el && this.$el.focus) {
            this.$el.focus();
          }
        } else if (this.prevFocused && this.prevFocused.focus) {
          this.prevFocused.focus();
        }
      }
    },
    changeVisible(v) {
      if (v) {
        if (!this.hasBeenOpened) {
          this.hasBeenOpened = true;
        }
        if (bbn.env.focused && bbn.env.focused !== this.prevFocused) {
          this.prevFocused = bbn.env.focused;
        }
      }
      /*
      if ( this.onResize !== undefined ){
        if ( v ){
          this.onResize();
        }
        else{
          this.isResized = false;
        }
      }
      */
      this.switchFocus(v);
    }
  },
  /**
   * If not defined, defines the focusable element.
   * @event mounted
   * @memberof focusComponent
   */
  mounted() {
    this.$nextTick(() => {
      if (!this.focusable) {
        this.focusable = this.$el;
      }
      if (this.currentVisible && this.focused) {
        this.switchFocus(true);
      }
    });
  },
  /**
   * Returns the focus on the previously focused element.
   * @event beforeDestroy
   * @memberof focusComponent
   */
  beforeDestroy() {
    if (!bbn.fn.isMobile()) {
      this.switchFocus(false);
    }
  },
  watch: {
    /**
     * Emits the event 'open' or 'close'
     * @watch currentVisible
     * @param {Boolean} v 
     * @emits open
     * @emits close
     * @fires switchFocus
     * @memberof toggleComponent
     */
    currentVisible: {
      handler(v) {
        this.$emit(v ? 'show' : 'hide');
        this.changeVisible(v);
      },
      immediate: true
    }
  }
};
export default toggle;
const url = {
  props: {
    /** 
     * The baseUrl.
     * @prop {String} baseUrl
     * @memberof urlComponent
     */
    baseUrl: {
      type: String
    }
  },
  data() {
    return {
      /**
       * @data currentURL
       * @memberof urlComponent
       */
      currentURL: null,
      /**
       * @data title
       * @memberof urlComponent
       */
      title: null
    };
  },
  methods: {
    /**
     * Updates the url.
     * @method updateUrl
     * @memberof urlComponent
     */
    updateUrl() {
      if (this.baseUrl && bbn.env.path.indexOf(this.baseUrl) === 0 && bbn.env.path.length > this.baseUrl.length + 1) {
        let url = this.baseUrl + (this.currentURL ? '/' + this.currentURL : '');
        bbn.fn.setNavigationVars(url, (this.currentURL ? bbn.fn.getField(this.source, this.sourceText, this.sourceValue, this.currentURL) + ' < ' : '') + document.title, {
          script: () => {
            //bbn.fn.log("updateUrl & EXEC SCRIPT");
            let idx = bbn.fn.search(this.source, this.sourceValue, this.currentURL);
            if (idx > -1) {
              this.widget.select(idx);
              this.widget.trigger("change");
            }
          }
        }, !this.ready);
      }
    }
  },
  /**
   * Adds the class 'bbn-url-component' to the component
   * @event created 
   * @memberof urlComponent
   */
  created() {
    this.componentClass.push('bbn-url-component');
  }
};
export default url;
import bbnCp from '../../classes/Cp.js';
const view = {
  props: {
    /**
     * The source of the component.
     * @prop {Object|Function} source
     * @memberof viewComponent
     */
    source: {
      type: [Array, Object, String, Function]
    },
    /**
     * The title of the component.
     * @prop {String|Number} ['Untitled'] title
     * @memberof viewComponent
     */
    title: {
      type: [String, Number],
      default: bbn._("Untitled")
    },
    /**
     * The options object of the component.
     * @prop {Object} options
     * @memberof viewComponent
     */
    options: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Defines if the component has to be cached.
     * @prop {Boolean} [false] cached
     * @memberof viewComponent
     */
    cached: {
      type: Boolean,
      default: false
    },
    /**
     * Defines if the component has to be scrollable.
     * @prop {Boolean} [true] scrollable
     * @memberof viewComponent
     */
    scrollable: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the component to use.
     * @prop component
     * @memberof viewComponent
     */
    component: {
      type: [String, Object, Function]
    },
    /**
     * Defines the icon.
     * @prop {String|Boolean} icon
     * @memberof viewComponent
     */
    icon: {
      type: [String, Boolean]
    },
    /**
     * Defines if the component can have a text.
     * @prop {Boolean} [false] notext
     * @memberof viewComponent
     */
    notext: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the component's content.
     * @prop {String} [''] content
     * @memberof viewComponent
     */
    content: {
      type: String,
      default: ""
    },
    /**
     * Defines the menu.
     * @prop {Array|Function} menu
     * @memberof viewComponent
     */
    menu: {
      type: [Array, Function, Boolean]
    },
    /**
     * Defines if the component is loaded.
     * @prop {Boolean} loaded
     * @memberof viewComponent
     */
    loaded: {
      type: Boolean,
      default: false
    },
    /**
     * Tells if the component is currently loading.
     * @prop {Boolean} loading
     * @memberof viewComponent
     */
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * Defines the component's fcolor.
     * @prop {String} fcolor
     * @memberof viewComponent
     */
    fcolor: {
      type: String
    },
    /**
     * Defines the component's bcolor.
     * @prop {String} bcolor
     * @memberof viewComponent
     */
    bcolor: {
      type: String
    },
    /**
     * @prop {Boolean} [false] load
     * @memberof viewComponent
     */
    load: {
      type: Boolean,
      default: false
    },
    /**
     * Defines if the component has to be selected.
     * @prop {Boolean|Number} [false] selected
     * @memberof viewComponent
     */
    selected: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Defines the css string for the component.
     * @prop {String} [''] css
     * @memberof viewComponent
     */
    css: {
      type: String,
      default: ""
    },
    /**
     * @prop {String|bbnCp} advert
     * @memberof viewComponent
     */
    advert: {
      type: [String, bbnCp]
    },
    /**
     * @prop {String} help
     * @memberof viewComponent
     */
    help: {
      type: String
    },
    /**
     * @prop {Array} imessages
     * @memberof viewComponent
     */
    imessages: {
      type: [Array, Function],
      default() {
        return [];
      }
    },
    /**
     * @prop script
     * @memberof viewComponent
     */
    script: {},
    /**
     * Defines if the component has to be static.
     * @prop {Boolean|Number} [false] static
     * @memberof viewComponent
     */
    static: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Defines
     if the component has to be pinned.
      * @prop {Boolean|Number} [false] pinned
      * @memberof viewComponent
      */
    pinned: {
      type: [Boolean, Number],
      default: false
    },
    /**
     * Defines the url.
     * @prop {String|Number} url
     * @memberof viewComponent
     */
    url: {
      type: [String, Number]
    },
    /**
     * @prop current
     * @prop {String|Number} current
     * @memberof viewComponent
     */
    current: {
      type: [String, Number]
    },
    /**
     * @prop {Boolean} [true] real
     * @memberof viewComponent
     */
    real: {
      type: Boolean,
      default: true
    },
    /**
     * The object of configuration for the component
     * @prop {Object} cfg
     * @memberof viewComponent
     */
    cfg: {
      type: Object
    },
    /**
     * @prop {Object} events
     * @memberof viewComponent
     */
    events: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * Defines if the component is disabled.
     * @prop {Boolean} [false] disabled
     */
    disabled: {
      type: [Boolean, Function],
      default: false
    },
    /**
     * Defines if the component is hidden.
     * @prop {Boolean} [false] hidden
     */
    hidden: {
      type: [Boolean, Function],
      default: false
    }
  }
};
export default view;
import "../cp.js";
import bbnData from '../classes/Data.js';

/**
 * Check the config of the component (mixins, computed, props, ect...) if everything is valid
 * and add them to their respective namespaces
 */
export default function normalizeComponent(cfg, clsName) {
  //bbn.fn.warning("NORMALIZE " + clsName);
  if (!bbn.fn.isObject(cfg)) {
    bbn.fn.log(cfg, clsName);
    throw new Error("Components definition must be objects");
  }

  //alert("normalize " + clsName);
  const res = bbnData.immunizeValue(bbn.fn.createObject({
    props: bbn.fn.createObject(),
    data: [],
    computed: bbnData.immunizeValue(bbn.fn.createObject()),
    methods: bbn.fn.createObject(),
    watch: bbn.fn.createObject(),
    components: bbn.fn.createObject(),
    componentNames: bbn.fn.createObject(),
    model: bbn.fn.createObject({
      prop: "value",
      event: "input"
    }),
    extension: null,
    statics: [],
    _bbnComponent: true
  }));
  //bbn.fn.log(["NORM", clsName, cfg, res]);

  if (cfg.mixins) {
    //bbn.fn.log("MIXINS", cfg);
    bbn.fn.checkType(cfg.mixins, 'array', bbn._("The mixins property must be an array in %s", clsName));
    cfg.mixins.forEach(mixin => {
      bbn.fn.checkType(mixin, 'object', bbn._("A mixin should be an object in %s", clsName));
      let cp = bbn.cp.normalizeComponent(mixin);
      bbn.fn.each(Object.keys(cp).sort(), name => {
        if (bbn.fn.isArray(cp[name]) && ['data', 'statics', ...bbn.cp.hooks].includes(name)) {
          if (!res[name]) {
            res[name] = [];
          }
          res[name].push(...cp[name]);
        } else if (bbn.fn.isObject(cp[name]) && bbn.fn.numProperties(cp[name]) || bbn.fn.isArray(cp[name]) && cp[name].length) {
          if (!res[name]) {
            res[name] = bbn.fn.createObject();
          }

          // Assigning each category of the mixin to the component
          Object.assign(res[name], cp[name]);
        }
      });
    });
  }
  bbn.fn.each(Object.keys(cfg).sort(), name => {
    switch (name) {
      case 'props':
        // Starting from the defined props
        let props = bbn.fn.clone(cfg.props);
        if (bbn.fn.isArray(props)) {
          let tmp = props;
          props = bbn.fn.createObject();
          tmp.forEach(a => {
            props[a] = bbn.fn.createObject();
          });
        }
        bbn.fn.checkType(props, 'object', bbn._("The props property must be an object in %s", clsName));
        for (let propName in props) {
          // If it's just an array or a constructor it's the type
          if (bbn.fn.isArray(props[propName]) || bbn.fn.isFunction(props[propName])) {
            // We transform it into an object
            props[propName] = bbn.fn.createObject({
              type: props[propName]
            });
          }
          // Now the prop should be an object
          bbn.fn.checkType(props[propName], 'object', `The prop ${propName} for ${clsName} is a ${typeof props[propName]}`);
          // Type must be an array
          if (props[propName].type && !bbn.fn.isArray(props[propName].type)) {
            props[propName].type = [props[propName].type];
          }
          res.props[propName] = props[propName];
        }
        break;
      case 'data':
        if (!bbn.fn.isArray(cfg[name])) {
          cfg[name] = [cfg[name]];
        }
        bbn.fn.each(cfg[name], (cf, i) => {
          if (!bbn.fn.isFunction(cf)) {
            bbn.fn.checkType(cf, 'object', bbn._("The data must be an object or a function in %s", clsName));
            let tmp = cf;
            cf = function () {
              return tmp;
            };
          }
          bbn.fn.checkType(cf, 'function', bbn._("The data must be an object or a function in %s", clsName));
          res[name].push(cf);
        });
        break;
      case 'computed':
        bbn.fn.checkType(cfg.computed, 'object', bbn._("The computed must be an object in %s", clsName));
        for (let computedName in cfg.computed) {
          var _cfg$computed$compute;
          if (typeof cfg.computed[computedName] !== 'function' && !((_cfg$computed$compute = cfg.computed[computedName]) !== null && _cfg$computed$compute !== void 0 && _cfg$computed$compute.get)) {
            throw new Error(bbn._("The computed must be a single function or an object with at least a get function (check %s in %s)", computedName, clsName));
          }
          res.computed[computedName] = bbn.fn.createObject({
            get: cfg.computed[computedName].get || cfg.computed[computedName],
            set: cfg.computed[computedName].set || null
          });
        }
        break;
      case 'methods':
        bbn.fn.checkType(cfg[name], 'object', bbn._("The methods must be an object in %s", clsName));
        for (let methName in cfg[name]) {
          bbn.fn.checkType(cfg[name][methName], 'function', bbn._("Methods must be functions, check %s in %s", methName, clsName));
          res[name][methName] = cfg[name][methName];
        }
        break;
      case 'watch':
        bbn.fn.checkType(cfg.watch, 'object', bbn._("The watch must be an object in %s", clsName));
        for (let watchName in cfg.watch) {
          const tmp = cfg.watch[watchName];
          bbn.fn.checkType((tmp === null || tmp === void 0 ? void 0 : tmp.handler) || tmp, 'function', bbn._("Watchers must be functions, see %s in %s", watchName, clsName));
          res.watch[watchName] = tmp;
        }
        break;
      case 'components':
        bbn.fn.checkType(cfg.components, 'object', bbn._("The components must be an object in %s", clsName));
        for (let originalName in cfg.components) {
          let componentName = bbn.fn.camelize(originalName);
          let indexName = bbn.fn.camelToCss(componentName);
          bbn.fn.log(cfg.components);
          bbn.fn.checkType(cfg.components[originalName], 'object', bbn._("Components definitions must be objects (check %s in %s)", componentName, clsName));
          res.components[componentName] = bbn.cp.normalizeComponent(cfg.components[originalName], clsName);
          let subName = (clsName || 'bbnsub-' + bbn.fn.randomString(10, 20, 'nl')) + bbn.fn.substr(componentName, 0, 1).toUpperCase() + bbn.fn.camelize(bbn.fn.substr(componentName, 1));
          let subTag = bbn.fn.camelToCss(subName);
          res.componentNames[indexName] = subTag;
          if (indexName !== componentName) {
            res.componentNames[componentName] = subTag;
          }
          if (![indexName, componentName].includes(originalName)) {
            res.componentNames[originalName] = subTag;
          }
        }
        break;
      case 'model':
        if (cfg.model) {
          bbn.fn.checkType(cfg.model, 'object', bbn._("Model configuration must be objects, check %s", clsName));
          if (!['input', 'change'].includes(cfg.model.event) || !bbn.fn.isString(cfg.model.prop)) {
            throw new Error(bbn._("The model configuration must have an event (input or change) and a prop (check %s)", cfg.model, clsName));
          }
          res.model = cfg.model;
        }
        break;
      case 'extension':
        if (cfg.extension) {
          bbn.fn.checkType(cfg.extension, 'object', bbn._("Extensions must be objects, check %s", clsName));
          res.extension = cfg.extension;
        }
        break;
      case 'render':
        bbn.fn.checkType(cfg.render, 'function', bbn._("Render property must be a function, check %s", clsName));
        res.render = cfg.render;
        break;
      case 'template':
        bbn.fn.checkType(cfg.template, 'string', bbn._("The template must be a string, check %s", clsName));
        res.template = cfg.template;
        break;
      case 'statics':
        if (cfg.statics) {
          if (!bbn.fn.isArray(cfg.statics)) {
            cfg.statics = [cfg.statics];
          }
          bbn.fn.each(cfg.statics, fn => {
            bbn.fn.checkType(fn, ['object', 'function'], bbn._("The statics property must be an object or a function in %s", clsName));
            res.statics.push(fn);
          });
        }
        break;
      case 'iface':
        if (cfg.iface) {
          bbn.fn.checkType(cfg.iface, ['object', 'function'], bbn._("The ifaceace property must be an object or a function in %s", clsName));
          res.iface = cfg.iface;
        }
        break;

      /** 
       * @todo Add the possibility to change the tag using Customized built-in elements 
       * See createElement
       */
      case 'tag':
        if (cfg.tag) {
          bbn.fn.checkType(cfg.tag, 'string', bbn._("Tags must be strings (check %s)", clsName));
          res.tag = cfg.tag;
        }
        break;
      default:
        if (bbn.cp.hooks.includes(name)) {
          bbn.fn.each(bbn.fn.isArray(cfg[name]) ? cfg[name] : [cfg[name]], fn => {
            bbn.fn.checkType(fn, 'function');
            if (!res[name]) {
              res[name] = [];
            }
            res[name].push(fn);
          });
        } else if (!["mixins", "componentNames", "name", "_bbnComponent"].includes(name)) {
          if (name.indexOf('__bbn') !== 0) {
            throw new Error(bbn._("Unrecognize index %s in the config object for %s", name, clsName));
          }
        }
    }
  });

  // If there are no props we add the source prop
  if (!bbn.fn.numProperties(res.props)) {
    res.props.source = bbn.fn.createObject();
  }
  return res;
}
/**
 * @method queueComponent
 * @memberof bbn.cp
 * @param {String} name 
 * @param {String} url
 * @param {Array} mixins
 * @param {Function} resolve
 * @param {Function} reject
 */
export default function queueComponent(name, url, mixins, resolve, reject) {
  bbn.fn.warning("queueComponent " + name + " " + url);
  clearTimeout(this.queueTimer);
  let def = false; //this.getStorageComponent(name);
  if (def) {
    this._realDefineComponent(name, def, mixins);
    this.queueTimer = setTimeout(() => {
      resolve(true);
      return true;
    });
  } else {
    this.queue.push({
      name: name,
      url: url,
      mixins: mixins,
      resolve: resolve,
      reject: reject
    });
    this.queueTimer = setTimeout(() => {
      let todo = this.queue.splice(0, this.queue.length);
      this.executeQueueItems(todo);
      /*
      bbn.fn.log("TODO", todo);
      bbn.fn.each(todo, (a, i) => {
        this.executeQueueItem(a);
      });
      */
    }, this.loadDelay);
  }
  return this.queueTimer;
}
/**
 * @method _realDefineComponent
 * @memberof bbn.cp
 * @param {String} name 
 * @param {Object} r
 * @param {Array} mixins
 */
export default function realDefineComponent(name, r, mixins) {
  bbn.fn.warning("REAL DEFINE COMPONENT");
  bbn.fn.log(name, r, mixins);
  if (r && r.script) {
    if (r.css) {
      let el = document.createElement('style');
      el.innerHTML = r.css;
      document.head.insertAdjacentElement('beforeend', el);
    }
    let tpl = false;
    if (r.content) {
      tpl = 'bbn-tpl-component-' + name;
      while (document.getElementById(tpl)) {
        tpl = bbn.fn.randomString();
      }
      let script = document.createElement('script');
      script.innerHTML = r.content;
      script.setAttribute('id', tpl);
      script.setAttribute('type', 'text/x-template');
      document.body.insertAdjacentElement('beforeend', script);
    }
    let data = r.data || {};
    let res;
    try {
      res = eval(r.script);
    } catch (e) {
      bbn.fn.log(r.script);
      throw new Error("Impossible to evaluate the content of tha component " + name);
    }
    if (typeof res === 'object') {
      if (!res.mixins) {
        res.mixins = [];
      }
      if (!res.template && tpl) {
        res.template = '#' + tpl;
      }
      if (!res.props) {
        res.props = bbn.fn.createObject();
      }
      if (!res.props.source) {
        res.props.source = bbn.fn.createObject();
      }
      if (!res.name) {
        res.name = name;
      }
      if (res.mixins && !bbn.fn.isArray(res.mixins)) {
        res.mixins = [res.mixins];
      }
      if (mixins) {
        if (!bbn.fn.isArray(mixins)) {
          mixins = [mixins];
        }
        if (res.mixins) {
          bbn.fn.each(mixins, b => {
            res.mixins.push(b);
          });
        } else {
          res.mixins = mixins;
        }
      }
      let bits = res.name.split('-'),
        st = '';
      bbn.fn.each(bits, b => {
        st += b + '-';
        let idx = bbn.fn.search(this.knownPrefixes, {
          prefix: st
        });
        if (idx > -1 && this.knownPrefixes[idx].mixins) {
          if (bbn.fn.isArray(this.knownPrefixes[idx].mixins)) {
            bbn.fn.each(this.knownPrefixes[idx].mixins.reverse(), m => {
              res.mixins.unshift(m);
            });
          } else {
            res.mixins.unshift(this.knownPrefixes[idx].mixins);
          }
        }
      });
      if (Object.keys(data).length) {
        res.props.source.default = () => {
          return data;
        };
      }
      //bbn.fn.log(name, res);
      alert("This shouldn't be called");
      Vue.component(name, res);
      return true;
    }
  }
  return false;
}
export default function removeComponent(cid) {
  if (!cid) {
    throw new Error("The component doesn't have a component ID");
  }
  const cp = this.componentsIndex.get(cid);
  //bbn.fn.log("REMOVING COMPONENT", cp);
  if (!cp) {
    bbn.fn.log(["The component is already removed", cid]);
    //throw new Error("The component is already removed")
  }

  this.componentsIndex.delete(cid);
}
/**
 * Remove the self closing tags and return an HTML string
 * @return {String}
 */
export default function removeSelfClosing(html) {
  const rxhtmlTag = new RegExp('<([A-z0-9-_]+)((([^>"]+"[^"]*")*)|([>]*))\\s*/>', 'gm');
  return html ? html.replace(rxhtmlTag, "<$1$2></$1>") : '';
}
export default async function repeatTick(cp, num) {
  if (!num) {
    num = 0;
  }
  let idx = bbn.fn.search(bbn.cp.queue, {
    cp
  });
  if (idx > -1) {
    const queueElement = bbn.cp.queue.splice(idx, 1)[0];
    await cp.$updateComponent();
    queueElement.fns.forEach(fn => {
      if (fn) {
        fn.bind(cp)();
      }
    });
    if (num < 3) {
      bbn.fn.log(`REPEAT ${num} times`);
      await bbn.cp.repeatTick(cp, num + 1);
    } else {
      bbn.fn.log(["INFINITE LOOP", cp, bbn.fn.filter(bbn.cp.queue, {
        cp: queueElement.cp
      })]);
      throw new Error(bbn._("Infinite loop detected"));
    }
  }
}
export default function retrieveModels(tpl, res) {
  if (res === undefined) {
    res = bbn.fn.createObject();
  }
  bbn.fn.each(tpl, node => {
    if (node.model) {
      /*
      if (!res[node.id]) {
        res[node.id] = bbn.fn.createObject();
      }
      */
      bbn.fn.iterate(node.model, (a, name) => {
        if (!res[a.hash]) {
          res[a.hash] = bbn.fn.createObject();
        }
        res[a.hash][node.id] = bbn.fn.createObject({
          [name]: bbn.fn.createObject({
            _root: bbn.fn.createObject()
          })
        });
      });
    }
    if (node.items) {
      bbn.cp.retrieveModels(node.items, res);
    }
    if (node.slots) {
      bbn.cp.retrieveModels(node.slots, res);
    }
  });
  return res;
}
export default function retrieveSlots(tpl, res) {
  if (res === undefined) {
    res = bbn.fn.createObject();
  }
  bbn.fn.each(tpl, node => {
    if (node.tag && node.tag === 'slot') {
      let idx = node.attr && node.attr.name ? node.attr.name.value : 'default';
      if (!idx) {
        throw new Error(bbn._("Invalid slot name"));
      }
      if (res[idx]) {
        //throw new Error("A same slot can't appear twice in the template");
      }
      res[idx] = [];
      res[idx].id = node.id;
    }
    if (node.items) {
      bbn.cp.retrieveSlots(node.items, res);
    }
  });
  return res;
}
export default function setComputed(obj, name, getter, setter) {
  if (Object.hasOwn(obj, name)) {
    throw new Error(bbn._("The computed property %s already exists", name));
  }
  const def = {
    get() {
      if (!this.$isDataSet) {
        return undefined;
      }
      if (!Object.hasOwn(this.$computed, name)) {
        this.$computed[name] = bbn.fn.createObject({
          old: undefined,
          val: undefined,
          hash: undefined,
          num: 0,
          update: () => {
            this.$updateComputed(name, getter.bind(this)());
          }
        });
      }
      this.$computed[name].update();
      return this.$computed[name].val;
    }
  };
  if (setter) {
    def.set = function (v) {
      const res = setter.bind(this)(v);
      this.$computed[name].update();
      return res;
    };
  }
  Object.defineProperty(obj, name, def);
  obj.$updateWatcher(name, obj[name], true);
}
/**
 * @method setDefaults
 * @memberof bbn.cp
 * @param {Object} defaults 
 * @param {String} cpName
 */
export default function setDefaults(defaults, cpName) {
  if (typeof defaults !== 'object') {
    throw new Error("The default object sent is not an object " + cpName);
  }
  bbn.cp.defaults[cpName] = bbn.fn.extend(bbn.cp.defaults[cpName] || {}, defaults);
}
export default function startTick() {
  if (bbn.cp.interval) {
    throw new Error(bbn._("The tick is already started"));
  }
  let lastUpdate;
  bbn.cp.interval = setInterval(async function () {
    if (bbn.cp.isRunning) {
      return;
    }
    requestAnimationFrame(tst => {
      if (tst !== lastUpdate && bbn.cp.queue.length) {
        lastUpdate = tst;
        bbn.cp.isRunning = true;
        const queue = bbn.cp.queue.splice(0, bbn.cp.queue.length);
        let i = 0;
        let time = bbn.fn.timestamp();
        const todo = [];
        while (queue[i]) {
          if (!queue[i].cp.$isBusy && (queue[i].force || time - queue[i].cp.$lastLaunch > bbn.cp.tickDelay)) {
            //bbn.fn.log("UPDATING")
            const queueElement = queue.splice(i, 1)[0];
            queueElement.cp.$updateComponent().then(() => {
              queueElement.fns.forEach(fn => {
                if (fn) {
                  fn.bind(queueElement.cp)();
                }
              });
            });
            //await bbn.cp.repeatTick(queueElement.cp);
          } else {
            const queueElement = bbn.fn.getRow(bbn.cp.queue, {
              cp: queue[i].cp
            });
            if (queueElement) {
              queueElement.fns.unshift(...queue[i].fns);
            } else {
              todo.push(queue[i]);
            }
            //bbn.fn.log(["I++", i, queue[i].cp.$isBusy, queueElement, queue[i].cp]);
            i++;
          }
        }
        if (todo.length) {
          bbn.cp.queue.unshift(...todo);
        }
        bbn.cp.isRunning = false;
      }
    });
  }, bbn.cp.tickDelay);
}
export default function stopTick() {
  if (!bbn.cp.interval) {
    throw new Error(bbn._("The tick is not started"));
  }
  clearInterval(bbn.cp.interval);
  bbn.cp.interval = null;
}
/**
 * Create a new DOM parser and parse the given HTML string.
 * @return {HTMLElement}
 */
const parser = new DOMParser();

/**
 * Transforms a HTML string into a template array
 * 
 * @param {String} str 
 * @returns {Array}
 */
export default function stringToTemplate(str, withMap) {
  const map = bbn.fn.createObject();
  const inlineTemplates = bbn.fn.createObject();
  if (bbn.fn.isString(str)) {
    str = str.trim();
  }
  if (!str) {
    if (withMap) {
      return {
        res: [],
        map,
        inlineTemplates
      };
    }
    return [];
  }
  const doc = parser.parseFromString(
  // There shouldn't be self-closing in the embedded HTML except if in template
  bbn.cp.removeSelfClosing(str), "text/html");
  const errorNode = doc.querySelector("parsererror");

  // If the HTML string cannot be parsed, It throw an error
  if (errorNode) {
    throw new Error("Impossible to parse the template");
  }
  let num = 0;
  const res = Array.prototype.map.apply(Array.prototype.filter.apply(Array.from(doc.documentElement.querySelector('body').childNodes), [n => n.tagName && n.tagName.toLowerCase() !== 'script']), [a => {
    const tmp = bbn.cp.analyzeElement(a, map, inlineTemplates, num.toString());
    num++;
    return tmp.res;
  }]);
  if (withMap) {
    return {
      res,
      map,
      inlineTemplates
    };
  }
  return res;
}
const $_prep = st => {
  if (st.trim().match(/^\{|\[/)) {
    return '(() => {return ' + st + '})()';
  }
  return st;
};
let sp = 2;
const x = (obj, spaces, content) => {
  if (!obj) {
    obj = bbn.fn.createObject({
      text: ''
    });
  }
  if (content) {
    obj.text += ' '.repeat(spaces) + content + '\n';
  } else {
    obj.text += '\n';
  }
  return obj;
};
const forbidden = ['bbn-forget', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else'];
const treatCondition = (cp, node, arr, hashName) => {
  const c = x();
  let tmp = arr.filter(a => a.conditionId === node.conditionId);
  if (!tmp.length || !node.conditionId) {
    bbn.fn.log("FINISHING HERE ", node.conditionId, node.condition);
    return c.text;
  }
  x(c, sp, `_isCondTrue = false;`);
  x(c, sp, '// Checking the set of conditions (if any other) on the first condition');
  bbn.fn.each(tmp, (cond, j) => {
    x(c, sp, `$_go['${cond.id}'] = false;`);
    // No need to check thge first as _isCondTrue has just been defined
    if (j) {
      x(c, sp, `if (!_isCondTrue) {`);
      sp += 2;
    }
    x(c, sp, `_isCondTrue = _sIr("${cond.condition.hash}", ${cond.condition.type === 'else' ? 'true' : cond.condition.exp}, ${hashName});`);
    if (j) {
      sp -= 2;
      x(c, sp, `}`);
      x(c, sp, `else {`);
      x(c, sp, `  _sIr("${cond.condition.hash}", false, ${hashName});`);
      x(c, sp, `}`);
    }
    x(c, sp, `if (_gIs("${cond.condition.hash}", ${hashName}) !== "OK") {`);
    x(c, sp, `  $_go['${cond.id}'] = true;`);
    x(c, sp, `  let _tmp = _gIv("${cond.condition.hash}", ${hashName});`);
    x(c, sp, `  let _e;`);
    x(c, sp, `  if (!_tmp) {`);
    if (['template', 'transition', 'slot'].includes(cond.tag)) {
      if (cond.items) {
        bbn.fn.each(cond.items, it => {
          x(c, sp, `    _e = _t.$retrieveElement("${it.id}", ${hashName});`);
          x(c, sp, `    if (_e && !bbn.fn.isComment(_e)) {`);
          x(c, sp, `      _t.$removeDOM(_e);`);
          x(c, sp, `    }`);
        });
      }
    } else {
      x(c, sp, `    _e = _t.$retrieveElement("${cond.id}", ${hashName});`);
      x(c, sp, `    if (_e && !bbn.fn.isComment(_e)) {`);
      //x(c, sp, `      bbn.fn.log("REMOVING ${cond.id} from node2fn")`);
      x(c, sp, `      let _cp = bbn.cp.getComponent(_e.bbnComponentId)?.bbn || _t;`);
      //x(c, sp, `      bbn.fn.log("this is my moment", _e.tagName, _t.$options.name);`);
      x(c, sp, `      _t.$removeDOM(_e);`);
      x(c, sp, `      _e = false;`);
      x(c, sp, `    }`);
      x(c, sp, `    if (!_e) {`);
      x(c, sp, `      _eles['${cond.id}'] = await _t.$createElement({`);
      x(c, sp, `        id: "${cond.id}",`);
      x(c, sp, `        hash: "${cond.condition.hash}",`);
      x(c, sp, `        loopHash: ${hashName},`);
      x(c, sp, `        conditionId: "${cond.conditionId}",`);
      x(c, sp, `        comment: true`);
      x(c, sp, `      }, _parents.at(-1));`);
      x(c, sp, `    }`);
    }
    x(c, sp, `  }`);
    x(c, sp, `}`);
  });
  return c.text;
};
/**
 * Generates the code recursively for a loop
 * @param {Object} node 
 * @param {String} rv 
 * @param {String} hashName   
 * @param {Number} sp 
 * @param {Array} done 
 * @returns 
 */
const treatLoop = (cp, node, hashName) => {
  var _node$attr;
  const clone = bbn.fn.clone(node);
  delete clone.loop;
  const c = x();
  const md5 = bbn.fn.md5(node.id);
  const hash = 'bbnLoopHash_' + md5;
  const isNumber = 'bbnLoopIsNumber_' + md5;
  const isArray = 'bbnLoopIsArray_' + md5;
  const varName = 'bbnLoopName_' + md5;
  const listName = 'bbnLoopList_' + md5;
  const parentName = 'bbnLoopParent_' + md5;
  const indexName = node.loop.index || 'bbnLoopIndex_' + md5;
  // Starting the loop

  x(c, sp, `let ${varName} = _sIr('${node.loop.hash}', ${node.loop.exp}, ${hashName});`);
  x(c, sp, `let ${isNumber} = bbn.fn.isNumber(${varName});`);
  x(c, sp, `let ${parentName} = _parents.at(-1);`);
  x(c, sp, `let ${listName} = [];`);
  x(c, sp, `let ${isArray} = bbn.fn.isArray(${varName});`);
  x(c, sp, `if (${isNumber}) {`);
  x(c, sp, `  ${varName} = Object.keys((new Array(${varName})).fill(0)).map(a=>parseInt(a));`);
  x(c, sp, `  //bbn.fn.log("LOOP VALUE", ${varName});`);
  x(c, sp, `}`);
  x(c, sp, `for (let ${indexName} in ${varName}) {`);
  x(c, sp, `  if (${isArray}) {`);
  x(c, sp, `    ${indexName} = parseInt(${indexName});`);
  x(c, sp, `  }`);
  x(c, sp, `  let ${node.loop.item} = ${isNumber} ? ${indexName} : ${varName}[${indexName}];`);
  x(c, sp, `  const ${hash} = (${hashName} || '') + '${node.loop.hash}-${indexName}-' + (${(_node$attr = node.attr) !== null && _node$attr !== void 0 && (_node$attr = _node$attr.key) !== null && _node$attr !== void 0 && _node$attr.exp ? node.attr.key.exp : indexName});`);
  x(c, sp, `  ${listName}.push(${hash});`);
  x(c, sp, `  _sIr('${node.loop.item}', ${node.loop.item}, ${hash});`);
  x(c, sp, `  //bbn.fn.log(${node.loop.item});`);
  sp += 2;
  c.text += nodesToFunction(cp, [clone], hash);
  x(c, sp, `delete $_go['${node.id}'];`);
  sp -= 2;
  // Ending the loop
  x(c, sp, `}`);
  x(c, sp, `Array.from(${parentName}.childNodes).forEach(a => {`);
  x(c, sp, `  if ((!a.bbnHash || (a.bbnHash.indexOf(${hashName}) === 0)) && (a.bbnId === "${node.id}") && (${listName}.indexOf(a.bbnHash) === -1)) {`);
  x(c, sp, `    _t.$removeDOM(a);`);
  x(c, sp, `  }`);
  x(c, sp, `});`);
  return c.text;
};
const setProperties = function (node, hashName) {
  const c = x();
  x(c, sp, `_props = bbn.fn.createObject();`);
  // Will GO if the element is new or modified and not forgotten
  if (bbn.fn.numProperties(node.attr)) {
    if (node.attr['bbn-bind']) {
      x(c, sp, `_tmp = _sIr('${node.attr['bbn-bind'].hash}', ${node.attr['bbn-bind'].exp}, ${hashName}) || bbn.fn.createObject();`);
      x(c, sp, `if (!$_go['${node.id}'] && (_gIs('${node.attr['bbn-bind'].hash}', ${hashName}) !== "OK")) {`);
      x(c, sp, `  $_go['${node.id}'] = true;`);
      x(c, sp, `}`);
      x(c, sp, `_tmp2 = bbn.fn.createObject();`);
      for (let n in node.attr) {
        if (['bbn-bind', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget'].includes(n)) {
          continue;
        }
        if (node.attr[n].exp) {
          x(c, sp, `_tmp2['${n}'] = _sIr('${node.attr[n].hash}', ${node.attr[n].exp}, ${hashName});`);
        } else {
          x(c, sp, `_tmp2['${n}'] = '${bbn.fn.escapeSquotes(node.attr[n].value)}';`);
        }
      }
      x(c, sp, `bbn.fn.each(bbn.fn.unique(Object.keys(_tmp).concat(Object.keys(_tmp2))), n => {`);
      x(c, sp, `  let val = _tmp2[n] === undefined ? _tmp?.[n] : _tmp2[n];`);
      x(c, sp, `  if (val === undefined) {`);
      x(c, sp, `    return;`);
      x(c, sp, `  }`);
      x(c, sp, `  if (n === 'class') {`);
      x(c, sp, `    _props[n] = bbn.cp.convertClasses(val);`);
      x(c, sp, `  }`);
      x(c, sp, `  else if (n === 'style') {`);
      x(c, sp, `    _props[n] = bbn.cp.convertStyles(val);`);
      x(c, sp, `  }`);
      x(c, sp, `  else {`);
      x(c, sp, `    _props[n] = val;`);
      x(c, sp, `  }`);
      x(c, sp, `  if (!$_go['${node.id}'] && _node.attr[n] && !Object.hasOwn(_node.attr[n], 'value') && _node.attr[n].hash && (_gIs(_node.attr[n].hash, ${hashName}) !== "OK")) {`);
      x(c, sp, `    $_go['${node.id}'] = true;`);
      x(c, sp, `  }`);
      x(c, sp, `});`);
      //x(c, sp, `bbn.fn.log(["PROPS", _props, _tmp, _tmp2, bbn.fn.unique(Object.keys(_tmp).concat(Object.keys(_tmp2)))]);`);
    }
    // Simpler version
    else {
      for (let n in node.attr) {
        if (['bbn-bind', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget'].includes(n)) {
          continue;
        }
        if (node.attr[n].exp) {
          x(c, sp, `_tmp = _sIr('${node.attr[n].hash}', ${node.attr[n].exp}, ${hashName});`);
          x(c, sp, `if (_tmp !== undefined) {`);
          if (n === 'class') {
            x(c, sp, `  _props['${n}'] = bbn.cp.convertClasses(_tmp);`);
          } else if (n === 'style') {
            x(c, sp, `  _props['${n}'] = bbn.cp.convertStyles(_tmp);`);
          } else {
            x(c, sp, `  _props['${n}'] = _tmp;`);
          }
          x(c, sp, `}`);
          x(c, sp, `if (!$_go['${node.id}'] && _node.attr['${n}'] && !Object.hasOwn(_node.attr['${n}'], 'value') && _node.attr['${n}'].hash && (_gIs(_node.attr['${n}'].hash, ${hashName}) !== "OK")) {`);
          x(c, sp, `  $_go['${node.id}'] = true;`);
          x(c, sp, `}`);
        } else {
          x(c, sp, `_props['${n}'] = '${bbn.fn.escapeSquotes(node.attr[n].value)}';`);
        }
      }
    }
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};

/*
const setDirectives = function(node, hashName) {
  const c = x();
  if (bbn.fn.numProperties(node.directives)) {
    for (let n in node.directives) {
      if (node.directives[n].exp) {
        x(c, sp, `_node.directives['${n}'].value = _sIr('${node.directives[n].hash}', ${node.directives[n].exp}, ${hashName});`);

      }
    }
  }

  return c.text;
}
*/

const treatElement = function (cp, node, hashName) {
  const c = x();
  if (node.tag) {
    if (node.model) {
      bbn.fn.iterate(node.model, m => {
        x(c, sp, `_sIr('${m.hash}', ${m.exp}, ${hashName});`);
        x(c, sp, `if (!$_go['${node.id}'] && (_gIs('${m.hash}', ${hashName}) !== "OK")) {`);
        x(c, sp, `  $_go['${node.id}'] = true;`);
        x(c, sp, `}`);
      });
      x(c, sp, ``);
      x(c, sp, ``);
    }
    if (bbn.fn.numProperties(node.directives)) {
      for (let n in node.directives) {
        if (node.directives[n].exp) {
          x(c, sp, `_sIr('${node.directives[n].hash}', ${node.directives[n].exp}, ${hashName});`);
          x(c, sp, `if (!$_go['${node.id}'] && (_gIs('${node.directives[n].hash}', ${hashName}) !== "OK")) {`);
          x(c, sp, `  $_go['${node.id}'] = true;`);
          x(c, sp, `}`);
        }
      }
    }

    // Start if ($_go)
    x(c, sp, `if ($_go['${node.id}'] && !_forgotten['${node.id}']?.[${hashName} || '_root']) {`);
    sp += 2;
    x(c, sp, `//  bbn.fn.log("IN TODO " + _t.$options.name);`);
    x(c, sp, `//  bbn.fn.log("DOING ${node.id} ${node.tag}");`);
    x(c, sp, `_tmp = bbn.fn.clone(_node);`);
    x(c, sp, `if (${hashName}) {`);
    x(c, sp, `  _tmp.loopHash = ${hashName};`);
    x(c, sp, `}`);
    x(c, sp, `_tmp.props = _props;`);
    if (node.tag === 'component') {
      x(c, sp, `if (bbn.fn.isObject(_props.is)) {`);
      x(c, sp, `  _tmp.tag = _props.name ? bbn.fn.camelToCss(_props.name) : 'bbn-anon';`);
      x(c, sp, `  _tmp.cfg = bbn.cp.normalizeComponent(_props.is);`);
      x(c, sp, `}`);
      x(c, sp, `else {`);
      x(c, sp, `  _tmp.tag = bbn.fn.camelToCss(_props.is);`);
      x(c, sp, `}`);
    }
    x(c, sp, `isAnew = false;`);
    x(c, sp, `if ((_eles['${node.id}'] !== _t.$el) && !_forgotten['${node.id}']?.[${hashName} || '_root'] && (`);
    x(c, sp, `    !_eles['${node.id}']`);
    x(c, sp, `    || bbn.fn.isComment(_eles['${node.id}'])`);
    x(c, sp, `    || !bbn.cp.isTag(_tmp.tag, _eles['${node.id}'])`);
    x(c, sp, `  )`);
    x(c, sp, `) {`);
    x(c, sp, `  isAnew = true;`);
    x(c, sp, `}`);
    x(c, sp, `if (isAnew) {`);
    if (node.model) {
      for (let n in node.model) {
        x(c, sp, `  _tmp.model['${n}'].value = _tmp.props['${n}'] = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
      }
    }
    if (bbn.fn.numProperties(node.directives)) {
      for (let n in node.directives) {
        if (node.directives[n].exp) {
          x(c, sp, `_tmp.directives['${n}'].value = _gIv('${node.directives[n].hash}', ${hashName});`);
        }
      }
    }
    x(c, sp, `  _eles['${node.id}'] = await _t.$createElement(_tmp, _parents.at(-1));`);
    x(c, sp, `  if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `    $_final.push({ele: _eles['${node.id}'], position: $_num});`);
    x(c, sp, `  }`);
    x(c, sp, `}`);
    x(c, sp, `else {`);
    if (node.model) {
      x(c, sp, `  _tmp.model = _eles['${node.id}'].bbnSchema.model;`);
      for (let n in node.model) {
        if (n === '_default_') {
          x(c, sp, `  if (_t.$isComponent(_eles['${node.id}'])) {`);
          x(c, sp, `    let modelProp = _eles['${node.id}'].bbnCfg?.model?.prop || _eles['${node.id}'].constructor?.bbnCfg?.model?.prop || 'value';`);
          x(c, sp, `    _tmp.model[modelProp].value = _tmp.props[modelProp] = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
          x(c, sp, `  }`);
          x(c, sp, `  else {`);
          x(c, sp, `    _tmp.model.value.value = _tmp.props.value = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
          x(c, sp, `  }`);
        } else {
          x(c, sp, `  _tmp.model['${n}'].value = _tmp.props['${n}'] = _sIr(_node.model['${n}'].hash, ${node.model[n].exp}, ${hashName});`);
        }
      }
    }
    if (bbn.fn.numProperties(node.directives)) {
      for (let n in node.directives) {
        if (node.directives[n].exp) {
          x(c, sp, `if (_gIs('${node.directives[n].hash}', ${hashName}) !== "OK") {`);
          x(c, sp, `  _node.directives['${n}'].value = _gIv('${node.directives[n].hash}', ${hashName});`);
          x(c, sp, `  _eles['${node.id}'].bbnSchema.directives['${n}'].value = _gIv('${node.directives[n].hash}', ${hashName});`);
          x(c, sp, `  bbn.cp.updateDirectives({"${n}": _node.directives['${n}']}, _eles['${node.id}']);`);
          x(c, sp, `}`);
        }
      }
    }
    x(c, sp, `  _t.$updateElementFromProps(_tmp, _eles['${node.id}']);`);
    x(c, sp, `}`);
    x(c, sp, `if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `  $_num++;`);
    x(c, sp, `}`);
    let hasEvents = Object.keys(node.events || {}).length > 0;
    if (node.model || hasEvents) {
      x(c, sp, `if (isAnew) {`);
      sp += 2;
      x(c, sp, `let _bbnCurrentElement = _eles['${node.id}'];`);
      if (node.model) {
        for (let name in node.model) {
          let m = node.model[name];
          const modelVarName = m.exp;
          const modelVarBits = bbn.fn.removeEmpty(modelVarName.replace(/\[([^\[\]]*)\]/g, '.$1.').split('.').filter(t => t !== ''));
          const modelVarRoot = modelVarBits[0];
          const eventName = m.modifiers.includes('lazy') ? 'change' : 'input';
          x(c, sp, `let _bbnEventName = '${eventName}';`);
          x(c, sp, `let _bbnRealName = '${name}';`);
          if (name === '_default_') {
            x(c, sp, `let _bbnModelCfg = _t.$isComponent(_eles['${node.id}']) ? _eles['${node.id}'].bbnCfg?.model || _eles['${node.id}'].constructor?.bbnCfg?.model : {prop: 'value', event: _bbnEventName};`);
            x(c, sp, `_bbnRealName = _bbnModelCfg.prop;`);
            x(c, sp, `_bbnEventName = _bbnModelCfg.event;`);
            x(c, sp, `_bbnCurrentElement.bbnSchema.model[_bbnRealName] = _bbnCurrentElement.bbnSchema.model._default_;`);
            x(c, sp, `delete _bbnCurrentElement.bbnSchema.model._default_;`);
            if (node.tag === 'bbn-checkbox') {
              x(c, sp, `bbn.fn.warning(_bbnRealName)`);
            }
          }
          x(c, sp, `_bbnCurrentElement.addEventListener(_bbnEventName, _bbnEventObject => {`);
          x(c, sp, `  let $event = _bbnEventObject;`);
          x(c, sp, `  let _bbnEventValue = $event.detail?.args ? $event.detail.args[0] : $event.target?.value;`);
          x(c, sp, `  let oldValue = bbn.fn.isPrimitive(${modelVarName}) ? _sIr("${m.hash}", ${modelVarName}, ${hashName}) : ${modelVarName};`);
          //x(c, sp, `  bbn.fn.log(["ON MODEL CHANGE", _bbnEventName, oldValue, "${modelVarRoot}", _bbnEventValue, _t.$options.name]);`);
          x(c, sp, `  if (oldValue !== _bbnEventValue) {`);
          if (modelVarRoot === modelVarName) {
            x(c, sp, `    if (Object.hasOwn(_t.$props, "${modelVarRoot}")) {`);
            x(c, sp, `      bbn.fn.log("IS A PROP " + _bbnRealName, _t.$options.name, "${modelVarRoot}", _bbnEventValue);`);
            x(c, sp, `      _t.$setProp("${modelVarRoot}", _bbnEventValue);`);
            x(c, sp, `    }`);
            x(c, sp, `    else {`);
            x(c, sp, `      _t["${modelVarRoot}"] = _bbnEventValue;`);
            x(c, sp, `    }`);
            x(c, sp, `    ${modelVarRoot} = _bbnEventValue;`);
            x(c, sp, `    bbn.fn.log("FROM MODEL " + _bbnRealName, _t.$options.name, _t.$cfg.props, _bbnEventValue, ${modelVarRoot}, "${modelVarRoot}", Object.hasOwn(_t.$cfg.props, "${modelVarRoot}"));`);
          } else {
            x(c, sp, `    ${modelVarName} = _bbnEventValue;`);
          }
          x(c, sp, `    if (_bbnCurrentElement?.bbn) {`);
          x(c, sp, `      _bbnCurrentElement?.bbn.$forceUpdate();`);
          x(c, sp, `    }`);
          x(c, sp, `    _t.$forceUpdate();`);
          x(c, sp, `  }`);
          x(c, sp, `});`);
        }
      }
      if (hasEvents) {
        for (let n in node.events) {
          let ev = node.events[n];
          //x(c, sp, `bbn.fn.log("SETTING EVENT ${n} ON " + _t.$options.name, _ele, ${isAnew});`);
          x(c, sp, `_eles['${node.id}'].addEventListener("${n}", _bbnEventObject => {`);
          //x(c, sp, `  bbn.fn.log("EXECUTING EVENT ${n} ${ev.action} ON ${node.tag}", _bbnEventObject.detail);`);
          x(c, sp, `  let $event = _bbnEventObject;`);
          if (ev.modifiers.length) {
            x(c, sp, `bbn.fn.log($event, "${n}");`);
            if (n.indexOf('key') === 0) {
              x(c, sp, `  if (!_bbnEventObject.key || !${JSON.stringify(ev.modifiers)}.includes(_bbnEventObject.key.toLowerCase())) {`);
              x(c, sp, `    return;`);
              x(c, sp, `  }`);
            } else if (n.indexOf('mouse') === 0) {
              if (ev.modifiers.includes('right')) {
                x(c, sp, `  if (_bbnEventObject.button !== 2) {`);
                x(c, sp, `    return;`);
                x(c, sp, `  }`);
              } else if (ev.modifiers.includes('left')) {
                x(c, sp, `  if (_bbnEventObject.button !== 0) {`);
                x(c, sp, `    return;`);
                x(c, sp, `  }`);
              }
            }
          }
          if (ev.prevent) {
            x(c, sp, `  $event.preventDefault();`);
          }
          if (ev.stop) {
            x(c, sp, `  $event.stopImmediatePropagation();`);
          }
          if (ev.action) {
            if (ev.action.indexOf(';') > -1 || ev.action.indexOf('if') === 0) {
              x(c, sp, `  ${ev.action};`);
            } else {
              x(c, sp, `  let $_action = (${ev.action});`);
              x(c, sp, `  if (bbn.fn.isFunction($_action)) {`);
              x(c, sp, `    const args = _bbnEventObject.detail?.args || [$event];`);
              x(c, sp, `    args.push(_bbnEventObject);`);
              x(c, sp, `    $_action.bind(_t.$origin)(...args);`);
              x(c, sp, `  }`);
            }
            x(c, sp, `  bbn.fn.iterate(_bbnCurrentData, (_bbnCurrentDataValue, _bbnCurrentDataIndex) => {`);
            x(c, sp, `    //bbn.fn.log('_bbnCurrentDataValue, _bbnCurrentDataIndex', _bbnCurrentDataValue, _bbnCurrentDataIndex, eval(_bbnCurrentDataIndex), _t[_bbnCurrentDataIndex], '++++');`);
            x(c, sp, `    if (_bbnCurrentDataValue !== eval(_bbnCurrentDataIndex)) {`);
            x(c, sp, `      if (_t[_bbnCurrentDataIndex] !== undefined) {`);
            x(c, sp, `        _t[_bbnCurrentDataIndex] = eval(_bbnCurrentDataIndex);`);
            x(c, sp, `      }`);
            x(c, sp, `      _bbnCurrentData[_bbnCurrentDataIndex] = _t[_bbnCurrentDataIndex];`);
            x(c, sp, `    }`);
            x(c, sp, `  });`);
          }
          x(c, sp, `  _t.$tick();`);
          let eventEnd = '}';
          if (ev.once || ev.passive || ev.capture) {
            eventEnd += ', {';
            if (ev.once) {
              eventEnd += `once: true,`;
            }
            if (ev.passive) {
              eventEnd += `passive: true,`;
            }
            if (ev.capture) {
              eventEnd += `capture: true,`;
            }
            eventEnd += '}';
          }
          eventEnd += ');';
          x(c, sp, eventEnd);
        }
      }
      sp -= 2;
      x(c, sp, `}`);
      x(c, sp, ``);
      x(c, sp, ``);
    }
    sp -= 2;
    // End if ($_go)
    x(c, sp, `}`);
  }
  return c.text;
};
const treatSlot = function (cp, node, hashName) {
  const c = x();
  if (node.tag === 'slot') {
    var _node$attr2;
    let slot = "'default'";
    if ((_node$attr2 = node.attr) !== null && _node$attr2 !== void 0 && _node$attr2.name) {
      slot = node.attr.name.exp ? `${node.attr.name.exp}` : `'${node.attr.name.value}'`;
    }
    x(c, sp, `_eles['${node.id}'] = _parents.at(-1);`);
    x(c, sp, `if (_t.$el.bbnSlots?.[${slot}]?.length) {`);
    // Iterating the elements going in the slot
    x(c, sp, `  bbn.fn.each(_t.$el.bbnSlots[${slot}], a => {`);
    //x(c, sp, `    bbn.fn.log("This is a slot element", a)`);
    x(c, sp, `    let search = {bbnId: a.bbnId};`);
    x(c, sp, `    if (a.bbnHash) {`);
    x(c, sp, `      search.bbnHash = a.bbnHash;`);
    x(c, sp, `    }`);
    // Case where the slot is inside another component
    x(c, sp, `    if ((_parents.at(-1) !== _t.$el) && bbn.cp.isComponent(_parents.at(-1))) {`);
    x(c, sp, `      let idx = bbn.fn.search(_parents.at(-1).bbnSlots[${slot}], search);`);
    x(c, sp, `      _parents.at(-1).bbnSlots.default.splice(idx > -1 ? idx : _parents.at(-1).bbnSlots.default.length, idx > -1 ? 1 : 0, a);`);
    x(c, sp, `      if (_parents.at(-1).bbn) {`);
    x(c, sp, `        _parents.at(-1).bbn.$tick();`);
    x(c, sp, `      }`);
    x(c, sp, `    }`);
    // Else if only the element is not mounted (otherwise it's already there)
    x(c, sp, `    else if (!a.parentNode) {`);
    x(c, sp, `      if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `        $_final.push({ele: a, position: $_num});`);
    x(c, sp, `      }`);
    x(c, sp, `      else {`);
    x(c, sp, `        let idx = bbn.fn.search(_parents.at(-1).childNodes, search);`);
    x(c, sp, `        if (idx > -1) {`);
    x(c, sp, `          _parents.at(-1).replaceChild(a, _parents.at(-1).childNodes[idx]);`);
    x(c, sp, `        }`);
    x(c, sp, `        else {`);
    x(c, sp, `          _parents.at(-1).appendChild(a);`);
    x(c, sp, `        }`);
    x(c, sp, `      }`);
    x(c, sp, `    }`);
    x(c, sp, `    if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `      $_num++;`);
    x(c, sp, `    }`);
    x(c, sp, `  });`);
    x(c, sp, `}`);
    c.text += treatItems(cp, node, hashName);
  }
  return c.text;
};
const treatText = function (node, hashName) {
  const c = x();
  if (node.text) {
    x(c, sp, `_sIr('${node.hash}', \`${bbn.fn.escapeTicks(node.text)}\`, ${hashName});`);
    x(c, sp, `if ($_go['${node.id}'] || (_gIs('${node.hash}', ${hashName}) !== "OK")) {`);
    x(c, sp, `  if (_eles['${node.id}'] && (_eles['${node.id}'].textContent !== _gIv('${node.hash}', ${hashName}))) {`);
    x(c, sp, `    _eles['${node.id}'].textContent = _gIv('${node.hash}', ${hashName});`);
    x(c, sp, `  }`);
    x(c, sp, `  else {`);
    x(c, sp, `    _eles['${node.id}'] = _t.$createText({`);
    x(c, sp, `      id: '${node.id}',`);
    x(c, sp, `      hash: '${node.hash}',`);
    x(c, sp, `      text: _gIv('${node.hash}', ${hashName}),`);
    x(c, sp, `      loopHash: ${hashName},`);
    x(c, sp, `    }, _parents.at(-1));`);
    x(c, sp, `    if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `      $_final.push({ele: _eles['${node.id}'], position: $_num});`);
    x(c, sp, `    }`);
    x(c, sp, `  }`);
    x(c, sp, `}`);
    x(c, sp, `if (_parents.at(-1) === _t.$el) {`);
    x(c, sp, `  $_num++;`);
    x(c, sp, `}`);
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};
const treatItems = function (cp, node, hashName) {
  var _node$items;
  const c = x();
  if ((_node$items = node.items) !== null && _node$items !== void 0 && _node$items.length) {
    x(c, sp, `if (_eles['${node.id}']) {`);
    sp += 2;
    x(c, sp, `_parents.push(_eles['${node.id}']);`);
    c.text += nodesToFunction(cp, node.items, hashName);
    x(c, sp, `_parents.pop();`);
    sp -= 2;
    x(c, sp, `}`);
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};
const endCondition = function (node) {
  const c = x();
  if (node.condition) {
    sp -= 2;
    x(c, sp, `//Ending condition`);
    x(c, sp, `}`);
    x(c, sp, ``);
    x(c, sp, ``);
  }
  return c.text;
};

/**
 * Recursive function that takes an array of objects representing nodes in an 
 * HTML-like structure and generates JavaScript code based on those nodes. 
 * 
 * @param {Array} arr the nodes array
 * @param {String} varName variable name that is used to reference the data object that corresponds to the current node
 * @param {Number} sp number of spaces to use for indentation in the generated code
 * @param {Array} done array that keeps track of variables that have already been defined to avoid re-definition
 * @returns {String}
 */
const nodesToFunction = function (cp, arr, hashName) {
  const c = x();
  let conditions = [];
  let conditionId = null;
  bbn.fn.each(arr, (node, i) => {
    var _node$loop, _node$forget;
    x(c, sp, '');
    x(c, sp, `// Taking care of the node ${node.tag || 'with no tag'} ${node.id}`);
    if ((_node$loop = node.loop) !== null && _node$loop !== void 0 && _node$loop.exp) {
      c.text += treatLoop(cp, node, hashName);
      return;
    }

    // Launching condition (MUST be before the rest)
    if (node.condition) {
      if (node.conditionId !== conditionId && !conditions.includes(node.conditionId)) {
        conditions.push(node.conditionId);
        conditionId = node.conditionId;
        c.text += treatCondition(cp, node, arr, hashName);
      }
      let condText = node.condition.type === 'elseif' ? 'else if' : node.condition.type;
      if (node.condition.type !== 'else') {
        condText += ' (_gIv("' + node.condition.hash + '", ' + hashName + '))';
      }
      // New level
      condText += ' {';
      x(c, sp, condText);
      sp += 2;
    }
    x(c, sp, `oldEle = _t.$retrieveElement("${node.id}", ${hashName});`);
    x(c, sp, `_node = _t.$currentMap['${node.id}'];`);
    x(c, sp, `_eles['${node.id}'] = oldEle;`);
    x(c, sp, `if (!Object.hasOwn($_go, '${node.id}')) {`);
    x(c, sp, `  $_go['${node.id}'] = !oldEle;`);
    x(c, sp, `}`);

    // Setting _forgotten variable
    if ((_node$forget = node.forget) !== null && _node$forget !== void 0 && _node$forget.exp) {
      x(c, sp, `_sIr('${node.forget.hash}', ${node.forget.exp}, ${hashName});`);
      x(c, sp, `if (!_forgotten['${node.id}']) {`);
      x(c, sp, `  _forgotten['${node.id}'] = bbn.fn.createObject();`);
      x(c, sp, `}`);
      x(c, sp, `_forgotten['${node.id}'][${hashName} || '_root'] = _gIv('${node.forget.hash}', ${hashName});`);
      x(c, sp, `if (_forgotten['${node.id}'][${hashName} || '_root']) {`);
      x(c, sp, `  _eles['${node.id}'] = _parents.at(-1);`);
      x(c, sp, `  $_go['${node.id}'] = false;`);
      x(c, sp, `}`);
      x(c, sp, `else if (['NEW', 'MOD'].includes(_gIs('${node.forget.hash}', ${hashName}))) {`);
      x(c, sp, `  $_go['${node.id}'] = true;`);
      x(c, sp, `}`);
      x(c, sp, ``);
      x(c, sp, ``);
    }
    let treatEle = true;
    if (!node.pre && node.tag === 'template' || 'transition' === node.tag) {
      x(c, sp, `_eles['${node.id}'] = _parents.at(-1);`);
      x(c, sp, `$_go['${node.id}'] = false;`);
      treatEle = false;
    } else {
      x(c, sp, `if (!$_go['${node.id}'] && !_eles['${node.id}']) {`);
      x(c, sp, `  $_go['${node.id}'] = true;`);
      x(c, sp, `}`);
    }
    //x(c, sp, `bbn.fn.log(["nodesToFunction", "${node.tag || 'no'}", $_go['${node.id}']]);`);

    if (node.text) {
      c.text += treatText(node, hashName);
    } else if (node.tag === 'slot') {
      c.text += treatSlot(cp, node, hashName);
    } else if (node.tag) {
      var _node$forget2;
      c.text += setProperties(node, hashName);
      //c.text += setDirectives(node, hashName);
      if (treatEle) {
        c.text += treatElement(cp, node, hashName);
      }
      if ((_node$forget2 = node.forget) !== null && _node$forget2 !== void 0 && _node$forget2.exp) {
        x(c, sp, `if (_gIs('${node.forget.hash}', ${hashName}) === 'MOD') {`);
        x(c, sp, `  if (_forgotten['${node.id}']?.[${hashName} || '_root']) {`);
        x(c, sp, `    if (oldEle) {`);
        x(c, sp, `      oldEle.childNodes.forEach(o => {`);
        x(c, sp, `        _parents.at(-1).appendChild(o);`);
        x(c, sp, `      });`);
        x(c, sp, `      bbn.fn.log("From here");`);
        x(c, sp, `      _t.$removeDOM(oldEle);`);
        x(c, sp, `    }`);
        x(c, sp, `    // Ele is the current parent`);
        x(c, sp, `    _eles['${node.id}'] = _parents.at(-1);`);
        x(c, sp, `  }`);
        x(c, sp, `  else {`);
        x(c, sp, `    _parents.at(-1).childNodes.forEach(o => {`);
        x(c, sp, `      if (o.bbnId.indexOf('${node.id}' + "-") === 0) {`);
        x(c, sp, `        _eles['${node.id}'].appendChild(o);`);
        x(c, sp, `      }`);
        x(c, sp, `    });`);
        x(c, sp, `  }`);
        x(c, sp, `}`);
        x(c, sp, `else if (_forgotten['${node.id}']?.[${hashName} || '_root']) {`);
        x(c, sp, `  _eles['${node.id}'] = _parents.at(-1);`);
        x(c, sp, `}`);
        x(c, sp, ``);
        x(c, sp, ``);
      }
      if (node.pre) {
        x(c, sp, `if (_eles['${node.id}']) {`);
        x(c, sp, `  _eles['${node.id}'].innerHTML = \`${bbn.fn.escapeTicks(node.pre)}\`;`);
        x(c, sp, `}`);
        x(c, sp, ``);
        x(c, sp, ``);
      } else {
        c.text += treatItems(cp, node, hashName);
      }
      x(c, sp, `if ((_t.$el === _parents.at(-1)) && _eles['${node.id}'] && (_eles['${node.id}'] !== _t.$el)) {`);
      x(c, sp, `  $_num++;`);
      x(c, sp, `}`);
    }
    c.text += endCondition(node);
  });
  return c.text;
};

/**
 * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not
 * - Updates the component element based on its own schema ($el.bbnSchema)
 * - Updates the schema
 * - Generates/update the DOM when needed
 * 
 * @param {Boolean} shadow The content will go to the shadow DOM if true
 * @returns {Promise}
 */
export default function templateToFunction(cp, tpl) {
  var _tpl$0$attr, _tpl$0$attr2, _tpl$0$attr3, _tpl$0$attr4;
  let sp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let hashName = '_bbnHash';
  let c = x();
  x(c, sp, `async (_t, _d) => {`);
  sp += 2;
  x(c, sp, `const _r = _t.$currentResult;`);
  x(c, sp, `let ${hashName} = '';`);
  x(c, sp, `bbn.fn.iterate(_r, a => {`);
  x(c, sp, `  bbn.fn.iterate(a, b => {`);
  x(c, sp, `    if (b.state !== 'DEL') {`);
  x(c, sp, `      b.state = 'TMP';`);
  x(c, sp, `    }`);
  x(c, sp, `  });`);
  x(c, sp, `});`);
  x(c, sp, `const _bbnCurrentData = bbn.fn.createObject();`);
  let argNames = [];
  let argValues = [];
  for (let n in cp.$namespaces) {
    argNames.push(n);
    argValues.push(cp.$namespaces[n] === 'method' ? `_t['${n}'].bind(_t)` : `_t['${n}']`);
    if (n.indexOf('$') !== 0 && !['method', 'props'].includes(cp.$namespaces[n]) && n !== 'internal') {
      x(c, sp, `_bbnCurrentData["${n}"] = _t.${n};`);
    }
  }
  x(c, sp, `await (async function (${argNames.join(', ')}) {`);
  sp += 2;

  //x(c, sp, `let ownProps = Object.getOwnPropertyNames(_t);`);
  //x(c, sp, `let n;`);
  //x(c, sp, `for (let i = 0; n = ownProps[i]; i++) {`);
  //x(c, sp, `  if ((n.indexOf('$') !== 0) && !_t.$namespaces[n]) {`);
  //x(c, sp, `    bbn.fn.warning('var ' + n + ' = _t["' + n + '"];');`);
  //x(c, sp, `    eval('var ' + n + ' = _t["' + n + '"];');`);
  //x(c, sp, `  }`);
  //x(c, sp, `}`);

  x(c, sp, `// _setInternalResult`);
  x(c, sp, `const _sIr = (_name, _exp, _hash) => {`);
  x(c, sp, `  return _t.$_setInternalResult(_r, _name, _exp, _hash);`);
  x(c, sp, `};`);
  x(c, sp, `// _getInternalState`);
  x(c, sp, `const _gIs = (_name, _hash) => {`);
  x(c, sp, `  return _t.$_getInternalState(_r, _name, _hash);`);
  x(c, sp, `};`);
  x(c, sp, `// _getInternalValue`);
  x(c, sp, `const _gIv = (_name, _hash) => {`);
  x(c, sp, `  let val = undefined;`);
  x(c, sp, `  try {`);
  x(c, sp, `    val = _t.$_getInternalValue(_r, _name, _hash);`);
  x(c, sp, `  } catch (e) {`);
  x(c, sp, `    bbn.fn.log("THERE SHOULD BE AN ERROR", _name, _t);`);
  x(c, sp, `  }`);
  x(c, sp, `  return val;`);
  x(c, sp, `};`);
  x(c, sp, `const _eles = bbn.fn.createObject({"-": _t.$el});`);
  x(c, sp, `let _isCondTrue = false;`);
  x(c, sp, `let _props = bbn.fn.createObject();`);
  x(c, sp, `let _lastId = '';`);
  x(c, sp, `let _tmp;`);
  x(c, sp, `let _tmp2;`);
  x(c, sp, `let _node;`);
  x(c, sp, `let isAnew;`);
  x(c, sp, `let oldEle;`);
  x(c, sp, `const _cps = [];`);
  x(c, sp, `const _parents = [_t.$el];`);
  x(c, sp, `let $_ct = _t.$el;`);
  x(c, sp, `const _forgotten = bbn.fn.createObject();`);
  x(c, sp, `const $_go = bbn.fn.createObject();`);
  x(c, sp, `let $_num = 0;`);
  x(c, sp, `const $_final = [];`);
  x(c, sp, `_r._num++;`);
  if (tpl.length === 1 && tpl[0].items && !((_tpl$0$attr = tpl[0].attr) !== null && _tpl$0$attr !== void 0 && _tpl$0$attr['bbn-if']) && !((_tpl$0$attr2 = tpl[0].attr) !== null && _tpl$0$attr2 !== void 0 && _tpl$0$attr2['bbn-for']) && !((_tpl$0$attr3 = tpl[0].attr) !== null && _tpl$0$attr3 !== void 0 && _tpl$0$attr3['bbn-model']) && !((_tpl$0$attr4 = tpl[0].attr) !== null && _tpl$0$attr4 !== void 0 && _tpl$0$attr4['bbn-forget']) && !bbn.cp.isComponent(tpl[0]) && (['div', 'span'].includes(tpl[0].tag) || tpl[0].tag === cp.$cfg.tag)) {
    //x(c, sp, `_eles['0-0'] = _t.$el;`);
    if (tpl[0].attr) {
      for (let n in tpl[0].attr) {
        x(c, sp, `_props["${n}"] = `);
        if (tpl[0].attr[n].exp) {
          x(c, sp, `_sIr("${tpl[0].attr[n].hash}", ${tpl[0].attr[n].exp}, ${hashName});`);
        } else {
          x(c, sp, `"${bbn.fn.escapeDquotes(tpl[0].attr[n].value)}";`);
        }
      }
      if (bbn.fn.numProperties(tpl[0].directives)) {
        for (let n in tpl[0].directives) {
          x(c, sp, `if (!_t.$el.bbnSchema.directives) {_t.$el.bbnSchema.directives = bbn.fn.createObject();}`);
          x(c, sp, `if (!_t.$el.bbnSchema.directives['${n}']) {_t.$el.bbnSchema.directives['${n}'] = bbn.fn.clone(_t.$tpl[0].directives['${n}']);}`);
          if (tpl[0].directives[n].exp) {
            x(c, sp, `  _t.$el.bbnSchema.directives['${n}'].value = _sIr('${tpl[0].directives[n].hash}', ${tpl[0].directives[n].exp}, ${hashName});`);
          }
          x(c, sp, `if (!_t.$el.bbnDirectives) {Object.defineProperty(_t.$el, 'bbnDirectives', {value: bbn.fn.createObject(), writable: false, configurable: false});}`);
          x(c, sp, `if (!_t.$el.bbnDirectives['{$n}']) {_t.$el.bbnDirectives['${n}'] = bbn.fn.createObject();}`);
        }
        x(c, sp, `if (!_t.$numBuild) {`);
        x(c, sp, `  bbn.cp.insertDirectives(_t.$el.bbnSchema.directives, _t.$el);`);
        x(c, sp, `}`);
        for (let n in tpl[0].directives) {
          x(c, sp, `if (_t.$numBuild) {`);
          x(c, sp, `  bbn.cp.updateDirectives({"${n}": _t.$el.bbnSchema.directives['${n}']}, _t.$el);`);
          x(c, sp, `}`);
        }
      }
      x(c, sp, `_t.$updateFromSchema(_props);`);
      if (tpl[0].events) {
        x(c, sp, `if (_r._num === 1) {`);
        sp += 2;
        for (let n in tpl[0].events) {
          let ev = tpl[0].events[n];
          x(c, sp, `if (!_eles['-'].bbnSchema?.events?.["${n}"]) {`);
          sp += 2;
          //x(c, sp, `bbn.fn.log("SETTING EVENT ${n} ON " + _t.$options.name, _ele, ${isAnew});`);
          x(c, sp, `_eles['-'].addEventListener("${n}", _bbnEventObject => {`);
          //x(c, sp, `  bbn.fn.log("EXECUTING EVENT ${n} ${ev.action} ON ${node.tag}", _bbnEventObject.detail);`);
          if (ev.modifiers.length) {
            x(c, sp, `  if (!_bbnEventObject.key || !${JSON.stringify(ev.modifiers)}.includes(_bbnEventObject.key.toLowerCase())) {`);
            x(c, sp, `    return;`);
            x(c, sp, `  }`);
          }
          x(c, sp, `  let $event = _bbnEventObject;`);
          if (ev.prevent) {
            x(c, sp, `  $event.preventDefault();`);
          }
          if (ev.stop) {
            x(c, sp, `  $event.stopImmediatePropagation();`);
          }
          if (ev.action) {
            if (ev.action.indexOf(';') > -1 || ev.action.indexOf('if') === 0) {
              x(c, sp, `  ${ev.action};`);
            } else {
              x(c, sp, `  let $_action = (${ev.action});`);
              x(c, sp, `  if (bbn.fn.isFunction($_action)) {`);
              x(c, sp, `    const args = _bbnEventObject.detail?.args || [$event];`);
              x(c, sp, `    args.push(_bbnEventObject);`);
              x(c, sp, `    $_action.bind(_t.$origin)(...args);`);
              x(c, sp, `  }`);
            }
            x(c, sp, `  bbn.fn.iterate(_bbnCurrentData, (_bbnCurrentDataValue, _bbnCurrentDataIndex) => {`);
            x(c, sp, `    //bbn.fn.log('_bbnCurrentDataValue, _bbnCurrentDataIndex', _bbnCurrentDataValue, _bbnCurrentDataIndex, eval(_bbnCurrentDataIndex), _t[_bbnCurrentDataIndex], '++++');`);
            x(c, sp, `    if (_bbnCurrentDataValue !== eval(_bbnCurrentDataIndex)) {`);
            x(c, sp, `      if (_t[_bbnCurrentDataIndex] !== undefined) {`);
            x(c, sp, `        _t[_bbnCurrentDataIndex] = eval(_bbnCurrentDataIndex);`);
            x(c, sp, `      }`);
            x(c, sp, `      _bbnCurrentData[_bbnCurrentDataIndex] = _t[_bbnCurrentDataIndex];`);
            x(c, sp, `    }`);
            x(c, sp, `  });`);
          }
          x(c, sp, `  _t.$forceUpdate();`);
          let eventEnd = '}';
          if (ev.once || ev.passive || ev.capture) {
            eventEnd += ', {';
            if (ev.once) {
              eventEnd += `once: true,`;
            }
            if (ev.passive) {
              eventEnd += `passive: true,`;
            }
            if (ev.capture) {
              eventEnd += `capture: true,`;
            }
            eventEnd += '}';
          }
          eventEnd += ');';
          x(c, sp, eventEnd);
          sp -= 2;
          x(c, sp, '}');
        }
        sp -= 2;
        x(c, sp, `}`);
      }
    } else {
      x(c, sp, `_t.$updateFromSchema();`);
    }
    c.text += nodesToFunction(cp, tpl[0].items, hashName);
  } else {
    x(c, sp, `_t.$updateFromSchema();`);
    c.text += nodesToFunction(cp, tpl, hashName);
  }
  //x(c, sp, `bbn.fn.warning("KKKKK"); bbn.fn.log($_final);`);
  x(c, sp, `bbn.fn.each($_final, a => {`);
  x(c, sp, `  if (_t.$el.childNodes[a.position]) {`);
  x(c, sp, `    _t.$insertElement(a.ele, _t.$el, _t.$el.childNodes[a.position]);`);
  x(c, sp, `  }`);
  x(c, sp, `  else {`);
  x(c, sp, `    _t.$insertElement(a.ele, _t.$el);`);
  x(c, sp, `  }`);
  x(c, sp, `})`);
  sp -= 2;
  x(c, sp, `})(${argValues.join(', ')});`);
  x(c, sp, `bbn.fn.iterate(_r, a => {`);
  x(c, sp, `  bbn.fn.iterate(a, b => {`);
  x(c, sp, `    if (b.state === 'TMP') {`);
  x(c, sp, `      b.state = 'DEL';`);
  x(c, sp, `    }`);
  x(c, sp, `  });`);
  x(c, sp, `});`);
  x(c, sp, `return _r;`);
  sp -= 2;
  x(c, sp, `}`);
  return eval(c.text);
}
/**
 * This function takes in a template and returns a string version of the template
 * @param {Array} tpl - The template array to be converted
 * @param {number} depth - The depth's level of where we are in the template
 * @return {string} The string version of the template
 */
export default function templateToString(tpl) {
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  res = depth ? '' : '`';
  let hasIf = false;
  let hasElseIf = false;
  let numElse = 0;
  let hasElse = false;
  const space = ' ';
  const closing = ')';
  // Each element
  bbn.fn.each(tpl, ele => {
    if (ele.text) {
      res += ele.text;
    } else if (ele.tag) {
      if (ele.props['bbn-for']) {
        let bits = ele.props['bbn-for'].split(' in ');
        if (bits.length !== 2) {
          throw new Error("Malformed for loop");
        }
        depth++;
        res += '` +\n' + space.repeat(depth * 2) + '(() => {\n' + space.repeat(depth * 2 + 2) + 'const bbnConstSt = "";\n' + space.repeat(depth * 2 + 2) + 'bbn.fn.each (' + bits[1] + ', ' + bits[0] + ' => {\n' + space.repeat(depth * 2 + 4) + 'bbnConstSt += `\n';
      }
      if (ele.props['bbn-if']) {
        if (hasIf) {
          res += '` : ``) + `';
        }
        res += '`\n' + space.repeat(depth * 2) + ' + (';
        res += ele.props['bbn-if'] + ' ? `\n';
        hasIf = true;
        hasElseIf = hasElse = false;
        numElse = 0;
      } else if (ele.props['bbn-elseif']) {
        numElse++;
        hasElseIf = true;
        hasIf = hasElse = false;
        res += '` : ( ' + ele.props['bbn-elseif'] + ' ? `\n';
      } else if (ele.props['bbn-else']) {
        hasElse = true;
        hasElseIf = hasIf = false;
        res += '` +\n' + space.repeat(depth * 2) + '(';
        res += ele.props['bbn-if'] + ' ? `';
        numElse = 0;
      } else if (hasIf) {
        res += '` : ``)\n';
        hasIf = hasElse = hasElseIf = false;
        numElse = 0;
      } else if (hasElseIf) {
        res += '` : ``' + closing.repeat(numElse) + '\n';
        hasIf = hasElse = hasElseIf = false;
        numElse = 0;
      } else if (hasElse) {
        res += '`' + closing.repeat(numElse + 1) + '\n';
        hasIf = hasElse = hasElseIf = false;
        numElse = 0;
      }
      res += space.repeat(depth * 2) + '<' + ele.tag;
      let propNum = 0;
      this.bbn.fn.each(ele.props, (value, name) => {
        if (name.indexOf('bbn-') !== 0) {
          if (!propNum) {
            res += ' ';
          } else {
            res += '\n' + space.repeat(depth * 2 + ele.tag.length + 2);
          }
          if (name === ':class') {
            res += 'class="${bbn.cp.convertClasses(' + value + ')}"';
          } else if (name === ':style') {
            res += 'style="${bbn.cp.convertStyles(' + value + ')}"';
          } else if (name.indexOf(':') === 0) {
            res += name.substr(1) + '="${' + value + '}"';
          } else {
            res += name + '="' + value + '"';
          }
          propNum++;
        }
      });
      res += '>\n';
      if (ele.props['bbn-html']) {
        res += '${' + value + '}\n';
      } else if (ele.props['bbn-text']) {
        res += '${bbn.fn.html2text(' + value + ')}\n';
      }
      if (ele.items) {
        res += bbn.cp.templateToString(ele.items, depth + 1) + '\n';
      } else if (ele.slots) {
        res += bbn.cp.templateToString(ele.slots, depth + 1) + '\n';
      }
      res += space.repeat(depth * 2) + '</' + ele.tag + '>';
      if (ele.props['bbn-for']) {
        depth--;
        res += '`;\n' + space.repeat(depth * 2 + 2) + '})\n' + space.repeat(depth * 2 + 2) + 'return bbnConstSt;\n' + space.repeat(depth * 2) + '})() + `';
      }
    }
  });
  if (hasIf) {
    res += '` : ``) + `';
    hasIf = hasElse = hasElseIf = false;
    numElse = 0;
  } else if (hasElseIf) {
    res += '` : ``' + closing.repeat(numElse) + '\n';
    hasIf = hasElse = hasElseIf = false;
    numElse = 0;
  } else if (hasElse) {
    res += '`' + closing.repeat(numElse + 1) + '\n';
    hasIf = hasElse = hasElseIf = false;
    numElse = 0;
  }
  if (!depth) {
    res += '`';
  }
  return res;
}
/**
 * Updates the given directives to the target element
 * @param {Object} directives
 * @param {HTMLElement} target
 */
export default function updateDirectives(directives, target) {
  if (bbn.fn.isObject(directives) && Object.keys(directives).length) {
    bbn.fn.iterate(directives, (dir, name) => {
      // Check if the "updated" function exists on this directive
      if (bbn.fn.isFunction(bbn.cp.directives[name].update)
      // Check if the value of the directive has changed
      && !bbn.fn.isSame(dir.value, dir.oldValue)) {
        // Set the "lastUpdate" property
        dir.lastUpdate = bbn.fn.dateSQL();
        // Call the "updated" function of the directive
        bbn.cp.directives[name].update(target, dir);
      }
    });
  }
}
import { bbn, axios, dayjs } from "@bbn/bbn/dist/index.js";
import addComponent from "./cp/addComponent.js";
import addPrefix from "./cp/addPrefix.js";
import analyzeElement from "./cp/analyzeElement.js";
import attributeChangedCallback from "./cp/attributeChangedCallback.js";
import connectedCallback from "./cp/connectedCallback.js";
import convertClasses from "./cp/convertClasses.js";
import convertStyles from "./cp/convertStyles.js";
import createApp from "./cp/createApp.js";
import createCid from "./cp/createCid.js";
import define from "./cp/define.js";
import disconnectedCallback from "./cp/disconnectedCallback.js";
import executeQueueItem from "./cp/executeQueueItem.js";
import executeQueueItems from "./cp/executeQueueItems.js";
import fetchComponents from "./cp/fetchComponents.js";
import generateCpClass from "./cp/generateCpClass.js";
import generateHTMLClass from "./cp/generateHTMLClass.js";
import getComponent from "./cp/getComponent.js";
import initDefaults from "./cp/initDefaults.js";
import insertDirectives from "./cp/insertDirectives.js";
import isComponent from "./cp/isComponent.js";
import isTag from "./cp/isTag.js";
import mapAttributes from "./cp/mapAttributes.js";
import mapTemplate from "./cp/mapTemplate.js";
import normalizeComponent from "./cp/normalizeComponent.js";
import queueComponent from "./cp/queueComponent.js";
import realDefineComponent from "./cp/realDefineComponent.js";
import removeComponent from "./cp/removeComponent.js";
import removeSelfClosing from "./cp/removeSelfClosing.js";
import repeatTick from "./cp/repeatTick.js";
import retrieveModels from "./cp/retrieveModels.js";
import retrieveSlots from "./cp/retrieveSlots.js";
import setComputed from "./cp/setComputed.js";
import setDefaults from "./cp/setDefaults.js";
import startTick from "./cp/startTick.js";
import stopTick from "./cp/stopTick.js";
import stringToTemplate from "./cp/stringToTemplate.js";
import templateToFunction from "./cp/templateToFunction.js";
import templateToString from "./cp/templateToString.js";
import updateDirectives from "./cp/updateDirectives.js";
import basic from "./cp/mixins/basic.js";
import browserNotification from "./cp/mixins/browserNotification.js";
import close from "./cp/mixins/close.js";
import componentInside from "./cp/mixins/componentInside.js";
import config from "./cp/mixins/config.js";
import data from "./cp/mixins/data.js";
import dataEditor from "./cp/mixins/dataEditor.js";
import dimensions from "./cp/mixins/dimensions.js";
import dropdown from "./cp/mixins/dropdown.js";
import editableList from "./cp/mixins/editableList.js";
import empty from "./cp/mixins/empty.js";
import events from "./cp/mixins/events.js";
import field from "./cp/mixins/field.js";
import input from "./cp/mixins/input.js";
import keepCool from "./cp/mixins/keepCool.js";
import keynav from "./cp/mixins/keynav.js";
import list from "./cp/mixins/list.js";
import localStorage from "./cp/mixins/localStorage.js";
import memory from "./cp/mixins/memory.js";
import observer from "./cp/mixins/observer.js";
import pageable from "./cp/mixins/pageable.js";
import popup from "./cp/mixins/popup.js";
import position from "./cp/mixins/position.js";
import resizer from "./cp/mixins/resizer.js";
import serviceWorker from "./cp/mixins/serviceWorker.js";
import toggle from "./cp/mixins/toggle.js";
import url from "./cp/mixins/url.js";
import view from "./cp/mixins/view.js";
import draggable from "./cp/directives/draggable.js";
import droppable from "./cp/directives/droppable.js";
import focused from "./cp/directives/focused.js";
import portal from "./cp/directives/portal.js";
import resizable from "./cp/directives/resizable.js";
const possibleAttributes = ['is', 'source', 'ref', 'slot', 'id', 'class', 'style', 'key'];
/** Custom elements polyfill */
!function () {
  "use strict";

  var e = (e, t) => {
    const n = e => {
        for (let t = 0, {
            length: n
          } = e; t < n; t++) o(e[t]);
      },
      o = _ref => {
        let {
          target: e,
          attributeName: t,
          oldValue: n
        } = _ref;
        e.attributeChangedCallback(t, n, e.getAttribute(t));
      };
    return (r, l) => {
      const {
        observedAttributes: s
      } = r.constructor;
      return s && e(l).then(() => {
        new t(n).observe(r, {
          attributes: !0,
          attributeOldValue: !0,
          attributeFilter: s
        });
        for (let e = 0, {
            length: t
          } = s; e < t; e++) r.hasAttribute(s[e]) && o({
          target: r,
          attributeName: s[e],
          oldValue: null
        });
      }), r;
    };
  };
  /*! (c) Andrea Giammarchi - ISC */
  const t = !0,
    n = !1,
    o = "querySelectorAll",
    r = "querySelectorAll",
    {
      document: l,
      Element: s,
      MutationObserver: c,
      Set: a,
      WeakMap: i
    } = self,
    u = e => r in e,
    {
      filter: f
    } = [];
  var h = e => {
    const h = new i(),
      d = (t, n) => {
        let o;
        if (n) for (let r, l = (e => e.matches || e.webkitMatchesSelector || e.msMatchesSelector)(t), s = 0, {
            length: c
          } = p; s < c; s++) l.call(t, r = p[s]) && (h.has(t) || h.set(t, new a()), o = h.get(t), o.has(r) || (o.add(r), e.handle(t, n, r)));else h.has(t) && (o = h.get(t), h.delete(t), o.forEach(o => {
          e.handle(t, n, o);
        }));
      },
      g = function (e) {
        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        for (let n = 0, {
            length: o
          } = e; n < o; n++) d(e[n], t);
      },
      {
        query: p
      } = e,
      m = e.root || l,
      y = function (e) {
        let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
        let l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MutationObserver;
        let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ["*"];
        const c = (n, r, l, s, a, i) => {
            for (const u of n) (i || o in u) && (a ? l.has(u) || (l.add(u), s.delete(u), e(u, a)) : s.has(u) || (s.add(u), l.delete(u), e(u, a)), i || c(u[o](r), r, l, s, a, t));
          },
          a = new l(e => {
            if (s.length) {
              const o = s.join(","),
                r = new Set(),
                l = new Set();
              for (const {
                addedNodes: s,
                removedNodes: a
              } of e) c(a, o, r, l, n, n), c(s, o, r, l, t, n);
            }
          }),
          {
            observe: i
          } = a;
        return (a.observe = e => i.call(a, e, {
          subtree: t,
          childList: t
        }))(r), a;
      }(d, m, c, p),
      {
        attachShadow: w
      } = s.prototype;
    return w && (s.prototype.attachShadow = function (e) {
      const t = w.call(this, e);
      return y.observe(t), t;
    }), p.length && g(m[r](p)), {
      drop: e => {
        for (let t = 0, {
            length: n
          } = e; t < n; t++) h.delete(e[t]);
      },
      flush: () => {
        const e = y.takeRecords();
        for (let t = 0, {
            length: n
          } = e; t < n; t++) g(f.call(e[t].removedNodes, u), !1), g(f.call(e[t].addedNodes, u), !0);
      },
      observer: y,
      parse: g
    };
  };
  const {
      document: d,
      Map: g,
      MutationObserver: p,
      Object: m,
      Set: y,
      WeakMap: w,
      Element: b,
      HTMLElement: E,
      Node: v,
      Error: S,
      TypeError: M,
      Reflect: O
    } = self,
    {
      defineProperty: A,
      keys: N,
      getOwnPropertyNames: q,
      setPrototypeOf: C
    } = m;
  let T = !self.customElements;
  const D = e => {
    const t = N(e),
      n = [],
      {
        length: o
      } = t;
    for (let r = 0; r < o; r++) n[r] = e[t[r]], delete e[t[r]];
    return () => {
      for (let r = 0; r < o; r++) e[t[r]] = n[r];
    };
  };
  if (T) {
    const {
        createElement: L
      } = d,
      P = new g(),
      $ = new g(),
      k = new g(),
      I = new g(),
      x = [],
      H = (e, t, n) => {
        const o = k.get(n);
        if (t && !o.isPrototypeOf(e)) {
          const t = D(e);
          R = C(e, o);
          try {
            new o.constructor();
          } finally {
            R = null, t();
          }
        }
        const r = (t ? "" : "dis") + "connectedCallback";
        r in o && e[r]();
      },
      {
        parse: _
      } = h({
        query: x,
        handle: H
      });
    let R = null;
    const V = e => {
        if (!$.has(e)) {
          let t,
            n = new Promise(e => {
              t = e;
            });
          $.set(e, {
            $: n,
            _: t
          });
        }
        return $.get(e).$;
      },
      j = e(V, p);
    function W() {
      const {
        constructor: e
      } = this;
      if (!P.has(e)) throw new M("Illegal constructor");
      const t = P.get(e);
      if (R) return j(R, t);
      const n = L.call(d, t);
      return j(C(n, e.prototype), t);
    }
    A(self, "customElements", {
      configurable: !0,
      value: {
        define: (e, t) => {
          if (I.has(e)) throw new S(`the name "${e}" has already been used with this registry`);
          P.set(t, e), k.set(e, t.prototype), I.set(e, t), x.push(e), V(e).then(() => {
            _(d.querySelectorAll(e));
          }), $.get(e)._(t);
        },
        get: e => I.get(e),
        whenDefined: V
      }
    }), A(W.prototype = E.prototype, "constructor", {
      value: W
    }), A(self, "HTMLElement", {
      configurable: !0,
      value: W
    }), A(d, "createElement", {
      configurable: !0,
      value(e, t) {
        const n = t && t.is,
          o = n ? I.get(n) : I.get(e);
        return o ? new o() : L.call(d, e);
      }
    }), "isConnected" in v.prototype || A(v.prototype, "isConnected", {
      configurable: !0,
      get() {
        return !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED);
      }
    });
  } else if (T = !self.customElements.get("extends-li"), T) try {
    function F() {
      return self.Reflect.construct(HTMLLIElement, [], F);
    }
    F.prototype = HTMLLIElement.prototype;
    const U = "extends-li";
    self.customElements.define("extends-li", F, {
      extends: "li"
    }), T = d.createElement("li", {
      is: U
    }).outerHTML.indexOf(U) < 0;
    const {
      get: z,
      whenDefined: B
    } = self.customElements;
    A(self.customElements, "whenDefined", {
      configurable: !0,
      value(e) {
        return B.call(this, e).then(t => t || z.call(this, e));
      }
    });
  } catch (G) {}
  if (T) {
    const J = self.customElements,
      {
        createElement: K
      } = d,
      {
        define: Q,
        get: X,
        upgrade: Y
      } = J,
      {
        construct: Z
      } = O || {
        construct(e) {
          return e.call(this);
        }
      },
      ee = new w(),
      te = new y(),
      ne = new g(),
      oe = new g(),
      re = new g(),
      le = new g(),
      se = [],
      ce = [],
      ae = e => le.get(e) || X.call(J, e),
      ie = (e, t, n) => {
        const o = re.get(n);
        if (t && !o.isPrototypeOf(e)) {
          const t = D(e);
          pe = C(e, o);
          try {
            new o.constructor();
          } finally {
            pe = null, t();
          }
        }
        const r = (t ? "" : "dis") + "connectedCallback";
        r in o && e[r]();
      },
      {
        parse: ue
      } = h({
        query: ce,
        handle: ie
      }),
      {
        parse: fe
      } = h({
        query: se,
        handle(e, t) {
          ee.has(e) && (t ? te.add(e) : te.delete(e), ce.length && me.call(ce, e));
        }
      }),
      {
        attachShadow: he
      } = b.prototype;
    he && (b.prototype.attachShadow = function (e) {
      const t = he.call(this, e);
      return ee.set(this, t), t;
    });
    const de = e => {
        if (!oe.has(e)) {
          let t,
            n = new Promise(e => {
              t = e;
            });
          oe.set(e, {
            $: n,
            _: t
          });
        }
        return oe.get(e).$;
      },
      ge = e(de, p);
    let pe = null;
    function me(e) {
      const t = ee.get(e);
      ue(t.querySelectorAll(this), e.isConnected);
    }
    q(self).filter(e => /^HTML.*Element$/.test(e)).forEach(e => {
      const t = self[e];
      function n() {
        const {
          constructor: e
        } = this;
        if (!ne.has(e)) throw new M("Illegal constructor");
        const {
          is: n,
          tag: o
        } = ne.get(e);
        if (n) {
          if (pe) return ge(pe, n);
          const t = K.call(d, o);
          return t.setAttribute("is", n), ge(C(t, e.prototype), n);
        }
        return Z.call(this, t, [], e);
      }
      C(n, t), A(n.prototype = t.prototype, "constructor", {
        value: n
      }), A(self, e, {
        value: n
      });
    }), A(d, "createElement", {
      configurable: !0,
      value(e, t) {
        const n = t && t.is;
        if (n) {
          const t = le.get(n);
          if (t && ne.get(t).tag === e) return new t();
        }
        const o = K.call(d, e);
        return n && o.setAttribute("is", n), o;
      }
    }), A(J, "get", {
      configurable: !0,
      value: ae
    }), A(J, "whenDefined", {
      configurable: !0,
      value: de
    }), A(J, "upgrade", {
      configurable: !0,
      value(e) {
        const t = e.getAttribute("is");
        if (t) {
          const n = le.get(t);
          if (n) return void ge(C(e, n.prototype), t);
        }
        Y.call(J, e);
      }
    }), A(J, "define", {
      configurable: !0,
      value(e, t, n) {
        if (ae(e)) throw new S(`'${e}' has already been defined as a custom element`);
        let o;
        const r = n && n.extends;
        ne.set(t, r ? {
          is: e,
          tag: r
        } : {
          is: "",
          tag: e
        }), r ? (o = `${r}[is="${e}"]`, re.set(o, t.prototype), le.set(e, t), ce.push(o)) : (Q.apply(J, arguments), se.push(o = e)), de(e).then(() => {
          r ? (ue(d.querySelectorAll(o)), te.forEach(me, [o])) : fe(d.querySelectorAll(o));
        }), oe.get(e)._(t);
      }
    });
  }
}();
const cpObj = bbn.fn.createObject({
  tickDelay: 25,
  uid: 0,
  mixins: bbn.fn.createObject({
    basic,
    browserNotification,
    close,
    componentInside,
    config,
    data,
    dataEditor,
    dimensions,
    dropdown,
    editableList,
    empty,
    events,
    field,
    input,
    keepCool,
    keynav,
    list,
    localStorage,
    memory,
    observer,
    pageable,
    popup,
    position,
    resizer,
    serviceWorker,
    toggle,
    url,
    view
  }),
  defaults: bbn.fn.createObject(),
  dataInventory: new Map(),
  version: 1,
  queue: [],
  known: [],
  interval: null,
  statics: bbn.fn.createObject(),
  /** @var {Array} directives List of existing directives */
  directives: bbn.fn.createObject(),
  conditionalExp: ['bbn-if', 'bbn-elseif', 'bbn-else'],
  badCaseAttributes: {
    accesskey: 'accessKey',
    autocapitalize: 'autoCapitalize',
    autocorrect: 'autoCorrect',
    tabindex: 'tabIndex',
    readonly: 'readOnly',
    contenteditable: 'contentEditable',
    crossorigin: 'crossOrigin',
    for: 'htmlFor'
  },
  hooks: ['beforeCreate', 'created', 'updated', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed'],
  tagExtensions: {
    'button': 'bbnButtonHTML',
    'form': 'bbnFormHTML',
    'ul': 'bbnListHTML',
    'li': 'bbnElementHTML',
    'tr': 'bbnRowHTML',
    'td': 'bbnCellHTML',
    'th': 'bbnCellHTML'
  },
  knownPrefixes: [],
  queue: [],
  queueTimer: null,
  loadDelay: 100,
  possibleAttributes,
  forbidden: ['bbn-forget', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else'],
  /** @var {Object} components All the components in the DOM are referenced in this object through their CID */
  componentsIndex: new Map(),
  addComponent,
  addPrefix,
  analyzeElement,
  attributeChangedCallback,
  connectedCallback,
  convertClasses,
  convertStyles,
  createApp,
  createCid,
  define,
  disconnectedCallback,
  executeQueueItem,
  executeQueueItems,
  fetchComponents,
  generateCpClass,
  generateHTMLClass,
  getComponent,
  initDefaults,
  insertDirectives,
  isComponent,
  isTag,
  mapAttributes,
  mapTemplate,
  normalizeComponent,
  queueComponent,
  realDefineComponent,
  removeComponent,
  removeSelfClosing,
  repeatTick,
  retrieveModels,
  retrieveSlots,
  setComputed,
  setDefaults,
  startTick,
  stopTick,
  stringToTemplate,
  templateToFunction,
  templateToString,
  updateDirectives
});
bbn.fn.autoExtend('cp', cpObj);
draggable();
droppable();
focused();
portal();
resizable();
export { bbn, dayjs, axios };
(() => {
  bbn.fn.autoExtend("lng", {
    "Contains": "",
    "Is": "",
    "Is not": "",
    "Starts with": "",
    "Does not contain": "",
    "To end by": "",
    "Is empty": "",
    "Is not empty": "",
    "Is equal to": "",
    "Is not equal to": "",
    "Is greater than or equal to": "",
    "Is greater than": "",
    "Is less than or equal to": "",
    "Is inferior to": "",
    "Is greater than or equal to": "",
    "Is after": "",
    "Is prior to or equal to": "",
    "Is older than": "",
    "Is true": "",
    "Is false": "",
    "Is null": "",
    "Is not null": "",
    "Yes": "",
    "No": "",
    "Choose": "",
    "The value you entered for this field is invalid.": "",
    "Please fill out this field.": "",
    "Please enter a valid email address.": "",
    "Please enter a valid URL.": "",
    "Please lengthen this text to %d characters or more. You are currently using %d characters.": "",
    "Please shorten this text to no more than %d characters. You are currently using %d characters.": "",
    "Please enter a number.": "",
    "Please select a valid value.": "",
    "Please select a value that is no more than %d.": "",
    "Please select a value that is no less than %d.": "",
    "Please match the requested format.": "",
    "Untitled": "",
    "Impossible to load the component": "",
    "Impossible to find a popup instance. Add a bbn-popup in your root element": "",
    "Impossible to delete the row": "",
    "Deleted successfully": "",
    "No data": "",
    "Are you sure you want to delete this group of conditions?": "",
    "Row edition": "",
    "Impossible to open a window if either an editor or a URL is not set": "",
    "Close": ""
  });
})();
(() => {
  bbn.fn.autoExtend("lng", {
    "Contains": "Contient",
    "Is": "Est",
    "Is not": "N\u2019est pas",
    "Starts with": "Commence par",
    "Does not contain": "Ne contient pas",
    "To end by": "Se termine par",
    "Is empty": "Est vide",
    "Is not empty": "N\u2019est pas vide",
    "Is equal to": "Est \u00e9gal \u00e0",
    "Is not equal to": "N\u2019est pas \u00e9gal \u00e0",
    "Is greater than or equal to": "Est sup\u00e9rieur ou \u00e9gal \u00e0",
    "Is greater than": "Est sup\u00e9rieur \u00e0",
    "Is less than or equal to": "Est inf\u00e9rieur ou \u00e9gal \u00e0",
    "Is inferior to": "Est inf\u00e9rieur \u00e0",
    "Is greater than or equal to": "Est post\u00e9rieur ou \u00e9gal \u00e0",
    "Is after": "Est post\u00e9rieur \u00e0",
    "Is prior to or equal to": "Est ant\u00e9rieur ou \u00e9gal \u00e0",
    "Is older than": "Est ant\u00e9rieur \u00e0",
    "Is true": "Est vrai",
    "Is false": "Est faux",
    "Is null": "Est nul",
    "Is not null": "N\u2019est pas nul",
    "Yes": "Oui",
    "No": "No",
    "Choose": "Choisir",
    "The value you entered for this field is invalid.": "La valeur que vous avez saisie pour ce champ n\u2019est pas valide.",
    "Please fill out this field.": "Veuillez remplir ce champ.",
    "Please enter a valid email address.": "S\u2019il vous plat, mettez une adresse email valide.",
    "Please enter a valid URL.": "Veuillez saisir une URL valide.",
    "Please lengthen this text to %d characters or more. You are currently using %d characters.": "Veuillez allonger ce texte \u00e0 %d caractres ou plus. Vous utilisez actuellement %d caractres.",
    "Please shorten this text to no more than %d characters. You are currently using %d characters.": "Veuillez raccourcir ce texte \u00e0 %d caractres maximum. Vous utilisez actuellement %d caractres.",
    "Please enter a number.": "Veuillez saisir un nombre.",
    "Please select a valid value.": "Veuillez s\u00e9lectionner une valeur valide.",
    "Please select a value that is no more than %d.": "Veuillez s\u00e9lectionner une valeur qui n\u2019est pas sup\u00e9rieure \u00e0 %d.",
    "Please select a value that is no less than %d.": "Veuillez s\u00e9lectionner une valeur qui n\u2019est pas inf\u00e9rieure \u00e0 %d.",
    "Please match the requested format.": "Veuillez faire correspondre le format demand\u00e9.",
    "Untitled": "Sans titre",
    "Impossible to load the component": "Impossible de charger le composant",
    "Impossible to find a popup instance. Add a bbn-popup in your root element": "Impossible de trouver une instance de popup. Ajoutez un bbn-popup dans votre \u00e9l\u00e9ment racine",
    "Impossible to delete the row": "Impossible de supprimer la ligne",
    "Deleted successfully": "Supprim\u00e9 avec succs",
    "No data": "Pas de donn\u00e9es",
    "Are you sure you want to delete this group of conditions?": "Voulez-vous vraiment supprimer ce groupe de conditions?",
    "Row edition": "\u00e9dition en ligne",
    "Impossible to open a window if either an editor or a URL is not set": "Impossible d'ouvrir une fentre si un \u00e9diteur ou une URL n\u2019est pas d\u00e9fini",
    "Close:": "Fermer"
  });
})();
(() => {
  bbn.fn.autoExtend("lng", {
    "Contains": "",
    "Is": "",
    "Is not": "",
    "Starts with": "",
    "Does not contain": "",
    "To end by": "",
    "Is empty": "",
    "Is not empty": "",
    "Is equal to": "",
    "Is not equal to": "",
    "Is greater than or equal to": "",
    "Is greater than": "",
    "Is less than or equal to": "",
    "Is inferior to": "",
    "Is greater than or equal to": "",
    "Is after": "",
    "Is prior to or equal to": "",
    "Is older than": "",
    "Is true": "",
    "Is false": "",
    "Is null": "",
    "Is not null": "",
    "Yes": "",
    "No": "",
    "Choose": "",
    "The value you entered for this field is invalid.": "",
    "Please fill out this field.": "",
    "Please enter a valid email address.": "",
    "Please enter a valid URL.": "",
    "Please lengthen this text to %d characters or more. You are currently using %d characters.": "",
    "Please shorten this text to no more than %d characters. You are currently using %d characters.": "",
    "Please enter a number.": "",
    "Please select a valid value.": "",
    "Please select a value that is no more than %d.": "",
    "Please select a value that is no less than %d.": "",
    "Please match the requested format.": "",
    "Untitled": "",
    "Impossible to load the component": "",
    "Impossible to find a popup instance. Add a bbn-popup in your root element": "",
    "Impossible to delete the row": "",
    "Deleted successfully": "",
    "No data": "",
    "Are you sure you want to delete this group of conditions?": "",
    "Row edition": "",
    "Impossible to open a window if either an editor or a URL is not set": "",
    "Close": ""
  });
})();
import bbnData from "./classes/Data.js";
import bbnHTML from "./classes/Html.js";
import bbnButtonHTML from "./classes/Button.js";
import bbnCellHTML from "./classes/Cell.js";
import bbnElementHTML from "./classes/Element.js";
import bbnFormHTML from "./classes/Form.js";
import bbnListHTML from "./classes/List.js";
import bbnRowHTML from "./classes/Row.js";
import bbnCp from "./classes/Cp.js";
import bbnAnonCp from "./classes/AnonCp.js";
import bbnAnon from "./classes/Anon.js";
import "./cp.js";
customElements.define('bbn-anon', bbnAnon);
const woo = {};
export { bbnHTML, bbnAnon, bbnButtonHTML, bbnCellHTML, bbnElementHTML, bbnFormHTML, bbnListHTML, bbnRowHTML, bbnAnonCp, bbnData, bbnCp };
