/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@bbn/bbn-css/dist/css lazy recursive ^\\.\\/bbn\\-css\\-.*\\.css$":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@bbn/bbn-css/dist/css/ lazy ^\.\/bbn\-css\-.*\.css$ strict namespace object ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./bbn-css-bbn-io.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-bbn-io.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-bbn-io_css\"\n\t],\n\t\"./bbn-css-bbn-io.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-bbn-io.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-bbn-io_min_css\"\n\t],\n\t\"./bbn-css-black.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-black.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-black_css\"\n\t],\n\t\"./bbn-css-black.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-black.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-black_min_css\"\n\t],\n\t\"./bbn-css-blue.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-blue.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-blue_css\"\n\t],\n\t\"./bbn-css-blue.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-blue.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-blue_min_css\"\n\t],\n\t\"./bbn-css-cornelius.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-cornelius.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-cornelius_css\"\n\t],\n\t\"./bbn-css-cornelius.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-cornelius.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-cornelius_min_css\"\n\t],\n\t\"./bbn-css-dark.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-dark.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-dark_css\"\n\t],\n\t\"./bbn-css-dark.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-dark.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-dark_min_css\"\n\t],\n\t\"./bbn-css-default.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-default.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-default_css\"\n\t],\n\t\"./bbn-css-default.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-default.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-default_min_css\"\n\t],\n\t\"./bbn-css-flat.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-flat.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-flat_css\"\n\t],\n\t\"./bbn-css-flat.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-flat.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-flat_min_css\"\n\t],\n\t\"./bbn-css-grey.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-grey.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-grey_css\"\n\t],\n\t\"./bbn-css-grey.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-grey.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-grey_min_css\"\n\t],\n\t\"./bbn-css-jeans.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-jeans.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-jeans_css\"\n\t],\n\t\"./bbn-css-jeans.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-jeans.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-jeans_min_css\"\n\t],\n\t\"./bbn-css-mirko.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-mirko.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-mirko_css\"\n\t],\n\t\"./bbn-css-mirko.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-mirko.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-mirko_min_css\"\n\t],\n\t\"./bbn-css-moonlight-variant.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-moonlight-variant.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-moonlight-variant_css\"\n\t],\n\t\"./bbn-css-moonlight-variant.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-moonlight-variant.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-moonlight-variant_min_css\"\n\t],\n\t\"./bbn-css-moonlight.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-moonlight.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-moonlight_css\"\n\t],\n\t\"./bbn-css-moonlight.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-moonlight.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-moonlight_min_css\"\n\t],\n\t\"./bbn-css-neutral.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-neutral.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-neutral_css\"\n\t],\n\t\"./bbn-css-neutral.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-neutral.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-neutral_min_css\"\n\t],\n\t\"./bbn-css-nomadpay-app.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay-app.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay-app_css\"\n\t],\n\t\"./bbn-css-nomadpay-app.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay-app.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay-app_min_css\"\n\t],\n\t\"./bbn-css-nomadpay-client.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay-client.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay-client_css\"\n\t],\n\t\"./bbn-css-nomadpay-client.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay-client.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay-client_min_css\"\n\t],\n\t\"./bbn-css-nomadpay-pro.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay-pro.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay-pro_css\"\n\t],\n\t\"./bbn-css-nomadpay-pro.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay-pro.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay-pro_min_css\"\n\t],\n\t\"./bbn-css-nomadpay.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay_css\"\n\t],\n\t\"./bbn-css-nomadpay.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-nomadpay.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-nomadpay_min_css\"\n\t],\n\t\"./bbn-css-poc.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-poc.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-poc_css\"\n\t],\n\t\"./bbn-css-poc.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-poc.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-poc_min_css\"\n\t],\n\t\"./bbn-css-turquoise-dark.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-dark.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-dark_css\"\n\t],\n\t\"./bbn-css-turquoise-dark.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-dark.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-dark_min_css\"\n\t],\n\t\"./bbn-css-turquoise-dark2.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-dark2.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-dark2_css\"\n\t],\n\t\"./bbn-css-turquoise-dark2.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-dark2.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-dark2_min_css\"\n\t],\n\t\"./bbn-css-turquoise-light.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-light.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-light_css\"\n\t],\n\t\"./bbn-css-turquoise-light.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-light.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-light_min_css\"\n\t],\n\t\"./bbn-css-turquoise-light2.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-light2.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-light2_css\"\n\t],\n\t\"./bbn-css-turquoise-light2.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-turquoise-light2.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-turquoise-light2_min_css\"\n\t],\n\t\"./bbn-css-uniform.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-uniform.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-uniform_css\"\n\t],\n\t\"./bbn-css-uniform.min.css\": [\n\t\t\"./node_modules/@bbn/bbn-css/dist/css/bbn-css-uniform.min.css\",\n\t\t\"vendors-node_modules_bbn_bbn-css_dist_css_bbn-css-uniform_min_css\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./node_modules/@bbn/bbn-css/dist/css lazy recursive ^\\\\.\\\\/bbn\\\\-css\\\\-.*\\\\.css$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/@bbn/bbn-css/dist/css/_lazy_^\\.\\/bbn\\-css\\-.*\\.css$_strict_namespace_object?");

/***/ }),

/***/ "./node_modules/acorn-loose/dist/acorn-loose.js":
/*!******************************************************!*\
  !*** ./node_modules/acorn-loose/dist/acorn-loose.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! acorn */ \"./node_modules/acorn-loose/node_modules/acorn/dist/acorn.mjs\")) :\n  0;\n}(this, function (exports, acorn) { 'use strict';\n\n  function noop() {}\n\n  var LooseParser = function LooseParser(input, options) {\n    if ( options === void 0 ) options = {};\n\n    this.toks = this.constructor.BaseParser.tokenizer(input, options);\n    this.options = this.toks.options;\n    this.input = this.toks.input;\n    this.tok = this.last = {type: acorn.tokTypes.eof, start: 0, end: 0};\n    this.tok.validateRegExpFlags = noop;\n    this.tok.validateRegExpPattern = noop;\n    if (this.options.locations) {\n      var here = this.toks.curPosition();\n      this.tok.loc = new acorn.SourceLocation(this.toks, here, here);\n    }\n    this.ahead = []; // Tokens ahead\n    this.context = []; // Indentation contexted\n    this.curIndent = 0;\n    this.curLineStart = 0;\n    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    this.inAsync = false;\n    this.inFunction = false;\n  };\n\n  LooseParser.prototype.startNode = function startNode () {\n    return new acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n  };\n\n  LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n  };\n\n  LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n    if (this.options.locations) {\n      return new acorn.Node(this.toks, pos[0], pos[1])\n    } else {\n      return new acorn.Node(this.toks, pos)\n    }\n  };\n\n  LooseParser.prototype.finishNode = function finishNode (node, type) {\n    node.type = type;\n    node.end = this.last.end;\n    if (this.options.locations)\n      { node.loc.end = this.last.loc.end; }\n    if (this.options.ranges)\n      { node.range[1] = this.last.end; }\n    return node\n  };\n\n  LooseParser.prototype.dummyNode = function dummyNode (type) {\n    var dummy = this.startNode();\n    dummy.type = type;\n    dummy.end = dummy.start;\n    if (this.options.locations)\n      { dummy.loc.end = dummy.loc.start; }\n    if (this.options.ranges)\n      { dummy.range[1] = dummy.start; }\n    this.last = {type: acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n    return dummy\n  };\n\n  LooseParser.prototype.dummyIdent = function dummyIdent () {\n    var dummy = this.dummyNode(\"Identifier\");\n    dummy.name = \"✖\";\n    return dummy\n  };\n\n  LooseParser.prototype.dummyString = function dummyString () {\n    var dummy = this.dummyNode(\"Literal\");\n    dummy.value = dummy.raw = \"✖\";\n    return dummy\n  };\n\n  LooseParser.prototype.eat = function eat (type) {\n    if (this.tok.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  LooseParser.prototype.isContextual = function isContextual (name) {\n    return this.tok.type === acorn.tokTypes.name && this.tok.value === name\n  };\n\n  LooseParser.prototype.eatContextual = function eatContextual (name) {\n    return this.tok.value === name && this.eat(acorn.tokTypes.name)\n  };\n\n  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n    return this.tok.type === acorn.tokTypes.eof || this.tok.type === acorn.tokTypes.braceR ||\n      acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n  };\n\n  LooseParser.prototype.semicolon = function semicolon () {\n    return this.eat(acorn.tokTypes.semi)\n  };\n\n  LooseParser.prototype.expect = function expect (type) {\n    if (this.eat(type)) { return true }\n    for (var i = 1; i <= 2; i++) {\n      if (this.lookAhead(i).type === type) {\n        for (var j = 0; j < i; j++) { this.next(); }\n        return true\n      }\n    }\n  };\n\n  LooseParser.prototype.pushCx = function pushCx () {\n    this.context.push(this.curIndent);\n  };\n\n  LooseParser.prototype.popCx = function popCx () {\n    this.curIndent = this.context.pop();\n  };\n\n  LooseParser.prototype.lineEnd = function lineEnd (pos) {\n    while (pos < this.input.length && !acorn.isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n    return pos\n  };\n\n  LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n    for (var count = 0;; ++pos) {\n      var ch = this.input.charCodeAt(pos);\n      if (ch === 32) { ++count; }\n      else if (ch === 9) { count += this.options.tabSize; }\n      else { return count }\n    }\n  };\n\n  LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n    if (this.tok.type === closeTok || this.tok.type === acorn.tokTypes.eof) { return true }\n    return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n      (!blockHeuristic || this.nextLineStart >= this.input.length ||\n       this.indentationAfter(this.nextLineStart) < indent)\n  };\n\n  LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n      var ch = this.input.charCodeAt(p);\n      if (ch !== 9 && ch !== 32) { return false }\n    }\n    return true\n  };\n\n  LooseParser.prototype.extend = function extend (name, f) {\n    this[name] = f(this[name]);\n  };\n\n  LooseParser.prototype.parse = function parse () {\n    this.next();\n    return this.parseTopLevel()\n  };\n\n  LooseParser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  LooseParser.parse = function parse (input, options) {\n    return new this(input, options).parse()\n  };\n\n  // Allows plugins to extend the base parser / tokenizer used\n  LooseParser.BaseParser = acorn.Parser;\n\n  var lp = LooseParser.prototype;\n\n  function isSpace(ch) {\n    return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || acorn.isNewLine(ch)\n  }\n\n  lp.next = function() {\n    this.last = this.tok;\n    if (this.ahead.length)\n      { this.tok = this.ahead.shift(); }\n    else\n      { this.tok = this.readToken(); }\n\n    if (this.tok.start >= this.nextLineStart) {\n      while (this.tok.start >= this.nextLineStart) {\n        this.curLineStart = this.nextLineStart;\n        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n      }\n      this.curIndent = this.indentationAfter(this.curLineStart);\n    }\n  };\n\n  lp.readToken = function() {\n    for (;;) {\n      try {\n        this.toks.next();\n        if (this.toks.type === acorn.tokTypes.dot &&\n            this.input.substr(this.toks.end, 1) === \".\" &&\n            this.options.ecmaVersion >= 6) {\n          this.toks.end++;\n          this.toks.type = acorn.tokTypes.ellipsis;\n        }\n        return new acorn.Token(this.toks)\n      } catch (e) {\n        if (!(e instanceof SyntaxError)) { throw e }\n\n        // Try to skip some text, based on the error message, and then continue\n        var msg = e.message, pos = e.raisedAt, replace = true;\n        if (/unterminated/i.test(msg)) {\n          pos = this.lineEnd(e.pos + 1);\n          if (/string/.test(msg)) {\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.string, value: this.input.slice(e.pos + 1, pos)};\n          } else if (/regular expr/i.test(msg)) {\n            var re = this.input.slice(e.pos, pos);\n            try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.regexp, value: re};\n          } else if (/template/.test(msg)) {\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.template,\n              value: this.input.slice(e.pos, pos)\n            };\n          } else {\n            replace = false;\n          }\n        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n          while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n        } else if (/character escape|expected hexadecimal/i.test(msg)) {\n          while (pos < this.input.length) {\n            var ch = this.input.charCodeAt(pos++);\n            if (ch === 34 || ch === 39 || acorn.isNewLine(ch)) { break }\n          }\n        } else if (/unexpected character/i.test(msg)) {\n          pos++;\n          replace = false;\n        } else if (/regular expression/i.test(msg)) {\n          replace = true;\n        } else {\n          throw e\n        }\n        this.resetTo(pos);\n        if (replace === true) { replace = {start: pos, end: pos, type: acorn.tokTypes.name, value: \"✖\"}; }\n        if (replace) {\n          if (this.options.locations)\n            { replace.loc = new acorn.SourceLocation(\n              this.toks,\n              acorn.getLineInfo(this.input, replace.start),\n              acorn.getLineInfo(this.input, replace.end)); }\n          return replace\n        }\n      }\n    }\n  };\n\n  lp.resetTo = function(pos) {\n    this.toks.pos = pos;\n    var ch = this.input.charAt(pos - 1);\n    this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n      /[enwfd]/.test(ch) &&\n      /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n    if (this.options.locations) {\n      this.toks.curLine = 1;\n      this.toks.lineStart = acorn.lineBreakG.lastIndex = 0;\n      var match;\n      while ((match = acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n        ++this.toks.curLine;\n        this.toks.lineStart = match.index + match[0].length;\n      }\n    }\n  };\n\n  lp.lookAhead = function(n) {\n    while (n > this.ahead.length)\n      { this.ahead.push(this.readToken()); }\n    return this.ahead[n - 1]\n  };\n\n  function isDummy(node) { return node.name === \"✖\" }\n\n  var lp$1 = LooseParser.prototype;\n\n  lp$1.parseTopLevel = function() {\n    var node = this.startNodeAt(this.options.locations ? [0, acorn.getLineInfo(this.input, 0)] : 0);\n    node.body = [];\n    while (this.tok.type !== acorn.tokTypes.eof) { node.body.push(this.parseStatement()); }\n    this.toks.adaptDirectivePrologue(node.body);\n    this.last = this.tok;\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType;\n    }\n    return this.finishNode(node, \"Program\")\n  };\n\n  lp$1.parseStatement = function() {\n    var starttype = this.tok.type, node = this.startNode(), kind;\n\n    if (this.toks.isLet()) {\n      starttype = acorn.tokTypes._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n    case acorn.tokTypes._break: case acorn.tokTypes._continue:\n      this.next();\n      var isBreak = starttype === acorn.tokTypes._break;\n      if (this.semicolon() || this.canInsertSemicolon()) {\n        node.label = null;\n      } else {\n        node.label = this.tok.type === acorn.tokTypes.name ? this.parseIdent() : null;\n        this.semicolon();\n      }\n      return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n    case acorn.tokTypes._debugger:\n      this.next();\n      this.semicolon();\n      return this.finishNode(node, \"DebuggerStatement\")\n\n    case acorn.tokTypes._do:\n      this.next();\n      node.body = this.parseStatement();\n      node.test = this.eat(acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n      this.semicolon();\n      return this.finishNode(node, \"DoWhileStatement\")\n\n    case acorn.tokTypes._for:\n      this.next(); // `for` keyword\n      var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n\n      this.pushCx();\n      this.expect(acorn.tokTypes.parenL);\n      if (this.tok.type === acorn.tokTypes.semi) { return this.parseFor(node, null) }\n      var isLet = this.toks.isLet();\n      if (isLet || this.tok.type === acorn.tokTypes._var || this.tok.type === acorn.tokTypes._const) {\n        var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n        if (init$1.declarations.length === 1 && (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\"))) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n            node.await = isAwait;\n          }\n          return this.parseForIn(node, init$1)\n        }\n        return this.parseFor(node, init$1)\n      }\n      var init = this.parseExpression(true);\n      if (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\")) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n          node.await = isAwait;\n        }\n        return this.parseForIn(node, this.toAssignable(init))\n      }\n      return this.parseFor(node, init)\n\n    case acorn.tokTypes._function:\n      this.next();\n      return this.parseFunction(node, true)\n\n    case acorn.tokTypes._if:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.consequent = this.parseStatement();\n      node.alternate = this.eat(acorn.tokTypes._else) ? this.parseStatement() : null;\n      return this.finishNode(node, \"IfStatement\")\n\n    case acorn.tokTypes._return:\n      this.next();\n      if (this.eat(acorn.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n      else { node.argument = this.parseExpression(); this.semicolon(); }\n      return this.finishNode(node, \"ReturnStatement\")\n\n    case acorn.tokTypes._switch:\n      var blockIndent = this.curIndent, line = this.curLineStart;\n      this.next();\n      node.discriminant = this.parseParenExpression();\n      node.cases = [];\n      this.pushCx();\n      this.expect(acorn.tokTypes.braceL);\n\n      var cur;\n      while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {\n        if (this.tok.type === acorn.tokTypes._case || this.tok.type === acorn.tokTypes._default) {\n          var isCase = this.tok.type === acorn.tokTypes._case;\n          if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          this.next();\n          if (isCase) { cur.test = this.parseExpression(); }\n          else { cur.test = null; }\n          this.expect(acorn.tokTypes.colon);\n        } else {\n          if (!cur) {\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            cur.test = null;\n          }\n          cur.consequent.push(this.parseStatement());\n        }\n      }\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      this.popCx();\n      this.eat(acorn.tokTypes.braceR);\n      return this.finishNode(node, \"SwitchStatement\")\n\n    case acorn.tokTypes._throw:\n      this.next();\n      node.argument = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ThrowStatement\")\n\n    case acorn.tokTypes._try:\n      this.next();\n      node.block = this.parseBlock();\n      node.handler = null;\n      if (this.tok.type === acorn.tokTypes._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(acorn.tokTypes.parenL)) {\n          clause.param = this.toAssignable(this.parseExprAtom(), true);\n          this.expect(acorn.tokTypes.parenR);\n        } else {\n          clause.param = null;\n        }\n        clause.body = this.parseBlock();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n      }\n      node.finalizer = this.eat(acorn.tokTypes._finally) ? this.parseBlock() : null;\n      if (!node.handler && !node.finalizer) { return node.block }\n      return this.finishNode(node, \"TryStatement\")\n\n    case acorn.tokTypes._var:\n    case acorn.tokTypes._const:\n      return this.parseVar(node, false, kind || this.tok.value)\n\n    case acorn.tokTypes._while:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WhileStatement\")\n\n    case acorn.tokTypes._with:\n      this.next();\n      node.object = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WithStatement\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseBlock()\n\n    case acorn.tokTypes.semi:\n      this.next();\n      return this.finishNode(node, \"EmptyStatement\")\n\n    case acorn.tokTypes._class:\n      return this.parseClass(true)\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === acorn.tokTypes.parenL) {\n        node.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n\n      return this.parseImport()\n\n    case acorn.tokTypes._export:\n      return this.parseExport()\n\n    default:\n      if (this.toks.isAsyncFunction()) {\n        this.next();\n        this.next();\n        return this.parseFunction(node, true, true)\n      }\n      var expr = this.parseExpression();\n      if (isDummy(expr)) {\n        this.next();\n        if (this.tok.type === acorn.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n        return this.parseStatement()\n      } else if (starttype === acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(acorn.tokTypes.colon)) {\n        node.body = this.parseStatement();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\")\n      } else {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n    }\n  };\n\n  lp$1.parseBlock = function() {\n    var node = this.startNode();\n    this.pushCx();\n    this.expect(acorn.tokTypes.braceL);\n    var blockIndent = this.curIndent, line = this.curLineStart;\n    node.body = [];\n    while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true))\n      { node.body.push(this.parseStatement()); }\n    this.popCx();\n    this.eat(acorn.tokTypes.braceR);\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  lp$1.parseFor = function(node, init) {\n    node.init = init;\n    node.test = node.update = null;\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.semi) { node.test = this.parseExpression(); }\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.parenR) { node.update = this.parseExpression(); }\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  lp$1.parseForIn = function(node, init) {\n    var type = this.tok.type === acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, type)\n  };\n\n  lp$1.parseVar = function(node, noIn, kind) {\n    node.kind = kind;\n    this.next();\n    node.declarations = [];\n    do {\n      var decl = this.startNode();\n      decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n      decl.init = this.eat(acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    } while (this.eat(acorn.tokTypes.comma))\n    if (!node.declarations.length) {\n      var decl$1 = this.startNode();\n      decl$1.id = this.dummyIdent();\n      node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n    }\n    if (!noIn) { this.semicolon(); }\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  lp$1.parseClass = function(isStatement) {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    else { node.id = null; }\n    node.superClass = this.eat(acorn.tokTypes._extends) ? this.parseExpression() : null;\n    node.body = this.startNode();\n    node.body.body = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      if (this.semicolon()) { continue }\n      var method = this.startNode(), isGenerator = (void 0), isAsync = (void 0);\n      if (this.options.ecmaVersion >= 6) {\n        method.static = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(method);\n      if (isDummy(method.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n          (this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL)) {\n        method.static = true;\n        isGenerator = this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        method.static = false;\n      }\n      if (!method.computed &&\n          method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== acorn.tokTypes.parenL &&\n          !this.canInsertSemicolon()) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        isAsync = false;\n      }\n      if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n          !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n          this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL) {\n        method.kind = method.key.name;\n        this.parsePropertyName(method);\n        method.value = this.parseMethod(false);\n      } else {\n        if (!method.computed && !method.static && !isGenerator && !isAsync && (\n          method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n            method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n        method.value = this.parseMethod(isGenerator, isAsync);\n      }\n      node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    this.semicolon();\n    this.finishNode(node.body, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  lp$1.parseFunction = function(node, isStatement, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = this.eat(acorn.tokTypes.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  lp$1.parseExport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.eat(acorn.tokTypes.star)) {\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(acorn.tokTypes._default)) {\n      // export default (function foo() {}) // This is FunctionExpression.\n      var isAsync;\n      if (this.tok.type === acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n      } else if (this.tok.type === acorn.tokTypes._class) {\n        node.declaration = this.parseClass(\"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n      node.declaration = this.parseStatement();\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifierList();\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  lp$1.parseImport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.string) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      var elt;\n      if (this.tok.type === acorn.tokTypes.name && this.tok.value !== \"from\") {\n        elt = this.startNode();\n        elt.local = this.parseIdent();\n        this.finishNode(elt, \"ImportDefaultSpecifier\");\n        this.eat(acorn.tokTypes.comma);\n      }\n      node.specifiers = this.parseImportSpecifiers();\n      node.source = this.eatContextual(\"from\") && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n      if (elt) { node.specifiers.unshift(elt); }\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  lp$1.parseImportSpecifiers = function() {\n    var elts = [];\n    if (this.tok.type === acorn.tokTypes.star) {\n      var elt = this.startNode();\n      this.next();\n      elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n      elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n    } else {\n      var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n      this.pushCx();\n      this.eat(acorn.tokTypes.braceL);\n      if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n      while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n        var elt$1 = this.startNode();\n        if (this.eat(acorn.tokTypes.star)) {\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n          this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n        } else {\n          if (this.isContextual(\"from\")) { break }\n          elt$1.imported = this.parseIdent();\n          if (isDummy(elt$1.imported)) { break }\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n          this.finishNode(elt$1, \"ImportSpecifier\");\n        }\n        elts.push(elt$1);\n        this.eat(acorn.tokTypes.comma);\n      }\n      this.eat(acorn.tokTypes.braceR);\n      this.popCx();\n    }\n    return elts\n  };\n\n  lp$1.parseExportSpecifierList = function() {\n    var elts = [];\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      if (this.isContextual(\"from\")) { break }\n      var elt = this.startNode();\n      elt.local = this.parseIdent();\n      if (isDummy(elt.local)) { break }\n      elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n      this.finishNode(elt, \"ExportSpecifier\");\n      elts.push(elt);\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.eat(acorn.tokTypes.braceR);\n    this.popCx();\n    return elts\n  };\n\n  var lp$2 = LooseParser.prototype;\n\n  lp$2.checkLVal = function(expr) {\n    if (!expr) { return expr }\n    switch (expr.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n      return expr\n\n    case \"ParenthesizedExpression\":\n      expr.expression = this.checkLVal(expr.expression);\n      return expr\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseExpression = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseMaybeAssign(noIn);\n    if (this.tok.type === acorn.tokTypes.comma) {\n      var node = this.startNodeAt(start);\n      node.expressions = [expr];\n      while (this.eat(acorn.tokTypes.comma)) { node.expressions.push(this.parseMaybeAssign(noIn)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseParenExpression = function() {\n    this.pushCx();\n    this.expect(acorn.tokTypes.parenL);\n    var val = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    return val\n  };\n\n  lp$2.parseMaybeAssign = function(noIn) {\n    if (this.toks.isContextual(\"yield\")) {\n      var node = this.startNode();\n      this.next();\n      if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n        node.delegate = false;\n        node.argument = null;\n      } else {\n        node.delegate = this.eat(acorn.tokTypes.star);\n        node.argument = this.parseMaybeAssign();\n      }\n      return this.finishNode(node, \"YieldExpression\")\n    }\n\n    var start = this.storeCurrentPos();\n    var left = this.parseMaybeConditional(noIn);\n    if (this.tok.type.isAssign) {\n      var node$1 = this.startNodeAt(start);\n      node$1.operator = this.tok.value;\n      node$1.left = this.tok.type === acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n      this.next();\n      node$1.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node$1, \"AssignmentExpression\")\n    }\n    return left\n  };\n\n  lp$2.parseMaybeConditional = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseExprOps(noIn);\n    if (this.eat(acorn.tokTypes.question)) {\n      var node = this.startNodeAt(start);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      node.alternate = this.expect(acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseExprOps = function(noIn) {\n    var start = this.storeCurrentPos();\n    var indent = this.curIndent, line = this.curLineStart;\n    return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n  };\n\n  lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n    if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n    var prec = this.tok.type.binop;\n    if (prec != null && (!noIn || this.tok.type !== acorn.tokTypes._in)) {\n      if (prec > minPrec) {\n        var node = this.startNodeAt(start);\n        node.left = left;\n        node.operator = this.tok.value;\n        this.next();\n        if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n          node.right = this.dummyIdent();\n        } else {\n          var rightStart = this.storeCurrentPos();\n          node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n        }\n        this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n      }\n    }\n    return left\n  };\n\n  lp$2.parseMaybeUnary = function(sawUnary) {\n    var start = this.storeCurrentPos(), expr;\n    if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n      (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n    ) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.tok.type.prefix) {\n      var node = this.startNode(), update = this.tok.type === acorn.tokTypes.incDec;\n      if (!update) { sawUnary = true; }\n      node.operator = this.tok.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(true);\n      if (update) { node.argument = this.checkLVal(node.argument); }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (this.tok.type === acorn.tokTypes.ellipsis) {\n      var node$1 = this.startNode();\n      this.next();\n      node$1.argument = this.parseMaybeUnary(sawUnary);\n      expr = this.finishNode(node$1, \"SpreadElement\");\n    } else {\n      expr = this.parseExprSubscripts();\n      while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n        var node$2 = this.startNodeAt(start);\n        node$2.operator = this.tok.value;\n        node$2.prefix = false;\n        node$2.argument = this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$2, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(acorn.tokTypes.starstar)) {\n      var node$3 = this.startNodeAt(start);\n      node$3.operator = \"**\";\n      node$3.left = expr;\n      node$3.right = this.parseMaybeUnary(false);\n      return this.finishNode(node$3, \"BinaryExpression\")\n    }\n\n    return expr\n  };\n\n  lp$2.parseExprSubscripts = function() {\n    var start = this.storeCurrentPos();\n    return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n  };\n\n  lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n    for (;;) {\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        if (this.tok.type === acorn.tokTypes.dot && this.curIndent === startIndent)\n          { --startIndent; }\n        else\n          { return base }\n      }\n\n      var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n      if (this.eat(acorn.tokTypes.dot)) {\n        var node = this.startNodeAt(start);\n        node.object = base;\n        if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine())\n          { node.property = this.dummyIdent(); }\n        else\n          { node.property = this.parsePropertyAccessor() || this.dummyIdent(); }\n        node.computed = false;\n        base = this.finishNode(node, \"MemberExpression\");\n      } else if (this.tok.type === acorn.tokTypes.bracketL) {\n        this.pushCx();\n        this.next();\n        var node$1 = this.startNodeAt(start);\n        node$1.object = base;\n        node$1.property = this.parseExpression();\n        node$1.computed = true;\n        this.popCx();\n        this.expect(acorn.tokTypes.bracketR);\n        base = this.finishNode(node$1, \"MemberExpression\");\n      } else if (!noCalls && this.tok.type === acorn.tokTypes.parenL) {\n        var exprList = this.parseExprList(acorn.tokTypes.parenR);\n        if (maybeAsyncArrow && this.eat(acorn.tokTypes.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(start), exprList, true) }\n        var node$2 = this.startNodeAt(start);\n        node$2.callee = base;\n        node$2.arguments = exprList;\n        base = this.finishNode(node$2, \"CallExpression\");\n      } else if (this.tok.type === acorn.tokTypes.backQuote) {\n        var node$3 = this.startNodeAt(start);\n        node$3.tag = base;\n        node$3.quasi = this.parseTemplate();\n        base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n      } else {\n        return base\n      }\n    }\n  };\n\n  lp$2.parseExprAtom = function() {\n    var node;\n    switch (this.tok.type) {\n    case acorn.tokTypes._this:\n    case acorn.tokTypes._super:\n      var type = this.tok.type === acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type)\n\n    case acorn.tokTypes.name:\n      var start = this.storeCurrentPos();\n      var id = this.parseIdent();\n      var isAsync = false;\n      if (id.name === \"async\" && !this.canInsertSemicolon()) {\n        if (this.eat(acorn.tokTypes._function))\n          { return this.parseFunction(this.startNodeAt(start), false, true) }\n        if (this.tok.type === acorn.tokTypes.name) {\n          id = this.parseIdent();\n          isAsync = true;\n        }\n      }\n      return this.eat(acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n    case acorn.tokTypes.regexp:\n      node = this.startNode();\n      var val = this.tok.value;\n      node.regex = {pattern: val.pattern, flags: val.flags};\n      node.value = val.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.num: case acorn.tokTypes.string:\n      node = this.startNode();\n      node.value = this.tok.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      if (this.tok.type === acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes._null: case acorn.tokTypes._true: case acorn.tokTypes._false:\n      node = this.startNode();\n      node.value = this.tok.type === acorn.tokTypes._null ? null : this.tok.type === acorn.tokTypes._true;\n      node.raw = this.tok.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.parenL:\n      var parenStart = this.storeCurrentPos();\n      this.next();\n      var inner = this.parseExpression();\n      this.expect(acorn.tokTypes.parenR);\n      if (this.eat(acorn.tokTypes.arrow)) {\n        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n        var params = inner.expressions || [inner];\n        if (params.length && isDummy(params[params.length - 1]))\n          { params.pop(); }\n        return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n      }\n      if (this.options.preserveParens) {\n        var par = this.startNodeAt(parenStart);\n        par.expression = inner;\n        inner = this.finishNode(par, \"ParenthesizedExpression\");\n      }\n      return inner\n\n    case acorn.tokTypes.bracketL:\n      node = this.startNode();\n      node.elements = this.parseExprList(acorn.tokTypes.bracketR, true);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseObj()\n\n    case acorn.tokTypes._class:\n      return this.parseClass(false)\n\n    case acorn.tokTypes._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false)\n\n    case acorn.tokTypes._new:\n      return this.parseNew()\n\n    case acorn.tokTypes.backQuote:\n      return this.parseTemplate()\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport()\n      } else {\n        return this.dummyIdent()\n      }\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseDynamicImport = function() {\n    var node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"Import\")\n  };\n\n  lp$2.parseNew = function() {\n    var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(acorn.tokTypes.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var start = this.storeCurrentPos();\n    node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n    if (this.tok.type === acorn.tokTypes.parenL) {\n      node.arguments = this.parseExprList(acorn.tokTypes.parenR);\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  lp$2.parseTemplateElement = function() {\n    var elem = this.startNode();\n\n    // The loose parser accepts invalid unicode escapes even in untagged templates.\n    if (this.tok.type === acorn.tokTypes.invalidTemplate) {\n      elem.value = {\n        raw: this.tok.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.tok.value\n      };\n    }\n    this.next();\n    elem.tail = this.tok.type === acorn.tokTypes.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  lp$2.parseTemplate = function() {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      this.next();\n      node.expressions.push(this.parseExpression());\n      if (this.expect(acorn.tokTypes.braceR)) {\n        curElt = this.parseTemplateElement();\n      } else {\n        curElt = this.startNode();\n        curElt.value = {cooked: \"\", raw: \"\"};\n        curElt.tail = true;\n        this.finishNode(curElt, \"TemplateElement\");\n      }\n      node.quasis.push(curElt);\n    }\n    this.expect(acorn.tokTypes.backQuote);\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  lp$2.parseObj = function() {\n    var node = this.startNode();\n    node.properties = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      var prop = this.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n      if (this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.ellipsis)) {\n        prop.argument = this.parseMaybeAssign();\n        node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n        this.eat(acorn.tokTypes.comma);\n        continue\n      }\n      if (this.options.ecmaVersion >= 6) {\n        start = this.storeCurrentPos();\n        prop.method = false;\n        prop.shorthand = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(prop);\n      if (this.toks.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(prop);\n      } else {\n        isAsync = false;\n      }\n      if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (this.eat(acorn.tokTypes.colon)) {\n        prop.kind = \"init\";\n        prop.value = this.parseMaybeAssign();\n      } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn.tokTypes.parenL || this.tok.type === acorn.tokTypes.braceL)) {\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n      } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n                 (this.tok.type !== acorn.tokTypes.comma && this.tok.type !== acorn.tokTypes.braceR && this.tok.type !== acorn.tokTypes.eq)) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n      } else {\n        prop.kind = \"init\";\n        if (this.options.ecmaVersion >= 6) {\n          if (this.eat(acorn.tokTypes.eq)) {\n            var assign = this.startNodeAt(start);\n            assign.operator = \"=\";\n            assign.left = prop.key;\n            assign.right = this.parseMaybeAssign();\n            prop.value = this.finishNode(assign, \"AssignmentExpression\");\n          } else {\n            prop.value = prop.key;\n          }\n        } else {\n          prop.value = this.dummyIdent();\n        }\n        prop.shorthand = true;\n      }\n      node.properties.push(this.finishNode(prop, \"Property\"));\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return this.finishNode(node, \"ObjectExpression\")\n  };\n\n  lp$2.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(acorn.tokTypes.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseExpression();\n        this.expect(acorn.tokTypes.bracketR);\n        return\n      } else {\n        prop.computed = false;\n      }\n    }\n    var key = (this.tok.type === acorn.tokTypes.num || this.tok.type === acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n    prop.key = key || this.dummyIdent();\n  };\n\n  lp$2.parsePropertyAccessor = function() {\n    if (this.tok.type === acorn.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n  };\n\n  lp$2.parseIdent = function() {\n    var name = this.tok.type === acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n    if (!name) { return this.dummyIdent() }\n    var node = this.startNode();\n    this.next();\n    node.name = name;\n    return this.finishNode(node, \"Identifier\")\n  };\n\n  lp$2.initFunction = function(node) {\n    node.id = null;\n    node.params = [];\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = false; }\n  };\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  lp$2.toAssignable = function(node, binding) {\n    if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) ; else if (node.type === \"ParenthesizedExpression\") {\n      this.toAssignable(node.expression, binding);\n    } else if (this.options.ecmaVersion < 6) {\n      return this.dummyIdent()\n    } else if (node.type === \"ObjectExpression\") {\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1)\n        {\n        var prop = list[i];\n\n        this.toAssignable(prop, binding);\n      }\n    } else if (node.type === \"ArrayExpression\") {\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, binding);\n    } else if (node.type === \"Property\") {\n      this.toAssignable(node.value, binding);\n    } else if (node.type === \"SpreadElement\") {\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, binding);\n    } else if (node.type === \"AssignmentExpression\") {\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n    } else {\n      return this.dummyIdent()\n    }\n    return node\n  };\n\n  lp$2.toAssignableList = function(exprList, binding) {\n    for (var i = 0, list = exprList; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      this.toAssignable(expr, binding);\n    }\n    return exprList\n  };\n\n  lp$2.parseFunctionParams = function(params) {\n    params = this.parseExprList(acorn.tokTypes.parenR);\n    return this.toAssignableList(params, true)\n  };\n\n  lp$2.parseMethod = function(isGenerator, isAsync) {\n    var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = !!isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  lp$2.parseArrowExpression = function(node, params, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    node.expression = this.tok.type !== acorn.tokTypes.braceL;\n    if (node.expression) {\n      node.body = this.parseMaybeAssign();\n    } else {\n      node.body = this.parseBlock();\n      this.toks.adaptDirectivePrologue(node.body.body);\n    }\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  lp$2.parseExprList = function(close, allowEmpty) {\n    this.pushCx();\n    var indent = this.curIndent, line = this.curLineStart, elts = [];\n    this.next(); // Opening bracket\n    while (!this.closes(close, indent + 1, line)) {\n      if (this.eat(acorn.tokTypes.comma)) {\n        elts.push(allowEmpty ? null : this.dummyIdent());\n        continue\n      }\n      var elt = this.parseMaybeAssign();\n      if (isDummy(elt)) {\n        if (this.closes(close, indent, line)) { break }\n        this.next();\n      } else {\n        elts.push(elt);\n      }\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(close)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return elts\n  };\n\n  lp$2.parseAwait = function() {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  // Acorn: Loose parser\n\n  acorn.defaultOptions.tabSize = 4;\n\n  function parse(input, options) {\n    return LooseParser.parse(input, options)\n  }\n\n  exports.LooseParser = LooseParser;\n  exports.parse = parse;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/acorn-loose/dist/acorn-loose.js?");

/***/ }),

/***/ "./node_modules/acorn-walk/dist/walk.js":
/*!**********************************************!*\
  !*** ./node_modules/acorn-walk/dist/walk.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, function (exports) { 'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st); }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state) {\n    var ancestors = [];\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st || ancestors, ancestors); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\")\n      { return function (type) { return type === test; } }\n    else if (!test)\n      { return function () { return true; } }\n    else\n      { return test }\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state; };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (!override) { callback(node, st, type); }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var ancestors = []\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (!override) { callback(node, st || ancestors, ancestors, type); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          { baseVisitor[type](node, st, c); }\n        if ((start == null || node.start === start) &&\n            (end == null || node.end === end) &&\n            test(type, node))\n          { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) { return }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) { return }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) { return }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        { max = new Found(node, st); }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max\n  }\n\n  // Fallback to an Object.create polyfill for older environments.\n  var create = Object.create || function(proto) {\n    function Ctor() {}\n    Ctor.prototype = proto;\n    return new Ctor\n  };\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = create(baseVisitor || base);\n    for (var type in funcs) { visitor[type] = funcs[type]; }\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st); }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n\n  base.Program = base.BlockStatement = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var stmt = list[i];\n\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n  };\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n\n      if (cs.test) { c(cs.test, st, \"Expression\"); }\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n        {\n        var cons = list[i];\n\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) { c(node.argument, st, \"Expression\"); }\n  };\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) { c(node.handler, st); }\n    if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) { c(node.param, st, \"Pattern\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) { c(node.init, st, \"ForInit\"); }\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    if (node.update) { c(node.update, st, \"Expression\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") { c(node, st); }\n    else { c(node, st, \"Expression\"); }\n  };\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) { c(node.init, st, \"Expression\"); }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\")\n      { c(node, st, \"VariablePattern\"); }\n    else if (node.type === \"MemberExpression\")\n      { c(node, st, \"MemberPattern\"); }\n    else\n      { c(node, st); }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Pattern\"); }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) { c(prop.key, st, \"Expression\"); }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Expression\"); }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1)\n      {\n      var quasi = list[i];\n\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n      {\n      var expr = list$1[i$1];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments)\n      { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n        {\n          var arg = list[i];\n\n          c(arg, st, \"Expression\");\n        } }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) { c(node.property, st, \"Expression\"); }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n    if (node.source) { c(node.source, st, \"Expression\"); }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n      {\n      var spec = list[i];\n\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n  base.Class = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var elt = list[i];\n\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.Property = function (node, st, c) {\n    if (node.computed) { c(node.key, st, \"Expression\"); }\n    c(node.value, st, \"Expression\");\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/acorn-walk/dist/walk.js?");

/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/***/ (function(module) {

eval("!function(t,e){ true?module.exports=e():0}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/dayjs.min.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/calendar.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/calendar.js ***!
  \***********************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";return function(e,t,a){var n=\"h:mm A\",d={lastDay:\"[Yesterday at] \"+n,sameDay:\"[Today at] \"+n,nextDay:\"[Tomorrow at] \"+n,nextWeek:\"dddd [at] \"+n,lastWeek:\"[Last] dddd [at] \"+n,sameElse:\"MM/DD/YYYY\"};t.prototype.calendar=function(e,t){var n=t||this.$locale().calendar||d,o=a(e||void 0).startOf(\"d\"),s=this.diff(o,\"d\",!0),i=\"sameElse\",f=s<-6?i:s<-1?\"lastWeek\":s<0?\"lastDay\":s<1?\"sameDay\":s<2?\"nextDay\":s<7?\"nextWeek\":i,l=n[f]||d[f];return\"function\"==typeof l?l.call(this,a()):this.format(l)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/calendar.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/dayOfYear.js":
/*!************************************************!*\
  !*** ./node_modules/dayjs/plugin/dayOfYear.js ***!
  \************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";return function(e,t,n){t.prototype.dayOfYear=function(e){var t=Math.round((n(this).startOf(\"day\")-n(this).startOf(\"year\"))/864e5)+1;return null==e?t:this.add(e-t,\"day\")}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/dayOfYear.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/duration.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/duration.js ***!
  \***********************************************/
/***/ (function(module) {

eval("!function(t,s){ true?module.exports=s():0}(this,(function(){\"use strict\";var t,s,n=1e3,i=6e4,e=36e5,r=864e5,o=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,u=31536e6,d=2628e6,a=/^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,h={years:u,months:d,days:r,hours:e,minutes:i,seconds:n,milliseconds:1,weeks:6048e5},c=function(t){return t instanceof g},f=function(t,s,n){return new g(t,n,s.$l)},m=function(t){return s.p(t)+\"s\"},l=function(t){return t<0},$=function(t){return l(t)?Math.ceil(t):Math.floor(t)},y=function(t){return Math.abs(t)},v=function(t,s){return t?l(t)?{negative:!0,format:\"\"+y(t)+s}:{negative:!1,format:\"\"+t+s}:{negative:!1,format:\"\"}},g=function(){function l(t,s,n){var i=this;if(this.$d={},this.$l=n,void 0===t&&(this.$ms=0,this.parseFromMilliseconds()),s)return f(t*h[m(s)],this);if(\"number\"==typeof t)return this.$ms=t,this.parseFromMilliseconds(),this;if(\"object\"==typeof t)return Object.keys(t).forEach((function(s){i.$d[m(s)]=t[s]})),this.calMilliseconds(),this;if(\"string\"==typeof t){var e=t.match(a);if(e){var r=e.slice(2).map((function(t){return null!=t?Number(t):0}));return this.$d.years=r[0],this.$d.months=r[1],this.$d.weeks=r[2],this.$d.days=r[3],this.$d.hours=r[4],this.$d.minutes=r[5],this.$d.seconds=r[6],this.calMilliseconds(),this}}return this}var y=l.prototype;return y.calMilliseconds=function(){var t=this;this.$ms=Object.keys(this.$d).reduce((function(s,n){return s+(t.$d[n]||0)*h[n]}),0)},y.parseFromMilliseconds=function(){var t=this.$ms;this.$d.years=$(t/u),t%=u,this.$d.months=$(t/d),t%=d,this.$d.days=$(t/r),t%=r,this.$d.hours=$(t/e),t%=e,this.$d.minutes=$(t/i),t%=i,this.$d.seconds=$(t/n),t%=n,this.$d.milliseconds=t},y.toISOString=function(){var t=v(this.$d.years,\"Y\"),s=v(this.$d.months,\"M\"),n=+this.$d.days||0;this.$d.weeks&&(n+=7*this.$d.weeks);var i=v(n,\"D\"),e=v(this.$d.hours,\"H\"),r=v(this.$d.minutes,\"M\"),o=this.$d.seconds||0;this.$d.milliseconds&&(o+=this.$d.milliseconds/1e3,o=Math.round(1e3*o)/1e3);var u=v(o,\"S\"),d=t.negative||s.negative||i.negative||e.negative||r.negative||u.negative,a=e.format||r.format||u.format?\"T\":\"\",h=(d?\"-\":\"\")+\"P\"+t.format+s.format+i.format+a+e.format+r.format+u.format;return\"P\"===h||\"-P\"===h?\"P0D\":h},y.toJSON=function(){return this.toISOString()},y.format=function(t){var n=t||\"YYYY-MM-DDTHH:mm:ss\",i={Y:this.$d.years,YY:s.s(this.$d.years,2,\"0\"),YYYY:s.s(this.$d.years,4,\"0\"),M:this.$d.months,MM:s.s(this.$d.months,2,\"0\"),D:this.$d.days,DD:s.s(this.$d.days,2,\"0\"),H:this.$d.hours,HH:s.s(this.$d.hours,2,\"0\"),m:this.$d.minutes,mm:s.s(this.$d.minutes,2,\"0\"),s:this.$d.seconds,ss:s.s(this.$d.seconds,2,\"0\"),SSS:s.s(this.$d.milliseconds,3,\"0\")};return n.replace(o,(function(t,s){return s||String(i[t])}))},y.as=function(t){return this.$ms/h[m(t)]},y.get=function(t){var s=this.$ms,n=m(t);return\"milliseconds\"===n?s%=1e3:s=\"weeks\"===n?$(s/h[n]):this.$d[n],s||0},y.add=function(t,s,n){var i;return i=s?t*h[m(s)]:c(t)?t.$ms:f(t,this).$ms,f(this.$ms+i*(n?-1:1),this)},y.subtract=function(t,s){return this.add(t,s,!0)},y.locale=function(t){var s=this.clone();return s.$l=t,s},y.clone=function(){return f(this.$ms,this)},y.humanize=function(s){return t().add(this.$ms,\"ms\").locale(this.$l).fromNow(!s)},y.valueOf=function(){return this.asMilliseconds()},y.milliseconds=function(){return this.get(\"milliseconds\")},y.asMilliseconds=function(){return this.as(\"milliseconds\")},y.seconds=function(){return this.get(\"seconds\")},y.asSeconds=function(){return this.as(\"seconds\")},y.minutes=function(){return this.get(\"minutes\")},y.asMinutes=function(){return this.as(\"minutes\")},y.hours=function(){return this.get(\"hours\")},y.asHours=function(){return this.as(\"hours\")},y.days=function(){return this.get(\"days\")},y.asDays=function(){return this.as(\"days\")},y.weeks=function(){return this.get(\"weeks\")},y.asWeeks=function(){return this.as(\"weeks\")},y.months=function(){return this.get(\"months\")},y.asMonths=function(){return this.as(\"months\")},y.years=function(){return this.get(\"years\")},y.asYears=function(){return this.as(\"years\")},l}(),p=function(t,s,n){return t.add(s.years()*n,\"y\").add(s.months()*n,\"M\").add(s.days()*n,\"d\").add(s.hours()*n,\"h\").add(s.minutes()*n,\"m\").add(s.seconds()*n,\"s\").add(s.milliseconds()*n,\"ms\")};return function(n,i,e){t=e,s=e().$utils(),e.duration=function(t,s){var n=e.locale();return f(t,{$l:n},s)},e.isDuration=c;var r=i.prototype.add,o=i.prototype.subtract;i.prototype.add=function(t,s){return c(t)?p(this,t,1):r.bind(this)(t,s)},i.prototype.subtract=function(t,s){return c(t)?p(this,t,-1):o.bind(this)(t,s)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/duration.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/isBetween.js":
/*!************************************************!*\
  !*** ./node_modules/dayjs/plugin/isBetween.js ***!
  \************************************************/
/***/ (function(module) {

eval("!function(e,i){ true?module.exports=i():0}(this,(function(){\"use strict\";return function(e,i,t){i.prototype.isBetween=function(e,i,s,f){var n=t(e),o=t(i),r=\"(\"===(f=f||\"()\")[0],u=\")\"===f[1];return(r?this.isAfter(n,s):!this.isBefore(n,s))&&(u?this.isBefore(o,s):!this.isAfter(o,s))||(r?this.isBefore(n,s):!this.isAfter(n,s))&&(u?this.isAfter(o,s):!this.isBefore(o,s))}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/isBetween.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/isLeapYear.js":
/*!*************************************************!*\
  !*** ./node_modules/dayjs/plugin/isLeapYear.js ***!
  \*************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";return function(e,t){t.prototype.isLeapYear=function(){return this.$y%4==0&&this.$y%100!=0||this.$y%400==0}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/isLeapYear.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/isoWeek.js":
/*!**********************************************!*\
  !*** ./node_modules/dayjs/plugin/isoWeek.js ***!
  \**********************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";var e=\"day\";return function(t,i,s){var a=function(t){return t.add(4-t.isoWeekday(),e)},d=i.prototype;d.isoWeekYear=function(){return a(this).year()},d.isoWeek=function(t){if(!this.$utils().u(t))return this.add(7*(t-this.isoWeek()),e);var i,d,n,o,r=a(this),u=(i=this.isoWeekYear(),d=this.$u,n=(d?s.utc:s)().year(i).startOf(\"year\"),o=4-n.isoWeekday(),n.isoWeekday()>4&&(o+=7),n.add(o,e));return r.diff(u,\"week\")+1},d.isoWeekday=function(e){return this.$utils().u(e)?this.day()||7:this.day(this.day()%7?e:e-7)};var n=d.startOf;d.startOf=function(e,t){var i=this.$utils(),s=!!i.u(t)||t;return\"isoweek\"===i.p(e)?s?this.date(this.date()-(this.isoWeekday()-1)).startOf(\"day\"):this.date(this.date()-1-(this.isoWeekday()-1)+7).endOf(\"day\"):n.bind(this)(e,t)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/isoWeek.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/localeData.js":
/*!*************************************************!*\
  !*** ./node_modules/dayjs/plugin/localeData.js ***!
  \*************************************************/
/***/ (function(module) {

eval("!function(n,e){ true?module.exports=e():0}(this,(function(){\"use strict\";return function(n,e,t){var r=e.prototype,o=function(n){return n&&(n.indexOf?n:n.s)},u=function(n,e,t,r,u){var i=n.name?n:n.$locale(),a=o(i[e]),s=o(i[t]),f=a||s.map((function(n){return n.slice(0,r)}));if(!u)return f;var d=i.weekStart;return f.map((function(n,e){return f[(e+(d||0))%7]}))},i=function(){return t.Ls[t.locale()]},a=function(n,e){return n.formats[e]||function(n){return n.replace(/(\\[[^\\]]+])|(MMMM|MM|DD|dddd)/g,(function(n,e,t){return e||t.slice(1)}))}(n.formats[e.toUpperCase()])},s=function(){var n=this;return{months:function(e){return e?e.format(\"MMMM\"):u(n,\"months\")},monthsShort:function(e){return e?e.format(\"MMM\"):u(n,\"monthsShort\",\"months\",3)},firstDayOfWeek:function(){return n.$locale().weekStart||0},weekdays:function(e){return e?e.format(\"dddd\"):u(n,\"weekdays\")},weekdaysMin:function(e){return e?e.format(\"dd\"):u(n,\"weekdaysMin\",\"weekdays\",2)},weekdaysShort:function(e){return e?e.format(\"ddd\"):u(n,\"weekdaysShort\",\"weekdays\",3)},longDateFormat:function(e){return a(n.$locale(),e)},meridiem:this.$locale().meridiem,ordinal:this.$locale().ordinal}};r.localeData=function(){return s.bind(this)()},t.localeData=function(){var n=i();return{firstDayOfWeek:function(){return n.weekStart||0},weekdays:function(){return t.weekdays()},weekdaysShort:function(){return t.weekdaysShort()},weekdaysMin:function(){return t.weekdaysMin()},months:function(){return t.months()},monthsShort:function(){return t.monthsShort()},longDateFormat:function(e){return a(n,e)},meridiem:n.meridiem,ordinal:n.ordinal}},t.months=function(){return u(i(),\"months\")},t.monthsShort=function(){return u(i(),\"monthsShort\",\"months\",3)},t.weekdays=function(n){return u(i(),\"weekdays\",null,null,n)},t.weekdaysShort=function(n){return u(i(),\"weekdaysShort\",\"weekdays\",3,n)},t.weekdaysMin=function(n){return u(i(),\"weekdaysMin\",\"weekdays\",2,n)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/localeData.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/localizedFormat.js":
/*!******************************************************!*\
  !*** ./node_modules/dayjs/plugin/localizedFormat.js ***!
  \******************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";var e={LTS:\"h:mm:ss A\",LT:\"h:mm A\",L:\"MM/DD/YYYY\",LL:\"MMMM D, YYYY\",LLL:\"MMMM D, YYYY h:mm A\",LLLL:\"dddd, MMMM D, YYYY h:mm A\"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t=\"YYYY-MM-DDTHH:mm:ssZ\");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\\[[^\\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\\[[^\\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,o){return t||o.slice(1)}))}))}(t,void 0===o?{}:o);return i.call(this,n)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/localizedFormat.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/minMax.js":
/*!*********************************************!*\
  !*** ./node_modules/dayjs/plugin/minMax.js ***!
  \*********************************************/
/***/ (function(module) {

eval("!function(e,n){ true?module.exports=n():0}(this,(function(){\"use strict\";return function(e,n,t){var i=function(e,n){if(!n||!n.length||1===n.length&&!n[0]||1===n.length&&Array.isArray(n[0])&&!n[0].length)return null;var t;1===n.length&&n[0].length>0&&(n=n[0]);t=(n=n.filter((function(e){return e})))[0];for(var i=1;i<n.length;i+=1)n[i].isValid()&&!n[i][e](t)||(t=n[i]);return t};t.max=function(){var e=[].slice.call(arguments,0);return i(\"isAfter\",e)},t.min=function(){var e=[].slice.call(arguments,0);return i(\"isBefore\",e)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/minMax.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/quarterOfYear.js":
/*!****************************************************!*\
  !*** ./node_modules/dayjs/plugin/quarterOfYear.js ***!
  \****************************************************/
/***/ (function(module) {

eval("!function(t,n){ true?module.exports=n():0}(this,(function(){\"use strict\";var t=\"month\",n=\"quarter\";return function(e,i){var r=i.prototype;r.quarter=function(t){return this.$utils().u(t)?Math.ceil((this.month()+1)/3):this.month(this.month()%3+3*(t-1))};var s=r.add;r.add=function(e,i){return e=Number(e),this.$utils().p(i)===n?this.add(3*e,t):s.bind(this)(e,i)};var u=r.startOf;r.startOf=function(e,i){var r=this.$utils(),s=!!r.u(i)||i;if(r.p(e)===n){var o=this.quarter()-1;return s?this.month(3*o).startOf(t).startOf(\"day\"):this.month(3*o+2).endOf(t).endOf(\"day\")}return u.bind(this)(e,i)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/quarterOfYear.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/relativeTime.js":
/*!***************************************************!*\
  !*** ./node_modules/dayjs/plugin/relativeTime.js ***!
  \***************************************************/
/***/ (function(module) {

eval("!function(r,e){ true?module.exports=e():0}(this,(function(){\"use strict\";return function(r,e,t){r=r||{};var n=e.prototype,o={future:\"in %s\",past:\"%s ago\",s:\"a few seconds\",m:\"a minute\",mm:\"%d minutes\",h:\"an hour\",hh:\"%d hours\",d:\"a day\",dd:\"%d days\",M:\"a month\",MM:\"%d months\",y:\"a year\",yy:\"%d years\"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:\"s\",r:44,d:\"second\"},{l:\"m\",r:89},{l:\"mm\",r:44,d:\"minute\"},{l:\"h\",r:89},{l:\"hh\",r:21,d:\"hour\"},{l:\"d\",r:35},{l:\"dd\",r:25,d:\"day\"},{l:\"M\",r:45},{l:\"MM\",r:10,d:\"month\"},{l:\"y\",r:17},{l:\"yy\",d:\"year\"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(\"\"+p)),a=\"string\"==typeof v?v.replace(\"%d\",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return\"function\"==typeof M?M(a):M.replace(\"%s\",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/relativeTime.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/timezone.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/timezone.js ***!
  \***********************************************/
/***/ (function(module) {

eval("!function(t,e){ true?module.exports=e():0}(this,(function(){\"use strict\";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||\"short\",o=t+\"|\"+i,r=e[o];return r||(r=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,h=r[0]+\"-\"+r[1]+\"-\"+r[2]+\" \"+l+\":\"+r[4]+\":\"+r[5]+\":000\",v=+e;return(o.utc(h).valueOf()-(v-=v%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate(),a=i.toLocaleString(\"en-US\",{timeZone:t}),u=Math.round((i-new Date(a))/1e3/60),f=o(a,{locale:this.$L}).$set(\"millisecond\",this.$ms).utcOffset(15*-Math.round(i.getTimezoneOffset()/15)-u,!0);if(e){var s=f.utcOffset();f=f.add(n-s,\"minute\")}return f.$x.$timezone=t,f},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return\"timezonename\"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if(\"string\"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/timezone.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/updateLocale.js":
/*!***************************************************!*\
  !*** ./node_modules/dayjs/plugin/updateLocale.js ***!
  \***************************************************/
/***/ (function(module) {

eval("!function(e,n){ true?module.exports=n():0}(this,(function(){\"use strict\";return function(e,n,t){t.updateLocale=function(e,n){var o=t.Ls[e];if(o)return(n?Object.keys(n):[]).forEach((function(e){o[e]=n[e]})),o}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/updateLocale.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/utc.js":
/*!******************************************!*\
  !*** ./node_modules/dayjs/plugin/utc.js ***!
  \******************************************/
/***/ (function(module) {

eval("!function(t,i){ true?module.exports=i():0}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/utc.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/weekOfYear.js":
/*!*************************************************!*\
  !*** ./node_modules/dayjs/plugin/weekOfYear.js ***!
  \*************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";var e=\"week\",t=\"year\";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),\"day\");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,\"millisecond\"),o=this.diff(a,e,!0);return o<0?r(this).startOf(\"week\").week():Math.ceil(o)},f.weeks=function(e){return void 0===e&&(e=null),this.week(e)}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/weekOfYear.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/weekday.js":
/*!**********************************************!*\
  !*** ./node_modules/dayjs/plugin/weekday.js ***!
  \**********************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";return function(e,t){t.prototype.weekday=function(e){var t=this.$locale().weekStart||0,i=this.$W,n=(i<t?i+7:i)-t;return this.$utils().u(e)?n:this.subtract(n,\"day\").add(e,\"day\")}}}));\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/dayjs/plugin/weekday.js?");

/***/ }),

/***/ "./node_modules/tern/lib/def.js":
/*!**************************************!*\
  !*** ./node_modules/tern/lib/def.js ***!
  \**************************************/
/***/ ((module, exports) => {

eval("// Type description parser\n//\n// Type description JSON files (such as ecmascript.json and browser.json)\n// are used to\n//\n// A) describe types that come from native code\n//\n// B) to cheaply load the types for big libraries, or libraries that\n//    can't be inferred well\n\n(function(mod) {\n  if (true) // CommonJS\n    return exports.init = mod;\n  if (true) // AMD\n    return !(module.exports = {init: mod});\n  tern.def = {init: mod};\n})(function(exports, infer) {\n  \"use strict\";\n\n  function hop(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {\n    this.pos = start || 0;\n    this.spec = spec;\n    this.base = base;\n    this.forceNew = forceNew;\n  };\n\n  function unwrapType(type, self, args) {\n    return type.call ? type(self, args) : type;\n  }\n\n  function extractProp(type, prop) {\n    if (prop == \"!ret\") {\n      if (type.retval) return type.retval;\n      var rv = new infer.AVal;\n      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));\n      return rv;\n    } else {\n      return type.getProp(prop);\n    }\n  }\n\n  function computedFunc(name, args, retType, generator) {\n    return function(self, cArgs) {\n      var realArgs = [];\n      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));\n      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);\n    };\n  }\n  function computedUnion(types) {\n    return function(self, args) {\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    };\n  }\n  function computedArray(inner) {\n    return function(self, args) {\n      return new infer.Arr(inner(self, args));\n    };\n  }\n  function computedTuple(types) {\n    return function(self, args) {\n      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }));\n    };\n  }\n  function computedObject(names, types) {\n    return function(self, args) {\n      var obj = new infer.Obj;\n      names.forEach(function (prop, i) {\n        obj.defProp(prop).addType(unwrapType(types[i], self, args));\n      });\n      return obj;\n    };\n  }\n\n  TypeParser.prototype = {\n    eat: function(str) {\n      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {\n        this.pos += str.length;\n        return true;\n      }\n    },\n    word: function(re) {\n      var word = \"\", ch, re = re || /[\\w$]/;\n      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }\n      return word;\n    },\n    error: function() {\n      throw new Error(\"Unrecognized type spec: \" + this.spec + \" (at \" + this.pos + \")\");\n    },\n    parseFnType: function(comp, name, top, generator) {\n      var args = [], names = [], computed = false;\n      if (!this.eat(\")\")) for (var i = 0; ; ++i) {\n        var colon = this.spec.indexOf(\": \", this.pos), argname;\n        if (colon != -1) {\n          argname = this.spec.slice(this.pos, colon);\n          if (/^(\\.\\.\\.)?[$\\w?]+$/.test(argname))\n            this.pos = colon + 2;\n          else\n            argname = null;\n        }\n        names.push(argname);\n        var argType = this.parseType(comp);\n        if (argType.call) computed = true;\n        args.push(argType);\n        if (!this.eat(\", \")) {\n          this.eat(\")\") || this.error();\n          break;\n        }\n      }\n      var retType, computeRet, computeRetStart, fn;\n      if (this.eat(\" -> \")) {\n        var retStart = this.pos;\n        retType = this.parseType(true);\n        if (retType.call && !computed) {\n          computeRet = retType;\n          retType = infer.ANull;\n          computeRetStart = retStart;\n        }\n      } else {\n        retType = infer.ANull;\n      }\n      if (computed) return computedFunc(name, args, retType, generator);\n\n      if (top && (fn = this.base))\n        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);\n      else\n        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);\n      if (computeRet) fn.computeRet = computeRet;\n      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);\n      return fn;\n    },\n    parseType: function(comp, name, top) {\n      var main = this.parseTypeMaybeProp(comp, name, top);\n      if (!this.eat(\"|\")) return main;\n      var types = [main], computed = main.call;\n      for (;;) {\n        var next = this.parseTypeMaybeProp(comp, name, top);\n        types.push(next);\n        if (next.call) computed = true;\n        if (!this.eat(\"|\")) break;\n      }\n      if (computed) return computedUnion(types);\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) types[i].propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    },\n    parseTypeMaybeProp: function(comp, name, top) {\n      var result = this.parseTypeInner(comp, name, top);\n      while (comp && this.eat(\".\")) result = this.extendWithProp(result);\n      return result;\n    },\n    extendWithProp: function(base) {\n      var propName = this.word(/[\\w<>$!:]/) || this.error();\n      if (base.apply) return function(self, args) {\n        return extractProp(base(self, args), propName);\n      };\n      return extractProp(base, propName);\n    },\n    parseTypeInner: function(comp, name, top) {\n      var gen;\n      if (this.eat(\"fn(\") || (gen = this.eat(\"fn*(\"))) {\n        return this.parseFnType(comp, name, top, gen);\n      } else if (this.eat(\"[\")) {\n        var inner = this.parseType(comp), types, computed = inner.call;\n        while (this.eat(\", \")) {\n          if (!types) types = [inner];\n          var next = this.parseType(comp);\n          types.push(next);\n          computed = computed || next.call;\n        }\n        this.eat(\"]\") || this.error();\n        if (computed) return types ? computedTuple(types) : computedArray(inner);\n        if (top && this.base) {\n          infer.Arr.call(this.base, types || inner);\n          return this.base;\n        }\n        return new infer.Arr(types || inner);\n      } else if (this.eat(\"{\")) {\n        var types = [], names = [], computed = false;\n        if (!this.eat(\"}\")) {\n          for (var i = 0; ; ++i) {\n            var colon = this.spec.indexOf(\": \", this.pos), propName;\n            if (colon != -1) {\n              propName = this.spec.slice(this.pos, colon);\n              if (/^[$\\w?]+$/.test(propName))\n                this.pos = colon + 2;\n              else\n                propName = null;\n            }\n            var propType = this.parseType(comp);\n            if (propType.call) computed = true;\n            names.push(propName);\n            types.push(propType);\n            if (!this.eat(\", \")) {\n              this.eat(\"}\") || this.error();\n              break;\n            }\n          }\n        }\n        if (computed) return computedObject(names, types);\n        var obj = new infer.Obj;\n        names.forEach(function (prop, i) {\n          obj.defProp(prop).addType(types[i]);\n        });\n        return obj;\n      } else if (this.eat(\"+\")) {\n        var path = this.word(/[\\w$<>\\.:!]/);\n        var base = infer.cx().localDefs[path + \".prototype\"];\n        if (!base) {\n          var base = parsePath(path);\n          if (!(base instanceof infer.Obj)) return base;\n          var proto = descendProps(base, [\"prototype\"]);\n          if (proto && (proto = proto.getObjType()))\n            base = proto;\n        }\n        if (comp && this.eat(\"[\")) return this.parsePoly(base);\n        if (top && this.base) {\n          this.base.proto = base;\n          var name = base.hasCtor && base.hasCtor.name || base.name;\n          if (name) this.base.name = name;\n          return this.base;\n        }\n        if (top && this.forceNew) return new infer.Obj(base);\n        return infer.getInstance(base);\n      } else if (this.eat(\":\")) {\n        var name = this.word(/[\\w$\\.]/);\n        return infer.getSymbol(name);\n      } else if (comp && this.eat(\"!\")) {\n        var arg = this.word(/\\d/);\n        if (arg) {\n          arg = Number(arg);\n          return function(_self, args) {return args[arg] || infer.ANull;};\n        } else if (this.eat(\"this\")) {\n          return function(self) {return self;};\n        } else if (this.eat(\"custom:\")) {\n          var fname = this.word(/[\\w$]/);\n          return customFunctions[fname] || function() { return infer.ANull; };\n        } else {\n          return this.fromWord(\"!\" + this.word(/[\\w$<>\\.!:]/));\n        }\n      } else if (this.eat(\"?\")) {\n        return infer.ANull;\n      } else {\n        return this.fromWord(this.word(/[\\w$<>\\.!:`]/));\n      }\n    },\n    fromWord: function(spec) {\n      var cx = infer.cx();\n      switch (spec) {\n      case \"number\": return cx.num;\n      case \"string\": return cx.str;\n      case \"bool\": return cx.bool;\n      case \"<top>\": return cx.topScope;\n      }\n      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];\n      return parsePath(spec);\n    },\n    parsePoly: function(base) {\n      var propName = \"<i>\", match;\n      if (match = this.spec.slice(this.pos).match(/^\\s*([\\w$:]+)\\s*=\\s*/)) {\n        propName = match[1];\n        this.pos += match[0].length;\n      }\n      var value = this.parseType(true);\n      if (!this.eat(\"]\")) this.error();\n      if (value.call) return function(self, args) {\n        var instance = new infer.Obj(base);\n        value(self, args).propagate(instance.defProp(propName));\n        return instance;\n      };\n      var instance = new infer.Obj(base);\n      value.propagate(instance.defProp(propName));\n      return instance;\n    }\n  };\n\n  function addArgCallEffects(type) {\n    if (type instanceof infer.Fn && type.args) for (var i = 0; i < type.args.length; ++i) {\n      var arg = type.args[i];\n      if (arg instanceof infer.Fn && arg.args && arg.args.length) addArgCallEffect(type, i);\n    }\n  }\n\n  function addArgCallEffect(type, argNum) {\n    addEffect(type, function(_self, args) {\n      if (args[argNum]) args[argNum].propagate(\n        new infer.IsCallee(infer.cx().topScope, type.args[argNum].args, null, infer.ANull));\n    });\n  }\n\n  function parseType(spec, name, base, forceNew) {\n    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);\n    if (type instanceof infer.AVal) type.types.forEach(addArgCallEffects);\n    else addArgCallEffects(type);\n    return type;\n  }\n\n  function addEffect(fn, handler, replaceRet) {\n    var oldCmp = fn.computeRet, rv = fn.retval;\n    fn.computeRet = function(self, args, argNodes) {\n      var handled = handler(self, args, argNodes);\n      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;\n      return replaceRet ? handled : old;\n    };\n  }\n\n  var parseEffect = exports.parseEffect = function(effect, fn) {\n    var m;\n    if (effect.indexOf(\"propagate \") == 0) {\n      var p = new TypeParser(effect, 10);\n      var origin = p.parseType(true);\n      if (!p.eat(\" \")) p.error();\n      var target = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));\n      });\n    } else if (effect.indexOf(\"call \") == 0) {\n      var andRet = effect.indexOf(\"and return \", 5) == 5;\n      var p = new TypeParser(effect, andRet ? 16 : 5);\n      var getCallee = p.parseType(true), getSelf = null, getArgs = [];\n      if (p.eat(\" this=\")) getSelf = p.parseType(true);\n      while (p.eat(\" \")) getArgs.push(p.parseType(true));\n      addEffect(fn, function(self, args) {\n        var callee = unwrapType(getCallee, self, args);\n        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];\n        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));\n        var result = andRet ? new infer.AVal : infer.ANull;\n        callee.propagate(new infer.IsCallee(slf, as, null, result));\n        return result;\n      }, andRet);\n    } else if (m = effect.match(/^custom (\\S+)\\s*(.*)/)) {\n      var customFunc = customFunctions[m[1]];\n      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);\n    } else if (effect.indexOf(\"copy \") == 0) {\n      var p = new TypeParser(effect, 5);\n      var getFrom = p.parseType(true);\n      p.eat(\" \");\n      var getTo = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);\n        from.forAllProps(function(prop, val, local) {\n          if (local && prop != \"<i>\")\n            to.propagate(new infer.DefProp(prop, val));\n        });\n      });\n    } else {\n      throw new Error(\"Unknown effect type: \" + effect);\n    }\n  };\n\n  var currentTopScope;\n\n  var parsePath = exports.parsePath = function(path, scope) {\n    var cx = infer.cx(), cached = cx.paths[path], origPath = path;\n    if (cached != null) return cached;\n    cx.paths[path] = infer.ANull;\n\n    var base = scope || currentTopScope || cx.topScope;\n\n    if (cx.localDefs) for (var name in cx.localDefs) {\n      if (path.indexOf(name) == 0) {\n        if (path == name) return cx.paths[path] = cx.localDefs[path];\n        if (path.charAt(name.length) == \".\") {\n          base = cx.localDefs[name];\n          path = path.slice(name.length + 1);\n          break;\n        }\n      }\n    }\n\n    var result = descendProps(base, path.split(\".\"));\n    // Uncomment this to get feedback on your poorly written .json files\n    // if (result == infer.ANull) console.error(\"bad path: \" + origPath + \" (\" + cx.curOrigin + \")\")\n    cx.paths[origPath] = result == infer.ANull ? null : result;\n    return result;\n  };\n\n  function descendProps(base, parts) {\n    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {\n      var prop = parts[i];\n      if (prop.charAt(0) == \"!\") {\n        if (prop == \"!proto\") {\n          base = (base instanceof infer.Obj && base.proto) || infer.ANull;\n        } else {\n          var fn = base.getFunctionType();\n          if (!fn) {\n            base = infer.ANull;\n          } else if (prop == \"!ret\") {\n            base = fn.retval && fn.retval.getType(false) || infer.ANull;\n          } else {\n            var arg = fn.args && fn.args[Number(prop.slice(1))];\n            base = (arg && arg.getType(false)) || infer.ANull;\n          }\n        }\n      } else if (base instanceof infer.Obj &&\n                 (prop == \"prototype\" && base instanceof infer.Fn || base.hasProp(prop))) {\n        var propVal = base.getProp(prop);\n        if (!propVal || propVal.isEmpty())\n          base = infer.ANull;\n        else\n          base = propVal.types[0];\n      } else {\n        base = infer.ANull;\n      }\n    }\n    return base;\n  }\n\n  function emptyObj(ctor) {\n    var empty = Object.create(ctor.prototype);\n    empty.props = Object.create(null);\n    empty.isShell = true;\n    return empty;\n  }\n\n  function isSimpleAnnotation(spec) {\n    if (!spec[\"!type\"] || /^(fn\\(|\\[|\\+)/.test(spec[\"!type\"])) return false;\n    for (var prop in spec)\n      if (prop != \"!type\" && prop != \"!doc\" && prop != \"!url\" && prop != \"!span\" && prop != \"!data\")\n        return false;\n    return true;\n  }\n\n  function passOne(base, spec, path) {\n    if (!base) {\n      var tp = spec[\"!type\"];\n      if (tp) {\n        if (/^fn\\(/.test(tp)) base = emptyObj(infer.Fn);\n        else if (tp.charAt(0) == \"[\") base = emptyObj(infer.Arr);\n        else if (tp.charAt(0) == \"+\") base = emptyObj(infer.Obj);\n        else throw new Error(\"Invalid !type spec: \" + tp);\n      } else if (spec[\"!stdProto\"]) {\n        base = infer.cx().protos[spec[\"!stdProto\"]];\n      } else {\n        base = emptyObj(infer.Obj);\n      }\n      base.name = path;\n    }\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name];\n      if (typeof inner == \"string\" || isSimpleAnnotation(inner)) continue;\n      var prop = base.defProp(name);\n      passOne(prop.getObjType(), inner, path ? path + \".\" + name : name).propagate(prop);\n    }\n    return base;\n  }\n\n  function passTwo(base, spec, path) {\n    if (base.isShell) {\n      delete base.isShell;\n      var tp = spec[\"!type\"];\n      if (tp) {\n        parseType(tp, path, base);\n      } else {\n        var proto = spec[\"!proto\"] && parseType(spec[\"!proto\"]);\n        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);\n      }\n    }\n\n    var effects = spec[\"!effects\"];\n    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)\n      parseEffect(effects[i], base);\n    copyInfo(spec, base);\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + \".\" + name : name;\n      if (typeof inner == \"string\") {\n        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);\n      } else {\n        if (!isSimpleAnnotation(inner))\n          passTwo(known.getObjType(), inner, innerPath);\n        else if (known.isEmpty())\n          parseType(inner[\"!type\"], innerPath, null, true).propagate(known);\n        else\n          continue;\n        if (inner[\"!doc\"]) known.doc = inner[\"!doc\"];\n        if (inner[\"!url\"]) known.url = inner[\"!url\"];\n        if (inner[\"!span\"]) known.span = inner[\"!span\"];\n      }\n    }\n    return base;\n  }\n\n  function copyInfo(spec, type) {\n    if (spec[\"!doc\"]) type.doc = spec[\"!doc\"];\n    if (spec[\"!url\"]) type.url = spec[\"!url\"];\n    if (spec[\"!span\"]) type.span = spec[\"!span\"];\n    if (spec[\"!data\"]) type.metaData = spec[\"!data\"];\n  }\n\n  function doLoadEnvironment(data, scope) {\n    var cx = infer.cx(), server = cx.parent;\n\n    infer.addOrigin(cx.curOrigin = data[\"!name\"] || \"env#\" + cx.origins.length);\n    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);\n\n    if (server) server.signal(\"preLoadDef\", data);\n\n    passOne(scope, data);\n\n    var def = data[\"!define\"];\n    if (def) {\n      for (var name in def) {\n        var spec = def[name];\n        cx.localDefs[name] = typeof spec == \"string\" ? parsePath(spec) : passOne(null, spec, name);\n      }\n      for (var name in def) {\n        var spec = def[name];\n        if (typeof spec != \"string\") passTwo(cx.localDefs[name], def[name], name);\n      }\n    }\n\n    passTwo(scope, data);\n\n    if (server) server.signal(\"postLoadDef\", data);\n\n    cx.curOrigin = cx.localDefs = null;\n  }\n\n  exports.load = function(data, scope) {\n    if (!scope) scope = infer.cx().topScope;\n    var oldScope = currentTopScope;\n    currentTopScope = scope;\n    try {\n      doLoadEnvironment(data, scope);\n    } finally {\n      currentTopScope = oldScope;\n    }\n  };\n\n  exports.parse = function(data, origin, path) {\n    var cx = infer.cx();\n    if (origin) {\n      cx.origin = origin;\n      cx.localDefs = cx.definitions[origin];\n    }\n\n    try {\n      if (typeof data == \"string\")\n        return parseType(data, path);\n      else\n        return passTwo(passOne(null, data, path), data, path);\n    } finally {\n      if (origin) cx.origin = cx.localDefs = null;\n    }\n  };\n\n  // Used to register custom logic for more involved effect or type\n  // computation.\n  var customFunctions = Object.create(null);\n  infer.registerFunction = function(name, f) { customFunctions[name] = f; };\n\n  var IsCreated = infer.constraint({\n    construct: function(created, target, spec) {\n      this.created = created;\n      this.target = target;\n      this.spec = spec;\n    },\n    addType: function(tp) {\n      if (tp instanceof infer.Obj && this.created++ < 5) {\n        var derived = new infer.Obj(tp), spec = this.spec;\n        if (spec instanceof infer.AVal) spec = spec.getObjType(false);\n        if (spec instanceof infer.Obj) for (var prop in spec.props) {\n          var cur = spec.props[prop].types[0];\n          var p = derived.defProp(prop);\n          if (cur && cur instanceof infer.Obj && cur.props.value) {\n            var vtp = cur.props.value.getType(false);\n            if (vtp) p.addType(vtp);\n          }\n        }\n        this.target.addType(derived);\n      }\n    }\n  });\n\n  infer.registerFunction(\"Object_create\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && argNodes[0].value == null)\n      return new infer.Obj();\n\n    var result = new infer.AVal;\n    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));\n    return result;\n  });\n\n  var PropSpec = infer.constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Obj)) return;\n      if (tp.hasProp(\"value\"))\n        tp.getProp(\"value\").propagate(this.target);\n      else if (tp.hasProp(\"get\"))\n        tp.getProp(\"get\").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));\n    }\n  });\n\n  infer.registerFunction(\"Object_defineProperty\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length >= 3 && argNodes[1].type == \"Literal\" &&\n        typeof argNodes[1].value == \"string\") {\n      var obj = args[0], connect = new infer.AVal;\n      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));\n      args[2].propagate(new PropSpec(connect));\n    }\n    return infer.ANull;\n  });\n\n  infer.registerFunction(\"Object_defineProperties\", function(_self, args, argNodes) {\n    if (args.length >= 2) {\n      var obj = args[0];\n      args[1].forAllProps(function(prop, val, local) {\n        if (!local) return;\n        var connect = new infer.AVal;\n        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));\n        val.propagate(new PropSpec(connect));\n      });\n    }\n    return infer.ANull;\n  });\n\n  var IsBound = infer.constraint({\n    construct: function(self, args, target) {\n      this.self = self; this.args = args; this.target = target;\n    },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Fn)) return;\n      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),\n                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));\n      this.self.propagate(tp.self);\n      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)\n        this.args[i].propagate(tp.args[i]);\n    }\n  });\n\n  infer.registerFunction(\"Function_bind\", function(self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    self.propagate(new IsBound(args[0], args.slice(1), result));\n    return result;\n  });\n\n  infer.registerFunction(\"Array_ctor\", function(_self, args) {\n    var arr = new infer.Arr;\n    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {\n      var content = arr.getProp(\"<i>\");\n      for (var i = 0; i < args.length; ++i) args[i].propagate(content);\n    }\n    return arr;\n  });\n\n  function makePromise() {\n    var defs = infer.cx().definitions.ecmascript;\n    return defs && new infer.Obj(defs[\"Promise.prototype\"]);\n  }\n\n  infer.registerFunction(\"Promise_ctor\", function(_self, args, argNodes) {\n    var self = makePromise();\n    if (!self || args.length < 1) return infer.ANull;\n    var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n    var valArg = new infer.AVal;\n    valArg.propagate(valProp);\n    var exec = new infer.Fn(\"execute\", infer.ANull, [valArg], [\"value\"], infer.ANull);\n    var reject = infer.cx().definitions.ecmascript.Promise_reject;\n    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));\n    return self;\n  });\n\n  // Definition for Promise.resolve()\n  // The behavior is different for Promise and non-Promise arguments, so we\n  // need a custom definition to handle the different cases properly.\n  infer.registerFunction(\"Promise_resolve\", function(_self, args, argNodes) {\n    var self = makePromise();\n    if (!self) return infer.ANull;\n    if (args.length) {\n      var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n      var valArg = new infer.AVal;\n      valArg.propagate(valProp);\n      args[0].propagate(new PromiseResolvesTo(valArg));\n    }\n    return self;\n  });\n\n  var PromiseResolvesTo = infer.constraint({\n    construct: function(output) { this.output = output; },\n    addType: function(tp) {\n      if (tp.constructor == infer.Obj && tp.name == \"Promise\" && tp.hasProp(\":t\"))\n        tp.getProp(\":t\").propagate(this.output);\n      else\n        tp.propagate(this.output);\n    }\n  });\n\n  var WG_PROMISE_KEEP_VALUE = 50;\n\n  infer.registerFunction(\"Promise_then\", function(self, args, argNodes) {\n    var fn = args.length && args[0].getFunctionType();\n    var defs = infer.cx().definitions.ecmascript;\n    if (!fn || !defs) return self;\n\n    var result = new infer.Obj(defs[\"Promise.prototype\"]);\n    var value = result.defProp(\":t\", argNodes && argNodes[0]), ty;\n    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(\":t\"))\n      ty.getProp(\":t\").propagate(value, WG_PROMISE_KEEP_VALUE);\n    fn.retval.propagate(new PromiseResolvesTo(value));\n    return result;\n  });\n\n  infer.registerFunction(\"getOwnPropertySymbols\", function(_self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    args[0].forAllProps(function(prop, _val, local) {\n      if (local && prop.charAt(0) == \":\") result.addType(infer.getSymbol(prop.slice(1)));\n    });\n    return result;\n  });\n\n  infer.registerFunction(\"getSymbol\", function(_self, _args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && typeof argNodes[0].value == \"string\")\n      return infer.getSymbol(argNodes[0].value);\n    else\n      return infer.ANull;\n  });\n\n  return exports;\n});\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/tern/lib/def.js?");

/***/ }),

/***/ "./node_modules/tern/lib/infer.js":
/*!****************************************!*\
  !*** ./node_modules/tern/lib/infer.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Main type inference engine\n\n// Walks an AST, building up a graph of abstract values and constraints\n// that cause types to flow from one node to another. Also defines a\n// number of utilities for accessing ASTs and scopes.\n\n// Analysis is done in a context, which is tracked by the dynamically\n// bound cx variable. Use withContext to set the current context.\n\n// For memory-saving reasons, individual types export an interface\n// similar to abstract values (which can hold multiple types), and can\n// thus be used in place abstract values that only ever contain a\n// single type.\n\n(function(root, mod) {\n  if (true) // CommonJS\n    return mod(exports, __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.mjs\"), __webpack_require__(/*! acorn-loose */ \"./node_modules/acorn-loose/dist/acorn-loose.mjs\"), __webpack_require__(/*! acorn-walk */ \"./node_modules/acorn-walk/dist/walk.mjs\"),\n               __webpack_require__(/*! ./def */ \"./node_modules/tern/lib/def.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\"));\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! acorn/dist/acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.js\"), __webpack_require__(/*! acorn-loose/dist/acorn-loose */ \"./node_modules/acorn-loose/dist/acorn-loose.js\"), __webpack_require__(/*! acorn-walk/dist/walk */ \"./node_modules/acorn-walk/dist/walk.js\"), __webpack_require__(/*! ./def */ \"./node_modules/tern/lib/def.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.tern || (root.tern = {}), acorn, acorn.loose, acorn.walk, tern.def, tern.signal); // Plain browser env\n})(this, function(exports, acorn, acorn_loose, walk, def, signal) {\n  \"use strict\";\n\n  var toString = exports.toString = function(type, maxDepth, parent) {\n    if (!type || type == parent || maxDepth && maxDepth < -3) return \"?\";\n    return type.toString(maxDepth, parent);\n  };\n\n  // A variant of AVal used for unknown, dead-end values. Also serves\n  // as prototype for AVals, Types, and Constraints because it\n  // implements 'empty' versions of all the methods that the code\n  // expects.\n  var ANull = exports.ANull = signal.mixin({\n    addType: function() {},\n    propagate: function() {},\n    getProp: function() { return ANull; },\n    forAllProps: function() {},\n    hasType: function() { return false; },\n    isEmpty: function() { return true; },\n    getFunctionType: function() {},\n    getObjType: function() {},\n    getSymbolType: function() {},\n    getType: function() {},\n    gatherProperties: function() {},\n    propagatesTo: function() {},\n    typeHint: function() {},\n    propHint: function() {},\n    toString: function() { return \"?\"; }\n  });\n\n  function extend(proto, props) {\n    var obj = Object.create(proto);\n    if (props) for (var prop in props) obj[prop] = props[prop];\n    return obj;\n  }\n\n  // ABSTRACT VALUES\n\n  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,\n      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,\n      WG_PHANTOM_OBJ = 1,\n      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;\n\n  var AVal = exports.AVal = function() {\n    this.types = [];\n    this.forward = null;\n    this.maxWeight = 0;\n  };\n  AVal.prototype = extend(ANull, {\n    addType: function(type, weight) {\n      weight = weight || WG_DEFAULT;\n      if (this.maxWeight < weight) {\n        this.maxWeight = weight;\n        if (this.types.length == 1 && this.types[0] == type) return;\n        this.types.length = 0;\n      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {\n        return;\n      }\n\n      this.signal(\"addType\", type);\n      this.types.push(type);\n      var forward = this.forward;\n      if (forward) withWorklist(function(add) {\n        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);\n      });\n    },\n\n    propagate: function(target, weight) {\n      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;\n      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);\n      (this.forward || (this.forward = [])).push(target);\n      var types = this.types;\n      if (types.length) withWorklist(function(add) {\n        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);\n      });\n    },\n\n    getProp: function(prop) {\n      if (ignoredProp(prop)) return ANull;\n      var found = (this.props || (this.props = Object.create(null)))[prop];\n      if (!found) {\n        found = this.props[prop] = new AVal;\n        this.propagate(new GetProp(prop, found));\n      }\n      return found;\n    },\n\n    forAllProps: function(c) {\n      this.propagate(new ForAllProps(c));\n    },\n\n    hasType: function(type) {\n      return this.types.indexOf(type) > -1;\n    },\n    isEmpty: function() { return this.types.length === 0; },\n    getFunctionType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Fn) return this.types[i];\n    },\n    getObjType: function() {\n      var seen = null;\n      for (var i = this.types.length - 1; i >= 0; --i) {\n        var type = this.types[i];\n        if (!(type instanceof Obj)) continue;\n        if (type.name) return type;\n        if (!seen) seen = type;\n      }\n      return seen;\n    },\n\n    getSymbolType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Sym) return this.types[i];\n    },\n\n    getType: function(guess) {\n      if (this.types.length === 0 && guess !== false) return this.makeupType();\n      if (this.types.length === 1) return this.types[0];\n      return canonicalType(this.types);\n    },\n\n    toString: function(maxDepth, parent) {\n      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);\n      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);\n      var simplified = simplifyTypes(this.types);\n      if (simplified.length > 2) return \"?\";\n      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join(\"|\");\n    },\n\n    makeupPropType: function(obj) {\n      var propName = this.propertyName;\n\n      var protoProp = obj.proto && obj.proto.hasProp(propName);\n      if (protoProp) {\n        var fromProto = protoProp.getType();\n        if (fromProto) return fromProto;\n      }\n\n      if (propName != \"<i>\") {\n        var computedProp = obj.hasProp(\"<i>\");\n        if (computedProp) return computedProp.getType();\n      } else if (obj.props[\"<i>\"] != this) {\n        for (var prop in obj.props) {\n          var val = obj.props[prop];\n          if (!val.isEmpty()) return val.getType();\n        }\n      }\n    },\n\n    makeupType: function() {\n      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);\n      if (computed) return computed;\n\n      if (!this.forward) return null;\n      for (var i = this.forward.length - 1; i >= 0; --i) {\n        var hint = this.forward[i].typeHint();\n        if (hint && !hint.isEmpty()) {guessing = true; return hint;}\n      }\n\n      var props = Object.create(null), foundProp = null;\n      for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop && prop != \"length\" && prop != \"<i>\" && prop != \"✖\" && prop != cx.completingProperty) {\n          props[prop] = true;\n          foundProp = prop;\n        }\n      }\n      if (!foundProp) return null;\n\n      var objs = objsWithProp(foundProp);\n      if (objs) {\n        var matches = [];\n        search: for (var i = 0; i < objs.length; ++i) {\n          var obj = objs[i];\n          for (var prop in props) if (!obj.hasProp(prop)) continue search;\n          if (obj.hasCtor) obj = getInstance(obj);\n          matches.push(obj);\n        }\n        var canon = canonicalType(matches);\n        if (canon) {guessing = true; return canon;}\n      }\n    },\n\n    typeHint: function() { return this.types.length ? this.getType() : null; },\n    propagatesTo: function() { return this; },\n\n    gatherProperties: function(f, depth) {\n      for (var i = 0; i < this.types.length; ++i)\n        this.types[i].gatherProperties(f, depth);\n    },\n\n    guessProperties: function(f) {\n      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop) f(prop, null, 0);\n      }\n      var guessed = this.makeupType();\n      if (guessed) guessed.gatherProperties(f);\n    }\n  });\n\n  function similarAVal(a, b, depth) {\n    var typeA = a.getType(false), typeB = b.getType(false);\n    if (!typeA || !typeB) return true;\n    return similarType(typeA, typeB, depth);\n  }\n\n  function similarType(a, b, depth) {\n    if (!a || depth >= 5) return b;\n    if (!a || a == b) return a;\n    if (!b) return a;\n    if (a.constructor != b.constructor) return false;\n    if (a.constructor == Arr) {\n      var innerA = a.getProp(\"<i>\").getType(false);\n      if (!innerA) return b;\n      var innerB = b.getProp(\"<i>\").getType(false);\n      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;\n    } else if (a.constructor == Obj) {\n      var propsA = 0, propsB = 0, same = 0;\n      for (var prop in a.props) {\n        propsA++;\n        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))\n          same++;\n      }\n      for (var prop in b.props) propsB++;\n      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;\n      return propsA > propsB ? a : b;\n    } else if (a.constructor == Fn) {\n      if (a.args.length != b.args.length ||\n          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||\n          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))\n        return false;\n      return a;\n    } else {\n      return false;\n    }\n  }\n\n  var simplifyTypes = exports.simplifyTypes = function(types) {\n    var found = [];\n    outer: for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      for (var j = 0; j < found.length; j++) {\n        var similar = similarType(tp, found[j], 0);\n        if (similar) {\n          found[j] = similar;\n          continue outer;\n        }\n      }\n      found.push(tp);\n    }\n    return found;\n  };\n\n  function canonicalType(types) {\n    var arrays = 0, fns = 0, objs = 0, prim = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      if (tp instanceof Arr) ++arrays;\n      else if (tp instanceof Fn) ++fns;\n      else if (tp instanceof Obj) ++objs;\n      else if (tp instanceof Prim) {\n        if (prim && tp.name != prim.name) return null;\n        prim = tp;\n      }\n    }\n    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);\n    if (kinds > 1) return null;\n    if (prim) return prim;\n\n    var maxScore = 0, maxTp = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i], score = 0;\n      if (arrays) {\n        score = tp.getProp(\"<i>\").isEmpty() ? 1 : 2;\n      } else if (fns) {\n        score = 1;\n        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;\n        if (!tp.retval.isEmpty()) ++score;\n      } else if (objs) {\n        score = tp.name ? 100 : 2;\n      }\n      if (score >= maxScore) { maxScore = score; maxTp = tp; }\n    }\n    return maxTp;\n  }\n\n  // PROPAGATION STRATEGIES\n\n  var constraint = exports.constraint = function(methods) {\n    var ctor = function() {\n      this.origin = cx.curOrigin;\n      this.construct.apply(this, arguments);\n    };\n    ctor.prototype = Object.create(ANull);\n    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];\n    return ctor;\n  };\n\n  var GetProp = constraint({\n    construct: function(prop, target) {\n      this.prop = prop; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type.getProp)\n        type.getProp(this.prop).propagate(this.target, weight);\n    },\n    propHint: function() { return this.prop; },\n    propagatesTo: function() {\n      if (this.prop == \"<i>\" || !/[^\\w_]/.test(this.prop))\n        return {target: this.target, pathExt: \".\" + this.prop};\n    }\n  });\n\n  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({\n    construct: function(prop, type, originNode) {\n      this.prop = prop; this.type = type; this.originNode = originNode;\n    },\n    addType: function(type, weight) {\n      if (!(type instanceof Obj)) return;\n      var prop = type.defProp(this.prop, this.originNode);\n      if (!prop.origin) prop.origin = this.origin;\n      this.type.propagate(prop, weight);\n    },\n    propHint: function() { return this.prop; }\n  });\n\n  var ForAllProps = constraint({\n    construct: function(c) { this.c = c; },\n    addType: function(type) {\n      if (!(type instanceof Obj)) return;\n      type.forAllProps(this.c);\n    }\n  });\n\n  function withDisabledComputing(fn, body) {\n    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};\n    var result = body();\n    cx.disabledComputing = cx.disabledComputing.prev;\n    return result;\n  }\n  var IsCallee = exports.IsCallee = constraint({\n    construct: function(self, args, argNodes, retval) {\n      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(fn, weight) {\n      if (!(fn instanceof Fn)) return;\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);\n        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);\n      }\n      if (!fn.isArrowFn())\n        this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);\n      var compute = fn.computeRet, result = fn.retval;\n      if (compute) for (var d = this.disabled; d; d = d.prev)\n        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;\n      if (compute) {\n        var old = cx.disabledComputing;\n        cx.disabledComputing = this.disabled;\n        result = compute(this.self, this.args, this.argNodes);\n        cx.disabledComputing = old;\n      }\n      if (fn.async && !fn.generator) {\n        var tp = result.getType();\n        if (!(tp && tp.constructor == Obj && tp.name == \"Promise\")) {\n          var defs = cx.definitions.ecmascript;\n          var rtnval = defs && new Obj(defs[\"Promise.prototype\"]);\n          if (rtnval) {\n            rtnval.getType().propagate(new DefProp(':t', result));\n            result = rtnval;            \n          }\n        }\n      }\n      maybeIterator(fn, result).propagate(this.retval, weight);\n    },\n    typeHint: function() {\n      var names = [];\n      for (var i = 0; i < this.args.length; ++i) names.push(\"?\");\n      return new Fn(null, this.self, this.args, names, ANull);\n    },\n    propagatesTo: function() {\n      return {target: this.retval, pathExt: \".!ret\"};\n    }\n  });\n\n  var HasMethodCall = constraint({\n    construct: function(propName, args, argNodes, retval) {\n      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(obj, weight) {\n      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);\n      callee.disabled = this.disabled;\n      obj.getProp(this.propName).propagate(callee, weight);\n    },\n    propHint: function() { return this.propName; }\n  });\n\n  var IsCtor = exports.IsCtor = constraint({\n    construct: function(target, noReuse) {\n      this.target = target; this.noReuse = noReuse;\n    },\n    addType: function(f, weight) {\n      if (!(f instanceof Fn)) return;\n      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;\n      f.getProp(\"prototype\").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);\n    }\n  });\n\n  var getInstance = exports.getInstance = function(obj, ctor) {\n    if (ctor === false) return new Obj(obj);\n\n    if (!ctor) ctor = obj.hasCtor;\n    if (!obj.instances) obj.instances = [];\n    for (var i = 0; i < obj.instances.length; ++i) {\n      var cur = obj.instances[i];\n      if (cur.ctor == ctor) return cur.instance;\n    }\n    var instance = new Obj(obj, ctor && ctor.name);\n    instance.origin = obj.origin;\n    obj.instances.push({ctor: ctor, instance: instance});\n    return instance;\n  };\n\n  var IsProto = exports.IsProto = constraint({\n    construct: function(ctor, target) {\n      this.ctor = ctor; this.target = target;\n    },\n    addType: function(o, _weight) {\n      if (!(o instanceof Obj)) return;\n      if ((this.count = (this.count || 0) + 1) > 8) return;\n      if (o == cx.protos.Array)\n        this.target.addType(new Arr);\n      else\n        this.target.addType(getInstance(o, this.ctor));\n    }\n  });\n\n  var FnPrototype = constraint({\n    construct: function(fn) { this.fn = fn; },\n    addType: function(o, _weight) {\n      if (o instanceof Obj && !o.hasCtor) {\n        o.hasCtor = this.fn;\n        var adder = new SpeculativeThis(o, this.fn);\n        adder.addType(this.fn);\n        o.forAllProps(function(_prop, val, local) {\n          if (local) val.propagate(adder);\n        });\n      }\n    }\n  });\n\n  var IsAdded = constraint({\n    construct: function(other, target) {\n      this.other = other; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type == cx.str)\n        this.target.addType(cx.str, weight);\n      else if (type == cx.num && this.other.hasType(cx.num))\n        this.target.addType(cx.num, weight);\n    },\n    typeHint: function() { return this.other; }\n  });\n\n  var IfObj = exports.IfObj = constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(t, weight) {\n      if (t instanceof Obj) this.target.addType(t, weight);\n    },\n    propagatesTo: function() { return this.target; }\n  });\n\n  var SpeculativeThis = constraint({\n    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },\n    addType: function(tp) {\n      if (tp instanceof Fn && tp.self)\n        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);\n    }\n  });\n\n  var HasProto = constraint({\n    construct: function(obj) { this.obj = obj },\n    addType: function(tp) {\n      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)\n        this.obj.replaceProto(tp);\n    }\n  });\n\n  var Muffle = constraint({\n    construct: function(inner, weight) {\n      this.inner = inner; this.weight = weight;\n    },\n    addType: function(tp, weight) {\n      this.inner.addType(tp, Math.min(weight, this.weight));\n    },\n    propagatesTo: function() { return this.inner.propagatesTo(); },\n    typeHint: function() { return this.inner.typeHint(); },\n    propHint: function() { return this.inner.propHint(); }\n  });\n\n  // TYPE OBJECTS\n\n  var Type = exports.Type = function() {};\n  Type.prototype = extend(ANull, {\n    constructor: Type,\n    propagate: function(c, w) { c.addType(this, w); },\n    hasType: function(other) { return other == this; },\n    isEmpty: function() { return false; },\n    typeHint: function() { return this; },\n    getType: function() { return this; }\n  });\n\n  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };\n  Prim.prototype = extend(Type.prototype, {\n    constructor: Prim,\n    toString: function() { return this.name; },\n    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},\n    gatherProperties: function(f, depth) {\n      if (this.proto) this.proto.gatherProperties(f, depth);\n    }\n  });\n\n  function isInteger(str) {\n    var c0 = str.charCodeAt(0);\n    if (c0 >= 48 && c0 <= 57) return !/\\D/.test(str);\n    else return false;\n  }\n\n  var Obj = exports.Obj = function(proto, name) {\n    if (!this.props) this.props = Object.create(null);\n    this.proto = proto === true ? cx.protos.Object : proto;\n    if (proto && proto != cx.protos.Object && !name && proto.name && !(this instanceof Fn)) {\n      var match = /^(.*)\\.prototype$/.exec(this.proto.name);\n      if (match) name = match[1];\n    }\n    this.name = name;\n    this.maybeProps = null;\n    this.origin = cx.curOrigin;\n  };\n  Obj.prototype = extend(Type.prototype, {\n    constructor: Obj,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= 0 && this.name) return this.name;\n      var props = [], etc = false;\n      for (var prop in this.props) if (prop != \"<i>\") {\n        if (props.length > 5) { etc = true; break; }\n        if (maxDepth)\n          props.push(prop + \": \" + toString(this.props[prop], maxDepth - 1, this));\n        else\n          props.push(prop);\n      }\n      props.sort();\n      if (etc) props.push(\"...\");\n      return \"{\" + props.join(\", \") + \"}\";\n    },\n    hasProp: function(prop, searchProto) {\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n      var found = this.props[prop];\n      if (searchProto !== false)\n        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];\n      return found;\n    },\n    defProp: function(prop, originNode) {\n      var found = this.hasProp(prop, false);\n      if (found) {\n        if (originNode && !found.originNode) found.originNode = originNode;\n        return found;\n      }\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n\n      var av = this.maybeProps && this.maybeProps[prop];\n      if (av) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n      } else {\n        av = new AVal;\n        av.propertyOf = this;\n        av.propertyName = prop;\n      }\n\n      this.props[prop] = av;\n      av.originNode = originNode;\n      av.origin = cx.curOrigin;\n      this.broadcastProp(prop, av, true);\n      return av;\n    },\n    getProp: function(prop) {\n      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);\n      if (found) return found;\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n      var av = this.ensureMaybeProps()[prop] = new AVal;\n      av.propertyOf = this;\n      av.propertyName = prop;\n      return av;\n    },\n    normalizeIntegerProp: function(_) { return \"<i>\" },\n    broadcastProp: function(prop, val, local) {\n      if (local) {\n        this.signal(\"addProp\", prop, val);\n        // If this is a scope, it shouldn't be registered\n        if (!(this instanceof Scope)) registerProp(prop, this);\n      }\n\n      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {\n        var h = this.onNewProp[i];\n        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);\n      }\n    },\n    onProtoProp: function(prop, val, _local) {\n      var maybe = this.maybeProps && this.maybeProps[prop];\n      if (maybe) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n        this.proto.getProp(prop).propagate(maybe);\n      }\n      this.broadcastProp(prop, val, false);\n    },\n    replaceProto: function(proto) {\n      for (var o = proto; o; o = o.proto)\n        if (o == this) return;\n      if (this.proto && this.maybeProps)\n        this.proto.unregPropHandler(this);\n      this.proto = proto;\n      if (this.maybeProps)\n        this.proto.forAllProps(this);\n    },\n    ensureMaybeProps: function() {\n      if (!this.maybeProps) {\n        if (this.proto) this.proto.forAllProps(this);\n        this.maybeProps = Object.create(null);\n      }\n      return this.maybeProps;\n    },\n    removeProp: function(prop) {\n      var av = this.props[prop];\n      delete this.props[prop];\n      this.ensureMaybeProps()[prop] = av;\n      av.types.length = 0;\n    },\n    forAllProps: function(c) {\n      if (!this.onNewProp) {\n        this.onNewProp = [];\n        if (this.proto) this.proto.forAllProps(this);\n      }\n      this.onNewProp.push(c);\n      for (var o = this; o; o = o.proto) for (var prop in o.props) {\n        if (c.onProtoProp)\n          c.onProtoProp(prop, o.props[prop], o == this);\n        else\n          c(prop, o.props[prop], o == this);\n      }\n    },\n    maybeUnregProtoPropHandler: function() {\n      if (this.maybeProps) {\n        for (var _n in this.maybeProps) return;\n        this.maybeProps = null;\n      }\n      if (!this.proto || this.onNewProp && this.onNewProp.length) return;\n      this.proto.unregPropHandler(this);\n    },\n    unregPropHandler: function(handler) {\n      for (var i = 0; i < this.onNewProp.length; ++i)\n        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }\n      this.maybeUnregProtoPropHandler();\n    },\n    gatherProperties: function(f, depth) {\n      for (var prop in this.props) if (prop != \"<i>\" && prop.charAt(0) != \":\")\n        f(prop, this, depth);\n      if (this.proto) this.proto.gatherProperties(f, depth + 1);\n    },\n    getObjType: function() { return this; }\n  });\n\n  var geckoIterators = typeof StopIteration != \"undefined\";\n  function ignoredProp(name) {\n    return name == \"__proto__\" || name == \"✖\" || geckoIterators && name == \"__iterator__\";\n  }\n\n  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator, async) {\n    Obj.call(this, cx.protos.Function, name);\n    this.self = self;\n    this.args = args;\n    this.argNames = argNames;\n    this.retval = retval;\n    this.generator = generator;\n    this.async = async;\n  };\n  Fn.prototype = extend(Obj.prototype, {\n    constructor: Fn,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      var str = this.generator ? \"fn*(\" : \"fn(\";\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i) str += \", \";\n        var name = this.argNames[i];\n        if (name && name != \"?\") str += name + \": \";\n        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : \"?\";\n      }\n      str += \")\";\n      if (!this.retval.isEmpty())\n        str += \" -> \" + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : \"?\");\n      return str;\n    },\n    getProp: function(prop) {\n      if (prop == \"prototype\") {\n        var known = this.hasProp(prop, false);\n        if (!known) {\n          known = this.defProp(prop);\n          var proto = new Obj(true, this.name && this.name + \".prototype\");\n          proto.origin = this.origin;\n          known.addType(proto, WG_MADEUP_PROTO);\n        }\n        return known;\n      }\n      return Obj.prototype.getProp.call(this, prop);\n    },\n    defProp: function(prop, originNode) {\n      if (prop == \"prototype\") {\n        var found = this.hasProp(prop, false);\n        if (found) return found;\n        found = Obj.prototype.defProp.call(this, prop, originNode);\n        found.origin = this.origin;\n        found.propagate(new FnPrototype(this));\n        return found;\n      }\n      return Obj.prototype.defProp.call(this, prop, originNode);\n    },\n    getFunctionType: function() { return this; },\n    isArrowFn: function() { return this.originNode && this.originNode.type == \"ArrowFunctionExpression\" }\n  });\n\n  var Arr = exports.Arr = function(contentType) {\n    Obj.call(this, cx.protos.Array);\n    var content = this.defProp(\"<i>\");\n    if (Array.isArray(contentType)) {\n      this.tuple = contentType.length;\n      for (var i = 0; i < contentType.length; i++) {\n        var prop = this.defProp(String(i));\n        contentType[i].propagate(prop);\n        prop.propagate(content);\n      }\n    } else if (contentType) {\n      this.tuple = 0;\n      contentType.propagate(content);\n    }\n  };\n  Arr.prototype = extend(Obj.prototype, {\n    constructor: Arr,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= -3) return \"[?]\";\n      var content = \"\";\n      if (this.tuple) {\n        var similar;\n        for (var i = 0; i in this.props; i++) {\n          var type = toString(this.getProp(String(i)), maxDepth - 1, this);\n          if (similar == null)\n            similar = type;\n          else if (similar != type)\n            similar = false;\n          else\n            similar = type;\n          content += (content ? \", \" : \"\") + type;\n        }\n        if (similar) content = similar;\n      } else {\n        content = toString(this.getProp(\"<i>\"), maxDepth - 1, this);\n      }\n      return \"[\" + content + \"]\";\n    },\n    normalizeIntegerProp: function(prop) {\n      if (+prop < this.tuple) return prop;\n      else return \"<i>\";\n    }\n  });\n\n  var Sym = exports.Sym = function(name, originNode) {\n    Prim.call(this, cx.protos.Symbol, \"Symbol\");\n    this.symName = name;\n    this.originNode = originNode;\n  };\n  Sym.prototype = extend(Prim.prototype, {\n    constructor: Sym,\n    asPropName: function() { return \":\" + this.symName },\n    getSymbolType: function() { return this }\n  });\n\n  exports.getSymbol = function(name, originNode) {\n    var cleanName = name.replace(/[^\\w$\\.]/g, \"_\");\n    var known = cx.symbols[cleanName];\n    if (known) {\n      if (originNode && !known.originNode) known.originNode = originNode;\n      return known;\n    }\n    return cx.symbols[cleanName] = new Sym(cleanName, originNode);\n  };\n\n  // THE PROPERTY REGISTRY\n\n  function registerProp(prop, obj) {\n    var data = cx.props[prop] || (cx.props[prop] = []);\n    data.push(obj);\n  }\n\n  function objsWithProp(prop) {\n    return cx.props[prop];\n  }\n\n  // INFERENCE CONTEXT\n\n  exports.Context = function(defs, parent) {\n    this.parent = parent;\n    this.props = Object.create(null);\n    this.protos = Object.create(null);\n    this.origins = [];\n    this.curOrigin = \"ecmascript\";\n    this.paths = Object.create(null);\n    this.definitions = Object.create(null);\n    this.purgeGen = 0;\n    this.workList = null;\n    this.disabledComputing = null;\n    this.curSuperCtor = this.curSuper = null;\n    this.symbols = Object.create(null);\n\n    exports.withContext(this, function() {\n      cx.protos.Object = new Obj(null, \"Object.prototype\");\n      cx.topScope = new Scope();\n      cx.topScope.name = \"<top>\";\n      cx.protos.Array = new Obj(true, \"Array.prototype\");\n      cx.protos.Function = new Fn(\"Function.prototype\", ANull, [], [], ANull);\n      cx.protos.Function.proto = cx.protos.Object;\n      cx.protos.RegExp = new Obj(true, \"RegExp.prototype\");\n      cx.protos.String = new Obj(true, \"String.prototype\");\n      cx.protos.Number = new Obj(true, \"Number.prototype\");\n      cx.protos.Boolean = new Obj(true, \"Boolean.prototype\");\n      cx.protos.Symbol = new Obj(true, \"Symbol.prototype\");\n      cx.str = new Prim(cx.protos.String, \"string\");\n      cx.bool = new Prim(cx.protos.Boolean, \"bool\");\n      cx.num = new Prim(cx.protos.Number, \"number\");\n      cx.curOrigin = null;\n\n      if (defs) for (var i = 0; i < defs.length; ++i)\n        def.load(defs[i]);\n    });\n  };\n\n  exports.Context.prototype.startAnalysis = function() {\n    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;\n  };\n\n  var cx = null;\n  exports.cx = function() { return cx; };\n\n  exports.withContext = function(context, f) {\n    var old = cx;\n    cx = context;\n    try { return f(); }\n    finally { cx = old; }\n  };\n\n  exports.TimedOut = function() {\n    this.message = \"Timed out\";\n    this.stack = (new Error()).stack;\n  };\n  exports.TimedOut.prototype = Object.create(Error.prototype);\n  exports.TimedOut.prototype.name = \"infer.TimedOut\";\n\n  var timeout;\n  exports.withTimeout = function(ms, f) {\n    var end = +new Date + ms;\n    var oldEnd = timeout;\n    if (oldEnd && oldEnd < end) return f();\n    timeout = end;\n    try { return f(); }\n    finally { timeout = oldEnd; }\n  };\n\n  exports.addOrigin = function(origin) {\n    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);\n  };\n\n  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;\n  function withWorklist(f) {\n    if (cx.workList) return f(cx.workList);\n\n    var list = [], depth = 0;\n    var add = cx.workList = function(type, target, weight) {\n      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)\n        list.push(type, target, weight, depth);\n    };\n    var ret = f(add);\n    for (var i = 0; i < list.length; i += 4) {\n      if (timeout && +new Date >= timeout)\n        throw new exports.TimedOut();\n      depth = list[i + 3] + 1;\n      list[i + 1].addType(list[i], list[i + 2]);\n    }\n    cx.workList = null;\n    return ret;\n  }\n\n  function withSuper(ctor, obj, f) {\n    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper;\n    cx.curSuperCtor = ctor; cx.curSuper = obj;\n    var result = f();\n    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj;\n    return result;\n  }\n\n  // SCOPES\n\n  var Scope = exports.Scope = function(prev, originNode, isBlock, isCatch) {\n    Obj.call(this, prev || true);\n    this.prev = prev;\n    this.originNode = originNode;\n    this.isBlock = !!isBlock;\n    this.isCatch = !!isCatch;\n  };\n  Scope.prototype = extend(Obj.prototype, {\n    constructor: Scope,\n    defVar: function(name, originNode) {\n      for (var s = this; ; s = s.proto) {\n        var found = s.props[name];\n        if (found) return found;\n        if (!s.prev) return s.defProp(name, originNode);\n      }\n    }\n  });\n\n  function functionScope(scope, arrow) {\n    while (scope.isBlock || scope.isCatch || (arrow === false && scope.fnType && scope.fnType.isArrowFn()))\n      scope = scope.prev;\n    return scope;\n  }\n\n\n  // RETVAL COMPUTATION HEURISTICS\n\n  function maybeInstantiate(scope, score) {\n    var fn = functionScope(scope).fnType;\n    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;\n  }\n\n  var NotSmaller = {};\n  function nodeSmallerThan(node, n) {\n    try {\n      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});\n      return true;\n    } catch(e) {\n      if (e == NotSmaller) return false;\n      throw e;\n    }\n  }\n\n  function maybeTagAsInstantiated(node, fn) {\n    var score = fn.instantiateScore;\n    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {\n      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);\n      setFunctionInstantiated(node, fn);\n      return true;\n    } else {\n      fn.instantiateScore = null;\n    }\n  }\n\n  function setFunctionInstantiated(node, fn) {\n    // Disconnect the arg avals, so that we can add info to them without side effects\n    var refScope = node.scope;\n    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;\n    fn.self = new AVal;\n    fn.computeRet = function(self, args) {\n      // Prevent recursion\n      return withDisabledComputing(fn, function() {\n        var oldOrigin = cx.curOrigin;\n        cx.curOrigin = fn.origin;\n        var scope = node.scope ? node.scope : refScope;\n        var scopeCopy = new Scope(scope.prev, scope.originNode);\n        for (var v in scope.props) {\n          var local = scopeCopy.defProp(v, scope.props[v].originNode);\n          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)\n            args[i].propagate(local);\n        }\n        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;\n        while (argNames.length < args.length) argNames.push(\"?\");\n        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator, fn.async);\n        scopeCopy.fnType.originNode = fn.originNode;\n        if (fn.arguments) {\n          var argset = scopeCopy.fnType.arguments = new AVal;\n          scopeCopy.defProp(\"arguments\").addType(new Arr(argset));\n          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);\n        }\n        node.scope = scopeCopy;\n        walk.recursive(node.body, scopeCopy, null, scopeGatherer);\n        walk.recursive(node.body, scopeCopy, null, inferWrapper);\n        cx.curOrigin = oldOrigin;\n        return scopeCopy.fnType.retval;\n      });\n    };\n  }\n\n  function maybeTagAsGeneric(fn) {\n    var target = fn.retval;\n    if (target == ANull || fn.isArrowFn()) return;\n    var targetInner, asArray;\n    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)\n      target = asArray = targetInner.getProp(\"<i>\");\n\n    function explore(aval, path, depth) {\n      if (depth > 3 || !aval.forward) return;\n      for (var i = 0; i < aval.forward.length; ++i) {\n        var prop = aval.forward[i].propagatesTo();\n        if (!prop) continue;\n        var newPath = path, dest;\n        if (prop instanceof AVal) {\n          dest = prop;\n        } else if (prop.target instanceof AVal) {\n          newPath += prop.pathExt;\n          dest = prop.target;\n        } else continue;\n        if (dest == target) return newPath;\n        var found = explore(dest, newPath, depth + 1);\n        if (found) return found;\n      }\n    }\n\n    var foundPath = explore(fn.self, \"!this\", 0);\n    for (var i = 0; !foundPath && i < fn.args.length; ++i)\n      foundPath = explore(fn.args[i], \"!\" + i, 0);\n\n    if (foundPath) {\n      if (asArray) foundPath = \"[\" + foundPath + \"]\";\n      var p = new def.TypeParser(foundPath);\n      var parsed = p.parseType(true);\n      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };\n      fn.computeRetSource = foundPath;\n      return true;\n    }\n  }\n\n  // SCOPE GATHERING PASS\n\n  function addVar(scope, nameNode) {\n    return scope.defProp(nameNode.name, nameNode);\n  }\n  function patternName(node) {\n    if (node.type == \"Identifier\") return node.name;\n    if (node.type == \"AssignmentPattern\") return patternName(node.left);\n    if (node.type == \"ObjectPattern\") return \"{\" + node.properties.map(function(e) { return patternName(e.type === 'RestElement' ? e : e.value) }).join(\", \") + \"}\";\n    if (node.type == \"ArrayPattern\") return \"[\" + node.elements.map(function(e) { return e ? patternName(e) : \"\" }).join(\", \") + \"]\";\n    if (node.type == \"RestElement\") return \"...\" + patternName(node.argument);\n    return \"_\";\n  }\n\n  function isBlockScopedDecl(node) {\n    return node.type == \"VariableDeclaration\" && node.kind != \"var\" ||\n      node.type == \"FunctionDeclaration\" ||\n      node.type == \"ClassDeclaration\";\n  }\n\n  function patternScopes(inner, outer) {\n    return {inner: inner, outer: outer || inner};\n  }\n\n  var scopeGatherer = exports.scopeGatherer = walk.make({\n    VariablePattern: function(node, scopes) {\n      if (scopes.inner) addVar(scopes.inner, node);\n    },\n    AssignmentPattern: function(node, scopes, c) {\n      c(node.left, scopes, \"Pattern\");\n      c(node.right, scopes.outer, \"Expression\");\n    },\n    AssignmentExpression: function(node, scope, c) {\n      if (node.left.type == \"MemberExpression\")\n        c(node.left, scope, \"Expression\");\n      else\n        c(node.left, patternScopes(false, scope), \"Pattern\");\n      c(node.right, scope, \"Expression\");\n    },\n    MemberPattern: function(node, scope, c) {\n      c(node, scope.outer);\n    },\n    Function: function(node, scope, c) {\n      var inner = node.scope = new Scope(scope, node);\n      var argVals = [], argNames = [];\n      for (var i = 0; i < node.params.length; ++i) {\n        var param = node.params[i];\n        argNames.push(patternName(param));\n        if (param.type == \"Identifier\") {\n          argVals.push(addVar(inner, param));\n        } else {\n          var arg = new AVal;\n          argVals.push(arg);\n          arg.originNode = param;\n          c(param, patternScopes(inner), \"Pattern\");\n        }\n      }\n      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator, node.async);\n      inner.fnType.originNode = node;\n      if (node.id) {\n        var decl = node.type == \"FunctionDeclaration\";\n        addVar(decl ? scope : inner, node.id);\n      }\n      c(node.body, inner, node.expression ? \"Expression\" : \"Statement\");\n    },\n    BlockStatement: function(node, scope, c) {\n      if (!node.scope && node.body.some(isBlockScopedDecl))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.BlockStatement(node, scope, c);\n    },\n    CatchClause: function(node, scope, c) {\n      if (!node.param) { return; }\n      scope = node.scope = new Scope(scope, node, false, true);\n      if (node.param.type == \"Identifier\") {\n        var v = addVar(scope, node.param);\n        c(node.body, scope, \"Statement\");\n        var ecma = cx.definitions.ecmascript;\n        if (ecma && v.isEmpty()) getInstance(ecma[\"Error.prototype\"]).propagate(v, WG_CATCH_ERROR);\n      } else {\n        c(node.param, patternScopes(scope), \"Pattern\");\n      }\n    },\n    VariableDeclaration: function(node, scope, c) {\n      var targetScope = node.kind == \"var\" ? functionScope(scope) : scope;\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        c(decl.id, patternScopes(targetScope, scope), \"Pattern\");\n        if (decl.init) c(decl.init, scope, \"Expression\");\n      }\n    },\n    ClassDeclaration: function(node, scope, c) {\n      if (node.id) addVar(scope, node.id);\n      if (node.superClass) c(node.superClass, scope, \"Expression\");\n      for (var i = 0; i < node.body.body.length; i++)\n        c(node.body.body[i], scope);\n    },\n    ForInStatement: function(node, scope, c) {\n      if (!node.scope && isBlockScopedDecl(node.left))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.ForInStatement(node, scope, c);\n    },\n    ForStatement: function(node, scope, c) {\n      if (!node.scope && node.init && isBlockScopedDecl(node.init))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.ForStatement(node, scope, c);\n    },\n    ImportDeclaration: function(node, scope) {\n      for (var i = 0; i < node.specifiers.length; i++)\n        addVar(scope, node.specifiers[i].local);\n    }\n  });\n  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement;\n\n  function rmScope(node) { if (node.scope) node.scope = null }\n  var scopeClearer = {BlockStatement: rmScope, Function: rmScope, CatchClause: rmScope,\n                      ForInStateMent: rmScope, ForStatement: rmScope};\n  exports.clearScopes = function(ast) {\n    walk.simple(ast, scopeClearer);\n  };\n\n  // CONSTRAINT GATHERING PASS\n\n  var propName = exports.propName = function(node, inferInScope) {\n    var key = node.property || node.key;\n    if (!node.computed && key.type == \"Identifier\") return key.name;\n    if (key.type == \"Literal\") {\n      if (typeof key.value == \"string\") return key.value;\n      if (typeof key.value == \"number\") return String(key.value);\n    }\n    if (inferInScope) {\n      var symName = symbolName(infer(key, inferInScope));\n      if (symName) return node.propName = symName;\n    } else if (node.propName) {\n      return node.propName;\n    }\n    return \"<i>\";\n  };\n  function symbolName(val) {\n    var sym = val.getSymbolType();\n    if (sym) return sym.asPropName();\n  }\n\n  function unopResultType(op) {\n    switch (op) {\n    case \"+\": case \"-\": case \"~\": return cx.num;\n    case \"!\": return cx.bool;\n    case \"typeof\": return cx.str;\n    case \"void\": case \"delete\": return ANull;\n    }\n  }\n  function binopIsBoolean(op) {\n    switch (op) {\n    case \"==\": case \"!=\": case \"===\": case \"!==\": case \"<\": case \">\": case \">=\": case \"<=\":\n    case \"in\": case \"instanceof\": return true;\n    }\n  }\n  function literalType(node) {\n    if (node.regex) return getInstance(cx.protos.RegExp);\n    switch (typeof node.value) {\n    case \"boolean\": return cx.bool;\n    case \"number\": return cx.num;\n    case \"string\": return cx.str;\n    case \"object\":\n    case \"function\":\n      if (!node.value) return ANull;\n      return getInstance(cx.protos.RegExp);\n    }\n  }\n\n  function join(a, b) {\n    if (a == b || b == ANull) return a;\n    if (a == ANull) return b;\n    var joined = new AVal;\n    a.propagate(joined);\n    b.propagate(joined);\n    return joined;\n  }\n\n  function connectParams(node, scope) {\n    for (var i = 0; i < node.params.length; i++) {\n      var param = node.params[i];\n      if (param.type == \"Identifier\") continue;\n      connectPattern(param, scope, node.scope.fnType.args[i]);\n    }\n  }\n\n  function ensureVar(node, scope) {\n    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node);\n  }\n\n  var inferPatternVisitor = exports.inferPatternVisitor = {\n    Identifier: function(node, scope, source) {\n      source.propagate(ensureVar(node, scope));\n    },\n    MemberExpression: function(node, scope, source) {\n      var obj = infer(node.object, scope);\n      var pName = propName(node, scope);\n      obj.propagate(new DefProp(pName, source, node.property));\n    },\n    RestElement: function(node, scope, source) {\n      connectPattern(node.argument, scope, new Arr(source));\n    },\n    ObjectPattern: function(node, scope, source) {\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.type == 'RestElement') { continue; }\n        connectPattern(prop.value, scope, source.getProp(propName(prop)));\n      }\n    },\n    ArrayPattern: function(node, scope, source) {\n      for (var i = 0; i < node.elements.length; i++)\n        if (node.elements[i])\n          connectPattern(node.elements[i], scope, source.getProp(String(i)));\n    },\n    AssignmentPattern: function(node, scope, source) {\n      connectPattern(node.left, scope, join(source, infer(node.right, scope)));\n    }\n  };\n\n  function connectPattern(node, scope, source) {\n    var connecter = inferPatternVisitor[node.type];\n    if (connecter) connecter(node, scope, source);\n  }\n\n  function getThis(scope) {\n    var fnScope = functionScope(scope);\n    return fnScope.fnType ? fnScope.fnType.self : fnScope;\n  }\n\n  function maybeAddPhantomObj(obj) {\n    if (!obj.isEmpty() || !obj.propertyOf) return;\n    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ);\n    maybeAddPhantomObj(obj.propertyOf);\n  }\n\n  function inferClass(node, scope, name) {\n    if (!name && node.id) name = node.id.name;\n\n    var sup = cx.protos.Object, supCtor, delayed;\n    if (node.superClass) {\n      if (node.superClass.type == \"Literal\" && node.superClass.value == null) {\n        sup = null;\n      } else {\n        var supVal = infer(node.superClass, scope), supProto;\n        supCtor = supVal.getFunctionType();\n        if (supCtor && (supProto = supCtor.getProp(\"prototype\").getObjType())) {\n          sup = supProto;\n        } else {\n          supCtor = supVal;\n          delayed = supVal.getProp(\"prototype\");\n        }\n      }\n    }\n    var proto = new Obj(sup, name && name + \".prototype\");\n    if (delayed) delayed.propagate(new HasProto(proto));\n\n    return withSuper(supCtor, delayed || sup, function() {\n      var ctor, body = node.body.body;\n      for (var i = 0; i < body.length; i++)\n        if (body[i].kind == \"constructor\") ctor = body[i].value;\n      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull);\n      fn.originNode = node.id || ctor || node;\n\n      var inst = getInstance(proto, fn);\n      fn.self.addType(inst);\n      fn.defProp(\"prototype\", node).addType(proto);\n      for (var i = 0; i < body.length; i++) {\n        var method = body[i], target;\n        if (method.kind == \"constructor\") continue;\n        var pName = propName(method, scope);\n        if (pName == \"<i>\" || method.kind == \"set\") {\n          target = ANull;\n        } else {\n          target = (method.static ? fn : proto).defProp(pName, method.key);\n          target.initializer = true;\n          if (method.kind == \"get\") target = new IsCallee(inst, [], null, target);\n        }\n        infer(method.value, scope, target);\n        var methodFn = target.getFunctionType();\n        if (methodFn) methodFn.self.addType(inst);\n      }\n      return fn;\n    });\n  }\n\n  function arrayLiteralType(elements, scope, inner) {\n    var tuple = elements.length > 1 && elements.length < 6;\n    if (tuple) {\n      var homogenous = true, litType;\n      for (var i = 0; i < elements.length; i++) {\n        var elt = elements[i];\n        if (!elt)\n          tuple = false;\n        else if (elt.type != \"Literal\" || (litType && litType != typeof elt.value))\n          homogenous = false;\n        else\n          litType = typeof elt.value;\n      }\n      if (homogenous) tuple = false;\n    }\n\n    if (tuple) {\n      var types = [];\n      for (var i = 0; i < elements.length; ++i)\n        types.push(inner(elements[i], scope));\n      return new Arr(types);\n    } else if (elements.length < 2) {\n      return new Arr(elements[0] && inner(elements[0], scope));\n    } else {\n      var eltVal = new AVal;\n      for (var i = 0; i < elements.length; i++)\n        if (elements[i]) inner(elements[i], scope).propagate(eltVal);\n      return new Arr(eltVal);\n    }\n  }\n\n  function ret(f) {\n    return function(node, scope, out, name) {\n      var r = f(node, scope, name);\n      if (out) r.propagate(out);\n      return r;\n    };\n  }\n  function fill(f) {\n    return function(node, scope, out, name) {\n      if (!out) out = new AVal;\n      f(node, scope, out, name);\n      return out;\n    };\n  }\n\n  var inferExprVisitor = exports.inferExprVisitor = {\n    ArrayExpression: ret(function(node, scope) {\n      return arrayLiteralType(node.elements, scope, infer);\n    }),\n    ObjectExpression: ret(function(node, scope, name) {\n      var proto = cx.protos.Object, waitForProto;\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.type == 'SpreadElement') { continue; }\n        if (prop.key.name == \"__proto__\") {\n          if (prop.value.type == \"Literal\" && prop.value.value == null) {\n            proto = null;\n          } else {\n            var protoVal = infer(prop.value, scope), known = protoVal.getObjType();\n            if (known) proto = known;\n            else waitForProto = protoVal;\n          }\n        }\n      }\n\n      var obj = node.objType = new Obj(proto, name);\n      if (waitForProto) waitForProto.propagate(new HasProto(obj));\n      obj.originNode = node;\n\n      withSuper(null, waitForProto || proto, function() {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var prop = node.properties[i], key = prop.key;\n          if (prop.type == 'SpreadElement' || ignoredProp(prop.key.name)) continue;\n\n          var name = propName(prop, scope), target;\n          if (name == \"<i>\" || prop.kind == \"set\") {\n            target = ANull;\n          } else {\n            target = obj.defProp(name, key);\n            var val = target;\n            val.initializer = true;\n            if (prop.kind == \"get\")\n              target = new IsCallee(obj, [], null, val);\n          }\n          infer(prop.value, scope, target, name);\n          if (prop.value.type == \"FunctionExpression\")\n            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);\n        }\n      });\n      return obj;\n    }),\n    FunctionExpression: ret(function(node, scope, name) {\n      var inner = node.scope, fn = inner.fnType;\n      if (name && !fn.name) fn.name = name;\n      connectParams(node, inner);\n      if (node.expression)\n        infer(node.body, inner, inner.fnType.retval = new AVal);\n      else\n        walk.recursive(node.body, inner, null, inferWrapper, \"Statement\");\n      if (node.type == \"ArrowFunctionExpression\")\n        getThis(scope).propagate(fn.self);\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) inner.getProp(node.id.name).addType(fn);\n      return fn;\n    }),\n    ClassExpression: ret(inferClass),\n    SequenceExpression: ret(function(node, scope) {\n      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return infer(node.expressions[l], scope);\n    }),\n    UnaryExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return unopResultType(node.operator);\n    }),\n    UpdateExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return cx.num;\n    }),\n    BinaryExpression: ret(function(node, scope) {\n      if (node.operator == \"+\") {\n        var lhs = infer(node.left, scope);\n        var rhs = infer(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;\n        var result = new AVal;\n        lhs.propagate(new IsAdded(rhs, result));\n        rhs.propagate(new IsAdded(lhs, result));\n        return result;\n      } else {\n        infer(node.left, scope, ANull);\n        infer(node.right, scope, ANull);\n        return binopIsBoolean(node.operator) ? cx.bool : cx.num;\n      }\n    }),\n    AssignmentExpression: ret(function(node, scope, name) {\n      var rhs, pName;\n      if (node.left.type == \"MemberExpression\") {\n        pName = propName(node.left, scope);\n        if (!name)\n          name = node.left.object.type == \"Identifier\" ? node.left.object.name + \".\" + pName : pName;\n      } else if (!name && node.left.type == \"Identifier\") {\n        name = node.left.name;\n      }\n\n      if (node.operator && node.operator != \"=\" && node.operator != \"+=\") {\n        infer(node.right, scope, ANull);\n        rhs = cx.num;\n      } else {\n        rhs = infer(node.right, scope, null, name);\n      }\n\n      if (node.left.type == \"MemberExpression\") {\n        var obj = infer(node.left.object, scope);\n        if (pName == \"prototype\") maybeInstantiate(scope, 20);\n        if (pName == \"<i>\") {\n          // This is a hack to recognize for/in loops that copy\n          // properties, and do the copying ourselves, insofar as we\n          // manage, because such loops tend to be relevant for type\n          // information.\n          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;\n          if (over) {\n            maybeInstantiate(scope, 20);\n            var fromRight = node.right.type == \"MemberExpression\" && node.right.computed && node.right.property.name == v;\n            over.forAllProps(function(prop, val, local) {\n              if (local && prop != \"prototype\" && prop != \"<i>\")\n                obj.propagate(new DefProp(prop, fromRight ? val : ANull));\n            });\n            return rhs;\n          }\n        }\n\n        obj.propagate(new DefProp(pName, rhs, node.left.property));\n        maybeAddPhantomObj(obj);\n        if (node.right.type == \"FunctionExpression\")\n          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);\n      } else {\n        connectPattern(node.left, scope, rhs);\n      }\n      return rhs;\n    }),\n    LogicalExpression: fill(function(node, scope, out) {\n      infer(node.left, scope, out);\n      infer(node.right, scope, out);\n    }),\n    ConditionalExpression: fill(function(node, scope, out) {\n      infer(node.test, scope, ANull);\n      infer(node.consequent, scope, out);\n      infer(node.alternate, scope, out);\n    }),\n    NewExpression: fill(function(node, scope, out, name) {\n      if (node.callee.type == \"Identifier\" && node.callee.name in scope.props)\n        maybeInstantiate(scope, 20);\n\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var callee = infer(node.callee, scope);\n      var self = new AVal;\n      callee.propagate(new IsCtor(self, name && /\\.prototype$/.test(name)));\n      self.propagate(out, WG_NEW_INSTANCE);\n      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));\n    }),\n    CallExpression: fill(function(node, scope, out) {\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var outerFn = functionScope(scope).fnType;\n      if (node.callee.type == \"MemberExpression\") {\n        var self = infer(node.callee.object, scope);\n        var pName = propName(node.callee, scope);\n        if (outerFn && (pName == \"call\" || pName == \"apply\") &&\n            outerFn.args.indexOf(self) > -1)\n          maybeInstantiate(scope, 30);\n        self.propagate(new HasMethodCall(pName, args, node.arguments, out));\n      } else if (node.callee.type == \"Super\" && cx.curSuperCtor) {\n        node.callee.superType = cx.curSuperCtor;\n        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out));\n        getThis(scope).propagate(out, WG_NEW_INSTANCE);\n      } else {\n        var callee = infer(node.callee, scope);\n        if (outerFn && outerFn.args.indexOf(callee) > -1)\n          maybeInstantiate(scope, 30);\n        var knownFn = callee.getFunctionType();\n        if (knownFn && knownFn.instantiateScore && outerFn)\n          maybeInstantiate(scope, knownFn.instantiateScore / 5);\n        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));\n      }\n    }),\n    AwaitExpression: fill(function(node, scope, out, name) {\n      var arg = infer(node.argument, scope, null, name);\n      var tp = arg.getType();\n      if (tp && tp.constructor == Obj && tp.name == \"Promise\") {\n        if (tp.hasProp(\":t\")) {\n          tp.getProp(\":t\").propagate(out);\n        }\n      } else {\n        arg.propagate(out);\n      }\n    }),\n    MemberExpression: fill(function(node, scope, out) {\n      var name = propName(node), wg;\n      if (name == \"<i>\") {\n        var propType = infer(node.property, scope);\n        var symName = symbolName(propType);\n        if (symName)\n          name = node.propName = symName;\n        else if (!propType.hasType(cx.num))\n          wg = WG_MULTI_MEMBER;\n      }\n      infer(node.object, scope).getProp(name).propagate(out, wg);\n    }),\n    Identifier: ret(function(node, scope) {\n      if (node.name == \"arguments\") {\n        var fnScope = functionScope(scope, false);\n        if (fnScope.fnType && !(node.name in fnScope.props))\n          fnScope.defProp(node.name, fnScope.fnType.originNode)\n            .addType(new Arr(fnScope.fnType.arguments = new AVal));\n      }\n      return scope.getProp(node.name);\n    }),\n    ThisExpression: ret(function(_node, scope) {\n      return getThis(scope);\n    }),\n    Super: ret(function(node) {\n      return node.superType = cx.curSuper || ANull;\n    }),\n    Literal: ret(function(node) {\n      return literalType(node);\n    }),\n    TemplateLiteral: ret(function(node, scope) {\n      for (var i = 0; i < node.expressions.length; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return cx.str;\n    }),\n    TaggedTemplateExpression: fill(function(node, scope, out) {\n      var args = [new Arr(cx.str)];\n      for (var i = 0; i < node.quasi.expressions.length; ++i)\n        args.push(infer(node.quasi.expressions[i], scope));\n      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out));\n    }),\n    YieldExpression: ret(function(node, scope) {\n      var output = ANull, fn = functionScope(scope).fnType;\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        if (!fn.yieldval) fn.yieldval = new AVal;\n        output = fn.retval;\n      }\n      if (node.argument) {\n        if (node.delegate) {\n          infer(node.argument, scope, new HasMethodCall(\"next\", [], null,\n                                                        new GetProp(\"value\", output)));\n        } else {\n          infer(node.argument, scope, output);\n        }\n      }\n      return fn ? fn.yieldval : ANull;\n    })\n  };\n  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression;\n\n  function infer(node, scope, out, name) {\n    var handler = inferExprVisitor[node.type];\n    return handler ? handler(node, scope, out, name) : ANull;\n  }\n\n  function loopPattern(init) {\n    return init.type == \"VariableDeclaration\" ? init.declarations[0].id : init;\n  }\n\n  var inferWrapper = exports.inferWrapper = walk.make({\n    Expression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    ObjectExpression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    FunctionDeclaration: function(node, scope, c) {\n      var inner = node.scope, fn = inner.fnType;\n      connectParams(node, inner);\n      c(node.body, inner, \"Statement\");\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) scope.getProp(node.id.name).addType(fn);\n    },\n\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope);\n    },\n\n    ExportDefaultDeclaration: function(node, scope, c) {\n      c(node.declaration, node.scope || scope);\n    },\n\n    VariableDeclaration: function(node, scope) {\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        if (decl.id.type == \"Identifier\") {\n          var prop = scope.getProp(decl.id.name);\n          if (decl.init)\n            infer(decl.init, scope, prop, decl.id.name);\n        } else if (decl.init) {\n          connectPattern(decl.id, scope, infer(decl.init, scope));\n        }\n      }\n    },\n\n    ClassDeclaration: function(node, scope) {\n      if (!node.id) inferClass(node, scope);\n      else scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name));\n    },\n\n    ReturnStatement: function(node, scope) {\n      if (!node.argument) return;\n      var output = ANull, fn = functionScope(scope).fnType;\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        output = fn.retval;\n      }\n      infer(node.argument, scope, output);\n    },\n\n    ForInStatement: function(node, scope, c) {\n      var source = infer(node.right, scope);\n      if ((node.right.type == \"Identifier\" && node.right.name in scope.props) ||\n          (node.right.type == \"MemberExpression\" && node.right.property.name == \"prototype\")) {\n        maybeInstantiate(scope, 5);\n        var pattern = loopPattern(node.left);\n        if (pattern.type == \"Identifier\") {\n          if (pattern.name in scope.props)\n            scope.getProp(pattern.name).iteratesOver = source;\n          source.getProp(\"<i>\").propagate(ensureVar(pattern, scope));\n        } else {\n          connectPattern(pattern, scope, source.getProp(\"<i>\"));\n        }\n      }\n      c(node.body, scope, \"Statement\");\n    },\n\n    ForOfStatement: function(node, scope, c) {\n      var pattern = loopPattern(node.left), target;\n      if (pattern.type == \"Identifier\")\n        target = ensureVar(pattern, scope);\n      else\n        connectPattern(pattern, scope, target = new AVal);\n\n      if (node.await) {\n        infer(node.right, scope, new HasMethodCall(\":Symbol.asyncIterator\", [], null,\n                                                   new HasMethodCall(\"next\", [], null,\n                                                                     new GetProp(\":t\",\n                                                                                 new GetProp(\"value\", target)))));\n      } else {\n        infer(node.right, scope, new HasMethodCall(\":Symbol.iterator\", [], null,\n                                                   new HasMethodCall(\"next\", [], null,\n                                                                     new GetProp(\"value\", target))));\n      }\n      c(node.body, scope, \"Statement\");\n    }\n  });\n\n  // PARSING\n\n  var parse = exports.parse = function(text, options, thirdArg) {\n    if (!options || Array.isArray(options)) options = thirdArg;\n    var ast;\n    try { ast = acorn.parse(text, options); }\n    catch(e) { ast = acorn_loose.parse(text, options); }\n    return ast;\n  };\n\n  // ANALYSIS INTERFACE\n\n  exports.analyze = function(ast, name, scope) {\n    if (typeof ast == \"string\") ast = parse(ast);\n\n    if (!name) name = \"file#\" + cx.origins.length;\n    exports.addOrigin(cx.curOrigin = name);\n\n    if (!scope) scope = cx.topScope;\n    cx.startAnalysis();\n\n    walk.recursive(ast, scope, null, scopeGatherer);\n    if (cx.parent) cx.parent.signal(\"preInfer\", ast, scope);\n    walk.recursive(ast, scope, null, inferWrapper);\n    if (cx.parent) cx.parent.signal(\"postInfer\", ast, scope);\n\n    cx.curOrigin = null;\n  };\n\n  // PURGING\n\n  exports.purge = function(origins, start, end) {\n    var test = makePredicate(origins, start, end);\n    ++cx.purgeGen;\n    cx.topScope.purge(test);\n    for (var prop in cx.props) {\n      var list = cx.props[prop];\n      for (var i = 0; i < list.length; ++i) {\n        var obj = list[i], av = obj.props[prop];\n        if (!av || test(av, av.originNode)) list.splice(i--, 1);\n      }\n      if (!list.length) delete cx.props[prop];\n    }\n  };\n\n  function makePredicate(origins, start, end) {\n    var arr = Array.isArray(origins);\n    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }\n    if (arr) {\n      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };\n    } else {\n      if (end == null) return function(n) { return n.origin == origins; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };\n    }\n  }\n\n  AVal.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return;\n    this.purgeGen = cx.purgeGen;\n    for (var i = 0; i < this.types.length; ++i) {\n      var type = this.types[i];\n      if (test(type, type.originNode))\n        this.types.splice(i--, 1);\n      else\n        type.purge(test);\n    }\n    if (!this.types.length) this.maxWeight = 0;\n\n    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n      var f = this.forward[i];\n      if (test(f)) {\n        this.forward.splice(i--, 1);\n        if (this.props) this.props = null;\n      } else if (f.purge) {\n        f.purge(test);\n      }\n    }\n  };\n  ANull.purge = function() {};\n  Obj.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return true;\n    this.purgeGen = cx.purgeGen;\n    for (var p in this.props) {\n      var av = this.props[p];\n      if (test(av, av.originNode))\n        this.removeProp(p);\n      av.purge(test);\n    }\n  };\n  Fn.prototype.purge = function(test) {\n    if (Obj.prototype.purge.call(this, test)) return;\n    this.self.purge(test);\n    this.retval.purge(test);\n    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);\n  };\n\n  // EXPRESSION TYPE DETERMINATION\n\n  function findByPropertyName(name) {\n    guessing = true;\n    var found = objsWithProp(name);\n    if (found) for (var i = 0; i < found.length; ++i) {\n      var val = found[i].getProp(name);\n      if (!val.isEmpty()) return val;\n    }\n    return ANull;\n  }\n\n  function generatorResult(input, output, async) {\n    var defs = cx.definitions.ecmascript;\n    var valObj = new Obj(true);\n    valObj.defProp(\"done\").addType(cx.bool);\n    output.propagate(valObj.defProp(\"value\"));\n    var retObj = valObj;\n    if (async && defs) {\n      retObj = new Obj(defs[\"Promise.prototype\"]);\n      retObj.getType().propagate(new DefProp(':t', valObj));\n    }\n    var method = new Fn(null, ANull, input ? [input] : [], input ? [\"?\"] : [], retObj);\n    var result = new Obj(defs ? async ? defs.async_generator_prototype : defs.generator_prototype : true);\n    result.defProp(\"next\").addType(method);\n    return result;\n  }\n\n  function maybeIterator(fn, output) {\n    if (!fn.generator) return output;\n    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types\n      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output, fn.async);\n      return fn.generator;\n    }\n    return generatorResult(fn.yieldval, output, fn.async);\n  }\n\n  function computeReturnType(funcNode, argNodes, scope) {\n    var fn = findType(funcNode, scope).getFunctionType();\n    if (!fn) return ANull;\n    var result = fn.retval;\n    if (fn.computeRet) {\n      for (var i = 0, args = []; i < argNodes.length; ++i)\n        args.push(findType(argNodes[i], scope));\n      var self = ANull;\n      if (funcNode.type == \"MemberExpression\")\n        self = findType(funcNode.object, scope);\n      result = fn.computeRet(self, args, argNodes);\n    }\n    return maybeIterator(fn, result);\n  }\n\n  var typeFinder = exports.typeFinder = {\n    ArrayExpression: function(node, scope) {\n      return arrayLiteralType(node.elements, scope, findType);\n    },\n    ObjectExpression: function(node) {\n      return node.objType;\n    },\n    ClassDeclaration: function(node) {\n      return node.objType;\n    },\n    ClassExpression: function(node) {\n      return node.objType;\n    },\n    FunctionDeclaration: function(node) {\n      return node.scope.fnType;\n    },\n    FunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    ArrowFunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    SequenceExpression: function(node, scope) {\n      return findType(node.expressions[node.expressions.length-1], scope);\n    },\n    UnaryExpression: function(node) {\n      return unopResultType(node.operator);\n    },\n    UpdateExpression: function() {\n      return cx.num;\n    },\n    BinaryExpression: function(node, scope) {\n      if (binopIsBoolean(node.operator)) return cx.bool;\n      if (node.operator == \"+\") {\n        var lhs = findType(node.left, scope);\n        var rhs = findType(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n      }\n      return cx.num;\n    },\n    AssignmentExpression: function(node, scope) {\n      return findType(node.right, scope);\n    },\n    LogicalExpression: function(node, scope) {\n      var lhs = findType(node.left, scope);\n      return lhs.isEmpty() ? findType(node.right, scope) : lhs;\n    },\n    ConditionalExpression: function(node, scope) {\n      var lhs = findType(node.consequent, scope);\n      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;\n    },\n    NewExpression: function(node, scope) {\n      var f = findType(node.callee, scope).getFunctionType();\n      var proto = f && f.getProp(\"prototype\").getObjType();\n      if (!proto) return ANull;\n      return getInstance(proto, f);\n    },\n    CallExpression: function(node, scope) {\n      return computeReturnType(node.callee, node.arguments, scope);\n    },\n    MemberExpression: function(node, scope) {\n      var propN = propName(node), obj = findType(node.object, scope).getType();\n      if (obj) return obj.getProp(propN);\n      if (propN == \"<i>\") return ANull;\n      return findByPropertyName(propN);\n    },\n    MethodDefinition: function(node) {\n      var propN = propName(node), obj = getThis(node.value.scope).getType();\n      if (obj) return obj.getProp(propN);\n      return ANull;\n    },\n    Identifier: function(node, scope) {\n      return scope.hasProp(node.name) || ANull;\n    },\n    ThisExpression: function(_node, scope) {\n      return getThis(scope);\n    },\n    Literal: function(node) {\n      return literalType(node);\n    },\n    Super: ret(function(node) {\n      return node.superType;\n    }),\n    TemplateLiteral: function() {\n      return cx.str;\n    },\n    TaggedTemplateExpression: function(node, scope) {\n      return computeReturnType(node.tag, node.quasi.expressions, scope);\n    },\n    YieldExpression: function(_node, scope) {\n      var fn = functionScope(scope).fnType;\n      return fn ? fn.yieldval : ANull;\n    }\n  };\n\n  function findType(node, scope) {\n    var finder = typeFinder[node.type];\n    return finder ? finder(node, scope) : ANull;\n  }\n\n  var searchVisitor = exports.searchVisitor = walk.make({\n    Function: function(node, _st, c) {\n      walk.base.Function(node, node.scope, c);\n    },\n    CatchClause: function(node, _st, c) {\n      walk.base.CatchClause(node, node.scope, c);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      if (node.key != node.value) c(node.value, st, \"Expression\");\n    },\n    Statement: function(node, st, c) {\n      c(node, node.scope || st);\n    },\n    ImportSpecifier: function(node, st, c) {\n      c(node.local, st);\n    },\n    ImportDefaultSpecifier: function(node, st, c) {\n      c(node.local, st);\n    },\n    ImportNamespaceSpecifier: function(node, st, c) {\n      c(node.local, st);\n    }\n  });\n  var searchExprVisitor = exports.searchExprVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      if (node.computed) { c(node.property, st, \"Expression\"); }\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n  exports.fullVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      c(node.property, st, node.computed ? \"Expression\" : null);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n\n  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAt(ast, start, end, test, searchExprVisitor, defaultScope || cx.topScope);\n  };\n  exports.findClosestExpression = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchExprVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.expressionType = function(found) {\n    return findType(found.node, found.state);\n  };\n\n  // Finding the expected type of something, from context\n\n  exports.parentNode = function(child, ast) {\n    var stack = [];\n    function c(node, st, override) {\n      if (node.start <= child.start && node.end >= child.end) {\n        var top = stack[stack.length - 1];\n        if (node == child) throw {found: top};\n        if (top != node) stack.push(node);\n        walk.base[override || node.type](node, st, c);\n        if (top != node) stack.pop();\n      }\n    }\n    try {\n      c(ast, null);\n    } catch (e) {\n      if (e.found) return e.found;\n      throw e;\n    }\n  };\n\n  var findTypeFromContext = exports.findTypeFromContext = {\n    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp(\"<i>\"); },\n    ObjectExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.value == node)\n          return get(parent, true).getProp(propName(prop));\n      }\n    },\n    UnaryExpression: function(parent) { return unopResultType(parent.operator); },\n    UpdateExpression: function() { return cx.num; },\n    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },\n    AssignmentExpression: function(parent, _, get) { return get(parent.left); },\n    LogicalExpression: function(parent, _, get) { return get(parent, true); },\n    ConditionalExpression: function(parent, node, get) {\n      if (parent.consequent == node || parent.alternate == node) return get(parent, true);\n    },\n    CallExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.arguments.length; i++) {\n        var arg = parent.arguments[i];\n        if (arg == node) {\n          var calleeType = get(parent.callee).getFunctionType();\n          if (calleeType instanceof Fn)\n            return calleeType.args[i];\n          break;\n        }\n      }\n    },\n    ReturnStatement: function(_parent, node, get) {\n      // tweaking search position to avoid endless recursion\n      // when looking for definition of key in fn ( return fn ( return object ) )\n      // see ternjs/tern#777\n      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start - 1, \"Function\");\n      if (fnNode) {\n        var fnType = fnNode.node.type != \"FunctionDeclaration\"\n          ? get(fnNode.node, true).getFunctionType()\n          : fnNode.node.scope.fnType;\n        if (fnType) return fnType.retval.getType();\n      }\n    },\n    VariableDeclarator: function(parent, node, get) {\n      if (parent.init == node) return get(parent.id);\n    }\n  };\n  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression;\n\n  exports.typeFromContext = function(ast, found) {\n    var parent = exports.parentNode(found.node, ast);\n    var type = null;\n    if (findTypeFromContext.hasOwnProperty(parent.type)) {\n      var finder = findTypeFromContext[parent.type];\n      type = finder && finder(parent, found.node, function(node, fromContext) {\n        var obj = {node: node, state: found.state};\n        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);\n        return tp || ANull;\n      });\n    }\n    return type || exports.expressionType(found);\n  };\n\n  // Flag used to indicate that some wild guessing was used to produce\n  // a type or set of completions.\n  var guessing = false;\n\n  exports.resetGuessing = function(val) { guessing = val; };\n  exports.didGuess = function() { return guessing; };\n\n  exports.forAllPropertiesOf = function(type, f) {\n    type.gatherProperties(f, 0);\n  };\n\n  exports.findRefs = function(ast, baseScope, name, refScope, f) {\n    function handleId(node, scope, ancestors) {\n      var parent = ancestors[ancestors.length - 2];\n      if (parent.type == \"MemberExpression\" && !parent.computed && !!node.object) return;\n      if (node.name != name ||\n          (node == ast.id && ast.type == \"FunctionDeclaration\")) return;\n      if (parent.property === node) return;\n      for (var s = scope; s; s = s.prev) {\n        if (s == refScope) f(node, scope, ancestors);\n        if (name in s.props) return;\n      }\n    }\n    walk.ancestor(ast, {Identifier: handleId, VariablePattern: handleId},\n                  exports.fullVisitor, baseScope);\n  };\n\n  var simpleWalker = walk.make({\n    Function: function(node, _scope, c) {\n      c(node.body, node.scope, node.expression ? \"Expression\" : \"Statement\");\n    },\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope);\n    }\n  });\n\n  exports.findPropRefs = function(ast, scope, objType, name, f) {\n    // Find the type which owns the property in hierarchy\n    while (objType && !objType.props[name] && !(objType.maybeProps && objType.maybeProps[name])) {\n      objType = objType.proto;\n    }\n    if (!objType) throw new Error(\"Couldn't locate property in the base object type.\");\n\n    function isObjTypeProto(type) {\n      // Check whether the found type has objType in its hierarchy\n      while (type && type != objType) {\n        // Ff property is overriden higher in the hierarchy, return false\n        if (type.props[name] || (type.maybeProps && type.maybeProps[name])) {\n          return false;\n        }\n        type = type.proto;\n      }\n      return type;\n    }\n\n    walk.simple(ast, {\n      MemberExpression: function(node, scope) {\n        if (node.computed || propName(node) != name) return;\n        if (isObjTypeProto(findType(node.object, scope).getType())) f(node.property, scope);\n      },\n      ObjectExpression: function(node, scope) {\n        if (findType(node, scope).getType() != objType) return;\n        for (var i = 0; i < node.properties.length; ++i)\n          if (propName(node.properties[i]) == name) f(node.properties[i].key, scope);\n      },\n      MethodDefinition: function(node) {\n        if (propName(node) != name) return;\n        if (node.value && isObjTypeProto(getThis(node.value.scope).getType())) f(node.key, node.value.scope);\n      }\n    }, simpleWalker, scope);\n  };\n\n  // LOCAL-VARIABLE QUERIES\n\n  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {\n    var found = walk.findNodeAround(ast, pos, function(_, node) {\n      return node.scope;\n    });\n    if (found) return found.node.scope;\n    else return defaultScope || cx.topScope;\n  };\n\n  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {\n    var scope = scopeAt(ast, pos, defaultScope);\n    scope.gatherProperties(f, 0);\n  };\n\n  // INIT DEF MODULE\n\n  // Delayed initialization because of cyclic dependencies.\n  def = exports.def = def.init({}, exports);\n});\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/tern/lib/infer.js?");

/***/ }),

/***/ "./node_modules/tern/lib/signal.js":
/*!*****************************************!*\
  !*** ./node_modules/tern/lib/signal.js ***!
  \*****************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, mod) {\n  if (true) // CommonJS\n    return mod(exports);\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env\n})(this, function(exports) {\n\n  function on(type, f) {\n    var handlers = this._handlers || (this._handlers = Object.create(null));\n    (handlers[type] || (handlers[type] = [])).push(f);\n  }\n\n  function off(type, f) {\n    var arr = this._handlers && this._handlers[type];\n    if (arr) for (var i = 0; i < arr.length; ++i)\n      if (arr[i] == f) { arr.splice(i, 1); break; }\n  }\n\n  var noHandlers = [];\n  function getHandlers(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length ? arr.slice() : noHandlers;\n  }\n\n  function signal(type, a1, a2, a3, a4) {\n    var arr = getHandlers(this, type);\n    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4);\n  }\n\n  function signalReturnFirst(type, a1, a2, a3, a4) {\n    var arr = getHandlers(this, type);\n    for (var i = 0; i < arr.length; ++i) {\n      var result = arr[i].call(this, a1, a2, a3, a4);\n      if (result) return result;\n    }\n  }\n\n  function hasHandler(type) {\n    var arr = this._handlers && this._handlers[type];\n    return arr && arr.length > 0 && arr;\n  }\n\n  exports.mixin = function(obj) {\n    obj.on = on; obj.off = off;\n    obj.signal = signal;\n    obj.signalReturnFirst = signalReturnFirst;\n    obj.hasHandler = hasHandler;\n    return obj;\n  };\n});\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/tern/lib/signal.js?");

/***/ }),

/***/ "./node_modules/tern/lib/tern.js":
/*!***************************************!*\
  !*** ./node_modules/tern/lib/tern.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// The Tern server object\n\n// A server is a stateful object that manages the analysis for a\n// project, and defines an interface for querying the code in the\n// project.\n\n(function(root, mod) {\n  if (true) // CommonJS\n    return mod(exports, __webpack_require__(/*! ./infer */ \"./node_modules/tern/lib/infer.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\"),\n               __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.mjs\"), __webpack_require__(/*! acorn-walk */ \"./node_modules/acorn-walk/dist/walk.mjs\"));\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./infer */ \"./node_modules/tern/lib/infer.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\"), __webpack_require__(/*! acorn/dist/acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.js\"), __webpack_require__(/*! acorn-walk/dist/walk */ \"./node_modules/acorn-walk/dist/walk.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env\n})(this, function(exports, infer, signal, acorn, walk) {\n  \"use strict\";\n\n  var plugins = Object.create(null);\n  exports.registerPlugin = function(name, init) { plugins[name] = init; };\n\n  var defaultOptions = exports.defaultOptions = {\n    debug: false,\n    async: false,\n    getFile: function(_f, c) { if (this.async) c(null, null); },\n    normalizeFilename: function(name) { return name },\n    defs: [],\n    plugins: {},\n    fetchTimeout: 1000,\n    dependencyBudget: 20000,\n    reuseInstances: true,\n    stripCRs: false,\n    ecmaVersion: 9,\n    projectDir: \"/\",\n    parent: null\n  };\n\n  var queryTypes = {\n    completions: {\n      takesFile: true,\n      run: findCompletions\n    },\n    properties: {\n      run: findProperties\n    },\n    type: {\n      takesFile: true,\n      run: findTypeAt\n    },\n    documentation: {\n      takesFile: true,\n      run: findDocs\n    },\n    definition: {\n      takesFile: true,\n      run: findDef\n    },\n    refs: {\n      takesFile: true,\n      fullFile: true,\n      run: findRefs\n    },\n    rename: {\n      takesFile: true,\n      fullFile: true,\n      run: buildRename\n    },\n    files: {\n      run: listFiles\n    }\n  };\n\n  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };\n\n  function File(name, parent) {\n    this.name = name;\n    this.parent = parent;\n    this.scope = this.text = this.ast = this.lineOffsets = null;\n  }\n  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };\n\n  function parseFile(srv, file) {\n    var options = {\n      directSourceFile: file,\n      allowReturnOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      ecmaVersion: srv.options.ecmaVersion,\n      allowHashBang: true\n    };\n    var text = srv.signalReturnFirst(\"preParse\", file.text, options) || file.text;\n    var ast = infer.parse(text, options);\n    srv.signal(\"postParse\", ast, text);\n    return ast;\n  }\n\n  var astral = /[\\uD800-\\uDBFF]/g;\n\n  function updateText(file, text, srv) {\n    file.text = srv.options.stripCRs ? text.replace(/\\r\\n/g, \"\\n\") : text;\n    file.hasAstral = astral.test(file.text);\n    infer.withContext(srv.cx, function() {\n      file.ast = parseFile(srv, file);\n    });\n    file.lineOffsets = null;\n  }\n\n  var Server = exports.Server = function(options) {\n    this.cx = null;\n    this.options = options || {};\n    for (var o in defaultOptions) if (!options.hasOwnProperty(o))\n      options[o] = defaultOptions[o];\n\n    this.projectDir = options.projectDir.replace(/\\\\/g, \"/\");\n    if (!/\\/$/.test(this.projectDir)) this.projectDir += \"/\";\n\n    this.parent = options.parent;\n    this.handlers = Object.create(null);\n    this.files = [];\n    this.fileMap = Object.create(null);\n    this.needsPurge = [];\n    this.budgets = Object.create(null);\n    this.uses = 0;\n    this.pending = 0;\n    this.asyncError = null;\n    this.mod = {};\n\n    this.defs = options.defs.slice(0);\n    this.plugins = Object.create(null);\n    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))\n      this.loadPlugin(plugin, options.plugins[plugin]);\n\n    this.reset();\n  };\n  Server.prototype = signal.mixin({\n    addFile: function(name, /*optional*/ text, parent) {\n      // Don't crash when sloppy plugins pass non-existent parent ids\n      if (parent && !(parent in this.fileMap)) parent = null;\n      if (!(name in this.fileMap))\n        name = this.normalizeFilename(name);\n      ensureFile(this, name, parent, text);\n    },\n    delFile: function(name) {\n      var file = this.findFile(name);\n      if (file) {\n        this.needsPurge.push(file.name);\n        for (var i = 0; i < this.files.length; i++) {\n          if (this.files[i] == file) this.files.splice(i--, 1);\n          else if (this.files[i].parent == name) this.files[i].parent = null;\n        }\n        delete this.fileMap[file.name];\n      }\n    },\n    reset: function() {\n      this.signal(\"reset\");\n      this.cx = new infer.Context(this.defs, this);\n      this.uses = 0;\n      this.budgets = Object.create(null);\n      for (var i = 0; i < this.files.length; ++i) {\n        var file = this.files[i];\n        if (file.scope) {\n          infer.clearScopes(file.ast);\n          file.scope = null;\n        }\n      }\n      this.signal(\"postReset\");\n    },\n\n    request: function(doc, c) {\n      var inv = invalidDoc(doc);\n      if (inv) return c(inv);\n\n      var self = this;\n      doRequest(this, doc, function(err, data) {\n        c(err, data);\n        if (self.uses > 40) {\n          self.reset();\n          analyzeAll(self, null, function(){});\n        }\n      });\n    },\n\n    findFile: function(name) {\n      return this.fileMap[this.normalizeFilename(name)];\n    },\n\n    flush: function(c) {\n      var cx = this.cx;\n      analyzeAll(this, null, function(err) {\n        if (err) return c(err);\n        infer.withContext(cx, c);\n      });\n    },\n\n    startAsyncAction: function() {\n      ++this.pending;\n    },\n    finishAsyncAction: function(err) {\n      if (err) this.asyncError = err;\n      if (--this.pending === 0) this.signal(\"everythingFetched\");\n    },\n\n    addDefs: function(defs, toFront) {\n      if (toFront) this.defs.unshift(defs);\n      else this.defs.push(defs);\n\n      if (this.cx) this.reset();\n    },\n\n    deleteDefs: function(name) {\n      for (var i = 0; i < this.defs.length; i++) if (this.defs[i][\"!name\"] == name) {\n        this.defs.splice(i, 1);\n        if (this.cx) this.reset();\n        return;\n      }\n    },\n\n    loadPlugin: function(name, options) {\n      if (arguments.length == 1) options = this.options.plugins[name] || true;\n      if (name in this.plugins || !(name in plugins) || !options) return;\n      this.plugins[name] = true;\n      var init = plugins[name](this, options);\n\n      // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly\n      if (!init) return;\n      if (init.defs) this.addDefs(init.defs, init.loadFirst);\n      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))\n        this.on(type, init.passes[type]);\n    },\n\n    normalizeFilename: function(name) {\n      var norm = this.options.normalizeFilename(name).replace(/\\\\/g, \"/\");\n      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length);\n      return norm;\n    }\n  });\n\n  function doRequest(srv, doc, c) {\n    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))\n      return c(\"No query type '\" + doc.query.type + \"' defined\");\n\n    var query = doc.query;\n    // Respond as soon as possible when this just uploads files\n    if (!query) c(null, {});\n\n    var files = doc.files || [];\n    if (files.length) ++srv.uses;\n    for (var i = 0; i < files.length; ++i) {\n      var file = files[i];\n      file.name = srv.normalizeFilename(file.name);\n      if (file.type == \"delete\")\n        srv.delFile(file.name);\n      else\n        ensureFile(srv, file.name, null, file.type == \"full\" ? file.text : null);\n    }\n\n    var timeBudget = typeof doc.timeout == \"number\" ? [doc.timeout] : null;\n    if (!query) {\n      analyzeAll(srv, timeBudget, function(){});\n      return;\n    }\n\n    var queryType = queryTypes[query.type];\n    if (queryType.takesFile) {\n      if (typeof query.file != \"string\") return c(\".query.file must be a string\");\n      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);\n    }\n\n    analyzeAll(srv, timeBudget, function(err) {\n      if (err) return c(err);\n      var file = queryType.takesFile && resolveFile(srv, files, query.file);\n      if (queryType.fullFile && file.type == \"part\")\n        return c(\"Can't run a \" + query.type + \" query on a file fragment\");\n\n      infer.resetGuessing();\n      infer.withContext(srv.cx, function() {\n        var result, run = function() { result = queryType.run(srv, query, file); };\n        try {\n          if (timeBudget) infer.withTimeout(timeBudget[0], run);\n          else run();\n        } catch (e) {\n          if (srv.options.debug && e.name != \"TernError\") console.error(e.stack);\n          return c(e);\n        }\n        c(null, result);\n      });\n    });\n  }\n\n  function analyzeFile(srv, file) {\n    infer.withContext(srv.cx, function() {\n      file.scope = srv.cx.topScope;\n      srv.signal(\"beforeLoad\", file);\n      infer.analyze(file.ast, file.name, file.scope);\n      srv.signal(\"afterLoad\", file);\n    });\n    return file;\n  }\n\n  function ensureFile(srv, name, parent, text) {\n    var known = srv.findFile(name);\n    if (known) {\n      if (text != null) {\n        if (known.scope) {\n          srv.needsPurge.push(name);\n          infer.clearScopes(known.ast);\n          known.scope = null;\n        }\n        updateText(known, text, srv);\n      }\n      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {\n        known.parent = parent;\n        if (known.excluded) known.excluded = null;\n      }\n      return;\n    }\n\n    var file = new File(name, parent);\n    srv.files.push(file);\n    srv.fileMap[name] = file;\n    if (text != null) {\n      updateText(file, text, srv);\n    } else if (srv.options.async) {\n      srv.startAsyncAction();\n      srv.options.getFile(name, function(err, text) {\n        updateText(file, text || \"\", srv);\n        srv.finishAsyncAction(err);\n      });\n    } else {\n      updateText(file, srv.options.getFile(name) || \"\", srv);\n    }\n  }\n\n  function fetchAll(srv, c) {\n    var done = true, returned = false;\n    srv.files.forEach(function(file) {\n      if (file.text != null) return;\n      if (srv.options.async) {\n        done = false;\n        srv.options.getFile(file.name, function(err, text) {\n          if (err && !returned) { returned = true; return c(err); }\n          updateText(file, text || \"\", srv);\n          fetchAll(srv, c);\n        });\n      } else {\n        try {\n          updateText(file, srv.options.getFile(file.name) || \"\", srv);\n        } catch (e) { return c(e); }\n      }\n    });\n    if (done) c();\n  }\n\n  function waitOnFetch(srv, timeBudget, c) {\n    var done = function() {\n      srv.off(\"everythingFetched\", done);\n      clearTimeout(timeout);\n      analyzeAll(srv, timeBudget, c);\n    };\n    srv.on(\"everythingFetched\", done);\n    var timeout = setTimeout(done, srv.options.fetchTimeout);\n  }\n\n  function analyzeAll(srv, timeBudget, c) {\n    if (srv.pending) return waitOnFetch(srv, timeBudget, c);\n\n    var e = srv.fetchError;\n    if (e) { srv.fetchError = null; return c(e); }\n\n    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {\n      infer.purge(srv.needsPurge);\n      srv.needsPurge.length = 0;\n    });\n\n    var done = true;\n    // The second inner loop might add new files. The outer loop keeps\n    // repeating both inner loops until all files have been looked at.\n    for (var i = 0; i < srv.files.length;) {\n      var toAnalyze = [];\n      for (; i < srv.files.length; ++i) {\n        var file = srv.files[i];\n        if (file.text == null) done = false;\n        else if (file.scope == null && !file.excluded) toAnalyze.push(file);\n      }\n      toAnalyze.sort(function(a, b) {\n        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);\n      });\n      for (var j = 0; j < toAnalyze.length; j++) {\n        var file = toAnalyze[j];\n        if (file.parent && !chargeOnBudget(srv, file)) {\n          file.excluded = true;\n        } else if (timeBudget) {\n          var startTime = +new Date;\n          try {\n            infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });\n          } catch(e) {\n            if (e instanceof infer.TimedOut) return c(e);\n            else throw e;\n          }\n          timeBudget[0] -= +new Date - startTime;\n        } else {\n          analyzeFile(srv, file);\n        }\n      }\n    }\n    if (done) c();\n    else waitOnFetch(srv, timeBudget, c);\n  }\n\n  function firstLine(str) {\n    var end = str.indexOf(\"\\n\");\n    if (end < 0) return str;\n    return str.slice(0, end);\n  }\n\n  function findMatchingPosition(line, file, near) {\n    var pos = Math.max(0, near - 500), closest = null;\n    if (!/^\\s*$/.test(line)) for (;;) {\n      var found = file.indexOf(line, pos);\n      if (found < 0 || found > near + 500) break;\n      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))\n        closest = found;\n      pos = found + line.length;\n    }\n    return closest;\n  }\n\n  function scopeDepth(s) {\n    for (var i = 0; s; ++i, s = s.prev) {}\n    return i;\n  }\n\n  function ternError(msg) {\n    var err = new Error(msg);\n    err.name = \"TernError\";\n    return err;\n  }\n\n  function resolveFile(srv, localFiles, name) {\n    var isRef = name.match(/^#(\\d+)$/);\n    if (!isRef) return srv.findFile(name);\n\n    var file = localFiles[isRef[1]];\n    if (!file || file.type == \"delete\") throw ternError(\"Reference to unknown file \" + name);\n    if (file.type == \"full\") return srv.fileMap[file.name];\n\n    // This is a partial file\n\n    var realFile = file.backing = srv.fileMap[file.name];\n    var offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);\n    var line = firstLine(file.text);\n    var foundPos = findMatchingPosition(line, realFile.text, offset);\n    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf(\"\\n\", offset)) : foundPos;\n    var inObject, atFunction;\n\n    infer.withContext(srv.cx, function() {\n      infer.purge(file.name, pos, pos + file.text.length);\n\n      var text = file.text, m;\n      if (m = text.match(/(?:\"([^\"]*)\"|([\\w$]+))\\s*:\\s*function\\b/)) {\n        var objNode = walk.findNodeAround(file.backing.ast, pos, \"ObjectExpression\");\n        if (objNode && objNode.node.objType)\n          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};\n      }\n      if (foundPos && (m = line.match(/^(.*?)\\bfunction\\b/))) {\n        var cut = m[1].length, white = \"\";\n        for (var i = 0; i < cut; ++i) white += \" \";\n        file.text = white + text.slice(cut);\n        atFunction = true;\n      }\n\n      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);\n      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);\n      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;\n      file.ast = parseFile(srv, file);\n      infer.analyze(file.ast, file.name, scope);\n\n      // This is a kludge to tie together the function types (if any)\n      // outside and inside of the fragment, so that arguments and\n      // return values have some information known about them.\n      tieTogether: {\n        if (inObject || atFunction) {\n          var newInner = infer.scopeAt(file.ast, line.length, scopeStart);\n          if (!newInner.fnType) break tieTogether;\n          if (inObject) {\n            var prop = inObject.type.getProp(inObject.prop);\n            prop.addType(newInner.fnType);\n          } else if (atFunction) {\n            var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);\n            if (inner == scopeStart || !inner.fnType) break tieTogether;\n            var fOld = inner.fnType, fNew = newInner.fnType;\n            if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;\n            for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)\n              fOld.args[i].propagate(fNew.args[i]);\n            fOld.self.propagate(fNew.self);\n            fNew.retval.propagate(fOld.retval);\n          }\n        }\n      }\n    });\n    return file;\n  }\n\n  // Budget management\n\n  function astSize(node) {\n    var size = 0;\n    walk.simple(node, {Expression: function() { ++size; }});\n    return size;\n  }\n\n  function parentDepth(srv, parent) {\n    var depth = 0;\n    while (parent) {\n      parent = srv.fileMap[parent].parent;\n      ++depth;\n    }\n    return depth;\n  }\n\n  function budgetName(srv, file) {\n    for (;;) {\n      var parent = srv.fileMap[file.parent];\n      if (!parent.parent) break;\n      file = parent;\n    }\n    return file.name;\n  }\n\n  function chargeOnBudget(srv, file) {\n    var bName = budgetName(srv, file);\n    var size = astSize(file.ast);\n    var known = srv.budgets[bName];\n    if (known == null)\n      known = srv.budgets[bName] = srv.options.dependencyBudget;\n    if (known < size) return false;\n    srv.budgets[bName] = known - size;\n    return true;\n  }\n\n  // Query helpers\n\n  function isPosition(val) {\n    return typeof val == \"number\" || typeof val == \"object\" &&\n      typeof val.line == \"number\" && typeof val.ch == \"number\";\n  }\n\n  // Baseline query document validation\n  function invalidDoc(doc) {\n    if (doc.query) {\n      if (typeof doc.query.type != \"string\") return \".query.type must be a string\";\n      if (doc.query.start && !isPosition(doc.query.start)) return \".query.start must be a position\";\n      if (doc.query.end && !isPosition(doc.query.end)) return \".query.end must be a position\";\n    }\n    if (doc.files) {\n      if (!Array.isArray(doc.files)) return \"Files property must be an array\";\n      for (var i = 0; i < doc.files.length; ++i) {\n        var file = doc.files[i];\n        if (typeof file != \"object\") return \".files[n] must be objects\";\n        else if (typeof file.name != \"string\") return \".files[n].name must be a string\";\n        else if (file.type == \"delete\") continue;\n        else if (typeof file.text != \"string\") return \".files[n].text must be a string\";\n        else if (file.type == \"part\") {\n          if (!isPosition(file.offset) && typeof file.offsetLines != \"number\")\n            return \".files[n].offset must be a position\";\n        } else if (file.type != \"full\") return \".files[n].type must be \\\"full\\\" or \\\"part\\\"\";\n      }\n    }\n  }\n\n  var offsetSkipLines = 25;\n\n  function forwardCharacters(file, start, chars) {\n    var pos = start + chars, m;\n    if (file.hasAstral) {\n      astral.lastIndex = start;\n      while ((m = astral.exec(file.text)) && m.index < pos) pos++;\n    }\n    return pos;\n  }\n\n  function findLineStart(file, line) {\n    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var pos = 0, curLine = 0;\n    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);\n    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;\n\n    while (curLine < line) {\n      ++curLine;\n      pos = text.indexOf(\"\\n\", pos) + 1;\n      if (pos === 0) return null;\n      if (curLine % offsetSkipLines === 0) offsets.push(pos);\n    }\n    return pos;\n  }\n\n  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {\n    if (typeof pos != \"number\") {\n      var lineStart = findLineStart(file, pos.line);\n      if (lineStart == null) {\n        if (tolerant) pos = file.text.length;\n        else throw ternError(\"File doesn't contain a line \" + pos.line);\n      } else {\n        pos = forwardCharacters(file, lineStart, pos.ch);\n      }\n    } else {\n      pos = forwardCharacters(file, 0, pos);\n    }\n    if (pos > file.text.length) {\n      if (tolerant) pos = file.text.length;\n      else throw ternError(\"Position \" + pos + \" is outside of file.\");\n    }\n    return pos;\n  };\n\n  function charDistanceBetween(file, start, end) {\n    var diff = end - start, m;\n    if (file.hasAstral) {\n      astral.lastIndex = start;\n      while ((m = astral.exec(file.text)) && m.index < end) diff--;\n    }\n    return diff;\n  }\n\n  function asLineChar(file, pos) {\n    if (!file) return {line: 0, ch: 0};\n    var offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var text = file.text, line, lineStart;\n    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {\n      line = i * offsetSkipLines;\n      lineStart = offsets[i];\n    }\n    for (;;) {\n      var eol = text.indexOf(\"\\n\", lineStart);\n      if (eol >= pos || eol < 0) break;\n      lineStart = eol + 1;\n      ++line;\n    }\n    return {line: line, ch: charDistanceBetween(file, lineStart, pos)};\n  }\n\n  var outputPos = exports.outputPos = function(query, file, pos) {\n    if (query.lineCharPositions) {\n      var out = asLineChar(file, pos);\n      if (file.type == \"part\")\n        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;\n      return out;\n    } else {\n      return charDistanceBetween(file, 0, pos) + (file.type == \"part\" ? file.offset : 0);\n    }\n  };\n\n  // Delete empty fields from result objects\n  function clean(obj) {\n    for (var prop in obj) if (obj[prop] == null) delete obj[prop];\n    return obj;\n  }\n  function maybeSet(obj, prop, val) {\n    if (val != null) obj[prop] = val;\n  }\n\n  // Built-in query types\n\n  function compareCompletions(a, b) {\n    if (typeof a != \"string\") { a = a.name; b = b.name; }\n    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);\n    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;\n    else return aUp ? 1 : -1;\n  }\n\n  function isStringAround(node, start, end) {\n    return node.type == \"Literal\" && typeof node.value == \"string\" &&\n      node.start == start - 1 && node.end <= end + 1;\n  }\n\n  function pointInProp(objNode, point) {\n    for (var i = 0; i < objNode.properties.length; i++) {\n      var curProp = objNode.properties[i];\n      if (curProp.key && curProp.key.start <= point && curProp.key.end >= point)\n        return curProp;\n    }\n  }\n\n  var jsKeywords = (\"break do instanceof typeof case else new var \" +\n    \"catch finally return void continue for switch while debugger \" +\n    \"function this with default if throw delete in try\").split(\" \");\n  var jsKeywordsES6 = jsKeywords.concat(\"export class extends const super yield import let static\".split(\" \"));\n\n  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {\n    var typeInfo = query.types || query.docs || query.urls || query.origins;\n    var wrapAsObjs = typeInfo || query.depths;\n\n    for (var i = 0; i < completions.length; ++i) {\n      var c = completions[i];\n      if ((wrapAsObjs ? c.name : c) == name) return;\n    }\n    var rec = wrapAsObjs ? {name: name} : name;\n    completions.push(rec);\n\n    if (aval && typeInfo) {\n      infer.resetGuessing();\n      var type = aval.getType();\n      rec.guess = infer.didGuess();\n      if (query.types)\n        rec.type = infer.toString(aval);\n      if (query.docs)\n        maybeSet(rec, \"doc\", parseDoc(query, aval.doc || type && type.doc));\n      if (query.urls)\n        maybeSet(rec, \"url\", aval.url || type && type.url);\n      if (query.origins)\n        maybeSet(rec, \"origin\", aval.origin || type && type.origin);\n    }\n    if (query.depths) rec.depth = depth || 0;\n    return rec;\n  };\n\n  function findCompletions(srv, query, file) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n    var fromPlugin = srv.signalReturnFirst(\"completion\", file, query);\n    if (fromPlugin) return fromPlugin;\n\n    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;\n    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;\n    if (query.expandWordForward !== false)\n      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;\n    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;\n    if (query.caseInsensitive) word = word.toLowerCase();\n\n    function gather(prop, obj, depth, addInfo) {\n      // 'hasOwnProperty' and such are usually just noise, leave them\n      // out when no prefix is provided.\n      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;\n      if (query.filter !== false && word &&\n          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;\n      if (ignoreObj && ignoreObj.props[prop]) return;\n      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);\n      if (addInfo && result && typeof result != \"string\") addInfo(result);\n    }\n\n    var hookname, prop, objType, isKey;\n\n    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);\n    var memberExpr, objLit;\n    // Decide whether this is an object property, either in a member\n    // expression or an object literal.\n    if (exprAt) {\n      var exprNode = exprAt.node;\n\n      if (query.inLiteral === false && exprNode.type === \"Literal\" &&\n          (typeof exprNode.value === 'string' || exprNode.regex))\n        return {\n          start: outputPos(query, file, wordStart),\n          end: outputPos(query, file, wordEnd),\n          completions: []\n        };\n\n      if (exprNode.type == \"MemberExpression\" && exprNode.object.end < wordStart) {\n        memberExpr = exprAt;\n      } else if (isStringAround(exprNode, wordStart, wordEnd)) {\n        var parent = infer.parentNode(exprNode, file.ast);\n        if (parent.type == \"MemberExpression\" && parent.property == exprNode)\n          memberExpr = {node: parent, state: exprAt.state};\n      } else if (exprNode.type == \"ObjectExpression\") {\n        var objProp = pointInProp(exprNode, wordEnd);\n        if (objProp) {\n          objLit = exprAt;\n          prop = isKey = objProp.key.name || objProp.key.value;\n        } else if (!word && !/:\\s*$/.test(file.text.slice(0, wordStart))) {\n          objLit = exprAt;\n          prop = isKey = true;\n        }\n      }\n    }\n\n    if (objLit) {\n      // Since we can't use the type of the literal itself to complete\n      // its properties (it doesn't contain the information we need),\n      // we have to try asking the surrounding expression for type info.\n      objType = infer.typeFromContext(file.ast, objLit);\n      ignoreObj = objLit.node.objType;\n    } else if (memberExpr) {\n      prop = memberExpr.node.property;\n      prop = prop.type == \"Literal\" ? prop.value.slice(1) : prop.name;\n      memberExpr.node = memberExpr.node.object;\n      objType = infer.expressionType(memberExpr);\n    } else if (text.charAt(wordStart - 1) == \".\") {\n      var pathStart = wordStart - 1;\n      while (pathStart && (text.charAt(pathStart - 1) == \".\" || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;\n      var path = text.slice(pathStart, wordStart - 1);\n      if (path) {\n        objType = infer.def.parsePath(path, file.scope).getObjType();\n        prop = word;\n      }\n    }\n\n    if (prop != null) {\n      srv.cx.completingProperty = prop;\n\n      if (objType) infer.forAllPropertiesOf(objType, gather);\n\n      if (!completions.length && query.guess !== false && objType && objType.guessProperties)\n        objType.guessProperties(function(p, o, d) {if (p != prop && p != \"✖\" && p != \"<i>\") gather(p, o, d);});\n      if (!completions.length && word.length >= 2 && query.guess !== false)\n        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);\n      hookname = \"memberCompletion\";\n    } else {\n      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);\n      if (query.includeKeywords) {\n        (srv.options.ecmaVersion >= 6 ? jsKeywordsES6 : jsKeywords).forEach(function(kw) {\n          gather(kw, null, 0, function(rec) { rec.isKeyword = true; });\n        });\n      }\n      hookname = \"variableCompletion\";\n    }\n    srv.signal(hookname, file, wordStart, wordEnd, gather);\n\n    if (query.sort !== false) completions.sort(compareCompletions);\n    srv.cx.completingProperty = null;\n\n    return {start: outputPos(query, file, wordStart),\n            end: outputPos(query, file, wordEnd),\n            isProperty: !!prop,\n            isObjectKey: !!isKey,\n            completions: completions};\n  }\n\n  function findProperties(srv, query) {\n    var prefix = query.prefix, found = [];\n    for (var prop in srv.cx.props)\n      if (prop != \"<i>\" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);\n    if (query.sort !== false) found.sort(compareCompletions);\n    return {completions: found};\n  }\n\n  function inBody(node, pos) {\n    var body = node.body, start, end;\n    if (!body) return false;\n    if (Array.isArray(body)) {\n      start = body[0].start;\n      end = body[body.length - 1].end;\n    } else {\n      start = body.start;\n      end = body.end;\n    }\n    return start <= pos && end >= pos;\n  }\n\n  var findExpr = exports.findQueryExpr = function(file, query, wide) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n\n    if (query.variable) {\n      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);\n      return {node: {type: \"Identifier\", name: query.variable, start: query.end, end: query.end + 1},\n              state: scope};\n    } else {\n      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);\n      if (!expr) {\n        var span = infer.findClosestExpression(file.ast, start, end, file.scope);\n        if (span && !inBody(span.node, end) &&\n            (wide || (start == null ? end : start) - span.node.start < 20 || span.node.end - end < 20))\n          expr = span;\n      }\n      if (!expr) {\n        var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n        if (around && !inBody(around.node, end) &&\n            (around.node.type == \"ObjectExpression\" || wide ||\n             (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n          expr = around;\n      }\n      return expr;\n    }\n  };\n\n  function findExprAround(file, query, wide) {\n    var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n    var expr = null;\n    var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n    if (around && !inBody(around.node, end) &&\n        (around.node.type == \"ObjectExpression\" || wide ||\n         (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n      expr = around;\n    return expr;\n  }\n\n  function findExprOrThrow(file, query, wide) {\n    var expr = findExpr(file, query, wide);\n    if (expr) return expr;\n    throw ternError(\"No expression at the given position.\");\n  }\n\n  function ensureObj(tp) {\n    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;\n    return tp;\n  }\n\n  function findExprType(srv, query, file, expr) {\n    var type;\n    if (expr) {\n      infer.resetGuessing();\n      type = infer.expressionType(expr);\n    }\n    var typeHandlers = srv.hasHandler(\"typeAt\");\n    if (typeHandlers) {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < typeHandlers.length; i++)\n        type = typeHandlers[i](file, pos, expr, type);\n    }\n    if (!type) throw ternError(\"No type found at the given position.\");\n\n    var objProp;\n    if (expr.node.type == \"ObjectExpression\" && query.end != null &&\n        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {\n      var name = objProp.key.name;\n      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));\n      if (fromCx && fromCx.hasProp(name)) {\n        type = fromCx.hasProp(name);\n      } else {\n        var fromLocal = ensureObj(type);\n        if (fromLocal && fromLocal.hasProp(name))\n          type = fromLocal.hasProp(name);\n      }\n    }\n    return type;\n  }\n\n  function findTypeAtExpr(srv, query, file, expr) {\n    var exprName, exprType;\n    var type = findExprType(srv, query, file, expr), exprType = type;\n    if (query.preferFunction)\n      type = type.getFunctionType() || type.getType();\n    else\n      type = type.getType();\n\n    if (expr) {\n      if (expr.node.type == \"Identifier\")\n        exprName = expr.node.name;\n      else if (expr.node.type == \"MemberExpression\" && !expr.node.computed)\n        exprName = expr.node.property.name;\n      else if (expr.node.type == \"MethodDefinition\" && !expr.node.computed)\n        exprName = expr.node.key.name;\n    }\n\n    if (query.depth != null && typeof query.depth != \"number\")\n      throw ternError(\".query.depth must be a number\");\n\n    return [type, exprName, exprType];\n  }\n\n  function findTypeAt(srv, query, file) {\n    var type, exprName, exprType;\n    var expr = findExpr(file, query);\n    var typeResult = findTypeAtExpr(srv, query, file, expr);\n    type = typeResult[0];\n    if (!type) {\n      expr = findExprAround(file, query);\n      typeResult = findTypeAtExpr(srv, query, file, expr);\n      type = typeResult[0];\n    }\n    exprName = typeResult[1];\n    exprType = typeResult[2];\n\n    var result = {guess: infer.didGuess(),\n                  type: infer.toString(exprType, query.depth),\n                  name: type && type.name,\n                  exprName: exprName,\n                  doc: exprType.doc,\n                  url: exprType.url};\n    if (type) storeTypeDocs(query, type, result);\n\n    return clean(result);\n  }\n\n  function parseDoc(query, doc) {\n    if (!doc) return null;\n    if (query.docFormat == \"full\") return doc;\n    var parabreak = /.\\n[\\s@\\n]/.exec(doc);\n    if (parabreak) doc = doc.slice(0, parabreak.index + 1);\n    doc = doc.replace(/\\n\\s*/g, \" \");\n    if (doc.length < 100) return doc;\n    var sentenceEnd = /[\\.!?] [A-Z]/g;\n    sentenceEnd.lastIndex = 80;\n    var found = sentenceEnd.exec(doc);\n    if (found) doc = doc.slice(0, found.index + 1);\n    return doc;\n  }\n\n  function findDocs(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    var inner = type.getType();\n    if (!inner) {\n      expr = findExprAround(file, query);\n      type = findExprType(srv, query, file, expr);\n      inner = type.getType();\n    }\n    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};\n    if (inner) storeTypeDocs(query, inner, result);\n    return clean(result);\n  }\n\n  function storeTypeDocs(query, type, out) {\n    if (!out.url) out.url = type.url;\n    if (!out.doc) out.doc = parseDoc(query, type.doc);\n    if (!out.origin) out.origin = type.origin;\n    var ctor, boring = infer.cx().protos;\n    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&\n        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {\n      out.url = ctor.url;\n      out.doc = parseDoc(query, ctor.doc);\n    }\n  }\n\n  var getSpan = exports.getSpan = function(obj) {\n    if (!obj.origin) return;\n    if (obj.originNode) {\n      var node = obj.originNode;\n      if (/^Function/.test(node.type) && node.id) node = node.id;\n      return {origin: obj.origin, node: node};\n    }\n    if (obj.span) return {origin: obj.origin, span: obj.span};\n  };\n\n  var storeSpan = exports.storeSpan = function(srv, query, span, target) {\n    target.origin = span.origin;\n    if (span.span) {\n      var m = /^(\\d+)\\[(\\d+):(\\d+)\\]-(\\d+)\\[(\\d+):(\\d+)\\]$/.exec(span.span);\n      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);\n      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);\n    } else {\n      var file = srv.fileMap[span.origin];\n      target.start = outputPos(query, file, span.node.start);\n      target.end = outputPos(query, file, span.node.end);\n    }\n  };\n\n  function findDef(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    if (infer.didGuess()) return {};\n\n    var span = getSpan(type);\n    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};\n\n    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {\n      var tp = type.types[i];\n      storeTypeDocs(query, tp, result);\n      if (!span) span = getSpan(tp);\n    }\n\n    if (span && span.node) { // refers to a loaded file\n      var spanFile = span.node.sourceFile || srv.fileMap[span.origin];\n      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);\n      result.start = start; result.end = end;\n      result.file = span.origin;\n      var cxStart = Math.max(0, span.node.start - 50);\n      result.contextOffset = span.node.start - cxStart;\n      result.context = spanFile.text.slice(cxStart, cxStart + 50);\n    } else if (span) { // external\n      result.file = span.origin;\n      storeSpan(srv, query, span, result);\n    }\n    return clean(result);\n  }\n\n  function findRefsToVariable(srv, query, file, expr, isRename) {\n    var name = expr.node.name;\n\n    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}\n    if (!scope) throw ternError(\"Could not find a definition for \" + name);\n\n    var type, refs = [];\n    function storeRef(file) {\n      return function(node, scopeHere, ancestors) {\n        var value = {file: file.name,\n                     start: outputPos(query, file, node.start),\n                     end: outputPos(query, file, node.end)};\n        if (isRename) {\n          for (var s = scopeHere; s != scope; s = s.prev) {\n            var exists = s.hasProp(isRename);\n            if (exists)\n              throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would make a variable at line \" +\n                              (asLineChar(file, node.start).line + 1) + \" point to the definition at line \" +\n                              (asLineChar(file, exists.name.start).line + 1));\n          }\n          var parent = ancestors[ancestors.length - 2];\n          if (parent && parent.type == \"Property\" && parent.key == parent.value)\n            value.isShorthand = true;\n        }\n        refs.push(value);\n      };\n    }\n\n    if (scope.originNode) {\n      type = \"local\";\n      if (isRename) {\n        for (var prev = scope.prev; prev; prev = prev.prev)\n          if (isRename in prev.props) break;\n        if (prev) infer.findRefs(scope.originNode, scope, isRename, prev, function(node) {\n          throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would shadow the definition used at line \" +\n                          (asLineChar(file, node.start).line + 1));\n        });\n      }\n      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));\n    } else {\n      type = \"global\";\n      if (query.onlySourceFile) {\n        infer.findRefs(file.ast, file.scope, name, scope, storeRef(file));\n      } else {\n        for (var i = 0; i < srv.files.length; ++i) {\n          var cur = srv.files[i];\n          infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));\n        }\n      }\n    }\n\n    return {refs: refs, type: type, name: name};\n  }\n\n  function findRefsToProperty(srv, query, sourceFile, expr, prop) {\n    var exprType = infer.expressionType(expr);\n    if (expr.node.type == \"MethodDefinition\") {\n      exprType = exprType.propertyOf;\n    }\n    var objType = exprType.getObjType();\n    if (!objType) throw ternError(\"Couldn't determine type of base object.\");\n\n    var refs = [];\n    function storeRef(file) {\n      return function(node) {\n        refs.push({file: file.name,\n                   start: outputPos(query, file, node.start),\n                   end: outputPos(query, file, node.end)});\n      };\n    }\n\n    if (query.onlySourceFile) {\n        infer.findPropRefs(sourceFile.ast, sourceFile.scope, objType, prop.name, storeRef(sourceFile));\n    } else {\n      for (var i = 0; i < srv.files.length; ++i) {\n        var cur = srv.files[i];\n        infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));\n      }\n    }\n\n    return {refs: refs, name: prop.name};\n  }\n\n  function findRefs(srv, query, file) {\n    var expr = findExprOrThrow(file, query, true);\n    if (expr && expr.node.type == \"Identifier\") {\n      return findRefsToVariable(srv, query, file, expr);\n    } else if (expr && expr.node.type == \"MemberExpression\" && !expr.node.computed) {\n      var p = expr.node.property;\n      expr.node = expr.node.object;\n      return findRefsToProperty(srv, query, file, expr, p);\n    } else if (expr && expr.node.type == \"ObjectExpression\") {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < expr.node.properties.length; ++i) {\n        var k = expr.node.properties[i].key;\n        if (k.start <= pos && k.end >= pos)\n          return findRefsToProperty(srv, query, file, expr, k);\n      }\n    } else if (expr && expr.node.type == \"MethodDefinition\") {\n      var p = expr.node.key;\n      return findRefsToProperty(srv, query, file, expr, p);\n    }\n    throw ternError(\"Not at a variable or property name.\");\n  }\n\n  function buildRename(srv, query, file) {\n    if (typeof query.newName != \"string\") throw ternError(\".query.newName should be a string\");\n    var expr = findExprOrThrow(file, query);\n    if (!expr || expr.node.type != \"Identifier\") throw ternError(\"Not at a variable.\");\n\n    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;\n    delete data.refs;\n    data.files = srv.files.map(function(f){return f.name;});\n\n    var changes = data.changes = [];\n    for (var i = 0; i < refs.length; ++i) {\n      var use = refs[i];\n      if (use.isShorthand) use.text = expr.node.name + \": \" + query.newName;\n      else use.text = query.newName;\n      changes.push(use);\n    }\n\n    return data;\n  }\n\n  function listFiles(srv) {\n    return {files: srv.files.map(function(f){return f.name;})};\n  }\n\n  exports.version = \"0.24.3\";\n});\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/tern/lib/tern.js?");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn/dist/acorn.js":
/*!************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn/dist/acorn.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) { 'use strict';\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords$1 = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n\n  var types = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code, ecma2019String) {\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return hasOwnProperty.call(obj, propName)\n  }\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur)\n      }\n    }\n  }\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n    // (2019). This influences support for strict mode, the set of\n    // reserved words, and support for new syntax features. The default\n    // is 9.\n    ecmaVersion: 9,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion >= 2015)\n      { options.ecmaVersion -= 2009; }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      for (var v = options.ecmaVersion;; v--)\n        { if (reserved = reservedWords[v]) { break } }\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = {};\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  // Switch to a getter for 7.0.0.\n  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\n  pp.strictDirective = function(start) {\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") { return true }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp.isContextual = function(name) {\n    return this.type === types.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp.canInsertSemicolon = function() {\n    return this.type === types.eof ||\n      this.type === types.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp.semicolon = function() {\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  }\n\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n  };\n\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$1 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function(node) {\n    var exports = {};\n    if (!node.body) { node.body = []; }\n    while (this.type !== types.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$1.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91) { return true } // '['\n    if (context) { return false }\n\n    if (nextCh === 123) { return true } // '{'\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$1.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$1.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types._debugger: return this.parseDebuggerStatement(node)\n    case types._do: return this.parseDoStatement(node)\n    case types._for: return this.parseForStatement(node)\n    case types._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types._if: return this.parseIfStatement(node)\n    case types._return: return this.parseReturnStatement(node)\n    case types._switch: return this.parseSwitchStatement(node)\n    case types._throw: return this.parseThrowStatement(node)\n    case types._try: return this.parseTryStatement(node)\n    case types._const: case types._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types._while: return this.parseWhileStatement(node)\n    case types._with: return this.parseWithStatement(node)\n    case types.braceL: return this.parseBlock(true, node)\n    case types.semi: return this.parseEmptyStatement(node)\n    case types._export:\n    case types._import:\n      if (this.options.ecmaVersion > 10 && starttype === types._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40) // '('\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$1.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$1.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$1.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types.parenL);\n    if (this.type === types.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types._var || this.type === types._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types._in) {\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\n          } else { node.await = awaitAt > -1; }\n        }\n        return this.parseForIn(node, init$1)\n      }\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, init$1)\n    }\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLVal(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$1.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$1.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$1.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types.braceR;) {\n      if (this.type === types._case || this.type === types._default) {\n        var isCase = this.type === types._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$1.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types.parenL)) {\n        clause.param = this.parseBindingAtom();\n        var simple = clause.param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$1.parseVarStatement = function(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$1.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$1.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$1.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$1.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$1.parseBlock = function(createNewLexicalScope, node) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (!this.eat(types.braceR)) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$1.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.type === types.semi ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.type === types.parenR ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$1.parseForIn = function(node, init) {\n    var isForIn = this.type === types._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$1.parseVar = function(node, isFor, kind) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) { break }\n    }\n    return node\n  };\n\n  pp$1.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$1.parseFunctionParams = function(node) {\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        }\n      }\n    }\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$1.parseClassElement = function(constructorAllowsSuper) {\n    var this$1 = this;\n\n    if (this.eat(types.semi)) { return null }\n\n    var method = this.startNode();\n    var tryContextual = function (k, noLineBreak) {\n      if ( noLineBreak === void 0 ) noLineBreak = false;\n\n      var start = this$1.start, startLoc = this$1.startLoc;\n      if (!this$1.eatContextual(k)) { return false }\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n      if (method.key) { this$1.unexpected(); }\n      method.computed = false;\n      method.key = this$1.startNodeAt(start, startLoc);\n      method.key.name = k;\n      this$1.finishNode(method.key, \"Identifier\");\n      return false\n    };\n\n    method.kind = \"method\";\n    method.static = tryContextual(\"static\");\n    var isGenerator = this.eat(types.star);\n    var isAsync = false;\n    if (!isGenerator) {\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      } else if (tryContextual(\"get\")) {\n        method.kind = \"get\";\n      } else if (tryContextual(\"set\")) {\n        method.kind = \"set\";\n      }\n    }\n    if (!method.key) { this.parsePropertyName(method); }\n    var key = method.key;\n    var allowsDirectSuper = false;\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n        key.type === \"Literal\" && key.value === \"constructor\")) {\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n      method.kind = \"constructor\";\n      allowsDirectSuper = constructorAllowsSuper;\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n    if (method.kind === \"get\" && method.value.params.length !== 0)\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && method.value.params.length !== 1)\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n    return method\n  };\n\n  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$1.parseClassId = function(node, isStatement) {\n    if (this.type === types.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLVal(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$1.parseClassSuper = function(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  };\n\n  // Parses module export declaration.\n\n  pp$1.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types.star)) {\n      this.expectContextual(\"from\");\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(types._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n      } else if (this.type === types._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(null);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n        }\n\n        node.source = null;\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$1.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (has(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat.name, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n    else if (type === \"ParenthesizedExpression\")\n      { this.checkPatternExport(exports, pat.expression); }\n  };\n\n  pp$1.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$1.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$1.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node = this.startNode();\n      node.local = this.parseIdent(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n      this.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$1.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$1.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(types.comma)) { return nodes }\n    }\n    if (this.type === types.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes\n    }\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node$2 = this.startNode();\n      node$2.imported = this.parseIdent(true);\n      if (this.eatContextual(\"as\")) {\n        node$2.local = this.parseIdent();\n      } else {\n        this.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n      this.checkLVal(node$2.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$1.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$1.isDirectiveCandidate = function(statement) {\n    return (\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$2 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$2.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$2.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$2.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$2.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types.comma); }\n      if (allowEmpty && this.type === types.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n    return elts\n  };\n\n  pp$2.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // Verify that a node is an lval — something that can be assigned\n  // to.\n  // bindingType can be either:\n  // 'var' indicating that the lval creates a 'var' binding\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (checkClashes) {\n        if (has(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      break\n\n    case \"MemberExpression\":\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\n        {\n      var prop = list[i];\n\n      this.checkLVal(prop, bindingType, checkClashes);\n    }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n      }\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  // A recursive descent parser operates by defining functions for all\n\n  var pp$3 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n    if (this.type === types.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(noIn) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types.parenL || this.type === types.name)\n      { this.potentialArrowAt = this.start; }\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n    if (prec != null && (!noIn || this.type !== types._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n      }\n    }\n    return left\n  };\n\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLVal(node.argument); }\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(types.starstar))\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n    else\n      { return expr }\n  };\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    }\n    return result\n  };\n\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n      if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n      base = element;\n    }\n  };\n\n  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n    var computed = this.eat(types.bracketL);\n    if (computed || this.eat(types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n      node.computed = !!computed;\n      if (computed) { this.expect(types.bracketR); }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== \"Import\", false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      if (node$1.callee.type === \"Import\") {\n        if (node$1.arguments.length !== 1) {\n          this.raise(node$1.start, \"import() requires exactly one argument\");\n        }\n\n        var importArg = node$1.arguments[0];\n        if (importArg && importArg.type === \"SpreadElement\") {\n          this.raise(importArg.start, \"... is not allowed in import()\");\n        }\n      }\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types.backQuote) {\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super Arguments\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n        }\n      }\n      return id\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types.num: case types.string:\n      return this.parseLiteral(this.value)\n\n    case types._null: case types._true: case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types._new:\n      return this.parseNew()\n\n    case types.backQuote:\n      return this.parseTemplate()\n\n    case types._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport()\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseDynamicImport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.type !== types.parenL) {\n      this.unexpected();\n    }\n    return this.finishNode(node, \"Import\")\n  };\n\n  pp$3.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$3.parseParenExpression = function() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types.parenR) {\n        first ? first = false : this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\n      this.expect(types.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$3.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function() {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\" || containsEsc)\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n      if (!this.inNonArrowFunction())\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (this.options.ecmaVersion > 10 && node.callee.type === \"Import\") {\n      this.raise(node.callee.start, \"Cannot use new with import(...)\");\n    }\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== \"Import\", false); }\n    else { node.arguments = empty$1; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$3.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$3.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$3.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // To disallow parenthesized identifier via `this.toAssignable()`.\n      if (this.type === types.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types.comma && this.type !== types.braceR)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\")\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      prop.kind = \"init\";\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === types.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$3.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$3.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n    var isExpression = isArrowFunction && this.type !== types.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      node.body = this.parseBlock(false);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    this.strict = oldStrict;\n  };\n\n  pp$3.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$3.checkParams = function(node, allowDuplicates) {\n    var nameHash = {};\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types.comma)\n        { elt = null; }\n      else if (this.type === types.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$3.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$3.parseIdent = function(liberal, isBinding) {\n    var node = this.startNode();\n    if (this.type === types.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$3.parseYield = function(noIn) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$3.parseAwait = function() {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$5 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$5.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$5.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$5.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$5.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$5.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$5.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$5.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$5.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$6.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$6.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types$1 = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$7 = Parser.prototype;\n\n  pp$7.initialContext = function() {\n    return [types$1.b_stat]\n  };\n\n  pp$7.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\n      { return true }\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n      { return true }\n    if (prevType === types.braceL)\n      { return parent === types$1.b_stat }\n    if (prevType === types._var || prevType === types._const || prevType === types.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$7.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$7.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Token-specific context update code\n\n  types.parenR.updateContext = types.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types.dollarBraceL.updateContext = function() {\n    this.context.push(types$1.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types._function.updateContext = types._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n      { this.context.push(types$1.f_expr); }\n    else\n      { this.context.push(types$1.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types.backQuote.updateContext = function() {\n    if (this.curContext() === types$1.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types$1.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types.star.updateContext = function(prevType) {\n    if (prevType === types._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types$1.f_expr)\n        { this.context[index] = types$1.f_expr_gen; }\n      else\n        { this.context[index] = types$1.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // This file contains Unicode properties extracted from the ECMAScript\n  // specification. The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n  buildUnicodeData(9);\n  buildUnicodeData(10);\n  buildUnicodeData(11);\n\n  var pp$8 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i), next;\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current () {\n    return this.at(this.pos)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead () {\n    return this.at(this.nextIndex(this.pos))\n  };\n\n  RegExpValidationState.prototype.advance = function advance () {\n    this.pos = this.nextIndex(this.pos);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch) {\n    if (this.current() === ch) {\n      this.advance();\n      return true\n    }\n    return false\n  };\n\n  function codePointToString(ch) {\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n    ch -= 0x10000;\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n  }\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$8.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$8.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      this.regexp_alternative(state);\n    }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$8.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\n      { }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$8.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$8.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$8.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$8.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$8.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$8.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$8.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$8.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$8.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier[U] ::\n  //   [empty]\n  //   `?` GroupName[?U]\n  pp$8.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n        state.groupNames.push(state.lastStringValue);\n        return\n      }\n      state.raise(\"Invalid group\");\n    }\n  };\n\n  // GroupName[U] ::\n  //   `<` RegExpIdentifierName[?U] `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName[U] ::\n  //   RegExpIdentifierStart[?U]\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart[U] ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  pp$8.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart[U] ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$8.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$8.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$8.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$8.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$8.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$8.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$8.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        state.switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$8.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$8.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$8.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true\n    }\n\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      if (\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\n        state.eat(0x7D /* } */)\n      ) {\n        return true\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return false\n  };\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true\n    }\n    return false\n  };\n  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!has(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (!state.unicodeProperties.binary.test(nameOrValue))\n      { state.raise(\"Invalid property name\"); }\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$8.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$8.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      state.eat(0x5E /* ^ */);\n      this.regexp_classRanges(state);\n      if (state.eat(0x5D /* [ */)) {\n        return true\n      }\n      // Unreachable since it threw \"unterminated regular expression\" error before.\n      state.raise(\"Unterminated character class\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$8.regexp_classRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$8.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* [ */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$8.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$8.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$8.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$8.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$8.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp$9 = Parser.prototype;\n\n  // Move to the next token\n\n  pp$9.next = function() {\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$9.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp$9[Symbol.iterator] = function() {\n      var this$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1.getToken();\n          return {\n            done: token.type === types.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$9.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp$9.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp$9.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp$9.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00\n  };\n\n  pp$9.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this.curLine;\n        this.lineStart = match.index + match[0].length;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp$9.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp$9.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp$9.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp$9.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types.dot)\n    }\n  };\n\n  pp$9.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.slash, 1)\n  };\n\n  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types.star : types.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp$9.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n  };\n\n  pp$9.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.bitwiseXOR, 1)\n  };\n\n  pp$9.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.plusMin, 1)\n  };\n\n  pp$9.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n      return this.finishOp(types.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types.relational, size)\n  };\n\n  pp$9.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types.arrow)\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n  };\n\n  pp$9.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types.parenL)\n    case 41: ++this.pos; return this.finishToken(types.parenR)\n    case 59: ++this.pos; return this.finishToken(types.semi)\n    case 44: ++this.pos; return this.finishToken(types.comma)\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\n    case 123: ++this.pos; return this.finishToken(types.braceL)\n    case 125: ++this.pos; return this.finishToken(types.braceR)\n    case 58: ++this.pos; return this.finishToken(types.colon)\n    case 63: ++this.pos; return this.finishToken(types.question)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 126: // '~'\n      return this.finishOp(types.prefix, 1)\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n  };\n\n  pp$9.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp$9.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp$9.readInt = function(radix, len) {\n    var start = this.pos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      ++this.pos;\n      total = total * radix + val;\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  pp$9.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp$9.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var str$1 = this.input.slice(start, this.pos);\n      var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types.num, val$1)\n    }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var str = this.input.slice(start, this.pos);\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\n    return this.finishToken(types.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp$9.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  function codePointToString$1(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  pp$9.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else {\n        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp$9.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp$9.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp$9.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp$9.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break\n        }\n      // falls through\n\n      case \"`\":\n        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      // no default\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp$9.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp$9.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp$9.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString$1(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp$9.readWord = function() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n      type = keywords$1[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n  var version = \"6.4.2\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types,\n    keywordTypes: keywords$1,\n    TokContext: TokContext,\n    tokContexts: types$1,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords$1;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types$1;\n  exports.tokTypes = types;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/tern/node_modules/acorn/dist/acorn.js?");

/***/ }),

/***/ "./src/components lazy recursive ^\\.\\/.*\\/.*\\.js$":
/*!*******************************************************************************************************!*\
  !*** ./src/components/ lazy ^\.\/.*\/.*\.js$ chunkName: components/[request] strict namespace object ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./appui/appui.js\": [\n\t\t\"./src/components/appui/appui.js\",\n\t\t\"components/appui-appui-js\"\n\t],\n\t\"./audio/audio.js\": [\n\t\t\"./src/components/audio/audio.js\",\n\t\t\"components/audio-audio-js\"\n\t],\n\t\"./autocomplete/autocomplete.js\": [\n\t\t\"./src/components/autocomplete/autocomplete.js\",\n\t\t\"components/autocomplete-autocomplete-js\"\n\t],\n\t\"./big-search/big-search.js\": [\n\t\t\"./src/components/big-search/big-search.js\",\n\t\t\"components/big-search-big-search-js\"\n\t],\n\t\"./block-list/block-list.js\": [\n\t\t\"./src/components/block-list/block-list.js\",\n\t\t\"components/block-list-block-list-js\"\n\t],\n\t\"./breadcrumb/breadcrumb.js\": [\n\t\t\"./src/components/breadcrumb/breadcrumb.js\",\n\t\t\"components/breadcrumb-breadcrumb-js\"\n\t],\n\t\"./browser/browser.js\": [\n\t\t\"./src/components/browser/browser.js\",\n\t\t\"components/browser-browser-js\"\n\t],\n\t\"./button/button.js\": [\n\t\t\"./src/components/button/button.js\",\n\t\t\"components/button-button-js\"\n\t],\n\t\"./calendar/calendar.js\": [\n\t\t\"./src/components/calendar/calendar.js\",\n\t\t\"components/calendar-calendar-js\"\n\t],\n\t\"./chart/chart.js\": [\n\t\t\"./src/components/chart/chart.js\",\n\t\t\"vendors-node_modules_apexcharts_dist_apexcharts_common_js-node_modules_css-loader_dist_runtim-2e24e2\",\n\t\t\"components/chart-chart-js\"\n\t],\n\t\"./chat/chat.js\": [\n\t\t\"./src/components/chat/chat.js\",\n\t\t\"components/chat-chat-js\"\n\t],\n\t\"./checkbox/checkbox.js\": [\n\t\t\"./src/components/checkbox/checkbox.js\",\n\t\t\"components/checkbox-checkbox-js\"\n\t],\n\t\"./clipboard/clipboard.js\": [\n\t\t\"./src/components/clipboard/clipboard.js\",\n\t\t\"components/clipboard-clipboard-js\"\n\t],\n\t\"./cms-block/cms-block.js\": [\n\t\t\"./src/components/cms-block/cms-block.js\",\n\t\t\"components/cms-block-cms-block-js\"\n\t],\n\t\"./code/code.js\": [\n\t\t\"./src/components/code/code.js\",\n\t\t\"vendors-node_modules_css-loader_dist_runtime_api_js-node_modules_css-loader_dist_runtime_noSo-b5d34e\",\n\t\t\"components/code-code-js\"\n\t],\n\t\"./collapsable-columns/collapsable-columns.js\": [\n\t\t\"./src/components/collapsable-columns/collapsable-columns.js\",\n\t\t\"components/collapsable-columns-collapsable-columns-js\"\n\t],\n\t\"./colorpicker/colorpicker.js\": [\n\t\t\"./src/components/colorpicker/colorpicker.js\",\n\t\t\"vendors-node_modules_jaames_iro_dist_iro_es_js-node_modules_css-loader_dist_runtime_api_js-no-16b07e\",\n\t\t\"components/colorpicker-colorpicker-js\"\n\t],\n\t\"./column-list/column-list.js\": [\n\t\t\"./src/components/column-list/column-list.js\",\n\t\t\"components/column-list-column-list-js\"\n\t],\n\t\"./combo/combo.js\": [\n\t\t\"./src/components/combo/combo.js\",\n\t\t\"components/combo-combo-js\"\n\t],\n\t\"./container/_mixins/2change.js\": [\n\t\t\"./src/components/container/_mixins/2change.js\",\n\t\t\"components/container-_mixins-2change-js\"\n\t],\n\t\"./container/_mixins/component.js\": [\n\t\t\"./src/components/container/_mixins/component.js\",\n\t\t\"components/container-_mixins-component-js\"\n\t],\n\t\"./container/_mixins/core.js\": [\n\t\t\"./src/components/container/_mixins/core.js\",\n\t\t\"components/container-_mixins-core-js\"\n\t],\n\t\"./container/_mixins/display.js\": [\n\t\t\"./src/components/container/_mixins/display.js\",\n\t\t\"components/container-_mixins-display-js\"\n\t],\n\t\"./container/_mixins/menu.js\": [\n\t\t\"./src/components/container/_mixins/menu.js\",\n\t\t\"components/container-_mixins-menu-js\"\n\t],\n\t\"./container/_mixins/screenshot.js\": [\n\t\t\"./src/components/container/_mixins/screenshot.js\",\n\t\t\"components/container-_mixins-screenshot-js\"\n\t],\n\t\"./container/_mixins/selection.js\": [\n\t\t\"./src/components/container/_mixins/selection.js\",\n\t\t\"components/container-_mixins-selection-js\"\n\t],\n\t\"./container/_mixins/view.js\": [\n\t\t\"./src/components/container/_mixins/view.js\",\n\t\t\"components/container-_mixins-view-js\"\n\t],\n\t\"./container/_mixins/visual.js\": [\n\t\t\"./src/components/container/_mixins/visual.js\",\n\t\t\"components/container-_mixins-visual-js\"\n\t],\n\t\"./container/container.js\": [\n\t\t\"./src/components/container/container.js\",\n\t\t\"components/container-_mixins-view-js\",\n\t\t\"components/container-_mixins-selection-js\",\n\t\t\"components/container-container-js\"\n\t],\n\t\"./context/context.js\": [\n\t\t\"./src/components/context/context.js\",\n\t\t\"components/context-context-js\"\n\t],\n\t\"./countdown/countdown.js\": [\n\t\t\"./src/components/countdown/countdown.js\",\n\t\t\"components/countdown-countdown-js\"\n\t],\n\t\"./cursor/cursor.js\": [\n\t\t\"./src/components/cursor/cursor.js\",\n\t\t\"components/cursor-cursor-js\"\n\t],\n\t\"./dashboard/dashboard.js\": [\n\t\t\"./src/components/dashboard/dashboard.js\",\n\t\t\"components/dashboard-dashboard-js\"\n\t],\n\t\"./datepicker/datepicker.js\": [\n\t\t\"./src/components/datepicker/datepicker.js\",\n\t\t\"components/datepicker-datepicker-js\"\n\t],\n\t\"./datetimepicker/datetimepicker.js\": [\n\t\t\"./src/components/datetimepicker/datetimepicker.js\",\n\t\t\"components/datetimepicker-datetimepicker-js\"\n\t],\n\t\"./dropdown/dropdown.js\": [\n\t\t\"./src/components/dropdown/dropdown.js\",\n\t\t\"components/dropdown-dropdown-js\"\n\t],\n\t\"./editable-content/editable-content.js\": [\n\t\t\"./src/components/editable-content/editable-content.js\",\n\t\t\"components/editable-content-editable-content-js\"\n\t],\n\t\"./editable/editable.js\": [\n\t\t\"./src/components/editable/editable.js\",\n\t\t\"components/editable-editable-js\"\n\t],\n\t\"./emoji/emoji.js\": [\n\t\t\"./src/components/emoji/emoji.js\",\n\t\t\"components/emoji-emoji-js\"\n\t],\n\t\"./field/field.js\": [\n\t\t\"./src/components/field/field.js\",\n\t\t\"components/field-field-js\"\n\t],\n\t\"./file/file.js\": [\n\t\t\"./src/components/file/file.js\",\n\t\t\"vendors-node_modules_css-loader_dist_runtime_api_js-node_modules_css-loader_dist_runtime_noSo-1a83d8\",\n\t\t\"components/file-file-js\"\n\t],\n\t\"./filter/filter.js\": [\n\t\t\"./src/components/filter/filter.js\",\n\t\t\"components/filter-filter-js\"\n\t],\n\t\"./finder/finder.js\": [\n\t\t\"./src/components/finder/finder.js\",\n\t\t\"components/finder-finder-js\"\n\t],\n\t\"./fisheye/fisheye.js\": [\n\t\t\"./src/components/fisheye/fisheye.js\",\n\t\t\"components/fisheye-fisheye-js\"\n\t],\n\t\"./flag/flag.js\": [\n\t\t\"./src/components/flag/flag.js\",\n\t\t\"vendors-node_modules_flag-icons_css_flag-icons_css\",\n\t\t\"components/flag-flag-js\"\n\t],\n\t\"./floater/floater.js\": [\n\t\t\"./src/components/floater/floater.js\",\n\t\t\"components/floater-floater-js\"\n\t],\n\t\"./form/form.js\": [\n\t\t\"./src/components/form/form.js\",\n\t\t\"components/form-form-js\"\n\t],\n\t\"./frame/frame.js\": [\n\t\t\"./src/components/frame/frame.js\",\n\t\t\"components/frame-frame-js\"\n\t],\n\t\"./gallery/gallery.js\": [\n\t\t\"./src/components/gallery/gallery.js\",\n\t\t\"components/gallery-gallery-js\"\n\t],\n\t\"./grid-configuration/grid-configuration.js\": [\n\t\t\"./src/components/grid-configuration/grid-configuration.js\",\n\t\t\"components/grid-configuration-grid-configuration-js\"\n\t],\n\t\"./icon-svg/icon-svg.js\": [\n\t\t\"./src/components/icon-svg/icon-svg.js\",\n\t\t\"components/icon-svg-icon-svg-js\"\n\t],\n\t\"./icon/icon.js\": [\n\t\t\"./src/components/icon/icon.js\",\n\t\t\"components/icon-icon-js\"\n\t],\n\t\"./image-editor/image-editor.js\": [\n\t\t\"./src/components/image-editor/image-editor.js\",\n\t\t\"vendors-node_modules_css-loader_dist_runtime_api_js-node_modules_css-loader_dist_runtime_noSo-844d74\",\n\t\t\"components/image-editor-image-editor-js\"\n\t],\n\t\"./initial/initial.js\": [\n\t\t\"./src/components/initial/initial.js\",\n\t\t\"components/initial-initial-js\"\n\t],\n\t\"./inline-editor/inline-editor.js\": [\n\t\t\"./src/components/inline-editor/inline-editor.js\",\n\t\t\"components/inline-editor-inline-editor-js\"\n\t],\n\t\"./input/input.js\": [\n\t\t\"./src/components/input/input.js\",\n\t\t\"components/input-input-js\"\n\t],\n\t\"./json-editor/json-editor.js\": [\n\t\t\"./src/components/json-editor/json-editor.js\",\n\t\t\"vendors-node_modules_jsoneditor_dist_jsoneditor_min_js-node_modules_jsoneditor_dist_jsoneditor_css\",\n\t\t\"components/json-editor-json-editor-js\"\n\t],\n\t\"./key/key.js\": [\n\t\t\"./src/components/key/key.js\",\n\t\t\"components/key-key-js\"\n\t],\n\t\"./keyboard/keyboard.js\": [\n\t\t\"./src/components/keyboard/keyboard.js\",\n\t\t\"components/keyboard-keyboard-js\"\n\t],\n\t\"./keyvalue/keyvalue.js\": [\n\t\t\"./src/components/keyvalue/keyvalue.js\",\n\t\t\"components/keyvalue-keyvalue-js\"\n\t],\n\t\"./list-input/list-input.js\": [\n\t\t\"./src/components/list-input/list-input.js\",\n\t\t\"components/list-input-list-input-js\"\n\t],\n\t\"./list/list.js\": [\n\t\t\"./src/components/list/list.js\",\n\t\t\"components/list-list-js\"\n\t],\n\t\"./loadbar/loadbar.js\": [\n\t\t\"./src/components/loadbar/loadbar.js\",\n\t\t\"components/loadbar-loadbar-js\"\n\t],\n\t\"./loader/loader.js\": [\n\t\t\"./src/components/loader/loader.js\",\n\t\t\"components/loader-loader-js\"\n\t],\n\t\"./loadicon/loadicon.js\": [\n\t\t\"./src/components/loadicon/loadicon.js\",\n\t\t\"components/loadicon-loadicon-js\"\n\t],\n\t\"./login/login.js\": [\n\t\t\"./src/components/login/login.js\",\n\t\t\"components/login-login-js\"\n\t],\n\t\"./map/map.js\": [\n\t\t\"./src/components/map/map.js\",\n\t\t\"components/map-map-js\"\n\t],\n\t\"./markdown/markdown.js\": [\n\t\t\"./src/components/markdown/markdown.js\",\n\t\t\"vendors-node_modules_easymde_src_js_easymde_js-node_modules_easymde_dist_easymde_min_css-node-db0a62\",\n\t\t\"components/markdown-markdown-js\"\n\t],\n\t\"./masked/masked.js\": [\n\t\t\"./src/components/masked/masked.js\",\n\t\t\"components/masked-masked-js\"\n\t],\n\t\"./masonry/masonry.js\": [\n\t\t\"./src/components/masonry/masonry.js\",\n\t\t\"components/masonry-masonry-js\"\n\t],\n\t\"./menu/menu.js\": [\n\t\t\"./src/components/menu/menu.js\",\n\t\t\"components/menu-menu-js\"\n\t],\n\t\"./message/message.js\": [\n\t\t\"./src/components/message/message.js\",\n\t\t\"components/message-message-js\"\n\t],\n\t\"./mini-search/mini-search.js\": [\n\t\t\"./src/components/mini-search/mini-search.js\",\n\t\t\"components/mini-search-mini-search-js\"\n\t],\n\t\"./multi-input/multi-input.js\": [\n\t\t\"./src/components/multi-input/multi-input.js\",\n\t\t\"components/multi-input-multi-input-js\"\n\t],\n\t\"./multipart/multipart.js\": [\n\t\t\"./src/components/multipart/multipart.js\",\n\t\t\"components/multipart-multipart-js\"\n\t],\n\t\"./multiselect/multiselect.js\": [\n\t\t\"./src/components/multiselect/multiselect.js\",\n\t\t\"components/multiselect-multiselect-js\"\n\t],\n\t\"./notification/notification.js\": [\n\t\t\"./src/components/notification/notification.js\",\n\t\t\"components/notification-notification-js\"\n\t],\n\t\"./numeric/numeric.js\": [\n\t\t\"./src/components/numeric/numeric.js\",\n\t\t\"components/numeric-numeric-js\"\n\t],\n\t\"./pager/pager.js\": [\n\t\t\"./src/components/pager/pager.js\",\n\t\t\"components/pager-pager-js\"\n\t],\n\t\"./pane/pane.js\": [\n\t\t\"./src/components/pane/pane.js\",\n\t\t\"components/pane-pane-js\"\n\t],\n\t\"./panelbar/panelbar.js\": [\n\t\t\"./src/components/panelbar/panelbar.js\",\n\t\t\"components/panelbar-panelbar-js\"\n\t],\n\t\"./popup/popup.js\": [\n\t\t\"./src/components/popup/popup.js\",\n\t\t\"components/popup-popup-js\"\n\t],\n\t\"./progressbar/progressbar.js\": [\n\t\t\"./src/components/progressbar/progressbar.js\",\n\t\t\"components/progressbar-progressbar-js\"\n\t],\n\t\"./radio/radio.js\": [\n\t\t\"./src/components/radio/radio.js\",\n\t\t\"components/radio-radio-js\"\n\t],\n\t\"./radiobuttons/radiobuttons.js\": [\n\t\t\"./src/components/radiobuttons/radiobuttons.js\",\n\t\t\"components/radiobuttons-radiobuttons-js\"\n\t],\n\t\"./range/range.js\": [\n\t\t\"./src/components/range/range.js\",\n\t\t\"components/range-range-js\"\n\t],\n\t\"./router-config/router-config.js\": [\n\t\t\"./src/components/router-config/router-config.js\",\n\t\t\"components/router-config-router-config-js\"\n\t],\n\t\"./router-group/router-group.js\": [\n\t\t\"./src/components/router-group/router-group.js\",\n\t\t\"components/router-group-router-group-js\"\n\t],\n\t\"./router/_components/listItem.js\": [\n\t\t\"./src/components/router/_components/listItem.js\",\n\t\t\"components/router-_components-listItem-js\"\n\t],\n\t\"./router/_components/searchResult.js\": [\n\t\t\"./src/components/router/_components/searchResult.js\",\n\t\t\"components/router-_components-searchResult-js\"\n\t],\n\t\"./router/_mixins/2move.js\": [\n\t\t\"./src/components/router/_mixins/2move.js\",\n\t\t\"components/router-_mixins-2move-js\"\n\t],\n\t\"./router/_mixins/breadcrumb.js\": [\n\t\t\"./src/components/router/_mixins/breadcrumb.js\",\n\t\t\"components/router-_mixins-breadcrumb-js\"\n\t],\n\t\"./router/_mixins/component.js\": [\n\t\t\"./src/components/router/_mixins/component.js\",\n\t\t\"components/router-_mixins-component-js\"\n\t],\n\t\"./router/_mixins/config.js\": [\n\t\t\"./src/components/router/_mixins/config.js\",\n\t\t\"components/router-_mixins-config-js\"\n\t],\n\t\"./router/_mixins/elements.js\": [\n\t\t\"./src/components/router/_mixins/elements.js\",\n\t\t\"components/router-_mixins-elements-js\"\n\t],\n\t\"./router/_mixins/getters.js\": [\n\t\t\"./src/components/router/_mixins/getters.js\",\n\t\t\"components/router-_mixins-getters-js\"\n\t],\n\t\"./router/_mixins/menu.js\": [\n\t\t\"./src/components/router/_mixins/menu.js\",\n\t\t\"components/router-_mixins-menu-js\"\n\t],\n\t\"./router/_mixins/misc.js\": [\n\t\t\"./src/components/router/_mixins/misc.js\",\n\t\t\"components/router-_mixins-misc-js\"\n\t],\n\t\"./router/_mixins/navigation.js\": [\n\t\t\"./src/components/router/_mixins/navigation.js\",\n\t\t\"components/router-_mixins-navigation-js\"\n\t],\n\t\"./router/_mixins/observers.js\": [\n\t\t\"./src/components/router/_mixins/observers.js\",\n\t\t\"components/router-_mixins-observers-js\"\n\t],\n\t\"./router/_mixins/panes.js\": [\n\t\t\"./src/components/router/_mixins/panes.js\",\n\t\t\"components/router-_mixins-panes-js\"\n\t],\n\t\"./router/_mixins/registration.js\": [\n\t\t\"./src/components/router/_mixins/registration.js\",\n\t\t\"components/router-_mixins-registration-js\"\n\t],\n\t\"./router/_mixins/search.js\": [\n\t\t\"./src/components/router/_mixins/search.js\",\n\t\t\"components/router-_mixins-search-js\"\n\t],\n\t\"./router/_mixins/views.js\": [\n\t\t\"./src/components/router/_mixins/views.js\",\n\t\t\"components/router-_mixins-views-js\"\n\t],\n\t\"./router/_mixins/visual.js\": [\n\t\t\"./src/components/router/_mixins/visual.js\",\n\t\t\"components/router-_mixins-visual-js\"\n\t],\n\t\"./router/router copy.js\": [\n\t\t\"./src/components/router/router copy.js\",\n\t\t\"src_components_router_router_html-src_components_router_router_less-src_components_router__i1-5fa7f0\",\n\t\t\"components/router-router-copy-js\"\n\t],\n\t\"./router/router.js\": [\n\t\t\"./src/components/router/router.js\",\n\t\t\"src_components_router_router_html-src_components_router_router_less-src_components_router__i1-5fa7f0\",\n\t\t\"components/router-_mixins-navigation-js\",\n\t\t\"components/router-_mixins-views-js\",\n\t\t\"components/router-_mixins-menu-js\",\n\t\t\"components/router-router-js\"\n\t],\n\t\"./rte/rte.js\": [\n\t\t\"./src/components/rte/rte.js\",\n\t\t\"components/rte-rte-js\"\n\t],\n\t\"./scroll/scroll.js\": [\n\t\t\"./src/components/scroll/scroll.js\",\n\t\t\"components/scroll-scroll-js\"\n\t],\n\t\"./scrollbar/scrollbar.js\": [\n\t\t\"./src/components/scrollbar/scrollbar.js\",\n\t\t\"components/scrollbar-scrollbar-js\"\n\t],\n\t\"./search/search.js\": [\n\t\t\"./src/components/search/search.js\",\n\t\t\"components/search-search-js\"\n\t],\n\t\"./slider-menu/slider-menu.js\": [\n\t\t\"./src/components/slider-menu/slider-menu.js\",\n\t\t\"components/slider-menu-slider-menu-js\"\n\t],\n\t\"./slider/slider.js\": [\n\t\t\"./src/components/slider/slider.js\",\n\t\t\"components/slider-slider-js\"\n\t],\n\t\"./slideshow/slideshow.js\": [\n\t\t\"./src/components/slideshow/slideshow.js\",\n\t\t\"components/slideshow-slideshow-js\"\n\t],\n\t\"./splashscreen/splashscreen.js\": [\n\t\t\"./src/components/splashscreen/splashscreen.js\",\n\t\t\"components/splashscreen-splashscreen-js\"\n\t],\n\t\"./split-tabs/split-tabs.js\": [\n\t\t\"./src/components/split-tabs/split-tabs.js\",\n\t\t\"components/split-tabs-split-tabs-js\"\n\t],\n\t\"./splitter/splitter.js\": [\n\t\t\"./src/components/splitter/splitter.js\",\n\t\t\"components/splitter-splitter-js\"\n\t],\n\t\"./stack/stack.js\": [\n\t\t\"./src/components/stack/stack.js\",\n\t\t\"components/stack-stack-js\"\n\t],\n\t\"./switch/switch.js\": [\n\t\t\"./src/components/switch/switch.js\",\n\t\t\"components/switch-switch-js\"\n\t],\n\t\"./table/table.js\": [\n\t\t\"./src/components/table/table.js\",\n\t\t\"components/table-table-js\"\n\t],\n\t\"./tabs/tabs.js\": [\n\t\t\"./src/components/tabs/tabs.js\",\n\t\t\"components/tabs-tabs-js\"\n\t],\n\t\"./terminal/terminal.js\": [\n\t\t\"./src/components/terminal/terminal.js\",\n\t\t\"components/terminal-terminal-js\"\n\t],\n\t\"./textarea/textarea.js\": [\n\t\t\"./src/components/textarea/textarea.js\",\n\t\t\"components/textarea-textarea-js\"\n\t],\n\t\"./timepicker/timepicker.js\": [\n\t\t\"./src/components/timepicker/timepicker.js\",\n\t\t\"components/timepicker-timepicker-js\"\n\t],\n\t\"./timer/timer.js\": [\n\t\t\"./src/components/timer/timer.js\",\n\t\t\"components/timer-timer-js\"\n\t],\n\t\"./timewheel/timewheel.js\": [\n\t\t\"./src/components/timewheel/timewheel.js\",\n\t\t\"components/timewheel-timewheel-js\"\n\t],\n\t\"./toolbar/toolbar.js\": [\n\t\t\"./src/components/toolbar/toolbar.js\",\n\t\t\"components/toolbar-toolbar-js\"\n\t],\n\t\"./tooltip/tooltip.js\": [\n\t\t\"./src/components/tooltip/tooltip.js\",\n\t\t\"components/tooltip-tooltip-js\"\n\t],\n\t\"./tracks/tracks.js\": [\n\t\t\"./src/components/tracks/tracks.js\",\n\t\t\"components/tracks-tracks-js\"\n\t],\n\t\"./tree-input/tree-input.js\": [\n\t\t\"./src/components/tree-input/tree-input.js\",\n\t\t\"components/tree-input-tree-input-js\"\n\t],\n\t\"./tree/tree.js\": [\n\t\t\"./src/components/tree/tree.js\",\n\t\t\"components/tree-tree-js\"\n\t],\n\t\"./treedown/treedown.js\": [\n\t\t\"./src/components/treedown/treedown.js\",\n\t\t\"components/treedown-treedown-js\"\n\t],\n\t\"./treemenu/treemenu.js\": [\n\t\t\"./src/components/treemenu/treemenu.js\",\n\t\t\"components/treemenu-treemenu-js\"\n\t],\n\t\"./upload/upload.js\": [\n\t\t\"./src/components/upload/upload.js\",\n\t\t\"components/upload-upload-js\"\n\t],\n\t\"./values/values.js\": [\n\t\t\"./src/components/values/values.js\",\n\t\t\"components/values-values-js\"\n\t],\n\t\"./video/video.js\": [\n\t\t\"./src/components/video/video.js\",\n\t\t\"components/video-video-js\"\n\t],\n\t\"./vlist/vlist.js\": [\n\t\t\"./src/components/vlist/vlist.js\",\n\t\t\"components/vlist-vlist-js\"\n\t],\n\t\"./wheel/wheel.js\": [\n\t\t\"./src/components/wheel/wheel.js\",\n\t\t\"components/wheel-wheel-js\"\n\t],\n\t\"./widget/widget.js\": [\n\t\t\"./src/components/widget/widget.js\",\n\t\t\"components/widget-widget-js\"\n\t],\n\t\"./window/window.js\": [\n\t\t\"./src/components/window/window.js\",\n\t\t\"components/window-window-js\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./src/components lazy recursive ^\\\\.\\\\/.*\\\\/.*\\\\.js$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/components/_lazy_^\\.\\/.*\\/.*\\.js$_chunkName:_components/%5Brequest%5D_strict_namespace_object?");

/***/ }),

/***/ "./node_modules/@bbn/bbn/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@bbn/bbn/dist/index.js + 280 modules ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  axios: () => (/* reexport */ lib_axios),\n  bbn: () => (/* binding */ dist_bbn),\n  dayjs: () => (/* reexport */ dayjs_min),\n  \"default\": () => (/* binding */ dist_bbn)\n});\n\n// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js\nvar common_utils_namespaceObject = {};\n__webpack_require__.r(common_utils_namespaceObject);\n__webpack_require__.d(common_utils_namespaceObject, {\n  hasBrowserEnv: () => (hasBrowserEnv),\n  hasStandardBrowserEnv: () => (hasStandardBrowserEnv),\n  hasStandardBrowserWebWorkerEnv: () => (hasStandardBrowserWebWorkerEnv),\n  origin: () => (origin)\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js\n\n\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString: utils_toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = utils_toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n}\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n}\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0]\n  }\n\n  return str;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n/* harmony default export */ const utils = ({\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty: utils_hasOwnProperty,\n  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nconst AxiosError_prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(AxiosError_prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n/* harmony default export */ const core_AxiosError = (AxiosError);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js\n// eslint-disable-next-line strict\n/* harmony default export */ const helpers_null = (null);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js\n\n\n\n\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (helpers_null || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/* harmony default export */ const helpers_toFormData = (toFormData);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && helpers_toFormData(params, this, options);\n}\n\nconst AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;\n\nAxiosURLSearchParams_prototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nAxiosURLSearchParams_prototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction buildURL_encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || buildURL_encode;\n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new helpers_AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js\n\n\n\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\n/* harmony default export */ const core_InterceptorManager = (InterceptorManager);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js\n\n\n/* harmony default export */ const defaults_transitional = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\n\n\n\n/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js\n\n\n/* harmony default export */ const classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/Blob.js\n\n\n/* harmony default export */ const classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js\n\n\n\n\n/* harmony default export */ const browser = ({\n  isBrowser: true,\n  classes: {\n    URLSearchParams: classes_URLSearchParams,\n    FormData: classes_FormData,\n    Blob: classes_Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/common/utils.js\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = (\n  (product) => {\n    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0\n  })(typeof navigator !== 'undefined' && navigator.product);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/index.js\n\n\n\n/* harmony default export */ const platform = ({\n  ...common_utils_namespaceObject,\n  ...browser\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js\n\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js\n\n\n\n\n\n\n\n\n\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: defaults_transitional,\n\n  adapter: ['xhr', 'http'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return helpers_toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\n/* harmony default export */ const lib_defaults = (defaults);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const parseHeaders = (rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js\n\n\n\n\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\n/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || lib_defaults;\n  const context = response || config;\n  const headers = core_AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, core_AxiosError, {\n  __CANCEL__: true\n});\n\n/* harmony default export */ const cancel_CanceledError = (CanceledError);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new core_AxiosError(\n      'Request failed with status code ' + response.status,\n      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js\n\n\n\n/* harmony default export */ const cookies = (platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils.isString(path) && cookie.push('path=' + path);\n\n      utils.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  });\n\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n\n\n\n\n\n/* harmony default export */ const isURLSameOrigin = (platform.hasStandardBrowserEnv ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    const msie = /(msie|trident)/i.test(navigator.userAgent);\n    const urlParsingNode = document.createElement('a');\n    let originURL;\n\n    /**\n    * Parse a URL to discover its components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      let href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n          urlParsingNode.pathname :\n          '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n          parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })());\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js\n\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/* harmony default export */ const helpers_speedometer = (speedometer);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  let bytesNotified = 0;\n  const _speedometer = helpers_speedometer(50, 250);\n\n  return e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e\n    };\n\n    data[isDownloadStream ? 'download' : 'upload'] = true;\n\n    listener(data);\n  };\n}\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\n/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    let requestData = config.data;\n    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();\n    let {responseType, withXSRFToken} = config;\n    let onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    let contentType;\n\n    if (utils.isFormData(requestData)) {\n      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n        requestHeaders.setContentType(false); // Let the browser set it\n      } else if ((contentType = requestHeaders.getContentType()) !== false) {\n        // fix semicolon duplication issue for ReactNative FormData implementation\n        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));\n    }\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = core_AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = config.transitional || defaults_transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new core_AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if(platform.hasStandardBrowserEnv) {\n      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n\n      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {\n        // Add xsrf header\n        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n\n        if (xsrfValue) {\n          requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n        }\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(fullPath);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js\n\n\n\n\n\nconst knownAdapters = {\n  http: helpers_null,\n  xhr: xhr\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\n/* harmony default export */ const adapters = ({\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new core_AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new core_AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js\n\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new cancel_CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = core_AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = core_AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js\n\n\n\n\n\nconst headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)\n  };\n\n  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js\nconst VERSION = \"1.6.8\";\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js\n\n\n\n\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new core_AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        core_AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\n/* harmony default export */ const validator = ({\n  assertOptions,\n  validators\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js\n\n\n\n\n\n\n\n\n\n\n\nconst Axios_validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new core_InterceptorManager(),\n      response: new core_InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy;\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n\n        if (!err.stack) {\n          err.stack = stack;\n          // match without the 2 top stack lines\n        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n          err.stack += '\\n' + stack\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: Axios_validators.function,\n          serialize: Axios_validators.function\n        }, true);\n      }\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\n/* harmony default export */ const core_Axios = (Axios);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js\n\n\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new cancel_CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\n/* harmony default export */ const cancel_CancelToken = (CancelToken);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\n/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new core_Axios(defaultConfig);\n  const instance = bind(core_Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios_axios = createInstance(lib_defaults);\n\n// Expose Axios class to allow class inheritance\naxios_axios.Axios = core_Axios;\n\n// Expose Cancel & CancelToken\naxios_axios.CanceledError = cancel_CanceledError;\naxios_axios.CancelToken = cancel_CancelToken;\naxios_axios.isCancel = isCancel;\naxios_axios.VERSION = VERSION;\naxios_axios.toFormData = helpers_toFormData;\n\n// Expose AxiosError class\naxios_axios.AxiosError = core_AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios_axios.Cancel = axios_axios.CanceledError;\n\n// Expose all/spread\naxios_axios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios_axios.spread = spread;\n\n// Expose isAxiosError\naxios_axios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios_axios.mergeConfig = mergeConfig;\n\naxios_axios.AxiosHeaders = core_AxiosHeaders;\n\naxios_axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios_axios.getAdapter = adapters.getAdapter;\n\naxios_axios.HttpStatusCode = helpers_HttpStatusCode;\n\naxios_axios.default = axios_axios;\n\n// this module should only have a default export\n/* harmony default export */ const lib_axios = (axios_axios);\n\n// EXTERNAL MODULE: ./node_modules/dayjs/dayjs.min.js\nvar dayjs_min = __webpack_require__(\"./node_modules/dayjs/dayjs.min.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/calendar.js\nvar calendar = __webpack_require__(\"./node_modules/dayjs/plugin/calendar.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/dayOfYear.js\nvar dayOfYear = __webpack_require__(\"./node_modules/dayjs/plugin/dayOfYear.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/duration.js\nvar duration = __webpack_require__(\"./node_modules/dayjs/plugin/duration.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/isBetween.js\nvar isBetween = __webpack_require__(\"./node_modules/dayjs/plugin/isBetween.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/isLeapYear.js\nvar isLeapYear = __webpack_require__(\"./node_modules/dayjs/plugin/isLeapYear.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/isoWeek.js\nvar isoWeek = __webpack_require__(\"./node_modules/dayjs/plugin/isoWeek.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/localeData.js\nvar localeData = __webpack_require__(\"./node_modules/dayjs/plugin/localeData.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/localizedFormat.js\nvar localizedFormat = __webpack_require__(\"./node_modules/dayjs/plugin/localizedFormat.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/minMax.js\nvar minMax = __webpack_require__(\"./node_modules/dayjs/plugin/minMax.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/quarterOfYear.js\nvar quarterOfYear = __webpack_require__(\"./node_modules/dayjs/plugin/quarterOfYear.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/relativeTime.js\nvar relativeTime = __webpack_require__(\"./node_modules/dayjs/plugin/relativeTime.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/timezone.js\nvar timezone = __webpack_require__(\"./node_modules/dayjs/plugin/timezone.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/updateLocale.js\nvar updateLocale = __webpack_require__(\"./node_modules/dayjs/plugin/updateLocale.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/utc.js\nvar utc = __webpack_require__(\"./node_modules/dayjs/plugin/utc.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/weekday.js\nvar weekday = __webpack_require__(\"./node_modules/dayjs/plugin/weekday.js\");\n// EXTERNAL MODULE: ./node_modules/dayjs/plugin/weekOfYear.js\nvar weekOfYear = __webpack_require__(\"./node_modules/dayjs/plugin/weekOfYear.js\");\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isArray.js\n/**\n * Returns true if the given argument is array.\n * @method   isArray\n * @global\n * @example\n * ```javascript\n * bbn.fn.isArray([5,2,6]);\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isArray_isArray() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!Array.isArray(a)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isNumber.js\n/**\n * Returns true if the given argument is a number\n * @method   isNumber\n * @global\n * @example\n * ```javascript\n * bbn.fn.isNumber(5);\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isNumber(0.5);\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isNumber_isNumber() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ([\"boolean\", \"object\", \"symbol\"].includes(typeof a) ||\n            a === \"\" ||\n            isNaN(a)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isIterable.js\n/**\n * Returns true if the given object can be iterated as an array (numerically).\n *\n * It is possible to pass as argument a string with hexadecimal value in rgb or the name of the color.\n *\n * @method   isIterable\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.isIterable([1, 2])\n * // true\n * bbn.fn.isIterable({a: 1, b: 2})\n * // false\n * bbn.fn.isIterable(25)\n * // false\n * bbn.fn.isIterable(document.body.querySelectorAll('.container > div'))\n * // true\n * ```\n *\n * @param    {String} st\n *\n * @returns  {Boolean}\n */\nfunction isIterable() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length) {\n        return false;\n    }\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!a ||\n            (typeof a !== \"object\") ||\n            !(Symbol.iterator in Object(a))) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isString.js\n/**\n * Returns true if the given argument is a string;\n * @method   isString\n * @global\n * @example\n * ```javascript\n * bbn.fn.isString('bbn');\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isString_isString() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object String]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isInt.js\n/**\n * Returns true if the given argument is an integer\n * @method   isInt\n * @global\n * @example\n * ```javascript\n * bbn.fn.isInt(5);\n * // true\n * bbn.fn.isInt(0.5);\n * // false\n * bbn.fn.isInt(\"hello\");\n * // false\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isInt() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!Number.isInteger(a)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isFunction.js\n/**\n * Returns true if the given argument is a function.\n * @global\n * @example\n * ```javascript\n * bbn.fn.isFunction(() => {\n *  alert('Hello world');\n * });\n * //true\n * ```\n * @method   isFunction\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isFunction_isFunction() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var obj = args_1[_a];\n        if (!(obj && obj.constructor && obj.call && obj.apply)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/log.js\n\n/**\n * Logs the given arguments in the browser's console.\n * @method   log\n * @global\n * @example\n * ```javascript\n * //'hello'\n * bbn.fn.log('hello');\n * ```\n * @memberof bbn.fn\n * @param    {...any} args\n * @returns\n */\nfunction log() {\n    var _a, _b;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (window.console !== undefined) {\n        var cfg = void 0;\n        var level = 5;\n        var fn = 'log';\n        if (args[0] && typeof args[0] === 'object' && args[0]._bbn_console_style) {\n            if (args[0]._bbn_console_mode && isFunction_isFunction(console[args[0]._bbn_console_mode])) {\n                fn = args[0]._bbn_console_mode;\n            }\n            else {\n                cfg = args[0]._bbn_console_style;\n                level = args[0]._bbn_console_level;\n            }\n            args.shift();\n        }\n        var exec = window.console[fn];\n        if (((_b = (_a = window['bbn']) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.loggingLevel) >= level) {\n            var i = 0;\n            while (i < args.length) {\n                var t = typeof args[i];\n                var consoleArguments = [args[i]];\n                if (t === 'string' || t === 'number') {\n                    consoleArguments.unshift('%c %s ', cfg);\n                }\n                exec.apply(window.console, consoleArguments);\n                i++;\n            }\n        }\n    }\n    return this;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/substr.js\n\n\n\n/**\n * Basic substring function accepting both positive and negative values.\n *\n * @method   substr\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.substr(bbn.fn, 'Hello', -3, -1);\n * // \"ll\"\n * bbn.fn.substr(bbn.fn, 'Hello', -3);\n * // \"llo\"\n * bbn.fn.substr(bbn.fn, 'Hello', 0, 1);\n * // \"H\"\n * ```\n * @memberof bbn.fn\n * @param    {String} str\n * @param    {Number} from\n * @param    {Number} length\n * @returns  {String} Result substring\n */\nfunction substr(str, from, length) {\n    if (!isString_isString(str) || !isInt(from)) {\n        log(arguments);\n        throw new Error(bbn._(\"The substr function should be applied to a string and at least a `from` argument should be given\"));\n    }\n    if (from < 0) {\n        from = str.length + from;\n    }\n    if (!isInt(length)) {\n        return str.substring(from);\n    }\n    return str.substring(from, (length < 0 ? str.length : from) + length);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/removePrivateProp.js\n\n/**\n  * Returns an object with the original objects' properties starting with an alphanumeric character.\n  *\n  * It is presumed that external libraries, bbn variables use prefixes such as _ or $ for\n  * naming private properties; this returns a new object purged from these properties.\n  *\n  * @method   removePrivateProp\n  * @global\n  * @example\n  * ```javascript\n  * bbn.fn.removePrivateProp({\n  *   _bbn_timestamp: 1587269593987,\n  *   name: \"Wonka\",\n  *   fname: \"Willy\"\n  * });\n  * // {name: \"Wonka\", fname: \"Willy\"}\n  * ```\n  * @memberof bbn.fn\n  * @param    {Object}  obj  The original object\n  * @param    {Boolean} deep If true the function will be reapplied on object properties\n  * @returns  {Object}  A new object without only the _public_ properties.\n  */\nfunction removePrivateProp(obj, deep) {\n    if (deep === void 0) { deep = false; }\n    var r = null;\n    if (typeof obj === 'object') {\n        r = {};\n        for (var n in obj) {\n            if (substr(n, 0, 1).match(/^[A-z0-9]$/) && (n in obj)) {\n                if (deep && typeof obj[n] === 'object') {\n                    r[n] = removePrivateProp(obj[n], true);\n                }\n                else {\n                    r[n] = obj[n];\n                }\n            }\n        }\n    }\n    return r || false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/loop/iterate.js\n\n/**\n * Executes the provided function on each property of the given object.\n *\n * @method   iterate\n * @global\n * @example\n * ```javascript\n * //[\"value1\", 2]\n * let arr = [];\n * bbn.fn.iterate({field1: \"value1\", field2: 2}, (val, idx) => {\n *   arr.push(value);\n * });\n * ```\n * @memberof bbn.fn\n * @param    {(Object|Number)} obj       The object to loop on\n * @param    {Function}        fn        The function, gets the array's element and the index as arguments\n * @param    {Boolean}         noPrivate If set to true the _private_ properties won't be included\n * @param    {Boolean}         reverse   If set to true the order of the keys will be reversed\n * @returns  {Object}\n */\nfunction iterate(obj, fn, noPrivate, reverse) {\n    if (noPrivate === void 0) { noPrivate = false; }\n    if (reverse === void 0) { reverse = false; }\n    if (obj !== null && typeof obj === \"object\") {\n        var iter = Object.keys(noPrivate ? removePrivateProp(obj) : obj);\n        if (reverse) {\n            iter.reverse();\n        }\n        for (var _i = 0, iter_1 = iter; _i < iter_1.length; _i++) {\n            var prop = iter_1[_i];\n            if (fn(obj[prop], prop) === false) {\n                break;\n            }\n        }\n    }\n    return obj;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/loop/each.js\n\n\n\n/**\n * Executes the provided function on each element of the given array.\n *\n * Returning false will stop the loop.\n *\n * @method   each\n * @global\n * @example\n * ```javascript\n * let res = 0;\n * bbn.fn.each([4, 5, 5, 10, 1, 2], d => {\n *   res += d;\n * });\n * // res = 27\n * ```\n * @example\n * ```javascript\n * let res = 0;\n * bbn.fn.each([4, 5, 5, 10, 1, 2], d => {\n *   if (res >= 20) {\n *     return false;\n *   }\n *   res += d;\n * });\n * // res = 24\n * ```\n * @memberof bbn.fn\n * @param    {*}     arr The array to loop on\n * @param    {Function}  fn  The function, gets the array's element and the index as arguments\n * @returns  {[Array, Object, void]}\n */\nfunction each(arr, fn) {\n    if (isNumber_isNumber(arr) && arr > 0) {\n        for (var i = 0; i < arr; i++) {\n            if (fn(i, i) === false) {\n                return;\n            }\n        }\n        return;\n    }\n    if (isIterable(arr)) {\n        for (var i = 0; i < arr.length; i++) {\n            if (fn(arr[i], i) === false) {\n                return;\n            }\n        }\n        return arr;\n    }\n    return iterate(arr, fn);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/correctCase.js\n/**\n * Converts the first character of the string to uppercase.\n *\n * @method   correctCase\n * @global\n *\n * @example\n * ```javascript\n * //\"This is a test\"\n * bbn.fn.correctCase(\"this is a test\");\n * ```\n *\n * @memberof bbn.fn\n * @param    {STring} str\n * @returns  {String}\n */\nfunction correctCase(str) {\n    return str.replace(/[A-z]{1}/, function (c) { return c.toUpperCase(); });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/error.js\n\n/**\n * Throws an error.\n * @method   error\n * @global\n * @ignore\n * ``` javascript\n * bbn.fn.error('I log this error in console with a red background')\n * ```\n * @memberof bbn.fn\n * @param    {String} errorMsg\n * @returns\n */\nfunction error(errorMsg) {\n    if (arguments.length > 1) {\n        var args = [];\n        for (var i = 1; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        args.unshift({\n            _bbn_console_mode: 'error',\n            _bbn_console_level: 1,\n            _bbn_console_style: 'color: #E64141; background: #F7E195; font-size: 14px',\n        });\n        log.apply(this, args);\n    }\n    throw new Error(errorMsg);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/checkType.js\n\n\n\n\n\n\n\nfunction checkType(value, type, msg) {\n    var logs = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        logs[_i - 3] = arguments[_i];\n    }\n    var ok = false;\n    if (!isArray_isArray(type)) {\n        type = [type];\n    }\n    var typesList = [];\n    each(type, function (t) {\n        var _a;\n        if (t === String) {\n            t = 'string';\n        }\n        else if (t === Number) {\n            t = 'number';\n        }\n        else if (t === Array) {\n            t = 'array';\n        }\n        else if (t === Boolean) {\n            t = 'boolean';\n        }\n        else if (t === Object) {\n            t = 'object';\n        }\n        else if (t === Function) {\n            t = 'function';\n        }\n        if (isFunction_isFunction(t)) {\n            typesList.push(t.name || ((_a = t.constructor) === null || _a === void 0 ? void 0 : _a.name) || t.toString());\n            if (value instanceof t) {\n                ok = true;\n                return false;\n            }\n        }\n        else if (!isString_isString(t) || !isFunction_isFunction(bbn.fn['is' + correctCase(t)])) {\n            error(\"The type \".concat(t, \" is not recognized\"));\n        }\n        else if (bbn.fn['is' + correctCase(t)](value)) {\n            ok = true;\n            return false;\n        }\n        else {\n            typesList.push(t);\n        }\n    });\n    if (!ok) {\n        log(['Value given', value, 'type', typeof value, 'expected', typesList.join(' or ')]);\n        if (logs.length) {\n            log(logs);\n        }\n        throw new Error((msg ? msg + ' - ' : '') + bbn._('The value should be a %s', typesList.join(' ' + bbn._('or a') + ' ')));\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/_.js\n\n/**\n * Translate an expression using the object bbn.lng\n *\n * @param {String} st\n * @returns {String}\n */\nfunction _() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var st = args.shift();\n    var res = bbn.lng[st] || st;\n    if (args.length) {\n        var i_1 = 0;\n        return res.replace(/\\%([d|s])/g, function (match, type) {\n            var tmp = args[i_1++];\n            if (!tmp) {\n                tmp = type === 'd' ? 0 : '';\n            }\n            checkType(tmp, type === 'd' ? 'number' : 'string', bbn._(\"The value you gave did not correspond, check the loggg\"));\n            return tmp;\n        });\n    }\n    return res;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/$.js\n/* harmony default export */ function $(selector, context) {\n    if (context === null || context === void 0 ? void 0 : context.querySelectorAll) {\n        return context.querySelectorAll(selector);\n    }\n    if (context) {\n        throw new Error('Invalid context');\n    }\n    return document.body.querySelectorAll(selector);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/lng.js\n/* harmony default export */ const lng = ({\n    /* User-defined languages elements */\n    select_unselect_all: \"Select/Clear all\",\n    select_all: \"Select all\",\n    search: 'Search',\n    loading: 'Loading...',\n    choose: 'Choose',\n    error: 'Error',\n    server_response: 'Server response',\n    reload: 'Reload',\n    errorText: 'Something went wrong',\n    closeAll: \"Close all\",\n    closeOthers: \"Close others\",\n    pin: \"Pin\",\n    arrange: \"Arrange\",\n    cancel: \"Cancel\",\n    unpin: \"Unpin\",\n    yes: \"Yes\",\n    no: \"No\",\n    unknown: \"Unknown\",\n    untitled: \"Untitled\",\n    confirmation: \"Confirmation\",\n    Today: \"Today\",\n    Tomorrow: \"Tomorrow\",\n    Yesterday: \"Yesterday\"\n});\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/vars.js\n/* harmony default export */ const vars = ({\n    loggers: {\n        _num: 0\n    },\n    /* Usable datatypes through Ajax function */\n    datatypes: ['xml', 'html', 'script', 'json', 'jsonp', 'text', 'blob'],\n    /* The default value used by the function shorten */\n    shortenLen: 30,\n    /* Categorizing keyboard map */\n    keys: {\n        upDown: [33, 34, 35, 36, 38, 40],\n        leftRight: [36, 35, 37, 39],\n        dels: [8, 46, 45],\n        confirm: [13, 9],\n        alt: [20, 16, 17, 18, 144],\n        numbers: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105],\n        numsigns: [109, 110, 189, 190]\n    },\n    comparators: [\">=\", \"<=\", \">\", \"<\", \"=\"],\n    operators: [\"+\", \"-\", \"/\", \"*\"],\n    tags: ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'slot', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'],\n    colors: {\n        darkgrey: '#5a6a62',\n        black: '#000000',\n        anthracite: '#454545',\n        grey: '#d3d3d3',\n        white: '#ffffff',\n        beige: '#fdfdfd',\n        lightgrey: '#dcdcdc',\n        pastelblue: '#ddebf6',\n        cyan: '#00c8f8',\n        blue: '#6e9ecf',\n        indigo: '#3f51b5',\n        navy: '#354458',\n        webblue: '#2196f3',\n        teal: '#009688',\n        turquoise: '#1fda9a',\n        pastelgreen: '#e2efda',\n        palegreen: '#ccffcc',\n        green: '#00a03e',\n        olive: '#92b06a',\n        pastelorange: '#fff2cc',\n        yellow: '#fdf200',\n        orange: '#ff9900',\n        pink: '#eb65a0',\n        purple: '#a333c8',\n        red: '#db3340',\n        brown: '#8c6954'\n    },\n    reserved: ['abstract', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'continue', 'const', 'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'export', 'extends', 'false', 'final', 'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface', 'long', /*'native', */ 'new', 'null', 'package', /*'private', 'protected', 'public', */ 'return', /*'short', 'static',*/ 'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with'],\n    mockText: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\",\n    regexp: {\n        url: new RegExp('^(https?:\\\\/\\\\/)?' + // protocol\n            '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.?)+[a-z]{2,}|' + // domain name\n            '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))' + // OR ip (v4) address\n            '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*' + // port and path\n            '(\\\\?[;&a-z\\\\d%_.~+=-]*)?' + // query string\n            '(\\\\#[-a-z\\\\d_]*)?$', 'i'),\n        ip: /^((\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$/,\n        hostname: /^[a-z\\d]([a-z\\d-]{0,61}[a-z\\d])?(\\.[a-z\\d]([a-z\\d-]{0,61}[a-z\\d])?)*$/i,\n    }\n});\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/env.js\n/* harmony default export */ const env = ({\n    siteTitle: window.document.title,\n    /* This variable should be set to true in debugging mode only */\n    logging: false,\n    /* Address of the CDN (where this file should be hosted) */\n    cdn: '',\n    /* Default language */\n    lang: 'en',\n    host: window.location.protocol + '//' + window.location.hostname,\n    url: window.location.href,\n    old_path: null,\n    /* True when non asynchronous Ajax loads */\n    loading: false,\n    /* Window width */\n    width: 0,\n    /* Window height */\n    height: 0,\n    /* Element currently focused (Element object) */\n    focused: false,\n    /* Last time user has been active */\n    last_focus: (new Date()).getTime(),\n    /* Sleep mode (tab or window unfocused */\n    sleep: false,\n    theme: 'dark',\n    /**\n     *  @var bbn.env.loaders Object where the props are MD5 of data and url while the values are the requests,\n     *  for preventing the same call to be made at the same time\n     **/\n    loaders: [],\n    loadersHistory: [],\n    maxLoadersHistory: 20,\n    /* bbn.env.params is an array of each element of the path */\n    resizeTimer: false,\n    hashChanged: 0,\n    params: [],\n    isInit: false,\n    isFocused: false,\n    timeoff: Math.round((new Date()).getTime() / 1000),\n    loggingLevel: 5,\n    ignoreUnload: false,\n    historyDisabled: false,\n    nav: 'ajax'\n});\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/db.js\n\n\n\n\nvar idb = window['indexedDB'] || window['webkitIndexedDB'] || window['mozIndexedDB'] || window['OIndexedDB'] || window['msIndexedDB'];\nvar dbObject = function (dbName) {\n    var _this = this;\n    var conn = db._connections[dbName];\n    var structure = db._structures[dbName];\n    this.insert = function (table, data) {\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        return new Promise(function (resolve) {\n            var tx = conn.transaction(table, \"readwrite\");\n            var store = tx.objectStore(table);\n            var res = data.length;\n            each(data, function (a) {\n                var request = store.put(a);\n                request.onerror = function () {\n                    log(request.error);\n                    res--;\n                };\n            });\n            tx.onabort = function () {\n                throw new Error(tx.error);\n            };\n            tx.oncomplete = function () {\n                resolve(res);\n            };\n        });\n    };\n    this.update = function (table, data, where) {\n        return new Promise(function (resolve) {\n            var tx = conn.transaction(table, \"readwrite\");\n            var store = tx.objectStore(table);\n            var arch = structure[table];\n            var primary = arch.keys.PRIMARY.columns.length > 1 ? arch.keys.PRIMARY.columns : arch.keys.PRIMARY.columns[0];\n            if (!where[primary]) {\n                throw new Error(_(\"No \"));\n            }\n            var res = 1;\n            var request = store.put(data, where[primary]);\n            request.onerror = function () {\n                log(request.error);\n                res--;\n            };\n            tx.onabort = function () {\n                throw new Error(tx.error);\n            };\n            tx.oncomplete = function () {\n                resolve(res);\n            };\n        });\n    };\n    this.delete = function (table, where) {\n        return new Promise(function (resolve) {\n            var tx = conn.transaction(table, \"readwrite\");\n            var store = tx.objectStore(table);\n            var arch = structure[table];\n            var primary = arch.keys.PRIMARY.columns.length > 1 ? arch.keys.PRIMARY.columns : arch.keys.PRIMARY.columns[0];\n            if (!where[primary]) {\n                throw new Error(_(\"No \"));\n            }\n            var res = 1;\n            var request = store.delete(where[primary]);\n            request.onerror = function () {\n                log(request.error);\n                res--;\n            };\n            tx.onabort = function () {\n                throw new Error(tx.error);\n            };\n            tx.oncomplete = function () {\n                resolve(res);\n            };\n        });\n    };\n    this.selectOne = function (table, field, where, order, start, limit) {\n        return new Promise(function (resolve) {\n            _this.select(table, [field], where, order, start, limit).then(function (d) {\n                var _a;\n                resolve((_a = d[field]) !== null && _a !== void 0 ? _a : undefined);\n            });\n        });\n    };\n    this.select = function (table, fields, where, order, start, limit) {\n        var tx = conn.transaction(table, \"readonly\");\n        var store = tx.objectStore(table);\n        var arch = structure[table];\n        var primary = arch.keys.PRIMARY.columns.length > 1 ? arch.keys.PRIMARY.columns : arch.keys.PRIMARY.columns[0];\n        if (!where[primary]) {\n            throw new Error(_(\"No \"));\n        }\n        return new Promise(function (resolve) {\n            var req = store.get(where[primary]);\n            req.onsuccess = function () {\n                var obj = req.result;\n                if (fields.length) {\n                    var res_1 = {};\n                    iterate(obj, function (v, n) {\n                        if (fields.indexOf(n) > -1) {\n                            res_1[n] = v;\n                        }\n                    });\n                    return resolve(res_1);\n                }\n                else {\n                    resolve(obj);\n                }\n            };\n        });\n    };\n    this.selectAll = function (table, fields, where, order, start, limit) {\n        var tx = conn.transaction(table, \"read\");\n        var store = tx.objectStore(table);\n        var arch = structure[table];\n        var primary = arch.keys.PRIMARY.columns.length > 1 ? arch.keys.PRIMARY.columns : arch.keys.PRIMARY.columns[0];\n        if (!where[primary]) {\n            throw new Error(_(\"No \"));\n        }\n        return new Promise(function (resolve) {\n            var req = store.get(structure.keys.PRIMARY);\n        });\n    };\n    this.getColumnValues = function (table, field, where, order, start, limit) {\n        return new Promise(function (resolve) {\n            var tx = conn.transaction(table, \"read\");\n            var store = tx.objectStore(table);\n        });\n    };\n};\nvar db = {\n    _structures: {},\n    /* This variable should be set to true in debugging mode only */\n    _connections: {},\n    /* Address of the CDN (where this file should be hosted) */\n    _stores: {},\n    ok: idb !== undefined,\n    open: function (name) {\n        return new Promise(function (resolve) {\n            if (!db._connections[name]) {\n                if (!db._structures[name]) {\n                    throw new Error(_(\"Impossible to find a structure for the database %s\", name));\n                }\n                var conn_1 = idb.open(name);\n                conn_1.onupgradeneeded = function () {\n                    log(\"UPGRADE NEEDED\");\n                    var res = conn_1.result;\n                    iterate(db._structures[name], function (structure, storeName) {\n                        var primary = structure.keys.PRIMARY.columns.length > 1 ? structure.keys.PRIMARY.columns : structure.keys.PRIMARY.columns[0];\n                        var store = res.createObjectStore(storeName, { keyPath: primary });\n                        iterate(structure.keys, function (a, n) {\n                            if (n !== 'PRIMARY') {\n                                store.createIndex(n, a.columns.length > 1 ? a.columns : a.columns[0], {\n                                    unique: !!a.unique\n                                });\n                            }\n                        });\n                    });\n                };\n                conn_1.onsuccess = function () {\n                    db._connections[name] = conn_1.result;\n                    var obj = new dbObject(name);\n                    resolve(obj);\n                };\n                return;\n            }\n            resolve(new dbObject(db._connections[name]));\n        });\n    },\n    add: function (database, name, structure) {\n        var _a;\n        if (((_a = structure === null || structure === void 0 ? void 0 : structure.keys) === null || _a === void 0 ? void 0 : _a.PRIMARY) && (structure === null || structure === void 0 ? void 0 : structure.fields)) {\n            if (!db._structures[database]) {\n                db._structures[database] = {};\n            }\n            db._structures[database][name] = structure;\n        }\n        else {\n            throw new Error(_(\"The database structure for %s is not valid (are there keys and field? Is there a primary?\", name));\n        }\n    }\n};\n/* harmony default export */ const dist_db = (db);\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/_addLoader.js\n\n/**\n * Creates and adds a \"loader\" object to the property bbn.env.loaders.\n *\n * @method   _addLoader\n * @global\n * @ignore\n * @memberof bbn.fn\n *\n * @param    {String}  requestId\n * @param    {Promise} prom\n * @param    {Object}  aborter\n *\n * @returns  {Number}  The timestamp (in ms)\n */\nfunction _addLoader(requestId, prom, aborter) {\n    /** @var {Number} tst Current timestamp */\n    var tst = new Date().getTime();\n    /** @var {String} url The original URL (part of requestId before : and md5) */\n    var url = substr(requestId, 0, requestId.length - 33);\n    /** @var {Object} loader The loader object */\n    var loader = {\n        key: requestId,\n        url: url,\n        loader: prom,\n        aborter: aborter,\n        loading: true,\n        error: false,\n        abort: false,\n        errorMessage: false,\n        success: false,\n        start: tst,\n    };\n    // Adding the loader in bbn.env.loaders\n    bbn.env.loaders.push(loader);\n    // Adding an object with this loader info in bbn.env.loadersHistory\n    bbn.env.loadersHistory.unshift(loader);\n    /** @var {Number} idx A pointer starting at the end of  array loadersHistory */\n    var idx = bbn.env.loadersHistory.length;\n    // Removing elements from the loadersHistory object if their number is higher\n    // than bbn.env.maxLoadersHistory\n    while (idx && bbn.env.loadersHistory.length > bbn.env.maxLoadersHistory) {\n        idx--;\n        // Not removing the ones still loading\n        if (!bbn.env.loading) {\n            bbn.env.loadersHistory.splice(idx, 1);\n        }\n    }\n    return tst;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/getProperty.js\n/**\n * Returns the value of the given property from the given object.\n *\n * Looks for the given property in the given object, accepting dot (.) separator\n * for deep property access, and returns its value if found and undefined otherwise.\n *\n * @method   getProperty\n * @global\n * @example\n * ```javascript\n * bbn.fn.getProperty({a: 1, b: 2}, 'b');\n * // 2\n * ```\n * @example\n * ```javascript\n * bbn.fn.getProperty({a: 1, b: {o: {a: 33, h: 5}}}, 'b.o.a');\n * // 33\n * ```\n * @example\n * ```javascript\n * bbn.fn.getProperty({a: 1, b: {o: {a: 33, h: 5}}}, 'b.h.a');\n * // undefined\n * ```\n * @memberof bbn.fn\n * @param    {Object} obj\n * @param    {String} props\n * @returns  {*}      The property's value or undefined\n */\nfunction getProperty(obj) {\n    var props = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        props[_i - 1] = arguments[_i];\n    }\n    if (typeof obj === 'object') {\n        var arr = [];\n        if (props.length === 1 && typeof props[0] === 'string') {\n            arr.push.apply(arr, props[0].split('.'));\n        }\n        return arr.reduce(function (o, i) {\n            if (o) {\n                return o[i];\n            }\n            return undefined;\n        }, obj);\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/removeAccents.js\n\n\n/**\n * Returns the string passed as an argument without accents.\n *\n * @method   removeAccents\n * @global\n *\n * @example\n * ```javascript\n * //\"eeou\"\n * bbn.fn.removeAccents(\"èéòù\");\n * ```\n * @memberof bbn.fn\n * @param    {String} st\n * @returns  {String}\n */\nfunction removeAccents(st) {\n    if (!isString_isString(st)) {\n        if (st.toString) {\n            st = st.toString();\n        }\n        else {\n            log(st);\n            throw new Error(bbn._(\"removeAccent expects a string\"));\n        }\n    }\n    return st.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isDate.js\n/**\n * Returns true if the given argument is a date object.\n * @method   isDate\n * @global\n * @example\n * ```javascript\n * let date = new Date();\n * bbn.fn.isDate(date);\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isDate('16/04/2020');\n * //false\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isDate_isDate() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object Date]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/_compareValues.js\n\n\n\n\n/**\n  * Compares the given property in the given objects and returns -1, 1, or 0 depending on their difference.\n  *\n  * This is only used as a sorting function by bbn.fn.order and bbn.fn.multiorder.\n  *\n  * @method   _compareValues\n  * @global\n  * @example\n  * ```javascript\n  * // Same value\n  * bbn.fn._compareValues({year: 2015, value: 2}, {year: 2016, value: 2}, 'value');\n  * // 0\n  * ```\n  * @example\n  * ```javascript\n  * // First value smaller than second\n  * bbn.fn._compareValues({year: 2015, value: 2}, {year: 2016, value: 2}, 'year');\n  * // -1\n  * ```\n  * @example\n  * ```javascript\n  * // First value greater than second\n  * bbn.fn._compareValues({year: 2017, value: 2}, {year: 2016, value: 2}, 'year');\n  * // 1\n  * ```\n  * @example\n  * ```javascript\n  * // First value is undefined\n  * bbn.fn._compareValues({year: 2017}, {year: 2016, value: 2}, 'value');\n  * // 1\n  * ```\n  * @memberof bbn.fn\n  * @param    {Object} a    First object for comparison\n  * @param    {Object} b    Second object for comparison\n  * @param    {String} prop Property to compare\n  * @param    {String} [dir=asc]  Direction of comparison (desc or asc by default)\n  * @returns  {Number} Always either -1, 1, or 0\n  */\nfunction _compareValues(a, b, prop, dir) {\n    if (dir === void 0) { dir = \"asc\"; }\n    var va = getProperty(a, prop), vb = getProperty(b, prop), ta = (typeof va).toLowerCase(), tb = (typeof vb).toLowerCase();\n    if (dir !== \"asc\" && isString_isString(dir) && dir.toLowerCase() === \"desc\") {\n        dir = \"desc\";\n    }\n    if (ta !== tb) {\n        va = ta;\n        vb = tb;\n    }\n    else {\n        switch (ta) {\n            case \"string\":\n                va = removeAccents(va).toLowerCase();\n                vb = removeAccents(vb).toLowerCase();\n                break;\n            case \"boolean\":\n                va = va ? 1 : 0;\n                vb = vb ? 1 : 0;\n                break;\n            case \"object\":\n                if (isDate_isDate(va)) {\n                    va = va.getTime();\n                    vb = isDate_isDate(vb) ? vb.getTime() : 0;\n                }\n                break;\n        }\n    }\n    if (va < vb) {\n        return dir === \"desc\" ? 1 : -1;\n    }\n    if (va > vb) {\n        return dir === \"desc\" ? -1 : 1;\n    }\n    return 0;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/numProperties.js\n/**\n  * Returns the number of properties contained in the object.\n  *\n  * Only takes into account the own properties - not the inherited ones - and the non _private_ ones.\n  *\n  * @method   numProperties\n  * @global\n  * @example\n  * ```javascript\n  * bbn.fn.numProperties({author: \"Chuck Palahniuk\", \"title\": \"Fight club\"});\n  * // 2\n  * ```\n  * @example\n  * ```javascript\n  * bbn.fn.numProperties({username: \"chuck\", \"password\": \"soap\", _bbn_timestamp: 1587323193751});\n  * // 2\n  * @example\n  * ```javascript\n  * let d = new Date();\n  * bbn.fn.numProperties(d);\n  * // 0\n  * d.myProp = 1;\n  * bbn.fn.numProperties(d);\n  * // 1\n  * ```\n  * @memberof bbn.fn\n  * @param    {Object} obj The object to analyze\n  * @returns  {Number} The number of properties\n  */\nfunction numProperties(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return 0;\n    }\n    return Object.keys(obj).length;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isEmpty.js\n\n\n/**\n * Checks if the argument is empty or not.\n * @method   isEmpty\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.isEmpty({});\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isEmpty({test : 1});\n * //false\n * ```\n * @example\n * ```javascript\n * bbn.fn.isEmpty([]);\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isEmpty(['test']);\n * //false\n * ```\n * @example\n * ```javascript\n * bbn.fn.isEmpty('');\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isEmpty('test');\n * //false\n * ```\n * @memberof bbn.fn\n * @param    {*} obj\n * @returns  {Boolean}\n */\nfunction isEmpty(obj) {\n    if (!obj) {\n        return true;\n    }\n    if (isArray_isArray(obj)) {\n        return obj.length ? false : true;\n    }\n    if (typeof obj === \"object\") {\n        if (numProperties(obj)) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isNull.js\n/**\n * Returns true if the given argument is null;\n * @method   isNull\n * @global\n * @example\n * ```javascript\n * bbn.fn.isNull(myData);\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isNull() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object Null]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isObject.js\n/**\n * Returns true if the given argument is an object.\n * @method   isObject\n * @global\n * @example\n * ```javascript\n * bbn.fn.isObject({name: 'cami', age: 7});\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isObject([{name: 'cami', age: 7}]);\n * //false\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isObject_isObject() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object Object]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isDom.js\n/**\n * Returns true if the given argument is a dom element;\n * @method   isDom\n * @example\n * ```javascript\n * bbn.fn.isDom(document.body.childNodes[0]);\n * //true\n * ```\n * @global\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isDom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!(a instanceof HTMLElement)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isCp.js\n\nfunction isCp() {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length) {\n        return false;\n    }\n    if (!('cp' in bbn) || !('isComponent' in bbn['cp']) || !(typeof bbn['cp'].isComponent === 'function')) {\n        return false;\n    }\n    for (var _b = 0, args_1 = args; _b < args_1.length; _b++) {\n        var a = args_1[_b];\n        var res = bbn.cp.isComponent(a);\n        if (!res || isDom(a) || !((_a = a.$el) === null || _a === void 0 ? void 0 : _a.bbnCid)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/circularReplacer.js\n\n\n/**\n * Returns a function to give to JSON.stringify in order to avoid circular values.\n *\n * @returns Function\n */\nfunction circularReplacer() {\n    var visited = new WeakSet();\n    return function (key, value) {\n        if (typeof value === \"object\" && value !== null) {\n            if (visited.has(value)) {\n                return;\n            }\n            visited.add(value);\n            if (![undefined, Object, Array, null].includes(value.constructor)) {\n                if (isDom(value)) {\n                    if (value.bbnId) {\n                        value =\n                            \"__BBN_DOM__\" + value.tagName + \"/\" + value.bbnId + value.bbnHash;\n                    }\n                    else {\n                        value = \"__BBN_DOM__\" + value.tagName + \"/\" + value.className;\n                    }\n                }\n                else if (isCp(value)) {\n                    value = \"__BBN_CP__\" + value.$options.name + \"/\" + value.$cid;\n                }\n                else {\n                    value = value.constructor.toString();\n                }\n            }\n        }\n        return value;\n    };\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/simpleHash1.js\nfunction simpleHash1(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash |= 0; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/simpleHash2.js\nfunction simpleHash2(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var char = str.charCodeAt(i);\n        hash = char + (hash << 6) + (hash << 16) - hash;\n        hash |= 0; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/simpleHash.js\n\n\nfunction simpleHash(str) {\n    var part1 = simpleHash1(str).padStart(8, '0');\n    var part2 = simpleHash2(str).padStart(8, '0');\n    return part1 + part2;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/hash.js\n\n\n\n\n/**\n * Makes a hash out of anything\n * @param {Object|Array} obj\n * @returns {String}\n */\nfunction hash(obj) {\n    //log(obj);\n    var st = \"__bbn__\";\n    for (var i in arguments) {\n        if (arguments[i]) {\n            var value = arguments[i];\n            if (isDom(value)) {\n                if (value.bbnId) {\n                    st +=\n                        \"__BBN_DOM__\" + value.tagName + \"/\" + value.bbnId + value.bbnHash;\n                }\n                else {\n                    st += \"__BBN_DOM__\" + value.tagName + \"/\" + value.className;\n                }\n            }\n            else if (isCp(value)) {\n                st += \"__BBN_CP__\" + value.$options.name + \"/\" + value.$cid;\n            }\n            else {\n                try {\n                    st += JSON.stringify(arguments[i], circularReplacer());\n                }\n                catch (e) {\n                    st += \".\";\n                }\n            }\n        }\n    }\n    return simpleHash(st);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/md5.js\n/**\n * Converts and returns the argument passed in a string in md5 format.\n *\n * This is a formatted version of popular md5 implementation\n * Original copyright (c) Paul Johnston & Greg Holt.\n *\n *\n * @method   md5\n * @global\n *\n * @example\n * ```javascript\n * //\"486eb65274adb86441072afa1e2289f3\"\n * bbn.fn.md5(\"this is a test string\");\n * ```\n *\n * @memberof bbn.fn\n * @param    {Mixed} st\n * @returns  {String} in md5 format\n */\nfunction md5(st) {\n    var hc = \"0123456789abcdef\";\n    function rh(n) {\n        var j, s = \"\";\n        for (j = 0; j <= 3; j++)\n            s +=\n                hc.charAt((n >> (j * 8 + 4)) & 0x0f) + hc.charAt((n >> (j * 8)) & 0x0f);\n        return s;\n    }\n    function ad(x, y) {\n        var l = (x & 0xffff) + (y & 0xffff);\n        var m = (x >> 16) + (y >> 16) + (l >> 16);\n        return (m << 16) | (l & 0xffff);\n    }\n    function rl(n, c) {\n        return (n << c) | (n >>> (32 - c));\n    }\n    function cm(q, a, b, x, s, t) {\n        return ad(rl(ad(ad(a, q), ad(x, t)), s), b);\n    }\n    function ff(a, b, c, d, x, s, t) {\n        return cm((b & c) | (~b & d), a, b, x, s, t);\n    }\n    function gg(a, b, c, d, x, s, t) {\n        return cm((b & d) | (c & ~d), a, b, x, s, t);\n    }\n    function hh(a, b, c, d, x, s, t) {\n        return cm(b ^ c ^ d, a, b, x, s, t);\n    }\n    function ii(a, b, c, d, x, s, t) {\n        return cm(c ^ (b | ~d), a, b, x, s, t);\n    }\n    function sb(x) {\n        var i;\n        var nblk = ((x.length + 8) >> 6) + 1;\n        var blks = new Array(nblk * 16);\n        for (i = 0; i < nblk * 16; i++)\n            blks[i] = 0;\n        for (i = 0; i < x.length; i++)\n            blks[i >> 2] |= x.charCodeAt(i) << ((i % 4) * 8);\n        blks[i >> 2] |= 0x80 << ((i % 4) * 8);\n        blks[nblk * 16 - 2] = x.length * 8;\n        return blks;\n    }\n    var i, x = sb(st), a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, olda, oldb, oldc, oldd;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = ff(a, b, c, d, x[i + 0], 7, -680876936);\n        d = ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = gg(b, c, d, a, x[i + 0], 20, -373897302);\n        a = gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = hh(d, a, b, c, x[i + 0], 11, -358537222);\n        c = hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = ii(a, b, c, d, x[i + 0], 6, -198630844);\n        d = ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = ad(a, olda);\n        b = ad(b, oldb);\n        c = ad(c, oldc);\n        d = ad(d, oldd);\n    }\n    return rh(a) + rh(b) + rh(c) + rh(d);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/analyzeFunction.js\n\n/**\n * Analyzes the given function and extracts details about its structure.\n *\n * @function analyzeFunction\n * @param {Function} fn - The function to analyze.\n * @returns {Object} An object containing details about the function.\n * @throws {Error} When unexpected syntax is encountered while parsing.\n */\nfunction analyzeFunction(fn) {\n    var all = typeof fn === \"function\" ? fn.toString() : fn;\n    if (typeof all !== \"string\") {\n        throw Error(\"Unexpected type \" + typeof fn + \" while parsing function\");\n    }\n    var exp = \"\";\n    var isArrow = false;\n    var isAsync = false;\n    var hasFunction = false;\n    var name = \"\";\n    var parOpened = 0;\n    var parClosed = 0;\n    var args = [];\n    var currentArg = {};\n    var body;\n    var currentQuote = \"\";\n    var escapable = ['\"', \"'\", \"`\"];\n    var isEscaped = false;\n    var settingDefault = false;\n    var isComment = false;\n    var isCommentLine = false;\n    var isDestructuring = false;\n    var returnType = \"\";\n    for (var i = 0; i < all.length; i++) {\n        // Handle string literals\n        if (!isComment && all[i] === \"/\" && all[i + 1] === \"*\") {\n            isComment = true;\n            exp = \"\";\n        }\n        else if (all[i] === \"/\" && all[i - 1] === \"*\") {\n            isComment = false;\n        }\n        else if (!isCommentLine && all[i] === \"/\" && all[i + 1] === \"/\") {\n            isCommentLine = true;\n            exp = \"\";\n        }\n        else if (all[i] === \"\\n\") {\n            isCommentLine = false;\n        }\n        else if (isComment || isCommentLine) {\n            continue;\n        }\n        else if (all[i] === currentQuote && !isEscaped && currentQuote) {\n            currentQuote = \"\";\n            exp += all[i];\n        }\n        else if (currentQuote) {\n            isEscaped = all[i] === \"\\\\\" && !isEscaped;\n            exp += all[i];\n        }\n        else if (escapable.includes(all[i]) && !isEscaped) {\n            currentQuote = all[i];\n            exp += all[i];\n        }\n        else if (all[i] === \"(\") {\n            parOpened++;\n            if (exp.trim() !== \"\") {\n                if (exp.trim() === \"function\") {\n                    hasFunction = true;\n                }\n                else if (exp.trim() !== \"async\") {\n                    name = exp.trim();\n                    var tmp = name.match(/^([a-zA-Z0-9_]+)<[a-zA-Z0-9_]+>$/);\n                    if (tmp) {\n                        name = tmp[1];\n                    }\n                }\n                exp = \"\";\n            }\n        }\n        else if (all[i] === \")\") {\n            if (parOpened === parClosed + 1) {\n                if (settingDefault) {\n                    currentArg[\"default\"] = exp.trim();\n                    settingDefault = false;\n                }\n                else if (exp) {\n                    currentArg[\"name\"] = exp.trim();\n                }\n                if (currentArg[\"name\"] || currentArg[\"default\"]) {\n                    args.push(currentArg);\n                    currentArg = {};\n                }\n                exp = \"\";\n            }\n            parClosed++;\n        }\n        else if (isDestructuring && all[i] !== \"}\") {\n            exp += all[i];\n        }\n        else if (parOpened && parOpened === parClosed && all[i] === \":\") {\n            var matches = all.substring(i + 1).trim().match(/^\\s*([a-zA-Z0-9_]+)\\s*\\{/);\n            if (!matches) {\n                throw Error(\"Unexpected ':' while parsing function\");\n            }\n            returnType = matches[1];\n            body = all.substring(i + matches[0].length).trim();\n            break;\n        }\n        else if (all[i] === \"=\" && all[i + 1] === \">\") {\n            if (exp.trim() !== \"\" && parOpened === parClosed) {\n                currentArg[\"name\"] = exp.trim();\n                args.push(currentArg);\n                currentArg = {};\n                exp = \"\";\n            }\n            isArrow = true;\n            i++;\n            continue;\n        }\n        else if (all[i] === \"=\" && parOpened > parClosed && !settingDefault) {\n            currentArg[\"name\"] = exp.trim();\n            exp = \"\";\n            settingDefault = true;\n        }\n        else if (all[i] === \",\") {\n            if (isDestructuring) {\n                exp += all[i];\n            }\n            else if (parOpened > parClosed) {\n                if (settingDefault) {\n                    currentArg[\"default\"] = exp.trim();\n                    settingDefault = false;\n                }\n                else if (exp) {\n                    currentArg[\"name\"] = exp.trim();\n                }\n                if (currentArg[\"name\"] || currentArg[\"default\"]) {\n                    args.push(currentArg);\n                    currentArg = {};\n                }\n                exp = \"\";\n            }\n            else {\n                throw Error(\"Unexpected ',' while parsing function\");\n            }\n        }\n        else if (all[i] === \"{\" || all[i] === \"}\") {\n            if (parOpened === parClosed) {\n                body = all.substring(i).trim();\n                break;\n            }\n            else {\n                if (parOpened > parClosed) {\n                    if (all[i] === \"{\" && !isDestructuring) {\n                        isDestructuring = true;\n                        exp = all[i];\n                    }\n                    else if (all[i] === \"}\" && isDestructuring) {\n                        isDestructuring = false;\n                        exp += all[i];\n                    }\n                }\n                else {\n                    exp = \"\";\n                }\n            }\n        }\n        else if (isArrow) {\n            body = all.substring(all.indexOf(\"=>\") + 2).trim();\n            break;\n        }\n        else if (all[i] === \" \") {\n            if (exp.trim() !== \"\") {\n                if (exp.trim() === \"async\") {\n                    isAsync = true;\n                }\n                if (parOpened > parClosed) {\n                    exp += all[i];\n                }\n                else {\n                    exp = \"\";\n                }\n            }\n        }\n        else {\n            exp += all[i];\n        }\n    }\n    if (!body) {\n        if (isArrow) {\n            body = exp;\n        }\n        else {\n            throw Error(\"Unexpected end of function while parsing function\");\n        }\n    }\n    var argString = args\n        .map(function (arg) { return arg.name + (arg.default ? \" = \" + arg.default : \"\"); })\n        .join(\", \");\n    var hash = md5(body + (name ? \"-\" + name : \"\") + (argString ? \"-\" + argString : \"\"));\n    return {\n        body: body,\n        args: args,\n        argString: argString,\n        isArrow: isArrow,\n        hasFunction: hasFunction,\n        name: name,\n        isAsync: isAsync,\n        hash: hash,\n        returnType: returnType\n    };\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isSame.js\n\n\n\n/**\n  * Checks whether the data contained in the given objects is identical.\n  *\n  * The properties starting with a non alphanumerical character and the\n  * inherited ones are removed for the comparison, then the properties are\n  * compared individually without the order being taken into account.\n  *\n  * @method   isSame\n  * @global\n  * @example\n  * ```javascript\n  * bbn.fn.isSame(\n  *   {name: \"Wonka\", fname: \"Willy\"},\n  *   {fname: \"Willy\", name: \"Wonka\"}\n  * );\n  * // true\n  * ```\n  * @example\n  * ```javascript\n  * // Doesn't take into account properties starting with non-alphanumeric characters\n  * bbn.fn.isSame(\n  *   {name: \"Wonka\", fname: \"Willy\", _bbn_timestamp: 1587269593987},\n  *   {fname: \"Willy\", name: \"Wonka\"}\n  * );\n  * // true\n  * ```\n  * @example\n  * ```javascript\n  * bbn.fn.isSame(\n  *   {name: \"Wonka\", fname: \"Willy\", real: false},\n  *   {fname: \"Willy\", name: \"Wonka\"}\n  * );\n  * // false\n  * ```\n  * @memberof bbn.fn\n  * @param    {Object} obj1\n  * @param    {Object} obj2\n  * @returns  {Boolean}\n  */\nfunction isSame(obj1, obj2, done) {\n    if (!done) {\n        done = [];\n    }\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 && obj2 && typeof obj1 === 'object' && typeof obj2 === 'object') {\n        var tmp1 = Object.keys(obj1).sort(), tmp2 = Object.keys(obj2).sort();\n        // Case where the keys are different\n        if (hash(tmp1) !== hash(tmp2)) {\n            return false;\n        }\n        var ok_1 = true;\n        if (obj1 && typeof obj1 === 'object') {\n            if (done.includes(obj1)) {\n                return ok_1;\n            }\n            done.push(obj1);\n        }\n        each(tmp1, function (a) {\n            if (!isSame(obj1[a], obj2[a])) {\n                ok_1 = false;\n                return false;\n            }\n        });\n        return ok_1;\n    }\n    else if (obj1 && obj2 && typeof obj1 === 'function' && typeof obj2 === 'function') {\n        var tmp1 = analyzeFunction(obj1);\n        var tmp2 = analyzeFunction(obj2);\n        return tmp1.hash === tmp2.hash;\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/compare.js\n\n\n\n\n\n/**\n * Performs a comparison between two values based on the given operator and returns a boolean.\n *\n * It is internally used by all the filtering functions; the available operators are:\n * - _===_, _=_, _equal_, _eq_, _is_, which stand for __===__\n * - _!==_, _notequal_, _neq_, _isnot_, which stand for __!==__\n * - _!=_, _different_, which stand for __!=__\n * - _contains_, _contain_, _icontains_, _icontain_\n * - _starts_, _start_\n * - _startswith_, _startsi_, _starti_, _istarts_, _istart_\n * - _endswith_, _endsi_, _endi_, _iends_, _iend_\n * - _like_\n * - _gt_, _>_, which stand for __>__\n * - _lt_, _<_, which stand for __<__\n * - _gte_, _>=_, which stand for __>=__\n * - _lte_, _<=_, which stand for __<=__\n * - _isnull_, which stands for __=== null__\n * - _isnotnull_, which stands for __!== null__\n * - _isempty_, which stands for __=== ''__\n * - _isnotempty_, which stands for __!== ''__\n *\n * The defaut operator (if none is given) is __==__ .\n *\n * @method   compare\n * @global\n * @example\n * ```javascript\n * bbn.fn.compare('foo', 'bar', 'eq');\n * // false\n * ```\n * @example\n * ```javascript\n * bbn.fn.compare('foo', 'bar', 'neq');\n * // true\n * ```\n * @example\n * ```javascript\n * bbn.fn.compare(3, 1, '>');\n * // true\n * ```\n * @example\n * ```javascript\n * bbn.fn.compare(\"JavaScript\", \"script\", 'contain');\n * // true\n * ```\n * @memberof bbn.fn\n * @param    {String|Number} v1\n * @param    {String|Number} v2\n * @param    {String}        operator\n * @returns  {Boolean}       True if the values' comparison complies with the operator, false otherwise\n */\nfunction compare(v1, v2, operator) {\n    switch (operator) {\n        case '===':\n        case '=':\n        case 'equal':\n        case 'eq':\n        case 'is':\n            return v1 === v2;\n        case '!==':\n        case 'notequal':\n        case 'neq':\n        case 'isnot':\n            return v1 !== v2;\n        case '!=':\n        case 'different':\n            return v1 != v2;\n        case 'contains':\n        case 'contain':\n        case 'icontains':\n        case 'icontain':\n            if (isEmpty(v1) || isEmpty(v2)) {\n                return false;\n            }\n            return removeAccents(v1).toLowerCase().indexOf(removeAccents(v2).toLowerCase()) !== -1;\n        case 'doesnotcontain':\n        case 'donotcontain':\n            if (isNull(v1) || isNull(v2)) {\n                return true;\n            }\n            return removeAccents(v1.toLowerCase()).indexOf(removeAccents(v2.toLowerCase())) === -1;\n        case 'starts':\n        case 'start':\n            if (isNull(v1) || isNull(v2)) {\n                return false;\n            }\n            if (typeof v1 !== 'string') {\n                v1 = v1.toString() || '';\n            }\n            if (typeof v2 !== 'string') {\n                v2 = v2.toString() || '';\n            }\n            return v1.indexOf(v2) === 0;\n        case 'startswith':\n        case 'startsi':\n        case 'starti':\n        case 'istarts':\n        case 'istart':\n            if (isNull(v1) || isNull(v2)) {\n                return false;\n            }\n            return removeAccents(v1).toLowerCase().indexOf(removeAccents(v2).toLowerCase()) === 0;\n        case 'endswith':\n        case 'endsi':\n        case 'endi':\n        case 'iends':\n        case 'iend':\n            if (isNull(v1) || isNull(v2)) {\n                return false;\n            }\n            return v1.lastIndexOf(v2) === v1.length - v2.length;\n        case 'like':\n            if (isNull(v1) || isNull(v2)) {\n                return false;\n            }\n            return removeAccents(v1).toLowerCase() === removeAccents(v2).toLowerCase();\n        case 'gt':\n        case '>':\n            return v1 > v2;\n        case 'gte':\n        case '>=':\n            return v1 >= v2;\n        case 'lt':\n        case '<':\n            return v1 < v2;\n        case 'lte':\n        case '<=':\n            return v1 <= v2;\n        case 'isnull':\n            return v1 === null;\n        case 'isnotnull':\n            return v1 !== null;\n        case 'isempty':\n            return v1 === '';\n        case 'isnotempty':\n            return v1 !== '';\n        case '==':\n            if (isObject_isObject(v1, v2)) {\n                return isSame(v1, v2);\n            }\n        default:\n            return v1 == v2;\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/compareConditions.js\n\n\n\n\n/**\n * Checks whether the given data object complies or not with the given filter.\n *\n * The filter format must be full (i.e. with the properties logic and conditions) such as\n * seen in the function bbn.fn.search and can be generated by the function bbn.fn.filterToConditions.\n *\n * @method   compareConditions\n * @global\n * @example\n * ```javascript\n * let item = {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589};\n * bbn.fn.compareConditions(item, {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *        field: \"director\",\n *        value: \"Steven Spielberg\"\n *     }\n *   ]\n * });\n * // true\n * bbn.fn.compareConditions(item, bbn.fn.filterToConditions({director: \"Steven Soderberg\"}));\n * // false\n * bbn.fn.compareConditions(item, bbn.fn.filterToConditions({director: \"Steven Spielberg\"}));\n * // true\n * bbn.fn.compareConditions(item, bbn.fn.filterToConditions({year: 1980}, \">\"));\n * // true\n * bbn.fn.compareConditions(item, {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *        field: \"year\",\n *        operator: \"<\",\n *        value: 1980\n *     }\n *   ]\n * });\n * // false\n * ```\n * @memberof bbn.fn\n * @param    {Object} data\n * @param    {Object} filter\n * @returns  {Boolean}\n */\nfunction compareConditions(data, filter) {\n    if (!filter.conditions || !filter.logic || !isArray_isArray(filter.conditions)) {\n        throw new Error(\"Error in compareConditions: the filter should an abject with conditions and logic properties and conditions should be an array of objects\");\n    }\n    var ok = filter.logic === \"AND\" ? true : false;\n    each(filter.conditions, function (a) {\n        var comparator;\n        if (a.conditions && isArray_isArray(a.conditions)) {\n            comparator = compareConditions(data, a);\n        }\n        else {\n            comparator = compare(getProperty(data, a.field), a.value, a.operator);\n            if (comparator) {\n                var bits = a.field.split(\".\");\n                var prop = bits.pop();\n                if (bits.length) {\n                    each(bits, function (b) { return (data = data[b]); });\n                }\n                // Case where both are undefined: value and prop which doesn't exist; they are not the same!\n                if (getProperty(data, prop) === undefined && a.value !== undefined) {\n                    comparator = false;\n                }\n            }\n        }\n        if (comparator) {\n            if (filter.logic === \"OR\") {\n                ok = true;\n                return false;\n            }\n        }\n        else if (filter.logic === \"AND\") {\n            ok = false;\n            return false;\n        }\n    });\n    return ok;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/filterToConditions.js\n\n\n\n/**\n * Converts the given object 'filter' to a valid format of condition.\n *\n * The resulting format will comply with bbn.fn.compareConditions and also with\n * bbn databases functions and complex filters applied to bbn-vue list components.\n *\n * @method   filterToConditions\n * @global\n * @example\n * ```javascript\n * bbn.fn.filterToConditions({num: 3});\n * // {\n * //   logic: \"AND\",\n * //   conditions: [{\n * //     field: \"num\",\n * //     operator: \"=\",\n * //     value: 3\n * //   }]\n * // }\n * ```\n * @example\n * ```javascript\n * bbn.fn.filterToConditions({num: 3}, '>');\n * // {\n * //   logic: \"AND\",\n * //   conditions: [{\n * //     field: \"num\",\n * //     operator: \">\",\n * //     value: 3\n * //   }]\n * // }\n * ```\n * @memberof bbn.fn\n * @param    {Object} filter\n * @param    {String} operator\n * @returns  {Object}\n */\nfunction filterToConditions(filter, operator) {\n    if (operator === void 0) { operator = \"=\"; }\n    if (!isObject_isObject(filter)) {\n        throw new Error(\"Error in filterToCondition: filter must be an object\");\n    }\n    if (!filter.conditions || !isArray_isArray(filter.conditions)) {\n        var tmp_1 = [];\n        iterate(filter, function (a, n) {\n            if (isObject_isObject(a) && typeof a.conditions === \"object\") {\n                tmp_1.push(filterToConditions(a));\n            }\n            else {\n                tmp_1.push({\n                    field: n,\n                    operator: operator,\n                    value: a,\n                });\n            }\n        });\n        filter = {\n            conditions: tmp_1,\n        };\n    }\n    if (!filter.logic) {\n        filter.logic = \"AND\";\n    }\n    return filter;\n}\n;\n\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/search.js\n\n\n\n\n\n\n/**\n * Retrieves the index of the array's first element corresponding to the given filter.\n *\n * Returns -1 if the element is not found. If the second parameter is an object or function\n * for filtering as defined in bbn.fn.filter, the remaining parameters will be shifted to the\n * left, i.e. val becomes operator, and operator startFrom. And if operator is a number, its value will\n * be given to startFrom and operator will be undefined. The filter object can be complex with different\n * operators (as seen in bbn.fn.compare) and logics (AND/OR), and infinitely nested, of this form:\n * ```javascript\n * {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *       field: \"prop1\",\n *       operator: \"eq\",\n *       value: \"value1\"\n *     }, {\n *       logic: \"OR\",\n *       conditions: [\n *         {\n *            field: \"prop2\",\n *            operator: \"eq\",\n *            value: 1\n *         }. {\n *            field: \"prop2\",\n *            operator: \"eq\",\n *            value: 2\n *         }\n *       ]\n *     }\n *   ]\n * }\n * ```\n * This way of managing the arguments is used in all the filtering functions.\n *\n * @method   search\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * ];\n *\n * bbn.fn.search(ar, \"id\", 256);\n * // 2\n *\n * bbn.fn.search(ar, {director: \"Steven Spielberg\"});\n * // 0\n *\n * bbn.fn.search(ar, {year: 1975, director: \"Steven Spielberg\"});\n * // 3\n *\n * bbn.fn.search(ar, {director: \"Steven Spielberg\"}, 1);\n * // 3\n *\n * // Complex filters\n * bbn.fn.search(ar, {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *       field: \"director\",\n *       operator: \"eq\",\n *       value: \"Steven Spielberg\"\n *     }, {\n *       logic: \"OR\",\n *       conditions: [\n *         {\n *            field: \"year\",\n *            operator: \"eq\",\n *            value: 1974\n *         }, {\n *            field: \"year\",\n *            operator: \"eq\",\n *            value: 1975\n *         }\n *       ]\n *     }\n *   ]\n * });\n * // 3\n *\n * Simple array\n * bbn.fn.search(['a', 'b', 'c'], null, 'b');\n * // 1\n *\n * ```\n *\n * @memberof bbn.fn\n * @param    {Array}                    arr       The subject array\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @param    {Number}                   startFrom The index from which the search should start\n * @returns  {Number}                   The index if found, otherwise -1\n */\nfunction search(arr, prop, val, operator, startFrom) {\n    if (val === void 0) { val = null; }\n    if (operator === void 0) { operator = '='; }\n    if (startFrom === void 0) { startFrom = 0; }\n    if (!isIterable(arr)) {\n        throw new Error(bbn._('The first argument for a search should be iterable') + ' ' + typeof arr + ' ' + bbn._('given'));\n    }\n    if (!arr.length) {\n        return -1;\n    }\n    var filter;\n    var isFn = false;\n    if (typeof prop === 'string') {\n        filter = {\n            conditions: [\n                {\n                    field: prop,\n                    value: val,\n                    operator: operator || '=',\n                },\n            ]\n        };\n    }\n    else if (!prop) {\n        isFn = true;\n        filter = function (a) {\n            return compareConditions({ value: a }, filterToConditions({\n                logic: 'AND',\n                conditions: [\n                    {\n                        field: 'value',\n                        operator: operator || '=',\n                        value: val,\n                    },\n                ],\n            }));\n        };\n    }\n    else {\n        startFrom = typeof (operator) === 'number' ? operator : 0;\n        operator = val;\n        if (isObject_isObject(prop)) {\n            filter = prop;\n        }\n        else if (typeof (prop) === 'function') {\n            isFn = true;\n            filter = prop;\n        }\n    }\n    if (isFn || (isObject_isObject(filter) && numProperties(filter))) {\n        if (isNumber_isNumber(operator)) {\n            startFrom = typeof (operator) === 'number' ? operator : 0;\n            operator = undefined;\n        }\n        if (!isNumber_isNumber(startFrom)) {\n            startFrom = 0;\n        }\n        if (typeof filter === 'function') {\n            for (var i = startFrom; i < arr.length; i++) {\n                if (filter(arr[i])) {\n                    return i;\n                }\n            }\n        }\n        else {\n            filter = filterToConditions(filter);\n            for (var i = startFrom; i < arr.length; i++) {\n                if (compareConditions(arr[i], filter)) {\n                    return i;\n                }\n            }\n        }\n    }\n    return -1;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/getRow.js\n\n/**\n * Returns the first object matching the given filter in an array of objects.\n *\n * The filtering arguments follow the same scheme as bbn.fn.search.\n *\n * @method    getRow\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * ];\n * bbn.fn.getRow(ar, {director: \"Steven Spielberg\"});\n * // {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n * bbn.fn.getRow(ar, \"director\", \"Steven Spielberg\");\n * // Same result as the previous example\n * bbn.fn.getRow(ar, {\n *   logic: \"OR\",\n *   conditions: [\n *     {\n *        field: \"director\",\n *        value: \"Richard Donner\"\n *     }, {\n *        field: \"director\",\n *        value: \"George Lucas\"\n *     }\n *   ]\n * );\n * // {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n * ```\n * @memberof bbn.fn\n * @param    {Array}                    arr       The subject array\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {Object|Boolean}           The item if found, false otherwise\n */\nfunction getRow(arr, prop, val, operator) {\n    if (val === void 0) { val = null; }\n    if (operator === void 0) { operator = '='; }\n    var idx = search(arr, prop, val, operator);\n    if (idx > -1) {\n        return arr[idx];\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/_deleteLoader.js\n\n\n\n/**\n * Deletes a loader and changes its history state after the promise is fullfilled.\n *\n * @method   _deleteLoader\n * @global\n * @ignore\n * @memberof bbn.fn\n *\n * @param    {String}  requestId   The unique ID of the request sent\n * @param    {String|Object}       res     The result of the request\n * @param    {Boolean} isAbort True if the deletion comes from abortion\n *\n * @returns  {Boolean} True if the loader was found\n */\nfunction _deleteLoader(requestId, res, isAbort) {\n    if (res === void 0) { res = null; }\n    if (isAbort === void 0) { isAbort = false; }\n    var idx = search(bbn.env.loaders, { key: requestId });\n    if (idx > -1) {\n        var loader = bbn.env.loaders.splice(idx, 1)[0];\n        var history_1 = getRow(bbn.env.loadersHistory, { key: requestId, start: loader.start });\n        if (history_1) {\n            history_1.loading = false;\n            history_1.duration = new Date().getTime() - loader.start;\n            if (typeof res === 'string') {\n                history_1.errorMessage = res;\n                history_1.error = !isAbort;\n                history_1.abort = isAbort;\n            }\n            else if (isObject_isObject(res)) {\n                history_1.success = true;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/getLoader.js\n\n/**\n * Finds the loader object corresponding to the given unique ID and returns it if found.\n *\n * The loader is an object representing an Ajax request, with the following properties:\n * * _key_ is the unique ID (_requestId_) of the loader\n * * _url_ is the URL called by the request\n * * _loader_ is the Promise from the Axios XHR\n * * _source_ is the source object for aborting the request\n * * _start_ is the timestamp of the moment the request was sent\n *\n * @method   getLoader\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.post('my/script', {a: 1, b: 2});\n * let requestId = bbn.fn.getRequestId('my/script', {a: 1, b: 2});\n * if (requestId) {\n *   let loader = bbn.fn.getLoader(requestId);\n *   console.log(loader);\n *   // {\n *   //    key: \"my/script:af27f0e81533ae2bae3c25dea67359f6\",\n *   //    url: \"my/script\",\n *   //    loader: {Promise},\n *   //    source: {token: {CancelToken}, cancel: {Function}},\n *   //    start: 1591804716757\n *   // }\n * }\n * ```\n *\n * @param    {String} requestId The unique ID of the request as used in bbn.env.loaders\n *\n * @returns  {null|Object} The corresponding loader Object if it exists, false otherwise\n */\nfunction getLoader(requestId) {\n    var idx = search(bbn.env.loaders, { key: requestId });\n    if (idx > -1) {\n        return bbn.env.loaders[idx];\n    }\n    return null;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/abort.js\n\n/**\n * Aborts (client side) the XHR corresponding to the given ID if it still exists.\n *\n * This will throw an error if the loader can't be found.\n *\n * @method   abort\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.post('my/script', {a: 1, b: 2});\n * let requestId = bbn.fn.getRequestId('my/script', {a: 1, b: 2});\n * if (requestId) {\n *   bbn.fn.abort(requestId);\n * }\n * ```\n *\n * @param    {String} requestId An ID generated by getRequestId\n *\n * @returns  {undefined}\n */\nfunction abort(requestId) {\n    var loader = getLoader(requestId);\n    if (loader === null || loader === void 0 ? void 0 : loader.aborter) {\n        loader.aborter.abort('Operation canceled by the user.');\n    }\n    /*\n    else {\n        throw new Error(\"Impossible to find the loader \" + requestId);\n    }*/\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/filter.js\n\n\n\n\n/**\n * Returns a new array with only the data matching the given filter.\n *\n * The filtering arguments follow the same scheme as bbn.fn.search.\n *\n * @method   filter\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * ];\n * bbn.fn.filter(ar, {director: \"Steven Spielberg\"});\n * // [\n * //   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n * //   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * // ]\n * bbn.fn.filter(ar, \"director\", \"Steven Spielberg\");\n * // Same result as the previous example\n * bbn.fn.filter(ar, {\n *   logic: \"OR\",\n *   conditions: [\n *     {\n *        field: \"director\",\n *        value: \"Richard Donner\"\n *     }, {\n *        field: \"director\",\n *        value: \"George Lucas\"\n *     }\n *   ]\n * );\n * // [\n * //   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n * //   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n * // ]\n * ```\n *\n * @memberof bbn.fn\n * @param    {Array}                    arr       The subject array\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {Array}                    A new filtered array\n */\nfunction filter(arr, prop, val, operator) {\n    if (val === void 0) { val = null; }\n    if (operator === void 0) { operator = '='; }\n    if (!isArray_isArray(arr)) {\n        bbn.fn.log(\"NOT ARRAY\", arr);\n        throw new Error('Error in filter: The first argument must be an array');\n    }\n    var cfg = {};\n    var res = [];\n    var isFn = typeof (prop) === 'function';\n    if (!prop || !arr.length) {\n        return arr;\n    }\n    if (arr.length) {\n        if (typeof prop === 'object') {\n            operator = val;\n            cfg = prop;\n        }\n        else if (typeof prop === 'string') {\n            cfg[prop] = val;\n        }\n        else if (!isFn) {\n            throw new Error('Search function error: The prop argument should be a string or an object');\n        }\n        if (typeof (prop) === 'function') {\n            each(arr, function (a, i) {\n                if (prop(a, i)) {\n                    res.push(a);\n                }\n            });\n        }\n        else {\n            cfg = filterToConditions(cfg, operator);\n            if (cfg.conditions && cfg.logic) {\n                each(arr, function (a) {\n                    if (compareConditions(a, cfg)) {\n                        res.push(a);\n                    }\n                });\n            }\n        }\n        return res;\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/abortURL.js\n\n\n/**\n * Aborts (client side) all the XHR using the given URL if it still exists.\n *\n * This will throw an error if the loader can't be found.\n *\n * @method   abortURL\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.post('my/script', {a: 1, b: 2});\n * bbn.fn.post('my/script', {c: 1, d: 2});\n * bbn.fn.abortURL('my/script');\n * ```\n *\n * @param    {String} requestId An ID generated by getRequestId\n *\n * @returns  {undefined}\n */\nfunction abortURL(url) {\n    each(filter(bbn.env.loaders, { url: url }), function (a) {\n        if (a && a.source) {\n            a.source.cancel('Operation canceled by the user.');\n        }\n        else {\n            throw new Error('Impossible to find the loader with URL ' + url);\n        }\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/addColors.js\n\n\n/**\n * Adds the given color to the object bbn.var.colors in order to be able to use\n * the css classes bbn-bg-myColor for the background and bbn-myColor for the text color.\n *\n * @method   addColors\n * @global\n * @example\n * ```javascript\n * //<div class=\"bbn-bg-maroon\">background</div> <span class=\"bbn-maroon\">text color</span>\n * bbn.fn.addColors({maroon: '#800000'});\n * ```\n * @memberof bbn.fn\n * @param    {Object} colors\n * @returns\n */\nfunction addColors(colors) {\n    if (numProperties(colors)) {\n        if (!bbn.var.colors) {\n            bbn.var.colors = {};\n        }\n        var element = document.createElement(\"style\");\n        document.head.appendChild(element);\n        var sheet_1 = element.sheet;\n        // Append style element to head\n        var i_1 = 0;\n        iterate(colors, function (v, n) {\n            bbn.var.colors[n] = v;\n            sheet_1.insertRule(\".bbn-\" +\n                n +\n                \", .bbn-color-text-\" +\n                n +\n                \" {color: \" +\n                v +\n                \" !important;}\", i_1);\n            sheet_1.insertRule(\"svg.bbn-\" +\n                n +\n                \", .bbn-\" +\n                n +\n                \" svg, svg.bbn-color-text-\" +\n                n +\n                \", .bbn-color-text-\" +\n                n +\n                \" svg {fill: \" +\n                v +\n                \";}\", i_1);\n            sheet_1.insertRule(\".bbn-bg-\" +\n                n +\n                \", .bbn-color-bg-\" +\n                n +\n                \", .bbn-color-background-\" +\n                n +\n                \" {background-color: \" +\n                v +\n                \" !important;}\", i_1);\n            sheet_1.insertRule(\".bbn-border-\" +\n                n +\n                \", .bbn-color-border-\" +\n                n +\n                \" {border-color: \" +\n                v +\n                \" !important;}\", i_1);\n            sheet_1.insertRule(\".bbn-color-\" +\n                n +\n                \" {border-color: \" +\n                v +\n                \"; background-color: \" +\n                v +\n                \"; color: \" +\n                v +\n                \";}\", i_1);\n        });\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/form/addInputs.js\n\n/**\n * Adds the given data to the given form by inserting hidden inputs.\n *\n * @method   addInputs\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * let o = {name: \"Smith\", fname: \"John\"};\n * bbn.fn.addInputs(document.getElementById('myform'), o, 'bbn');\n * // Will write at the end of the given form:\n * // <input type=\"hidden\" name=\"bbn[name]\" value=\"Smith\">\n * // <input type=\"hidden\" name=\"bbn[fname]\" value=\"John\">\n *\n * ```\n *\n * @example\n * ```javascript\n * let o = {\n *   People: [\n *     {name: \"Smith\", fname: \"John\"},\n *     {name: \"Smith\", fname: \"Eileen\"}\n *   ],\n *   Dates: ['2021-08-25', '2021-09-06']\n * };\n * bbn.fn.addInputs(document.getElementById('myform'), o);\n * // Will write at the end of the given form:\n * // <input type=\"hidden\" name=\"People[0][name]\" value=\"Smith\">\n * // <input type=\"hidden\" name=\"People[0][fname]\" value=\"John\">\n * // <input type=\"hidden\" name=\"People[1][name]\" value=\"Smith\">\n * // <input type=\"hidden\" name=\"People[1][fname]\" value=\"Eileen\">\n * // <input type=\"hidden\" name=\"Dates[0]\" value=\"2021-08-25\">\n * // <input type=\"hidden\" name=\"Dates[1]\" value=\"2021-09-06\">\n * ```\n *\n * @param    {HTMLElement} form   The form to which the inputs should be added\n * @param    {Object}      params The data which will be added\n * @param    {String}      prefix The optional object's name of the fields in the form\n * @returns  {undefined}\n */\nfunction addInputs(form, params, prefix) {\n    if (params === void 0) { params = null; }\n    if (prefix === void 0) { prefix = ''; }\n    if (form && form.tagName === 'FORM') {\n        var appendToForm_1 = function (name, val) {\n            var input = document.createElement('input');\n            input.setAttribute('type', 'hidden');\n            input.setAttribute('name', name);\n            input.setAttribute('value', val);\n            form.appendChild(input);\n        };\n        params = JSON.parse(JSON.stringify(params || {}));\n        prefix = prefix || '';\n        if (params) {\n            iterate(params, function (param, key) {\n                var name = prefix ? \"\".concat(prefix, \"[\").concat(key, \"]\") : key;\n                if (param instanceof Date) {\n                    appendToForm_1(name, param.toISOString());\n                }\n                else if (param instanceof Array) {\n                    param.forEach(function (e, i) {\n                        var tempName = \"\".concat(name, \"[\").concat(i, \"]\");\n                        if (typeof e === 'object') {\n                            addInputs(form, e, tempName);\n                        }\n                        else {\n                            appendToForm_1(tempName, e.toString());\n                        }\n                    });\n                }\n                else if (typeof param === 'object' && !(param instanceof File)) {\n                    addInputs(form, param, name);\n                }\n                else {\n                    appendToForm_1(name, param.toString());\n                }\n            });\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/addStyle.js\n\n\n/**\n * @ignore\n * @method   addStyle\n * @todo     Add method description for addStyle\n * @global\n * @memberof bbn.fn\n * @param    {HTMLElement} ele\n * @param    {Object}      o\n * @returns  {*}\n */\nfunction addStyle(ele, o) {\n    if (isObject_isObject(o)) {\n        iterate(o, function (v, k) {\n            ele.style[k] = v;\n        });\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/adjustSize.js\n\nfunction adjustSize(type, eles) {\n    var max = 0, idx;\n    each(eles, function (el) {\n        el.style[type] = 'auto';\n    });\n    each(eles, function (el, i) {\n        var rect = el.getBoundingClientRect(), s = rect[type] % 1 ? rect[type] - (rect[type] % 1) + 1 : rect[type];\n        //s = rect[type];\n        if (s > max) {\n            max = s;\n            idx = i;\n        }\n    });\n    each(eles, function (el, i) {\n        if (max) {\n            el.style[type] = max + 'px';\n        }\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/adjustHeight.js\n\n\nfunction adjustHeight() {\n    var args = arguments;\n    if (args.length === 1 && isIterable(args[0])) {\n        args = args[0];\n    }\n    return adjustSize('height', args);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/adjustWidth.js\n\n\nfunction adjustWidth() {\n    var args = arguments;\n    if (args.length === 1 && isIterable(args[0])) {\n        args = args[0];\n    }\n    return adjustSize('width', args);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/escapeRegExp.js\n/**\n * Returns a string escaped.\n *\n * To escape the string by reducing the ambiguity between quotation marks and other characters used.\n *\n * @method   escapeRegExp\n * @global\n *\n * @example\n * ```javascript\n * //\"this\\/is\\/a\\/test\\/string\"\n * bbn.fn.escapeRegExp(\"this/is/a/test/string\");\n * ```\n * @memberof bbn.fn\n * @param    {String} str\n * @returns  {String} string with escape\n */\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/replaceAll.js\n\n\n/**\n * Looks for and replaces parts of string with what we want.\n *\n * With the first argument you define what to replace,\n * the second argument with what you have to replace instead and the third argument is the string to be replaced.\n *\n * @method   replaceAll\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.replaceAll('day', 'night', 'Today is a beautiful day');\n * //\"Tonight is a beautiful night\"\n * ```\n * @memberof bbn.fn\n * @param    {String} find\n * @param    {String} replace\n * @param    {String|RegExp} str\n * @param    {String} flags\n * @returns  {String}\n */\nfunction replaceAll(find, replace, str, flags) {\n    if (flags === void 0) { flags = \"\"; }\n    return str\n        .toString()\n        .replace(isObject_isObject(find) ? find : new RegExp(escapeRegExp(find), \"g\" + flags), replace);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/getRequestId.js\n\n\n/**\n * Returns a unique ID for a \"loader\" based on the URL, the data keys and the datatype.\n *\n * The routing functions don't allow to send the same request at the same moment,\n * therefore a unique ID is generated to identify them, based on the URL,\n * the keys of the data sent, and the expected returned data type.\n *\n * @method   getRequestId\n * @global\n *\n * @example\n * ```javascript\n * // The URL is the first part of the key\n * bbn.fn.getRequestId('my/location', {a: 1, b: 2});\n * // my/location:af27f0e81533ae2bae3c25dea67359f6\n * bbn.fn.getRequestId('my/other/location', {a: 1, b: 2});\n * // my/other/location:af27f0e81533ae2bae3c25dea67359f6\n * ```\n *\n * @example\n * ```javascript\n * // A change of value will not change the requestId\n * bbn.fn.getRequestId('my/location', {a: 1, b: 3});\n * // my/location:af27f0e81533ae2bae3c25dea67359f6\n * // A change of key will\n * bbn.fn.getRequestId('my/location', {a: 1, c: 3});\n * // my/location:fde97ca7c6c998c911f4ab481a136d5f\n * ```\n *\n * @example\n * ```javascript\n * // Same with nested object\n * bbn.fn.getRequestId('my/location', {data: {a: 1, b: 3}});\n * // my/location:a7a58435275054106c4e4c9fb0cea5e5\n * bbn.fn.getRequestId('my/location', {data: {a: 1, b: 2}});\n * // my/location:a7a58435275054106c4e4c9fb0cea5e5\n * bbn.fn.getRequestId('my/location', {data: {a: 1, c: 3}});\n * // my/location:730da481e30d421afbadf1f1282dabb7\n * ```\n *\n * @memberof bbn.fn\n *\n * @param    {String} url      The URL used by the request\n * @param    {Object} data     The data sent to the URL\n * @param    {String} datatype The type of data requested (JSON by default)\n *\n * @returns  {String} The unique ID\n */\nfunction getRequestId(url, data, datatype) {\n    var d = {};\n    if (data) {\n        iterate(data, function (a, n) {\n            if (n.indexOf('_bbn') === -1) {\n                d[n] = a;\n            }\n        });\n    }\n    return url + ':' + md5((datatype || 'json') + JSON.stringify(d));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/extend.js\n\n\n\n\n/**\n * Merges the contents of two or more objects together into the first object.\n *\n * A boolean true argument can be done to operate a deep extend. In this case,\n * the content of properties or subproperties arrays and objects will also be merged.\n *\n * @method   extend\n * @global\n * @example\n * ```javascript\n * bbn.fn.extend(\n *   {prop1: 10, prop2: 20},\n *   {prop1: 11, prop3: 21},\n *   {prop2: 22, prop4: false},\n *   {prop5: false, prop3: 45}\n * );\n * // {prop1: 11, prop2: 22, prop3: 45, prop4: false, prop5: false}\n * ```\n * @example\n * ```javascript\n * bbn.fn.extend(\n *   {\n *     prop1: [3, 5, 6],\n *     prop2: {\n *       subprop1: 87,\n *       subprop2: 100\n *     }\n *   }, {\n *     prop1: 11,\n *     prop3: [8, 12, {aProperty: 1, anotherProperty: true}, 26]\n *   }, {\n *     prop2: {\n *       subprop1: 90,\n *       subprop3: 25\n *     },\n *     prop4: false\n *   }, {\n *     prop5: false,\n *     prop3: [8, 45, {anotherProperty: false, andAnother: true}]\n *   }\n * );\n * // {\n * //   prop1: 11,\n * //   prop2: {subprop1: 90, subprop3: 25},\n * //   prop3: [8, 45, {anotherProperty: false, andAnother: true}],\n * //   prop4: false,\n * //   prop5: false\n * // }\n * ```\n * @example\n * ```javascript\n * // Deep\n * bbn.fn.extend(\n *   true,\n *   {\n *     prop1: [3, 5, 6],\n *     prop2: {\n *       subprop1: 87,\n *       subprop2: 100\n *     }\n *   }, {\n *     prop1: 11,\n *     prop3: [8, 12, {aProperty: 1, anotherProperty: true}, 26]\n *   }, {\n *     prop2: {\n *       subprop1: 90,\n *       subprop3: 25\n *     },\n *     prop4: false\n *   }, {\n *     prop5: false,\n *     prop3: [8, 45, {anotherProperty: false, andAnother: true}]\n *   }\n * );\n * // {\n * //   prop1: 11,\n * //   prop2: {subprop1: 90, subprop3: 25},\n * //   prop3: [8, 45, {aProperty: 1, anotherProperty: false, andAnother: true}, 26],\n * //   prop4: false,\n * //   prop5: false\n * // }\n * ```\n * @memberof bbn.fn\n * @returns  {Object} The first object argument, merged with the other objects given\n */\nfunction extend_extend() {\n    var originalArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        originalArgs[_i] = arguments[_i];\n    }\n    var deep = false;\n    var args = [];\n    for (var i = 0; i < originalArgs.length; i++) {\n        if (originalArgs[i] === true) {\n            deep = true;\n        }\n        else if (!originalArgs[i]) {\n            continue;\n        }\n        else if (typeof originalArgs[i] !== \"object\") {\n            throw new Error(bbn._(\"Error in extend: all arguments should be object, you have given \") + typeof originalArgs[i]);\n        }\n        else {\n            args.push(originalArgs[i]);\n        }\n    }\n    if (!args.length) {\n        throw new Error(\"No argument given\");\n    }\n    var out = args[0];\n    for (var i = 1; i < args.length; i++) {\n        iterate(args[i], function (a, key) {\n            if (deep) {\n                if (isArray_isArray(a)) {\n                    out[key] = isArray_isArray(out[key]) ? out[key] : [];\n                    each(a, function (b, i) {\n                        if (b && typeof b === \"object\") {\n                            var tmp = out[key][i];\n                            if (isArray_isArray(b)) {\n                                if (!isArray_isArray(tmp)) {\n                                    tmp = [];\n                                }\n                            }\n                            else if (!isObject_isObject(tmp)) {\n                                tmp = {};\n                            }\n                            out[key][i] = extend_extend(true, tmp, b);\n                        }\n                        else {\n                            out[key][i] = b;\n                        }\n                    });\n                }\n                else if (isObject_isObject(a)) {\n                    out[key] = extend_extend(true, out[key] && typeof out[key] === \"object\"\n                        ? out[key]\n                        : Object.create(Object.getPrototypeOf(a)), a);\n                }\n                else {\n                    out[key] = a;\n                }\n            }\n            else if ((out[key] !== a) || ((a === undefined) && !Object.prototype.hasOwnProperty.apply(out, [key]))) {\n                out[key] = a;\n            }\n        });\n        if (args[i].__bbnNoData) {\n            Object.defineProperty(out, \"__bbnNoData\", {\n                value: true,\n                enumerable: false,\n                configurable: false,\n                writable: false,\n            });\n        }\n    }\n    return out;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/ajax.js\n\n\n\n\n\n\n\n\n\n/**\n * Creates an XHR object and returns the Promise.\n *\n * Checks the URL, makes an ID, creates a loader, sets the general callbacks,\n * makes a POST if data is given a GET otherwise (GET data should be added\n * directly in the URL), and returns the Promise.\n *\n * @method   ajax\n * @global\n * @memberof bbn.fn\n * @example\n * ```javascript\n * // Promise\n * bbn.fn.ajax(\n *   'my/location',\n *   'json',\n *   {id: 7},\n *   d => {\n *     console.log(d);\n *     alert(\"Success!\");\n *   },\n *   err => {\n *     console.log(err);\n *     alert(\"Failure!\");\n *   },\n *   () => {\n *     alert(\"Request aborted!\");\n *   }\n * )\n * ```\n *\n * @example\n * ```javascript\n * // Promise\n * bbn.fn.ajax('my/location')\n *   .then(\n *     d => {\n *       console.log(d);\n *       alert(\"Success!\");\n *     }\n *   )\n *   .catch(\n *     err => {\n *     }\n *   )\n * ```\n *\n * @param    {String}   url      The URL to be requested by XHR\n * @param    {String}   datatype The type of data expected\n * @param    {Object}   data     The data to send through POST\n * @param    {Function} success  The function to execute if the request goes well (200)\n * @param    {Function} failure  The function to execute if the request goes bad\n * @param    {Function} abort    The function to execute if the request is aborted\n *\n * @returns  {Promise}  The Promise created by the generated XHR.\n */\nfunction ajax(url, datatype, data, success, failure, abort) {\n    if (datatype === void 0) { datatype = null; }\n    if (data === void 0) { data = null; }\n    if (success === void 0) { success = null; }\n    if (failure === void 0) { failure = null; }\n    if (abort === void 0) { abort = null; }\n    if (arguments.length === 1 && url && typeof url === \"object\" && url.url) {\n        if (url.abort) {\n            abort = url.abort;\n        }\n        if (url.failure) {\n            failure = url.failure;\n        }\n        if (url.success) {\n            success = url.success;\n        }\n        if (url.data) {\n            data = url.data;\n        }\n        if (url.datatype) {\n            datatype = url.datatype;\n        }\n        url = url.url;\n    }\n    if (!url) {\n        return;\n    }\n    if (url && typeof url === \"string\") {\n        if (url.indexOf(\"://\") === -1) {\n            // Prevent protocol mismatch by Axios\n            url = replaceAll(\"//\", \"/\", url);\n        }\n        if (!datatype) {\n            datatype = \"json\";\n        }\n        var requestId_1 = getRequestId(url, data, datatype);\n        var loaderObj = getLoader(requestId_1);\n        //log(\"IN AJAX\", loaderObj? loaderObj.loader : \"NO LOADER\")\n        if (loaderObj === null || loaderObj === void 0 ? void 0 : loaderObj.loader) {\n            return loaderObj.loader;\n        }\n        if (bbn.env.token) {\n            extend_extend(data || {}, { _bbn_token: bbn.env.token });\n        }\n        var aborter = new AbortController();\n        var options = {\n            responseType: datatype,\n            signal: aborter.signal\n        };\n        if (datatype === \"text\") {\n            options['headers'] = {\n                accept: \"text/javascript\",\n                \"Content-Type\": \"text/javascript\",\n            };\n        }\n        var args = [url];\n        if (isObject_isObject(data) && numProperties(data) > 0) {\n            args.push(data);\n        }\n        args.push(options);\n        var axiosMethod = args.length === 2 ? \"get\" : \"post\";\n        var loader_1 = axios[axiosMethod]\n            .apply(null, args)\n            .then(function (res) {\n            _deleteLoader(requestId_1, res);\n            bbn.fn.defaultEndLoadingFunction(url, tst_1, data, res);\n            switch (res.status) {\n                case 200:\n                    if (isFunction_isFunction(success)) {\n                        success(res.data, res.headers);\n                    }\n                    break;\n                default:\n                    bbn.fn.defaultAjaxErrorFunction(loader_1, res);\n            }\n            return res;\n        })\n            .catch(function (err) {\n            var isAbort = axios.isCancel(err);\n            _deleteLoader(requestId_1, err.message || err.response.data, isAbort);\n            bbn.fn.defaultEndLoadingFunction(url, tst_1, data, err);\n            if (isAbort) {\n                var ok = 1;\n                if (isFunction_isFunction(abort)) {\n                    ok = abort(err.message, url);\n                }\n                if (ok) {\n                    bbn.fn.defaultAjaxAbortFunction(err.message, url);\n                }\n            }\n            else {\n                var ok = 1;\n                if (isFunction_isFunction(failure)) {\n                    ok = failure(err.request, err);\n                }\n                if (ok) {\n                    bbn.fn.defaultAjaxErrorFunction(err.request, err.response ? err.response.data : \"\", err.response ? err.response.status : err);\n                }\n            }\n        });\n        var tst_1 = _addLoader(requestId_1, loader_1, aborter);\n        bbn.fn.defaultStartLoadingFunction(url, tst_1, data, requestId_1);\n        return loader_1;\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/animateCss.js\n/**\n * @ignore\n * @method   animateCss\n * @todo     Add method description for animateCss\n * @global\n * @memberof bbn.fn\n * @param    {HTMLElement} ele\n * @param    {String}      animationName\n * @param    {Function}    callback\n * @returns  {*}\n */\nfunction animateCss(ele, animationName, callback) {\n    var animationEnd = \"webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend\";\n    /*$(ele).addClass('animated ' + animationName).one(animationEnd, function(){\n          if ( typeof callback == 'function' ){ // make sure the callback is a function\n            callback.call(this); // brings the scope to the callback\n          }\n          $(this).removeClass('animated ' + animationName);\n        })*/\n    ele.classList.add(\"animated\");\n    ele.classList.add(animationName);\n    ele.addEventListener(animationEnd, function animationEndHandler(e) {\n        e.target.removeEventListener(e.type, animationEndHandler);\n        if (typeof callback == \"function\") {\n            // make sure the callback is a function\n            callback.call(this); // brings the scope to the callback\n        }\n        e.target.classList.remove(animationName);\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/arrayBuffer2String.js\nfunction arrayBuffer2String(buf) {\n    return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/arrayFromProp.js\n\n\n/**\n * Creates and returns a new array made of the given property's values from the given array of objects.\n *\n * The returned array will always have the same length of the given array, even if the property is not found.\n *\n * @method   arrayFromProp\n * @global\n * @example\n * ```javascript\n * bbn.fn.arrayFromProp([\n *   {movie: \"Brazil\", year: 1985},\n *   {movie: \"Donnie Darko\", year: 2001},\n *   {movie: \"Barry Lindon\", year: 1976}\n * ], \"year\");\n * // [1985, 2001, 1976]\n * ```\n * @example\n * ```javascript\n * bbn.fn.arrayFromProp([\n *   {pupil: \"Agnes Varda\", grade: {year: \"B\", month: \"A\"}},\n *   {pupil: \"Jacques Rivette\"},\n *   {pupil: \"Luc Besson\", grade: {year: \"C\", month: \"D\"}},\n *   {pupil: \"Nicole Garcia\", grade: {year: \"B\", month: \"B\"}}\n * ], \"grade.month\");\n * // [\"A\", undefined, \"D\", \"B\"]\n * ```\n * @memberof bbn.fn\n * @param    {Array}  arr\n * @param    {String} prop\n * @returns  {Array}  The new array\n */\nfunction arrayFromProp(arr, prop) {\n    var r = [];\n    each(arr, function (a, i) {\n        r.push(getProperty(a, prop));\n    });\n    return r;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/autoExtend.js\n\n/**\n * Extends the bbn object by passing the namespace and the object it will merge with.\n *\n * This function is a self-centric shortcut for adding functions or proerties\n * to the bbn object itself.\n *\n * @method   autoExtend\n * @global\n * @example\n * ```javascript\n * bbn.fn.autoExtend(\"fn\", {myOwnFunction: () => \"Result of my own function\"});\n * bbn.fn.myOwnFunction();\n * // Result of my own function\n * ```\n * @example\n * ```javascript\n * bbn.fn.autoExtend(\"env\", {serverLanguage: \"php\"});\n * bbn.env.sercerLanguage\n * // php\n * ```\n * @example\n * ```javascript\n * bbn.fn.autoExtend(\"myProject\", {name: \"My Project\"});\n * bbn.myProject.name\n * // Project\n * ```\n * @memberof bbn.fn\n * @param    {String}    namespace The bbn property, existing or not, in which the object will be merged\n * @param    {Object}    obj       The object to merge\n * @returns  {undefined} No return value\n */\nfunction autoExtend(namespace, obj) {\n    if (!bbn[namespace]) {\n        bbn[namespace] = {};\n        //$.extend(true, bbn[namespace], obj);\n        extend_extend(bbn[namespace], obj);\n    }\n    else {\n        // $.extend(true, bbn[namespace], obj);\n        extend_extend(bbn[namespace], obj);\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/baseName.js\n\n\n/**\n * Returns the name of the element indicated by path given to it as an argument.\n *\n * @method   baseName\n * @global\n *\n * @example\n * ```javascript\n * // \"file.png\"\n * bbn.fn.baseName('folder/other_folder/file.png');\n * ```\n * @example\n * ```javascript\n * // \"file\"\n * bbn.fn.baseName('folder/other_folder/file.png', '.png');\n * ```\n *\n * @memberof bbn.fn\n * @param    {String} path   The path from which the basename must be extracted\n * @param    {String} suffix An optional suffix that will be removed from the basename\n * @returns  {String} The basename of path\n */\nfunction baseName(path, suffix) {\n    if (path && isString_isString(path)) {\n        var bits = path.split(\"/\");\n        var res = bits.pop();\n        if (!suffix) {\n            return res;\n        }\n        var len = suffix.length;\n        if (res && substr(res, -len) === suffix) {\n            return substr(res, 0, res.length - len);\n        }\n    }\n    return \"\";\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/br2nl.js\n\n/**\n * Replaces the html <br> tag with new line characters '\\ n' if present in the string.\n *\n * @method   br2nl\n * @global\n *\n * @example\n * ```javascript\n * //\"hello\n * //world!\"\n * bbn.fn.br2nl('hello <br> world!')\n * ```\n *\n * @memberof bbn.fn\n * @param    string st\n * @returns  {String}\n */\nfunction br2nl(st) {\n    return replaceAll(\"<br />\", \"\\n\", replaceAll(\"<br/>\", \"\\n\", replaceAll(\"<br>\", \"\\n\", st)));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/date.js\n\n\n\n/**\n * Returns a date object from the given argument.\n *\n * @method   date\n * @global\n *\n * @example\n * ``` javascript\n * //Mon Feb 11 2019 12:00:00 GMT+0100 (Central European Standard Time)\n * bbn.fn.date('2019/02/11')\n * ```\n *\n * @memberof bbn.fn\n * @param    {String|Number} v\n * @returns  {date}\n */\nfunction date(v) {\n    var d = false, t = typeof v;\n    if (v === undefined) {\n        return new Date();\n    }\n    if (t === 'number' || (isNumber_isNumber(v) && v !== '')) {\n        if (v < 10000000000) {\n            v = v * 1000;\n        }\n        return new Date(v);\n    }\n    if (t === 'string') {\n        if (v.length === 10) {\n            return new Date(parseInt(substr(v, 0, 4)), parseInt(substr(v, 5, 2)) - 1, parseInt(substr(v, 8, 2)), 12);\n        }\n        else if (v.length === 19) {\n            return new Date(parseInt(substr(v, 0, 4)), parseInt(substr(v, 5, 2)) - 1, parseInt(substr(v, 8, 2)), parseInt(substr(v, 11, 2)), parseInt(substr(v, 14, 2)), parseInt(substr(v, 17, 2)));\n        }\n    }\n    else if (isDate_isDate(v)) {\n        return v;\n    }\n    return d;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/fdatetime.js\n\n\n\n/**\n * @method   fdatetime\n * @todo     Add method description for fdatetime\n * @global\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction fdatetime(d, wrong_result) {\n    if (wrong_result === void 0) { wrong_result = false; }\n    var r = date(d);\n    if (!isDate_isDate(r)) {\n        return wrong_result && isString_isString(wrong_result) ? wrong_result : '';\n    }\n    if (undefined !== dayjs) {\n        //return dayjs(r).format('lll');\n        return dayjs(r).calendar(null, {\n            sameDay: '[' + bbn._('Today') + '] HH:mm',\n            nextDay: '[' + bbn._('Tomorrow') + '] HH:mm',\n            nextWeek: 'ddd D HH:mm',\n            lastDay: '[' + bbn._('Yesterday') + '] HH:mm',\n            lastWeek: 'ddd D HH:mm',\n            sameElse: 'DD/MM/YYYY HH:mm',\n        });\n        //return dayjs(r).format(\"DD/MM/YYYY HH:mm\")\n    }\n    return r.toLocaleDateString();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/fdate.js\n\n\n\n\n/**\n * @method   fdate\n * @todo     Add method description for fdate\n * @global\n * @memberof bbn.fn\n * @param    {String|Date} d\n * @param    {String}      wrong_result\n * @returns\n */\nfunction fdate(d, wrong_result) {\n    if (wrong_result === void 0) { wrong_result = false; }\n    // Retro compatibility\n    if (wrong_result === true) {\n        return fdatetime(d);\n    }\n    var r = date(d);\n    if (!isDate_isDate(r)) {\n        return wrong_result && isString_isString(wrong_result) ? wrong_result : '';\n    }\n    if (undefined !== dayjs) {\n        return dayjs(r).format('L');\n    }\n    return r.toLocaleDateString();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/calendar.js\n\n\n\n\n\n\n\nvar calendar_bbn = {\n    _: function (st) { return st; }\n};\ndayjs_min.extend(calendar);\ndayjs_min.extend(isLeapYear);\n/**\n * Returns a date relative to the current day.\n *\n * @method   calendar\n * @global\n *\n * @example\n * ``` javascript\n * //\"2020-04-16 16:15:23\"\n * let date = new Date();\n * bbn.fn.dateSQL(date,false);\n * ```\n *\n * @memberof bbn.fn\n * @param    {Date|String} d\n * @param    {String | Boolean} wrong_result Whether or not include the time in the date\n * @returns  {String}\n */\nfunction calendar_calendar(d, wrong_result) {\n    if (wrong_result === void 0) { wrong_result = false; }\n    if (undefined === dayjs_min) {\n        return fdate(d, wrong_result);\n    }\n    var r = date(d);\n    if (!isDate_isDate(r)) {\n        return wrong_result && isString_isString(wrong_result) ? wrong_result : '';\n    }\n    return dayjs_min(r).calendar(null, {\n        sameDay: '[' + calendar_bbn._('Today') + ']',\n        nextDay: '[' + calendar_bbn._('Tomorrow') + ']',\n        nextWeek: 'ddd D',\n        lastDay: '[' + calendar_bbn._('Yesterday') + ']',\n        lastWeek: 'ddd D',\n        sameElse: 'L',\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/callback.js\n\n\n\n/**\n * Executes a serie of predefined actions once an Ajax request has been done.\n *\n * Used to treat all the requests functions results, it expects at least url and res to be defined;\n * The following properties from the object res have direct effects:\n * - __url__ {String}: if not given it will be automatically defined by the url parameter;\n *   __the given URL will be passed to location.href (without reloading)__\n * - __prescript__ {String}: if defined it will attempt to evaluate the code contained in the property\n * - __content__ {String}: if defined and ele is defined too, the string will be inserted as content in the element\n * - __script__ {String}: if defined it will be evaluated, executed, and its result will be returned\n * - __data__ {Object}:\n * - __postscript__ {String}: if defined it will be evaluated and executed\n * - __error__ {String}: if defined it will be trigger bbn.fn.defaultAlertFunction\n *\n * If fn is defined it will be executed after prescript, otherwise it will be bbn.fn.defaultLinkFunction.\n *\n * The rest of the function comes executed if either of these results is not empty.\n *\n * If fn2 is defined it will be executed after script, otherwise it will be bbn.fn.defaultPostLinkFunction.\n *\n * Although not private this function should only be used internally.\n *\n * @method   callback\n * @todo     Add method description for callback\n * @global\n * @memberof bbn.fn\n *\n * @param    {String}      url The URL that has been called\n * @param    {Object}      res The object returned by the request\n * @param    {Function}    fn  A first callback function to execute\n * @param    {Function}    fn2 A second callback function to execute\n * @param    {HTMLElement} ele A DOM element where the content will be inserted\n *\n * @returns  {*} The result of the main callback function: res.script, fn, or bbn.fn.defaultLinkFunction\n */\nfunction callback(url, res, fn, fn2, ele) {\n    if (res === void 0) { res = null; }\n    if (fn === void 0) { fn = null; }\n    if (fn2 === void 0) { fn2 = null; }\n    if (ele === void 0) { ele = null; }\n    var tmp = false;\n    if (res) {\n        tmp = true;\n        var t = typeof res;\n        var isObj = t.toLowerCase() === 'object';\n        var errTitle = void 0;\n        if (isObj && res.prescript) {\n            /* var ok can be changed to false in prescript execution */\n            try {\n                var preFn = new Function(res.prescript);\n                preFn();\n            }\n            catch (e) {\n                error(e.message || '');\n            }\n        }\n        if (isObj && res.url === undefined) {\n            res.url = url;\n        }\n        /* Case where a callback is defined */\n        if (fn && isFunction_isFunction(fn)) {\n            tmp = fn(res, ele);\n        }\n        else {\n            tmp = bbn.fn.defaultLinkFunction(res, ele);\n        }\n        if (ele && isObj && (res.content !== undefined)) {\n            if ('value' in ele) {\n                ele.value = res.content;\n            }\n            else {\n                ele.innerHTML = res.content;\n            }\n        }\n        if (tmp && isObj && res.script) {\n            if (typeof (res.script) === 'function') {\n                tmp = res.script(res.data ? res.data : {}, ele || null);\n            }\n            else {\n                tmp = (function (data, ele) {\n                    var r = null;\n                    try {\n                        var fnScript = new Function(res.script);\n                        r = fnScript();\n                        if (isFunction_isFunction(r)) {\n                            r = r(data, ele);\n                        }\n                    }\n                    catch (e) {\n                        log(e, res);\n                        error(isFunction_isFunction(e.getMessage) ? e.getMessage() : null);\n                    }\n                    return r;\n                })(res.data ? res.data : {}, ele ? ele : false);\n            }\n        }\n        /* Case where a callback is defined */\n        if (tmp && fn2 && isFunction_isFunction(fn2)) {\n            fn2(res);\n        }\n        else if (isObj && bbn.fn.defaultPostLinkFunction) {\n            bbn.fn.defaultPostLinkFunction(res, ele);\n        }\n        if (tmp && isObj && res.postscript) {\n            var fnPost = new Function(res.postscript);\n            fnPost(res.postscript);\n        }\n        if (isObj && res.error) {\n            errTitle = res.errorTitle || bbn.lng.server_response;\n            bbn.fn.defaultAlertFunction(res.error, errTitle);\n        }\n    }\n    else {\n        bbn.fn.defaultAlertFunction(bbn.lng.errorText, bbn.lng.error);\n    }\n    return tmp;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/camelize.js\n/**\n * Returns the string passed as an argument in camelize mode.\n *\n * A string can be separated for example by a underscore, a dash or space;\n * so the camelize function will automatically convert them to a single string.\n *\n * @method   camelize\n * @global\n *\n * @example\n * ```javascript\n * //\"thisIsATest\"\n * bbn.fn.camelize(\"this_is-a test\");\n * ```\n * @memberof bbn.fn\n * @param    {String} str\n * @returns  {String}\n */\nfunction camelize(str) {\n    return str.replace(/^([A-Z])|[\\s-](\\w)/g, function (match, p1, p2, offset) {\n        if (p2) {\n            return p2.toUpperCase();\n        }\n        return p1.toLowerCase();\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/camelToCss.js\n/**\n * Returns the string passed as an argument in camelize mode for css.\n *\n * @method   camelToCss\n * @global\n *\n * @example\n * ```javascript\n * //\"this-is-a-test\"\n * bbn.fn.camelToCss(\"thisIsATest\");\n * ```\n *\n * @memberof bbn.fn\n * @param   {String} str\n * @returns {String}\n */\nfunction camelToCss(str) {\n    return str\n        .replace(/([A-Z])/g, function (st) {\n        return \"-\" + st.toLowerCase();\n    })\n        .replace(\"/^./\", function (st) {\n        return st.toLowerCase();\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/canvasToImage.js\n/**\n * Returns a canvas in a HTML element img\n * @method   canvasToImage\n * @global\n * ``` javascript\n * //<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAgCAYAAABO6BuSAAAUzUlEQVRYRz2ZWXBc95Xef/f27Xtv7w000AsaADdwh0iKlETRtrbYpi3ZsZNUJaOZcs2MPQ95SSaVrSqVqrykUqmkKp4lNfMwM/Ikk1lijxyrrLEkW5QtS6LMVQt3guAGEGiggUbv611T54+xu6rJJtG493/O+b7vfOdc7RuxUmhGoxiageYF6B5E0dFCndD30cKAqGXg+z66pWOnEnRHPYpTBV7+1m+hj2X5P//7L+jeqRBrjUj1QoqRNLrvE8XCwyCMRhgRMHJHRAiIYxJDJ4K8Qhz5GWBkEhC3WFlbYVdhGqfeJuVHsQPUdzU0PM3CsyJ4tklogE2A6zpomkY0ZhOJ6nhaSBjRiVombuCqu/zypf3PL/yTMBKJoPsa/sjBH3rgBwQjF9d16TRbGJbBYNij2WsT6iFDd8gLp7/Ar3/zN/GSMVpbLb73R6/QWVylGMQY1hpMmuOMHBcHjT4OHpCIJcjEEliBRtAf4DsOqWSGdr/HyAwZRaA56hOPx0noUZIYxAYhtgemrxNqOkHE+FXAkgVTCwlch1CPqMJEDANfRwVsmFGCwCMMQ/UOggDtR//6P4a6rqP7EDgumgdaCHg+nuOqyvphQK/XoTPsEUvY1DsNTn/5y+w8uAd9PKO+f/uDy7z//TcZrdSwHQ2n45BIp3ElYF8C1ojqEXAc/N6QGBFSsTgjb8Sm28C0UoxPFbDTGY7Mz3Pr8qe0KxtMECPmhBiehh6CF4ngRyO4UR1NA9330AMfLRJVAUuQEqwe3f4ssW0H620H/Np/+E+hwEEPQgIvwAx1LIE4xt9nRyMMfQICvMAlOZaiUq3w+S9+ga1+m5nD++i02+QzBRZ++iFnX38bYwROb0TUjrHV6+GGPm4YbCfS8dAdh1hgYBkRuqMBVirGrkP7OXj0KOUds8QnClx6/U0+fPMM8UFIwgXLEwpohJoEbBAYusJ5OmKhE4D8qQUEoYaPJMBAi0DMToAWCEkVqrXv/5f/HIZBgDdycEceJjp21CSiRQh9D0KNqGmgR3Vanaa6SavT4uXf+HXabp9qr0EymSQVmhST41z78BKfXviUfL5IbWuLmX1zdAd9esOBuu5kKosVQm2pwtLSQ1zdZ+7wQeYOHSBXKJJIJakuV1i+vcjP/t8bUOuRcMB2NSIBBBoEuo6no3ib0AzMiIFhmEQimqq0YUYwTVv9WxKhS24ExbqO9vZ3/vhXAXuOCI1U2EYHfNdTMBTOur5DvVUnYuhKGL74pdMMQ5fYWBJDkrFeRxv6dDebvP3jM3z80RXFpcT4OC4BumEwOZZlZ2GKQnacWKDjuyP2zB8gVyqgm1Fc31fJ21qvkcLi0jvv0bhbwR4FRPoefn/E0BkxkLfr4PshfndEzDAxDEFkgE+oPkej23CWZAiktVBTXNXO/fCvBGiEfoAWaOoLZsRUwY5GI9zhSAmWF3pKZS0rSiwZozhVUhCPxqNAQC41xvK9hwollco6r73+JnrMZBh4dIcDBSdLbt4dYnge+6d3Mj9/iGe++CxO4NF3XFw/JJMZI5fIovVd7l25QT6awRz66AMfdzBkNBhuB+06eJ5HMPQx9CiO49BsNmk3mgyHQ/UzeacSSXwRz6HLyBmgXfjxdxWHJQMiChHNUH8PekP6vY66kG2bZLMZVeXBaEgqlSCejpPPT7CyusRseUrdtFarce4XF1l8+JBWr8+Z994lm5+gVt/Ctm1mSmVioQ6DIY8fOMwLzz9DOpdR7SU7llO867UH7JiaZfHGAr2NJtlIDNuPIJgT9ClYahqBgiuM+h521FKf+/2+SoigU4mVD51Oh2F/QLfVpdtuoV1977VQSi6V6Xe6DPtD1ZaEE9GIQSqVYqu+iWWZmKYhlFZipkU1ds6WWVpcIJtJEYsnGToe12/eYml1lbfefYfKxiaT5RJ3794nk0kxv28fq/cesnuqzKkTT1IuFnj+hc8qfnt+oEROojcjUT4+9zFxw8bWTEbtHk5/SMKyFVRFQwS6k/kCth0nYpjYpqUq22q0MXSdRCwOfkjMklRp+I7PcNRHu3X270LJQrvdVYFKr5Q+GCGiILGy/IioGaFQyBONRhgMBmzUqgShx7HHDnPrysdkUkl27Znj+u0F7j5cYml1hffPn1OGQoLodLt02k12l6fZXF2jPDnJP//m72CbOsXCBPv375Wz0ZF2ZafYXK/x0zM/wx0GtBttVbVBt690NhLRGbkOZsykWCpTmpkhm82qt7TRfqdPzLaZyOSwLIt0LKXi8F1ftVjt5s9fD4Xsnucr3gYBGJquVE4CfLS0jB0zyWTSCtry3WvXr7C4uMDeXTthNGRu107agwEeIWubNWrNOj95910erVbYtXs316/f4qknj7F8/z4bK22+8qXPUMwXmD+wl3w+zdHHDrO50WCr0aGQn+LDDy/w8/fOMhx4tNpdwhDava6CbBhKe/QV2jK5cdK5HIVCgVK+QDKeIJPKMF2aojRZVAFLe5UieW6AaZpo1376WigwsaKWykCvN8AZDIlEosRiMfXlmGUqJTYM6YQBZ8++zwcffMBMKc9sqcBnnz6llDhi2bz2xt9R3rGDv/6b7zI1M836+jr1zRqF/ARWJMLqoxVeeO4ZJsbHmCpOUi7lsE2DtUoVy0pQzM/w6g9+yK3bi3T6DoOhCKON4/r0hj3FX1/6ujdSajzyHdLpNKlkkuJkkaOH5jl04DCTuQlipo1kq9PuEYaa6gDatTOvhYL9AE0Ji23FFeal0mI4JKvZdBLD0BkM+wz7PS5eOs+1K1fZN7ebmVJBZS4/VeLR2hrvnn2fr339H/PK//pzXnjh83zvr/6G9UqFbDrF/n1zrK2s8OJLX1Ktbv7QfvxRF2c0UM46m5nAGYX86I23qTc6rKxv0h6MlH/3xVCEHrGYhR7RGI0GBL67rSeapooUtxMc3n+A/XsPsHNmlumpGZLJFMPeUImY6JH2yVuvho4nBlvfhkDEVBeIx5MqI5IM35VM9+iJyumw/PABN2/eZHwsQ7O+Qahr9EdDDDtGIptmLJtT6BAH9nDxHjeuXuPpkycZz2a4fuMqJ04c560zb/HM506yY7ZILGqQScq1ely9coubN+8ycAPuL6+gW3GMmMXI93B9D9uMoimP6WHo0l1cdC2kudVkNPDJpVMU8nkeP/I4zz/7HIVCCV8cpGkrbdI++ckPQjEFsVgCGSL6/aEKMplIMTGZU9Vr1bfo9Tu4oyF2zKJR2+TcuXOsr1dYfLDIY0eOELUtJosldbBLlz7iX/3L32Xt0Qp/9Ad/yEyxyOPHjnHyySdY31hjbWMND5/sWBJNG5FOxDF1m5WlClc/uclmrcX9BxVagyH56WmVSMd1GTgDQt9lNOyj+yHZVBycIVZEo91s4zkOlljNEOYPPcbXvvaP2Lf3AJZlq/iEutrt998KhbsSWCKVUdXt9Xo4jqcSoIge+IonoszOcMDa2hpn33+P24t32HfoIENnwLPPP8dGrcathZu4jsOTxx9nZnqaP/79P1SW8tf+6T9jc3OTO3cX+fjKp6zXqszuKLN3bppkPIahmYg1a9S7rK3Xef1HP8OwDYrlaWKppDqLJz6g16XbbCirWMiNYRIgtnrU6xONbLenRm2LwmSRF09/ic997lmS6SyJRBIEEa2Fj8J6va4a99hYTl242W4pVRNIi/GIaDqLi4vq8+H5g7TbbS5fvkyvP2R65y4uXrxIt9fkt377G3zw/jtU1h6xd88Ojswf5s9feYW9e+b4F7/7b/n3/+bfMbtjN49Wqzx18hTtTp0zP/4hG9VVchNFDh6Yp9bscOHSp6xX60TtuDrXxMSEsrSa7yF+Y9CRXhsyO1NWVROtkYDFLI1nsmpIEed49OhRXn75ZaamZ2i1WtjxGNryuXfCsYmcqkK1tkm1WlXeM5lMKx4K0UXMpFdvbW2RiKdIZ5IsPXzE5Y8/otntK5v5ve/+Nb434Pf+x3+lUnnID77/f/nqV19irVJhfGyCVrPLu++dpVSeZdfO/cw/doQb16+xvnqXpQf36fT6YJjUWwOqtTrdvoMfhOr+YxKEjKmeg21EwHOI6JCTCtuWapUDCbjbYyKXU/7fGY7Ys2cPzz33HEcfP6aQO5RFQe36xbDT66ov6EZEZUsatTiUTCaj/LRAfnx8XGW71+6RTMZZXl7he99/leT4OOXpaXxvyBs/+iE6Hom4RbddZ3aHwDXBoD/i6vUbvPTSV/nGb36Tsx+c50//7DtSBp55+rhS3Ga7w/0Hy9y5v0RPWpEps7LP5OSkMhW4PsNeC1M2G4amAhZfn8qkt1V6OKLbbpNNZ1TxBv0++Xxe/e6LL75IuVym1++jrV07H969e1cZ71KpxEy5rMYpxWsjquArcJYqT5VLWEZUXURucufuPaqNBoVSnlKxwO3bN3nt1b/lyNFDpONxqtU1njh+gm9/+/dJplN02l1qjSarK5uUZ6Z47tnPsGdmmnKpgGHafPTpVd58+6fcf7iMJ23IC5mZmVHnipkW7WadUa+j5mgruu2lJ/J54smEssH1Wo3A89UAJDoiVJAYTp8+zfHjx4lEDbR7l95TKx5Z50im43aMsbExJf29dkcNDQJzuYD4YbmYwFtdOBGj57ps1mrEbJPp6Wnu3l5QQ0Wv2ebPXvkThRCp0te//nX+8i//guXVClNTU+zYuZOt2gajTpt0Mkk8maa2VefarTtUN2tiY8TpKk3ZvXMXhckc7VaTerWKGY2QTgq/A/KlIrlcjlx2TInpxnpV7eIMPUK5NKViOHDgAE888QTjkxNoGwtXQk32QkGAMxopOMu/pbfJa/H2bXbt2kXm781H3LLpdsUsjEiPj3Hv0RJvvPUmhw/O89RTTymxiOpRxnbv5jv/7b/Tbjf51re+xdbWJucvn+fpp59Sq5dqdZ12s8Wo0+Hm1WvcvfeApnjuXp92t0+7M6DR7qvlXblcpDxVwh0OVEtMJWJM5sYVyrLjY6THsspabmxssHTvvmqrMjzsnN2BFoRKi0TABNZar/IgrG6sq1aUsC2VUTEZooYiGJ7rKOUT87+6+khdIJGMKZNixmx67ohzly4y6A7UiPjFz59GDzVMw+Lq1asc2DtHPBFTM7S4tcraMpc/vry9PgoCwqHL5fMXuHHzNgPHQfYyoSzqvEB1gdFwqDy96Imhge+MKBUmKRWK+IGHZdsqcEGR0G91aXnbR8QTzM7MMOz1VWv9zNOntgMOO5shAulen3pjS01M2WwaSyAjA2UY0tiosrb6iGZ9SyVkYnJcCUOj22R5vcLySkVNKeJXT544ydGjx+g1trePWuirRJVmpjhz5i26gxatVlOZiFwmzfpShWqlqtqGBCzDgidjXSyGYdnq8M1mXe2zbFk+2Ca7ZncwVSoquggOBXGiK0LLzY0Nta4SzZGkeK6rIP8PX/oKs7OzaJWFa2p4ENFynCGtZoODB/eTjMXxA1e5q/PnfsHlyxe5t7igLlooTBI1DLWY002dTm9A3IozMZHHH/k4jsvhvfM888wz6jD9QZeLF89z4+ZVIrIgMba3iBPZMfqNLtlURvXTlco6D5YeokeiqivIcCDDhwQmBxfOCrV2795NPpfbnn9bbeUPpMpCR9EXYaMacTVNBSsLgFMnn+bUqVNoreV7ykvLaChZXVp6oMy5cHVyMkejucUf/N63SaWTLC0tqSoL36dnpkgkk0TjJlHTVmCYKkzR2GoogVtdXlXzqQig3LzRrLG5tYFs4gSiYlEnx3OkrQS+G6hD15tS/ZY6R0ZaESjz8+DBA2qbVfUdz3OIx2IUiwVy2XGVDBFVme7Gx7Mq+XLmfC7P3NxutW4SJ3f8+BPs2zeH5m9WQ1mgjXpdtpoNlpeXGRvLKCsp20rJ8Hf+9E+IJ2zeeecdZmbK3Lt3Tz0xmD96RJmRQqmo1P3Q/oNsVjewTJOl+w+UgdnarGFaUTzfV5WWRb4cTNrS1GSJTr2tYCj8EygLZSRJskaSxMpbLKn8rrTKVquhEimJSCYS6KGMrQYj12cw6BG1bHV90YJWu8Heuf0cO/oYJ0+eojhVRBs8Wg7tdErBpddqKfGaLBbQDIP6ZpWFhQUuXDyvAv/bV1/lyadOKPmXG8vgLT8X6ApfpJUZocbBQwfYqq5z48YN1itrJBIJ8sWCamuyV5bZWlAhra2+scnm+qYaQ0UIZfwTgZKAxATJZwXddoOVlRVVTRE/mX4EqhPjk+rMruuTTCdIpjJq4RiJyh4uzeOPn+Cznz3F3Nw+1X206vVroazw84UCqMCVCiij7fuu2hDeunWLO3fucOHyBSqVilrWabrOtWvXlBLi+8rXyqrm9OefVw5o7dEyn3zyEbG4pR6niOuJRi3WqpusVTdoNdt0O2IionTbHcVBCVgIKNsMgbW8hOtSWYFzo9FQkDflkYoepdtq0+8OGB8bw44l1D5aNy0iZoTdc3t54qkTHD70GHvmdim3d//BXbStGzdCWW6LaDxaWVHiJQ+hDj02T2pyUjq/PMWiX6+r/xfIN1pNVQGB4UeXLnP+Fx8SFTM/O8XXvvJlms2aspr12qY6oHBY1yPUm10ePFzh0fIKw6GHGbVJxIX/rrq/vGQakplbYKr4KvxvbOuG3P+XVlf+P2bF2VnewaFDh1Rvr7eapMayTE2XyU7kGMuNq7FVUCLUk7Nr4dp6iBFRcH7zJz9mZXVVwe/Z5/+BUsr1japyKM1WCytmq6cI3X6PMEAN2mPJNGHgs1Wt8PP3zmBHIZGMYkZ1FhZucG9xUT3uGLoeriPMN6hvdWh3+qpXxmP2r7YW4vSG/b4SNV2TFWtLwVmClTOJAZJ+WyqX2bdvH9NTUxTzZdpbddbW18lMjFM8eAA8l2Gviz0xjtPrYgpyfvkwLRw5If2+quSju3cUV4WjpfIUVizBkSeO8/DhEpP5Io7vsXjvjvK30vdaggZ0XGdE3DawTI3axiq3F67TaddJJhNqfbO2VuXC+YtUN+rkJ8sEga4CTidT8rQI1x2p3ik8llaoVjFhQG1rU/H/+IkTyg/vO3hAmQhJgKCrWlljx8wOxeFPrnxKrVHn6LFj7JjbjS+otUwsO67alax4hDL/H0xJ7BFdZf6MAAAAAElFTkSuQmCC\">\n * let a = '<canvas width=\"60\" height=\"32\"></canvas>';\n * bbn.fn.canvasToImage(a);\n * ```\n *\n * @memberof bbn.fn\n * @param {canvas} canvas\n * @returns  {HTMLElement}\n */\nfunction canvasToImage(canvas) {\n    var img = new Image();\n    img.src = canvas.toDataURL('image/png');\n    return img;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/center.js\n/**\n * Centers the given element by giving it a position absolute.\n *\n * @method   center\n * @global\n * @example\n * ```javascript\n * //<div style=\"position: absolute; top: 73px; left: 0px;\">Documentation</div>\n * bbn.fn.center('<div>Documentation</div>')\n * ```\n * @memberof bbn.fn\n * @param    {HTMLElement} ele\n * @returns  {HTMLElement} The dom element with the new style.\n */\nfunction center(ele) {\n    //ele = $(ele);\n    var parent = ele.parentNode, \n    //w = parent.width(),\n    w = parent.clientWidth, \n    //h = parent.height();\n    h = parent.clientHeight;\n    while (parent && (!w || !h)) {\n        /*parent = parent.parent(),\n              w = parent.width(),\n              h = parent.height();*/\n        parent = ele.parentNode;\n        w = parent.clientWidth;\n        h = parent.clientHeight;\n    }\n    //ele.css(\"position\",\"absolute\");\n    ele.style.position = \"absolute\";\n    //ele.css(\"top\", Math.max(0, ((h - ele.outerHeight()) / 2) + parent.scrollTop()) + \"px\");\n    ele.style.top =\n        Math.max(0, (h - ele.offsetHeight) / 2 + parent.scrollTop) + \"px\";\n    //ele.css(\"left\", Math.max(0, ((w - ele.outerWidth()) / 2) + parent.scrollLeft()) + \"px\");\n    ele.style.left =\n        Math.max(0, (h - ele.offsetWidth) / 2 + parent.scrollLeft) + \"px\";\n    return ele;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/checkPropsDetails.js\n\n\n\n\nfunction checkPropsDetails(obj, props, checkEmpty) {\n    if (checkEmpty === void 0) { checkEmpty = false; }\n    var res = {\n        error: false,\n        result: true,\n    };\n    if (typeof props === \"string\") {\n        props = [props];\n    }\n    if (!isArray_isArray(props)) {\n        res.error = bbn._(\"checkProps must receive a string or an array as props argument\");\n    }\n    if (!isObject_isObject(obj)) {\n        res.error = bbn._(\"checkProps must receive an object as obj argument\");\n    }\n    if (!res.error) {\n        var check_1;\n        each(props, function (varName) {\n            varName = varName.trim().split(\":\");\n            var type = varName[1] || false;\n            varName = varName[0];\n            if (obj[varName] === undefined) {\n                res.error = varName + \" \" + bbn._(\"is not defined\");\n            }\n            else if (type) {\n                check_1 =\n                    \"is\" +\n                        substr(type, 0, 1).toUpperCase() +\n                        substr(type, 1).toLowerCase();\n                if (bbn.fn[check_1] === undefined) {\n                    res.error = type + \" \" + bbn._(\"is not a valid type\");\n                }\n                else if (!bbn.fn[check_1](obj[varName])) {\n                    res.error = varName + \" \" + bbn._(\"is not a\") + \" \" + type;\n                }\n            }\n            else if (checkEmpty && !obj[varName]) {\n                res.error = varName + \" \" + bbn._(\"is empty\");\n            }\n            if (res.error) {\n                return false;\n            }\n        });\n    }\n    if (res.error) {\n        res.result = false;\n    }\n    return res;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/checkProps.js\n\nfunction checkProps(obj, props, checkEmpty) {\n    if (checkEmpty === void 0) { checkEmpty = false; }\n    return checkPropsDetails(obj, props, checkEmpty).result;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/checkPropsOrDie.js\n\nfunction checkPropsOrDie(obj, props, checkEmpty) {\n    if (checkEmpty === void 0) { checkEmpty = false; }\n    var res = checkPropsDetails(obj, props, checkEmpty);\n    if (res.error) {\n        throw new Error(res.error);\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/clone.js\n\n\n\n/**\n * Creates and returns a perfect clone - but different - from the given object.\n *\n * @method   clone\n * @global\n * @example\n * ```javascript\n * let obj = {name: \"Thomas\"};\n * let objCopy = bbn.fn.clone(obj);\n * obj.name = \"Julie\";\n * // obj:     {name: \"Julie\"}\n * // objCopy: {name: \"Thomas\"}\n * ```\n * @memberof bbn.fn\n * @param    {Object} obj The source object\n * @returns  {Object} A new object\n */\nfunction clone(obj) {\n    if (isArray_isArray(obj)) {\n        return obj.slice().map(function (a) {\n            return typeof a === \"object\" ? clone(a) : a;\n        });\n    }\n    if (isObject_isObject(obj)) {\n        var o = Object.create(Object.getPrototypeOf(obj));\n        return extend_extend(true, o, obj);\n    }\n    return obj;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/colorToHex.js\n/**\n * Returns the hex color of the given rgb or color name.\n * @method   colorToHex\n * @global\n * @example\n * ```javascript\n * //\"#ff0000\"\n * bbn.fn.colorToHex('red');\n * ```\n *\n * @example\n * ```javascript\n * //\"#ff0000\"\n * bbn.fn.colorToHex('rgb(255,0,0)');\n * ```\n * @memberof bbn.fn\n * @returns  {String}\n */\nfunction colorToHex(color) {\n    var canvas = document.createElement(\"canvas\").getContext(\"2d\");\n    canvas.fillStyle = color;\n    return canvas.fillStyle;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/copy.js\n\n\n/**\n * Copies to the clipboard the value of the given string.\n * @method   copy\n * @global\n * ``` javascript\n * let myVal = 'the value you want to copy to clipbord';\n * bbn.fn.copy(myVal);\n *\n * ```\n * @memberof bbn.fn\n * @param {String} st The string to copy.\n * @returns\n */\nfunction copy(st) {\n    return new Promise(function (resolve) {\n        var _a;\n        if (st) {\n            if (navigator && navigator.clipboard) {\n                if (st instanceof Blob) {\n                    navigator.clipboard.write([new ClipboardItem((_a = {}, _a[st.type.toString()] = st, _a))]).then(function () {\n                        resolve(true);\n                    });\n                }\n                else if (isObject_isObject(st) && isFunction_isFunction(st.toBlob)) {\n                    st.toBlob(function (blob) {\n                        var _a;\n                        navigator.clipboard.write([new ClipboardItem((_a = {}, _a[blob.type.toString()] = blob, _a))]).then(function () {\n                            resolve(true);\n                        });\n                    });\n                }\n                else {\n                    navigator.clipboard.writeText(st);\n                    resolve(true);\n                }\n                return;\n            }\n            var input = document.createElement('textarea');\n            input.style.opacity = '0';\n            input.value = st;\n            document.body.appendChild(input);\n            input.select();\n            document.execCommand('copy');\n            document.body.removeChild(input);\n            resolve(true);\n        }\n        resolve(false);\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/count.js\n\n/**\n * Counts the number of objects matching the given filter in the given array.\n *\n * The arguments follow the same scheme as bbn.fn.search.\n *\n * @method   count\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * ];\n * bbn.fn.count(ar, \"id\", 256);\n * // 1\n * bbn.fn.count(ar, {director: \"Steven Spielberg\"});\n * // 2\n * bbn.fn.search(ar, \"year\", 1975, \">\");\n * // 3\n * // Complex filters: all the movies from Spielberg between 1974 and 1980\n * bbn.fn.search(ar, {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *       field: \"director\",\n *       operator: \"eq\",\n *       value: \"Steven Spielberg\"\n *     }, {\n *       logic: \"AND\",\n *       conditions: [\n *         {\n *            field: \"year\",\n *            operator: \">=\",\n *            value: 1974\n *         }, {\n *            field: \"year\",\n *            operator: \"<=\",\n *            value: 1980\n *         }\n *       ]\n *     }\n *   ]\n * });\n * // 1\n * ```\n * @memberof bbn.fn\n * @param    {Array}                    arr       The subject array\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {Number}                   The number of items\n */\nfunction count(arr, prop, val, operator) {\n    if (val === void 0) { val = null; }\n    if (operator === void 0) { operator = '='; }\n    return filter(arr, prop, val, operator).length || 0;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/crc32.js\n/**\n * CRC32 implementation.\n */\nvar crc32Table = [];\nfor (var i = 0; i < 256; i++) {\n    var c = i;\n    for (var j = 0; j < 8; j++) {\n        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;\n    }\n    crc32Table.push(c);\n}\nfunction crc32(str) {\n    var crc = 0 ^ -1;\n    for (var i = 0; i < str.length; i++) {\n        var charCode = str.charCodeAt(i);\n        crc = (crc >>> 8) ^ crc32Table[(crc ^ charCode) & 0xff];\n    }\n    return (crc ^ -1) >>> 0; // Make sure the result is a 32-bit positive integer\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/createObject.js\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nfunction createObject() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var obj = Object.create(null);\n    if (args.length) {\n        extend_extend.apply(void 0, __spreadArray([obj], args, false));\n    }\n    return obj;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/cssExists.js\n//import log from './log.js'  ;\n\n/**\n * not used\n * @ignore\n * @method   cssExists\n * @todo     Add method description for cssExists\n * @global\n * @memberof bbn.fn\n * @param    {String} f\n * @returns\n */\nfunction cssExists(f) {\n    var ok;\n    var rules;\n    var css = document.styleSheets;\n    for (var sx = 0; sx < css.length; sx++) {\n        ok = 1;\n        try {\n            rules = css[sx].rules || css[sx].cssRules;\n        }\n        catch (e) {\n            ok = false;\n            if (e.name !== \"SecurityError\") {\n                throw e;\n            }\n        }\n        if (ok) {\n            //log(rules);\n            for (var cx = 0; cx < rules.length; cx++) {\n                //log(rules[cx].selectorText);\n                if (new RegExp(\"(^|\\\\s)\" + escapeRegExp(f) + \"(\\\\{|\\\\s)\", \"g\").test(rules[cx].selectorText)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/dateSQL.js\n\n\n/**\n * Returns a date with SQL format.\n *\n * @method   dateSQL\n * @global\n *\n * @example\n * ``` javascript\n * //\"2020-04-16 16:15:23\"\n * let date = new Date();\n * bbn.fn.dateSQL(date,false);\n * ```\n *\n * @memberof bbn.fn\n * @param    {Date|String} v\n * @param    {Boolean}     dayOnly Whether or not include the time in the date\n * @returns  {String}\n */\nfunction dateSQL(v, dayOnly) {\n    var value = date(v);\n    if (value) {\n        return dayjs_min(value).format('YYYY-MM-DD' + (dayOnly ? '' : ' HH:mm:ss'));\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/daysInMonth.js\n\n/**\n * Returns the number of days of the month given in the date.\n * @method   daysInMonth\n * @global\n *\n * @example\n * ``` javascript\n * //30\n * bbn.fn.daysInMonth(new Date());\n * ```\n *\n * @memberof bbn.fn\n * @param    {String|Date} v\n * @returns  {Number}\n */\nfunction daysInMonth(v) {\n    var d = date(v);\n    if (d) {\n        return dayjs(d).daysInMonth();\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/deepPath.js\n\n\n\n/**\n * Retrieves all elements of a hierarchical array corresponding to the filter.\n *\n * The arguments follow the same scheme as bbn.fn.search.\n *\n * @method   findAll\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * ];\n * bbn.fn.count(ar, \"id\", 256);\n * // 1\n * bbn.fn.count(ar, {director: \"Steven Spielberg\"});\n * // 2\n * bbn.fn.search(ar, \"year\", 1975, \">\");\n * // 3\n * // Complex filters: all the movies from Spielberg between 1974 and 1980\n * bbn.fn.search(ar, {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *       field: \"director\",\n *       operator: \"eq\",\n *       value: \"Steven Spielberg\"\n *     }, {\n *       logic: \"AND\",\n *       conditions: [\n *         {\n *            field: \"year\",\n *            operator: \">=\",\n *            value: 1974\n *         }, {\n *            field: \"year\",\n *            operator: \"<=\",\n *            value: 1980\n *         }\n *       ]\n *     }\n *   ]\n * });\n * // 1\n * ```\n * @memberof bbn.fn\n * @todo Do the doc!\n * @param    {Array}                    arr       The subject array\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {Number}                   The number of items\n */\nfunction deepPath(arr, filter, deepProperty, res) {\n    if (res === void 0) { res = []; }\n    var idx;\n    var start = 0;\n    if ((idx = search(arr, filter, start)) > -1) {\n        res.push(idx);\n        return res;\n    }\n    each(arr, function (it, i) {\n        if (isArray_isArray(it[deepProperty])) {\n            var r = res.slice();\n            r.push(i);\n            var tmp = deepPath(it[deepProperty], filter, deepProperty, r);\n            if (tmp !== false) {\n                return tmp;\n            }\n        }\n    });\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultAjaxAbortFunction.js\n\nfunction defaultAjaxAbortFunction(message, url) {\n    if (url === void 0) { url = \"\"; }\n    log(message);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultAjaxErrorFunction.js\n\nfunction defaultAjaxErrorFunction(jqXHR, textStatus, errorThrown) {\n    if (textStatus === void 0) { textStatus = null; }\n    if (errorThrown === void 0) { errorThrown = null; }\n    log(textStatus, errorThrown);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultAlertFunction.js\nfunction defaultAlertFunction(msg, title) {\n    if (title === void 0) { title = null; }\n    /** @todo */\n    alert(msg);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultConfirmFunction.js\n\nfunction defaultConfirmFunction(text, yesFn, noFn) {\n    if (noFn === void 0) { noFn = null; }\n    var ok = 0;\n    if (confirm(text)) {\n        if (isFunction_isFunction(yesFn)) {\n            yesFn();\n            ok = 1;\n        }\n    }\n    if (!ok && isFunction_isFunction(noFn)) {\n        noFn();\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultEndLoadingFunction.js\nfunction defaultEndLoadingFunction(url, timestamp, data, res) {\n    if (data === void 0) { data = null; }\n    if (res === void 0) { res = null; }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultErrorFunction.js\n\nfunction defaultErrorFunction(message) {\n    log(message);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultHistoryFunction.js\nfunction defaultHistoryFunction(obj) {\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultLinkFunction.js\nfunction defaultLinkFunction(responseObj, ele) {\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultPostLinkFunction.js\nfunction defaultPostLinkFunction(r, ele) {\n    if (ele === void 0) { ele = null; }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultPreLinkFunction.js\n\nfunction defaultPreLinkFunction(url, force, ele) {\n    if (force === void 0) { force = false; }\n    if (ele === void 0) { ele = null; }\n    log(\"defaultPreLinkFunction\", url, force, ele);\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultResizeFunction.js\nfunction defaultResizeFunction() {\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/default/defaultStartLoadingFunction.js\nfunction defaultStartLoadingFunction(url, tst, data, requestId) {\n    if (data === void 0) { data = null; }\n    if (requestId === void 0) { requestId = null; }\n    return true;\n}\n;\n\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/deleteProp.js\n\n/**\n * Gets the given property from the given object\n * @param {Object} obj\n * @param {String} prop\n * @returns\n */\nfunction deleteProp(obj, prop) {\n    checkType(obj, \"object\", bbn._(\"The obj must be an object in setProp\"));\n    checkType(prop, \"string\", bbn._(\"The prop must be a string in setProp\"));\n    delete obj[prop];\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isValue.js\n\n/**\n * Returns true if the given argument is not null or type object or array.\n * @method   isValue\n * @deprecated\n * @see bbn.fn.isPrimitive\n * @example\n * ```javascript\n * bbn.fn.isValue('myString');\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isValue(6);\n * //true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isValue([80,10,22]);\n * //false\n * ```\n * @global\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isValue() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (typeof a === \"object\" && !isNull(a)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/diffObj.js\n\n\n\n\n\n\nvar diffObjProcessed = [];\n/**\n  * Returns an object describing the differences for transforming the first given object into the second.\n  *\n  * The returned data will use the objects properties as keys. If unchanged is set to true, all the\n  * properties will be returned, otherwise only the different ones. Each of these keys will have the\n  * following properties:\n  * - type: can be _modified_, _created_, _deleted_, and if unchanged is set to true _unchanged_\n  * - data: the first object's property's value, or the second if type is _created_\n  * - newData: the second object's property's value in case of type _updated_\n  *\n  * @method   diffObj\n  * @global\n  * @example\n  * ```javascript\n  * bbn.fn.diffObj(\n  *   {\n  *     name: \"Thomas\",\n  *     age: 45\n  *   }, {\n  *     name: \"Eva\",\n  *     sex: \"Female\",\n  *     retired: false\n  *   }\n  * );\n  * // {\n  * //   name: {\n  * //     type: \"updated\",\n  * //     data: \"Thomas\",\n  * //     newData: \"Eva\"\n  * //   },\n  * //   age: {\n  * //     type: \"deleted\",\n  * //     data: 45\n  * //   },\n  * //   sex: {\n  * //     type: \"created\",\n  * //     data: \"Female\"\n  * //   },\n  * //   retired: {\n  * //     type: \"created\",\n  * //     data: false\n  * //   }\n  * // }\n  * ```\n  * @example\n  * ```javascript\n  * bbn.fn.diffObj(\n  *   {pupil: \"Agnes Varda\", grade: {year: \"B\", month: \"A\"}},\n  *   {pupil: \"Luc Besson\", grade: {year: \"C\", month: \"D\"}}\n  * );\n  * // {\n  * //   \"pupil\": {\n  * //     \"type\": \"updated\",\n  * //     \"data\": \"Agnes Varda\",\n  * //     \"newData\": \"Luc Besson\"\n  * //   },\n  * //   \"grade\": {\n  * //     \"year\": {\n  * //       \"type\": \"updated\",\n  * //       \"data\": \"B\",\n  * //       \"newData\": \"C\"\n  * //     },\n  * //     \"month\": {\n  * //       \"type\": \"updated\",\n  * //       \"data\": \"A\",\n  * //       \"newData\": \"D\"\n  * //     }\n  * //   }\n  * // }\n  * ```\n  * @memberof bbn.fn\n  * @param    {Object}  obj1\n  * @param    {Object}  obj2\n  * @param    {String}  unchanged\n  * @param    {Boolean} notRoot\n  * @returns  {Object}\n  */\nfunction diffObj(obj1, obj2, unchanged, notRoot) {\n    if (unchanged === void 0) { unchanged = false; }\n    if (notRoot === void 0) { notRoot = false; }\n    if (!notRoot) {\n        diffObjProcessed = [];\n    }\n    var VALUE_CREATED = 'created', VALUE_UPDATED = 'updated', VALUE_DELETED = 'deleted', VALUE_UNCHANGED = 'unchanged', _compareValues = function (value1, value2) {\n        if (value1 === value2) {\n            return VALUE_UNCHANGED;\n        }\n        if (isDate_isDate(value1) && isDate_isDate(value2) && value1.getTime() === value2.getTime()) {\n            return VALUE_UNCHANGED;\n        }\n        if ('undefined' == typeof value1) {\n            return VALUE_CREATED;\n        }\n        if ('undefined' == typeof value2) {\n            return VALUE_DELETED;\n        }\n        return VALUE_UPDATED;\n    };\n    if (notRoot === undefined) {\n        notRoot = false;\n    }\n    var diff = createObject();\n    if (!isFunction_isFunction(obj1) && !isFunction_isFunction(obj2)) {\n        if (isValue(obj1) || isValue(obj2)) {\n            var res = _compareValues(obj1, obj2);\n            if (unchanged || res !== VALUE_UNCHANGED) {\n                var ret = createObject();\n                Object.defineProperty(ret, 'type', {\n                    value: res,\n                    enumerable: false,\n                });\n                Object.defineProperty(ret, 'data', {\n                    value: obj1 === undefined ? obj2 : obj1,\n                    enumerable: false,\n                });\n                Object.defineProperty(ret, '_bbnDiffObjProof', {\n                    value: true,\n                    enumerable: false,\n                });\n                if (obj1 !== undefined) {\n                    Object.defineProperty(ret, 'newData', {\n                        value: obj2,\n                        enumerable: false,\n                    });\n                }\n                return ret;\n            }\n            return false;\n        }\n        if (isDom(obj1) || isDom(obj2)) {\n            return false;\n        }\n        if (diffObjProcessed.includes(obj1) || diffObjProcessed.includes(obj2)) {\n            //error(bbn._(\"Can't compare objects because they contain circular references\"));\n            return false;\n        }\n        diffObjProcessed.push(obj1, obj2);\n        for (var key in obj1) {\n            if (isFunction_isFunction(obj1[key])) {\n                continue;\n            }\n            var value2 = undefined;\n            if ('undefined' != typeof obj2[key]) {\n                value2 = obj2[key];\n            }\n            var res = diffObj(obj1[key], value2, unchanged, true);\n            if (res) {\n                diff[key] = res;\n            }\n        }\n        for (var key in obj2) {\n            if (isFunction_isFunction(obj2[key]) || 'undefined' != typeof obj1[key]) {\n                continue;\n            }\n            var res = diffObj(undefined, obj2[key], unchanged, true);\n            if (res) {\n                diff[key] = res;\n            }\n        }\n    }\n    return !notRoot || unchanged || numProperties(diff) ? diff : false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/dirName.js\n\n\n/**\n * Returns the path of the folder containing the last hierarchical element of the path.\n *\n * @method   dirName\n * @global\n *\n * @example\n * ```javascript\n * //\"folder/other_folder\"\n * bbn.fn.dirName('folder/other_folder/file');\n * ```\n * @memberof bbn.fn\n * @param    {String} path\n * @returns  {String} path of the folder\n */\nfunction dirName(path) {\n    if (isString_isString(path) && path) {\n        while (substr(path, path.length - 1) === \"/\") {\n            path = substr(path, 0, path.length - 1);\n        }\n        var pos = path.lastIndexOf(\"/\");\n        if (pos > 0) {\n            return substr(path, 0, pos);\n        }\n        if (pos === 0) {\n            return \"/\";\n        }\n    }\n    return \"\";\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isBlob.js\n/**\n * @method   isBlob\n * @todo     Add method description for isFunction\n * @global\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isBlob_isBlob() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object Blob]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/fileExt.js\n\n/**\n * Gets the extension from a file's name.\n *\n * The extension is returned in lower case; if the filename has no extension\n * or is not valid it will return an empty string.\n *\n * @method   fileExt\n * @global\n *\n * @example\n * ```javascript\n * // \"txt\"\n * bbn.fn.fileExt('my_file.txt')\n * ```\n *\n * @example\n * ```javascript\n * // \"txt\"\n * bbn.fn.fileExt('MY_FILE.TXT')\n * ```\n *\n * @example\n * ```javascript\n * // \"\"\n * bbn.fn.fileExt('MY_FILE')\n * ```\n *\n * @example\n * ```javascript\n * // \"\"\n * bbn.fn.fileExt('.MY_FILE')\n * ```\n *\n * @param   {String} filename\n * @returns {String} The file's extension\n */\nfunction fileExt(filename) {\n    if (filename && isString_isString(filename)) {\n        var bits = filename.split(\".\");\n        if (bits[0] && bits.length > 1) {\n            return bits[bits.length - 1].toLowerCase();\n        }\n    }\n    return \"\";\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isCanvas.js\n/**\n * Returns true if the given argumen is a Canvas.\n *\n * @method   isCanvas\n * @global\n * @example\n * ```javascript\n * let myCanvas = document.createElement('canvas');\n * bbn.fn.isCanvas(myCanvas);\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isCanvas() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!(a instanceof HTMLCanvasElement)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/downloadContent.js\n\n\n\n\n/**\n * Downloads a file with given filename from the given content.\n *\n * Creates a link putting in href a URL Object Blob made of the given content,\n * which can be a canvas, a file or a blob object, or just a string.\n *\n * @method   downloadContent\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * // Download from a string\n * bbn.fn.downloadContent('myTextFile.txt', 'Just a string\\nThat we can save directly in a file', 'text/plain');\n *\n * // Download from a file\n * let file = new File([\"foo\"], \"foo.txt\", {type: \"text/plain\"});\n * bbn.fn.downloadContent('foo.txt', file);\n * ```\n *\n * @param    {String}                        filename The name for the downloaded file\n * @param    {HTMLCanvasElement|File|String} content  A Canvas, a File object or a String\n * @param    {String}                        type     The type of file to be made\n *\n * @returns  {undefined}\n */\nfunction downloadContent(filename, content, type) {\n    if (type === void 0) { type = null; }\n    if (isCanvas(content)) {\n        content.toBlob(function (blob) {\n            // blob ready, download it\n            var a = document.createElement('a');\n            a.download = filename;\n            a.href = window.URL.createObjectURL(blob);\n            a.className = 'bbn-no';\n            a.click();\n            // delete the internal blob reference, to let the browser clear memory from it\n            window.URL.revokeObjectURL(a.href);\n        }, type || 'image/png');\n        return;\n    }\n    if (!type) {\n        type = isObject_isObject(content) && content.type ? content.type : 'octet/stream';\n    }\n    else if (type.indexOf('/') === -1) {\n        type = 'text/' + type;\n    }\n    var a = window.document.createElement('a');\n    a.className = 'bbn-no';\n    var src = null;\n    if (isString_isString(content)) {\n        src = new Blob([content], { type: type });\n    }\n    else {\n        try {\n            src = content;\n        }\n        catch (e) {\n            log(e);\n        }\n    }\n    a.href = window.URL.createObjectURL(src);\n    a.download = filename;\n    // Append anchor to body.\n    document.body.appendChild(a);\n    a.click();\n    window.URL.revokeObjectURL(a.href);\n    // Remove anchor from body\n    document.body.removeChild(a);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/download.js\n\n\n\n\n\n\n/**\n * Downloads a file with given filename from a URL.\n *\n * Gets the file's content as Blob through XHR, then sends it to bbn.fn.downloadContent.\n * __Attention__ The CORS policy applies\n *\n * @method   download\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * // Forcing the download of an image\n * bbn.fn.download('/bbn/js-title-black.png');\n *\n * // Forcing the download of a PDF\n * bbn.fn.download('/files/my-document.pdf');\n *\n * // Changing the name as it is downloaded\n * bbn.fn.download('/files/f4b1092d71aefd96458feaa71d170f69.pdf', 'myDocument_' + bbn.fn.dateSQL() + '.pdf');\n * ```\n *\n * @param    {String} url      The URL from which the file will be requested\n * @param    {String} filename The name for the downloaded file (otherwise it will take the basename of the url)\n * @param    {Object} params   A data object to send with the request\n *\n * @returns  {undefined}\n */\nfunction download(url, filename, params) {\n    if (filename === void 0) { filename = ''; }\n    if (params === void 0) { params = null; }\n    // We can intervert the arguments\n    if (filename && typeof filename === \"object\") {\n        params = filename;\n        filename = \"\";\n    }\n    return ajax(url, \"blob\", params || { _bbn_download: 1 }, function (d, headers) {\n        if (!filename) {\n            var prop = \"content-disposition\";\n            var cd = \"attachment; filename=\";\n            if ((headers === null || headers === void 0 ? void 0 : headers[prop]) && headers[prop].indexOf(cd) === 0) {\n                filename = substr(headers[prop], cd.length + 1, headers[prop].length - cd.length - 2);\n            }\n            else {\n                filename = baseName(url);\n            }\n        }\n        if (isBlob_isBlob(d)) {\n            var extension = fileExt(filename);\n            var htmlExtensions = [\"php\", \"html\"];\n            if (typeof filename === \"string\" &&\n                ((\"type\" in d && d.type !== \"text/html\") ||\n                    htmlExtensions.includes(extension))) {\n                downloadContent(filename, d);\n                return;\n            }\n        }\n    }, function (e) {\n        bbn.fn.defaultAjaxErrorFunction(e);\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/eraseCookie.js\n/**\n * Erase the cookie corresponding to the given name;\n *\n * @method   eraseCookie\n * @global\n * @example\n * ``` javascript\n * // 'en'\n * bbn.fn.erase('lang');\n * ```\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction eraseCookie(name) {\n    document.cookie = name + '=; Max-Age=-99999999;';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/escapeDquotes.js\n\nfunction escapeDquotes(str) {\n    if (!isString_isString(str)) {\n        return str;\n    }\n    return str.replace(/\"/g, '\\\\\"');\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/escapeSquotes.js\n\nfunction escapeSquotes(str) {\n    if (!isString_isString(str)) {\n        return str;\n    }\n    return str.replace(/'/g, \"\\\\'\");\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/escapeTicks.js\n\nfunction escapeTicks(str) {\n    if (!isString_isString(str)) {\n        return str;\n    }\n    return str.replace(/`/g, '\\\\`');\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/escapeUrl.js\n\n\n\n\n/**\n * Escapes a URL or a file path, optionally adding parameters (get type, to append to the URL without the first separator).\n *\n * @param {*} url\n * @param {*} params\n * @returns\n */\nfunction escapeUrl(url, params) {\n    var st = \"\";\n    if (url.match(\"^(http|https)://\")) {\n        st += \"http\";\n        url = url.substring(4);\n        if (url.substr(0, 1) === \"s\") {\n            st += \"s\";\n            url = url.substring(1);\n        }\n        st += \"://\";\n        url = url.substring(3);\n    }\n    each(dirName(url).split(\"/\"), function (a) {\n        st += encodeURIComponent(a) + \"/\";\n    });\n    var base = baseName(url);\n    var sep = \"?\";\n    var existingParams = \"\";\n    if (base.indexOf(sep)) {\n        var tmp = base.split(\"?\");\n        sep = \"&\";\n        existingParams = \"?\" + tmp[1];\n        base = tmp[0];\n    }\n    if (params && isString_isString(params)) {\n        if (params.match(\"^(\\\\&|\\\\?)\")) {\n            params = params.substring(1);\n        }\n        params = sep + params;\n    }\n    else {\n        params = \"\";\n    }\n    return st + encodeURIComponent(base) + existingParams + params;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/extendOut.js\n\n/**\n * Returns a new object made of the properties from all the given objects.\n *\n * Compared to bbn.fn.extend this still treats the arguments from left to right\n * but without overwriting existing properties, and returning a new object.\n *\n * @method   extendOut\n * @global\n * @example\n * ```javascript\n * //{field1: 1, field2: 2, field3: 3, items: {item: 0, item1: 1, item2: 2}, field4: 4}\n * bbn.fn.extendOut({field1: 1, field2: 2, field3: 3, items: {item: 0}}, {field4: 4, items: {item1: 1, item2: 2}});\n * ```\n * @memberof bbn.fn\n * @returns  {Object}\n */\nfunction extendOut() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var r = null;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!isObject_isObject(a)) {\n            throw new Error(\"Each argument for extendOut must be an object, \" + typeof a + \" given\");\n        }\n        if (r === null) {\n            r = a;\n        }\n        else {\n            for (var n in a) {\n                if (isObject_isObject(r[n], a[n])) {\n                    extendOut(r[n], a[n]);\n                }\n                else if (r[n] === undefined) {\n                    r[n] = a[n];\n                }\n            }\n        }\n    }\n    return r;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/form/fieldValue.js\n/**\n * Returns the value of a form's input, differenciating between checkboxes, radio and other inputs.\n *\n * @method   fieldValue\n * @global\n * @memberof bbn.fn\n * @param    {HTMLElement} field The input element\n *\n * @returns  {Mixed}       The value\n */\nfunction fieldValue(field) {\n    var v;\n    if (field.type === 'checkbox') {\n        if (field.checked) {\n            v = field.value;\n            if (!v) {\n                v = 1;\n            }\n        }\n        else {\n            v = 0;\n        }\n    }\n    else if (field.type === 'radio') {\n        if (field.checked) {\n            v = field.value;\n        }\n    }\n    else {\n        v = field.value;\n    }\n    return v;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/findAll.js\n\n\n\n/**\n * Retrieves all elements of a hierarchical array corresponding to the filter.\n *\n * The arguments follow the same scheme as bbn.fn.search.\n *\n * @method   findAll\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n * ];\n * bbn.fn.count(ar, \"id\", 256);\n * // 1\n * bbn.fn.count(ar, {director: \"Steven Spielberg\"});\n * // 2\n * bbn.fn.search(ar, \"year\", 1975, \">\");\n * // 3\n * // Complex filters: all the movies from Spielberg between 1974 and 1980\n * bbn.fn.search(ar, {\n *   logic: \"AND\",\n *   conditions: [\n *     {\n *       field: \"director\",\n *       operator: \"eq\",\n *       value: \"Steven Spielberg\"\n *     }, {\n *       logic: \"AND\",\n *       conditions: [\n *         {\n *            field: \"year\",\n *            operator: \">=\",\n *            value: 1974\n *         }, {\n *            field: \"year\",\n *            operator: \"<=\",\n *            value: 1980\n *         }\n *       ]\n *     }\n *   ]\n * });\n * // 1\n * ```\n * @memberof bbn.fn\n * @todo Do the doc!\n * @param    {Array}                    arr       The subject array\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {Number}                   The number of items\n */\nfunction findAll(arr, filter, deepProperty, res) {\n    if (res === void 0) { res = []; }\n    var idx;\n    var start = 0;\n    while ((idx = search(arr, filter, start)) > -1) {\n        res.push(arr[idx]);\n        start = idx + 1;\n    }\n    each(arr, function (it) {\n        if (isArray_isArray(it[deepProperty])) {\n            findAll(it[deepProperty], filter, deepProperty, res);\n        }\n    });\n    return res;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/loop/fori.js\n\n\n/**\n * Executes the provided function on each element of the given array.\n *\n * A minimum and a maximum value can be provided, within the boundaries of the\n * array's indexes. Returning false will stop the loop.\n *\n * @method   fori\n * @global\n * @example\n * ```javascript\n * let res = 0;\n * bbn.fn.fori([4, 5, 5, 10, 1, 2], d => {\n *   res += d;\n * }, 3);\n * // res = 24\n * ```\n * @example\n * ```javascript\n * let res = 0;\n * bbn.fn.fori([4, 5, 5, 10, 1, 2], d => {\n *   if (res >= 20) {\n *     return false;\n *   }\n *   res += d;\n * }, 4, 1);\n * // res = 20\n * ```\n * @memberof bbn.fn\n * @param    {Array}     arr The array to loop on\n * @param    {Function}  fn  The function, gets the array's element and the index as arguments\n * @param    {Number}    max The index to which the loop will stop\n * @param    {Number}    min The index at which the loop will start\n * @returns  {undefined}\n */\nfunction fori(arr, fn, max, min) {\n    if (max === void 0) { max = arr.length - 1; }\n    if (min === void 0) { min = 0; }\n    if (isArray_isArray(arr)) {\n        var realMax = arr.length - 1;\n        if (!isNumber_isNumber(max) || !(0 < max && max <= realMax)) {\n            max = realMax;\n        }\n        if (!isNumber_isNumber(min) || !(0 <= min && min < realMax) || min > max) {\n            min = 0;\n        }\n        for (var i = min; i <= max; i++) {\n            if (fn(arr[i], i) === false) {\n                return;\n            }\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/loop/forir.js\n\n\n/**\n * Executes the provided function on each element of the given array, going backward.\n *\n * A maximum and a minimum value can be provided, within the boundaries of the\n * array's indexes. Returning false will stop the loop.\n *\n * @method   forir\n * @global\n * @example\n * ```javascript\n * let res = 0;\n * bbn.fn.forir([4, 5, 5, 10, 1, 2], d => {\n *   res += d;\n * }, 4, 2);\n * // res = 16\n * ```\n * @example\n * ```javascript\n * let res = 0;\n * bbn.fn.forir([4, 5, 5, 10, 1, 2], d => {\n *   if (res >= 20) {\n *     return false;\n *   }\n *   res += d;\n * });\n * // res = 23\n * ```\n * @memberof bbn.fn\n * @param    {Array}     arr The array to loop on\n * @param    {Function}  fn  The function, gets the array's element and the index as arguments\n * @param    {Number}    max The index to which the loop will stop\n * @param    {Number}    min The index at which the loop will start\n * @returns  {undefined}\n */\nfunction forir(arr, fn, max, min) {\n    if (max === void 0) { max = arr.length - 1; }\n    if (min === void 0) { min = 0; }\n    if (isArray_isArray(arr)) {\n        var realMax = arr.length - 1;\n        if (!isNumber_isNumber(max) || !(0 < max && max <= realMax)) {\n            max = realMax;\n        }\n        if (!isNumber_isNumber(min) || !(0 <= min && min < realMax) || min > max) {\n            min = 0;\n        }\n        for (var i = max; i >= min; i--) {\n            if (fn(arr[i], i) === false) {\n                return;\n            }\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/format.js\n\nfunction format(str) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length) {\n        var i_1 = 0;\n        return str.replace(/\\%([d|s])/g, function (match, type) {\n            var tmp = args[i_1++];\n            checkType(tmp, type === 'd' ? 'number' : 'string', bbn._(\"The value doesn't correspond to the format\"));\n            return tmp;\n        });\n    }\n    return str;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/formatBytes.js\n/**\n * Formats the value given in bytes.\n * @method   formatBytes\n * @global\n * @example\n * //\"52.23 MB\"\n * ``` javascript\n * bbn.fn.formatBytes(54764654);\n * ```\n * @memberof bbn.fn\n * @returns  {String}\n */\nfunction formatBytes(bytes, decimals) {\n    if (decimals === void 0) { decimals = 2; }\n    if (!bytes) {\n        return '0 B';\n    }\n    var k = 1024, s = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals < 0 ? 0 : decimals)) + ' ' + s[i];\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/formatDate.js\nfunction formatDate(date, format) {\n    return dayjs(date).format(format);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/formatSize.js\n\n\nfunction formatSize(st, noValid) {\n    if (isNumber_isNumber(st)) {\n        return st + 'px';\n    }\n    if (isString_isString(st)) {\n        return st;\n    }\n    return noValid ? false : 'auto';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/form/formdata.js\n\n\n\n\n/**\n * Returns all the data contained in a form as a single object.\n *\n * @method   formdata\n * @global\n * @memberof bbn.fn\n * @fires    {*}\n *\n * @example\n * ```javascript\n * // <form id=\"myform\">\n * // <input type=\"hidden\" name=\"bbn[name]\" value=\"Smith\">\n * // <input type=\"hidden\" name=\"bbn[fname]\" value=\"John\">\n * // </form>\n * bbn.fn.formdata(document.getElementById('myform'));\n * // {name: \"Smith\", fname: \"John\"};\n *\n * ```\n *\n * @example\n * ```javascript\n * // <form id=\"myform\">\n * // <input type=\"hidden\" name=\"People[0][name]\" value=\"Smith\">\n * // <input type=\"hidden\" name=\"People[0][fname]\" value=\"John\">\n * // <input type=\"hidden\" name=\"People[1][name]\" value=\"Smith\">\n * // <input type=\"hidden\" name=\"People[1][fname]\" value=\"Eileen\">\n * // <input type=\"hidden\" name=\"Dates[0]\" value=\"2021-08-25\">\n * // <input type=\"hidden\" name=\"Dates[1]\" value=\"2021-09-06\">\n * // </form>\n * bbn.fn.formdata(document.getElementById('myform'));\n * // {\n * //   People: [\n * //     {name: \"Smith\", fname: \"John\"},\n * //     {name: \"Smith\", fname: \"Eileen\"}\n * //   ],\n * //   Dates: ['2021-08-25', '2021-09-06']\n * // }\n * ```\n *\n * @param    {HTMLElementL} form\n *\n * @returns  {Object}\n */\nfunction formdata(form) {\n    var $inputs = form.querySelectorAll('input[name],select[name],textarea[name],button[name]');\n    var res = {};\n    var n;\n    var v;\n    each($inputs, function (input, i) {\n        v = fieldValue(input);\n        if (v !== undefined && !input.disabled) {\n            var name_1 = input.name;\n            if (name_1.indexOf('[]') === -1 &&\n                name_1.indexOf('[') > -1 &&\n                name_1.indexOf(']') > -1 &&\n                name_1.lastIndexOf(']') === name_1.length - 1) {\n                name_1 = replaceAll('][', '.', name_1);\n                name_1 = replaceAll('[', '.', name_1);\n                name_1 = replaceAll(']', '', name_1);\n            }\n            if (name_1.length > 2 && name_1.indexOf('[]') === name_1.length - 2) {\n                n = substr(name_1, 0, name_1.length - 2);\n                if (res[n] === undefined) {\n                    res[n] = [];\n                }\n                res[n].push(v);\n            }\n            else if (name_1.indexOf('.') > -1) {\n                var tmp = void 0, parts = name_1.split('.');\n                tmp = res;\n                for (var i_1 = 0; i_1 < parts.length; i_1++) {\n                    if (res[parts[i_1]] === undefined) {\n                        if (i_1 < parts.length - 1) {\n                            tmp[parts[i_1]] = {};\n                        }\n                        else {\n                            tmp[parts[i_1]] = v;\n                        }\n                    }\n                    tmp = tmp[parts[i_1]];\n                }\n            }\n            else {\n                res[name_1] = v;\n            }\n        }\n    });\n    // return num_changes ? res : false;\n    return res;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/fromXml.js\n/**\n * Parses XML and returns an object.\n *\n * Picked from https://stackoverflow.com/questions/4200913/xml-to-javascript-object\n *\n * @memberof bbn.fn\n * @param   {String} xml       The XML to be parsed\n * @param   {Array}  arrayTags An array of tag names which should always be returned as array (even if single)\n * @returns {Object}\n */\nfunction fromXml(xml, arrayTags) {\n    var dom = null;\n    if (window.DOMParser)\n        dom = new DOMParser().parseFromString(xml, \"text/xml\");\n    else if (window[\"ActiveXObject\"]) {\n        dom = new window[\"ActiveXObject\"](\"Microsoft.XMLDOM\");\n        dom.async = false;\n        if (!dom.loadXML(xml))\n            throw dom.parseError.reason + \" \" + dom.parseError.srcText;\n    }\n    else\n        throw new Error(\"cannot parse xml string!\");\n    function parseNode(xmlNode, result) {\n        if (xmlNode.nodeName == \"#text\") {\n            var v = xmlNode.nodeValue;\n            if (v.trim())\n                result[\"#text\"] = v;\n            return;\n        }\n        var jsonNode = {}, existing = result[xmlNode.nodeName];\n        if (existing) {\n            if (!Array.isArray(existing))\n                result[xmlNode.nodeName] = [existing, jsonNode];\n            else\n                result[xmlNode.nodeName].push(jsonNode);\n        }\n        else {\n            if (arrayTags && arrayTags.indexOf(xmlNode.nodeName) != -1)\n                result[xmlNode.nodeName] = [jsonNode];\n            else\n                result[xmlNode.nodeName] = jsonNode;\n        }\n        if (xmlNode.attributes)\n            for (var _i = 0, _a = xmlNode.attributes; _i < _a.length; _i++) {\n                var attribute = _a[_i];\n                jsonNode[attribute.nodeName] = attribute.nodeValue;\n            }\n        for (var _b = 0, _c = xmlNode.childNodes; _b < _c.length; _b++) {\n            var node = _c[_b];\n            parseNode(node, jsonNode);\n        }\n    }\n    var result = {};\n    for (var _i = 0, _a = dom.childNodes; _i < _a.length; _i++) {\n        var node = _a[_i];\n        parseNode(node, result);\n    }\n    return result;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/ftime.js\n\n\n\n/**\n * @method   ftime\n * @todo     Add method description for ftime\n * @global\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction ftime(d, wrong_result) {\n    var r = date(d);\n    if (!isDate_isDate(r)) {\n        return wrong_result && isString_isString(wrong_result) ? wrong_result : '';\n    }\n    if (undefined !== dayjs) {\n        return dayjs(r).calendar();\n    }\n    return r.toLocaleDateString();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/unique.js\n/**\n * Removes duplicate values from an array.\n *\n * Takes an input array and returns a new array without duplicate values.\n *\n * @method   unique\n * @global\n * @example\n * ```javascript\n * bbn.fn.unique([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"c\", \"c\", \"d\"]);\n * // [\"a\", \"b\", \"c\", \"d\"]\n * ```\n * @memberof bbn.fn\n * @param    {Array} arr\n * @returns  {Array}\n */\nfunction unique(arr) {\n    return arr.filter(function (el, index, ar) {\n        return index === ar.indexOf(el);\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getAllTags.js\n\n/**\n * Gets all the tag names present in the DOM\n * @returns array\n */\nfunction getAllTags() {\n    return unique(Array.prototype.map.apply(document.all, [function (a) { return a.tagName.toLowerCase(); }]));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getAncestors.js\nfunction getAncestors(ele, selector) {\n    if (selector === void 0) { selector = null; }\n    var r = [];\n    if (typeof ele === 'string') {\n        ele = document.querySelector(ele);\n    }\n    if (ele instanceof HTMLElement) {\n        if (ele.parentElement) {\n            if (typeof selector === 'string') {\n                while ((ele = ele.parentElement.closest(selector))) {\n                    r.push(ele);\n                }\n            }\n            else {\n                if (selector === true) {\n                    r.push(ele);\n                }\n                while ((ele = ele.parentElement)) {\n                    r.push(ele);\n                }\n            }\n        }\n    }\n    return r;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getAttributes.js\n\n/**\n * Check if the property contain sizing\n * @return {Boolean}\n */\nfunction getAttributes(ele) {\n    if (!ele.getAttributeNames) {\n        error('The element is not a proper HTML Element');\n    }\n    var res = Object.create(null);\n    ele.getAttributeNames().forEach(function (name) {\n        res[name] = ele.getAttribute(name);\n    });\n    return res;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/getBrowserName.js\n/**\n * Gets the browser's name\n * @method getBrowserName\n * @global\n * @memberof bbn.fn\n * @returns {String}\n */\nfunction getBrowserName() {\n    var userAgent = navigator.userAgent.toLowerCase();\n    switch (true) {\n        case userAgent.includes('edge'):\n        case userAgent.includes('edg/'):\n            return 'Edge';\n        case userAgent.includes('opr') && !!window['opr']:\n            return 'Opera';\n        case userAgent.includes('chrome') && !!window['chrome']:\n            return 'Chrome';\n        case userAgent.includes('trident'):\n            return 'Internet Explorer';\n        case userAgent.includes('firefox'):\n            return 'Firefox';\n        case userAgent.includes('safari'):\n            return 'Safari';\n        default:\n            return 'Other';\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/getBrowserVersion.js\n/**\n * Gets the browser's version\n * @method getBrowserVersion\n * @global\n * @memberof bbn.fn\n * @returns {String}\n */\nfunction getBrowserVersion() {\n    var userAgent = navigator.userAgent.toLowerCase();\n    switch (true) {\n        case userAgent.includes('edge/'):\n            return userAgent.split('edge/')[1].split(' ')[0];\n        case userAgent.includes('edg/'):\n            return userAgent.split('edg/')[1].split(' ')[0];\n        case userAgent.includes('opr/') && !!window['opr']:\n            return userAgent.split('opr/')[1].split(' ')[0];\n        case userAgent.includes('chrome/') && !!window['chrome']:\n            return userAgent.split('chrome/')[1].split(' ')[0];\n        case userAgent.includes('trident/'):\n            return userAgent.split('trident/')[1].split(' ')[0];\n        case userAgent.includes('firefox/'):\n            return userAgent.split('firefox/')[1].split(' ')[0];\n        case userAgent.includes('safari/'):\n            return userAgent.split('version/')[1].split(' ')[0];\n        default:\n            return '';\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/getCookie.js\n/**\n * If it exsists returns the cookie corresponding to the given name.\n *\n * @method   getCookie\n * @example\n * ``` javascript\n * // 'en'\n * bbn.fn.getCookie('lang');\n * ```\n * @global\n * @memberof bbn.fn\n * @param    {String} name\n * @returns\n */\nfunction getCookie(name) {\n    var nameEqual = name + '=';\n    var ca = document.cookie.split(';');\n    for (var i = 0; i < ca.length; i++) {\n        var c = ca[i];\n        while (c.charAt(0) == ' ') {\n            c = c.substring(1, c.length);\n        }\n        if (c.indexOf(nameEqual) == 0) {\n            var st = c.substring(nameEqual.length, c.length);\n            if (st) {\n                return JSON.parse(unescape(st)).value;\n            }\n        }\n    }\n    return null;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/getCssVar.js\n/**\n * Gets a CSS variable value\n * @param {String*} varname\n * @returns\n */\nfunction getCssVar(varname) {\n    if (varname.indexOf(\"--\") !== 0) {\n        varname = \"--\" + varname;\n    }\n    return getComputedStyle(document.documentElement).getPropertyValue(varname);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/getDay.js\n\n/**\n * @method   getDay\n * @ignore\n * @todo     Add method description for getDay\n * @global\n * @memberof bbn.fn\n * @param    {String|Date} v\n * @returns\n */\nfunction getDay(v) {\n    var biss = 1972;\n    var d = date(v);\n    if (d) {\n        var t = d.getTime(), y = d.getYear(), m = d.getMonth(), days = (y - 1970) * 365;\n        if (m < 2) {\n            y--;\n        }\n        for (var i = biss; i <= y; i += 4) {\n            days++;\n        }\n        return days + Math.floor(t / (24 * 3600000));\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/getDeviceType.js\n/**\n * Returns the current device type.\n * @method   getDeviceType\n * @global\n * @example\n * ``` javascript\n * bbn.fn.getDeviceType();\n * // mobile\n * ```\n * @memberof bbn.fn\n * @returns  {String}\n */\nfunction getDeviceType() {\n    var userAgent = navigator.userAgent.toLowerCase();\n    if (/iPhone|Android/i.test(navigator.userAgent)) {\n        return 'mobile';\n    }\n    if (/(ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/.test(userAgent)) {\n        return 'tablet';\n    }\n    return 'desktop';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getHTMLOfSelection.js\n\nfunction getHTMLOfSelection() {\n    var range;\n    var selection = window.getSelection();\n    if (selection.rangeCount > 0) {\n        range = selection.getRangeAt(0);\n        log('RANGE', range);\n        var clonedSelection = range.cloneContents();\n        log('clonedSelection', clonedSelection);\n        var div = document.createElement('div');\n        div.appendChild(clonedSelection);\n        return div.innerHTML;\n    }\n    else {\n        return '';\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/getEventData.js\n\n\n/**\n * Returns a promise having the event's data as argument.\n * @method   getEventData\n * @global\n * @example\n * ``` javascript\n * let type = e.type;\n *   bbn.fn.getEventData(e).then((data) => {\n *     bbn.fn.log(\"DATA FROM \" + type, data);\n *   });\n * ```\n * @memberof bbn.fn\n * @returns  {Promise}\n */\nfunction getEventData(e) {\n    var dt = e.dataTransfer || e.clipboardData;\n    var t = dt.getData('Text');\n    var res = { raw: t, files: [], str: [] };\n    var p = new Promise(function (ok, err) {\n        var done = !(dt instanceof DataTransfer);\n        if (!t && e.type === 'copy') {\n            var sel = window.getSelection();\n            res.raw = sel.toString();\n            var html = getHTMLOfSelection();\n            res.str.push({\n                type: 'text/plain',\n                data: res.raw,\n            });\n            if (html !== res.raw) {\n                res.str.push({\n                    type: 'text/html',\n                    data: html,\n                });\n            }\n            else if (res.raw.trim().indexOf('<') === 0) {\n                res.str.push({\n                    type: 'text/html',\n                    data: \"<meta charset='utf-8'><code style=\\\"white-space: pre; font-family: 'Courier New', sans-serif\\\">\\n\" +\n                        res.raw +\n                        '\\n</code>',\n                });\n            }\n            done = true;\n            ok(res);\n        }\n        if (!done) {\n            var strings_1 = [];\n            var num_1 = dt.items.length;\n            each(dt.items, function (item, idx) {\n                var kind = item.kind;\n                var type = item.type;\n                if (kind === 'file') {\n                    var cp = dt.files[idx];\n                    if (!type && cp.name) {\n                        var bits = cp.name.split('.');\n                        type = bits[bits.length - 1];\n                    }\n                    var name_1 = cp ? cp.name : bbn._('untitled');\n                    var size = cp ? cp.size : null;\n                    var lastModified = cp ? cp.lastModified : null;\n                    var blob = item.getAsFile();\n                    if (blob) {\n                        done = true;\n                        num_1--;\n                        res.files.push({\n                            type: type,\n                            data: blob,\n                            name: name_1,\n                            size: size,\n                            mdate: lastModified,\n                        });\n                        strings_1.push(name_1);\n                        if (!num_1) {\n                            if (!res.raw) {\n                                res.raw = strings_1.join(', ');\n                            }\n                            ok(res);\n                        }\n                    }\n                    else {\n                        bbn.fn.defaultErrorFunction(bbn._('Impossible to read the file') + ' ' + name_1);\n                    }\n                }\n                else {\n                    done = true;\n                    item.getAsString(function (data) {\n                        num_1--;\n                        res.str.push({\n                            type: type,\n                            data: data,\n                        });\n                        if (type === 'text/plain') {\n                            strings_1.push(name);\n                        }\n                        if (!num_1) {\n                            if (!res.raw) {\n                                res.raw = strings_1.join(', ');\n                            }\n                            ok(res);\n                        }\n                    });\n                }\n            });\n        }\n        if (!done) {\n            setTimeout(function () {\n                ok(res);\n            });\n        }\n    });\n    return p;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/getField.js\n\n/**\n  * Returns the value of the given field (property) from the first object matching the given filter in an array of objects.\n  *\n  * The filtering arguments follow the same scheme as bbn.fn.search.\n  *\n  * @method   getField\n  * @global\n  * @example\n  * ```javascript\n  * let ar = [\n  *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n  *   {name: \"Goonies\", director: \"Richard Donner\", year: 1985, id: 689},\n  *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n  *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n  * ];\n  * bbn.fn.getField(ar, \"name\", {id: 256});\n  * // Star wars\n  * bbn.fn.getField(ar, \"name\", \"id\", 689);\n  * // Goonies\n  * ```\n  * @memberof bbn.fn\n  * @param    {Array}                    arr       The subject array\n  * @param    {String}                   field     The property from which the value is returned\n  * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n  * @param    {*}                        val       The value with which comparing the given property\n  * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n  * @returns  {*}\n  */\nfunction getField(arr, field, prop, val, operator) {\n    if (prop === void 0) { prop = ''; }\n    if (val === void 0) { val = null; }\n    if (operator === void 0) { operator = '='; }\n    var r;\n    if (field && (r = getRow(arr, prop, val, operator))) {\n        return r[field];\n    }\n    return undefined;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/getFieldValues.js\n\n\n\n/**\n * Returns all the unique values of the given field (property) from the first object matching the given filter in an array.\n *\n * The filtering arguments follow the same scheme as bbn.fn.search.\n *\n * @method   getFieldValues\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {name: \"Raiders of the lost ark\", director: \"Steven Spielberg\", year: 1981, id: 589},\n *   {name: \"Star wars\", director: \"George Lucas\", year: 1977, id: 256},\n *   {name: \"Jaws\", director: \"Steven Spielberg\", year: 1975, id: 423}\n *   {name: \"Barry Lindon\", director: \"Stanley Kubrick\", year: 1975, id: 802}\n * ];\n * bbn.fn.getFieldValues(ar, \"director\");\n * // [\"Steven Spielberg\", \"George Lucas\", \"Stanley Kubrick\"]\n * bbn.fn.getFieldValues(ar, \"name\", {year: 1975});\n * // [\"Jaws\", \"Barry Lindon\"]\n * ```\n * @memberof bbn.fn\n * @param    {Array}                    arr       The subject array\n * @param    {String}                   field     The property from which the values are returned\n * @param    {(String|Object|Function)} prop      A property's name or a filter object or function\n * @param    {*}                        val       The value with which comparing the given property\n * @param    {String}                   operator  The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {*}\n */\nfunction getFieldValues(arr, field, prop, val, operator) {\n    checkType(field, 'string');\n    if (prop) {\n        arr = filter(arr, prop, val, operator);\n    }\n    var res = [];\n    each(arr, function (a) { return (res.indexOf(a[field]) === -1 ? res.push(a[field]) : null); });\n    return res;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/removeHtmlComments.js\n\nfunction removeHtmlComments(str) {\n    if (!isString_isString(str)) {\n        return str;\n    }\n    return str.replace(/<!--[\\s\\S]*?-->/g, '');\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getHtml.js\n\nfunction getHtml(ele, stripComments) {\n    if (stripComments === void 0) { stripComments = false; }\n    var st = ele.innerHTML();\n    if (stripComments) {\n        st = removeHtmlComments(st);\n    }\n    return st.trim();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getPath.js\n\n/**\n * @method   getPath\n * @todo     Add method description for getPath\n * @global\n * @ignore\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction getPath(element) {\n    var path, \n    //node = $(element),\n    node = element, done = 0;\n    var _loop_1 = function () {\n        //let realNode = node[0],\n        var realNode = node, name_1 = realNode.localName;\n        if (!name_1)\n            return \"break\";\n        if (realNode === document.body)\n            return \"break\";\n        if (realNode.id) {\n            return { value: '#' + realNode.id };\n        }\n        if (!done) {\n            if (realNode.className && realNode.className !== ' ') {\n                name_1 += '.' + replaceAll(' ', '.', replaceAll('  ', ' ', realNode.className));\n            }\n            done = 1;\n        }\n        //var parent = node.parent(),\n        var parent_1 = node.parentNode, \n        //sameTagSiblings = parent.children(name);\n        sameTagSiblings = parent_1.children.filter(function (val) {\n            return val.tagName === name_1;\n        });\n        if (sameTagSiblings.length > 1) {\n            //var allSiblings = parent.children(),\n            var allSiblings = parent_1.children, \n            //index = allSiblings.index(realNode) + 1;\n            index = allSiblings.indexOf(realNode) + 1;\n            if (index > 1) {\n                name_1 += ':nth-child(' + index + ')';\n            }\n        }\n        path = name_1 + (path ? '>' + path : '');\n        node = parent_1;\n    };\n    while (node.length) {\n        var state_1 = _loop_1();\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        if (state_1 === \"break\")\n            break;\n    }\n    return path;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/getProp.js\n\n/**\n * Gets the given property from the given object\n * @param {Object} obj\n * @param {String} prop\n * @returns\n */\nfunction getProp(obj, prop) {\n    checkType(obj, \"object\", bbn._(\"The obj must be an object in setProp\"));\n    checkType(prop, \"string\", bbn._(\"The prop must be a string in setProp\"));\n    return obj[prop];\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/getScrollBarSize.js\nfunction getScrollBarSize() {\n    if (bbn.env.scrollBarSize === undefined) {\n        var outer = document.createElement('div');\n        outer.style.visibility = 'hidden';\n        outer.style.width = '100px';\n        if ('msOverflowStyle' in outer.style) {\n            outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\n        }\n        document.body.appendChild(outer);\n        var widthNoScroll = outer.offsetWidth;\n        // force scrollbars\n        outer.style.overflow = 'scroll';\n        // add innerdiv\n        var inner = document.createElement('div');\n        inner.style.width = '100%';\n        outer.appendChild(inner);\n        var widthWithScroll = inner.offsetWidth;\n        // remove divs\n        outer.parentNode.removeChild(outer);\n        var sz = widthNoScroll - widthWithScroll;\n        bbn.env.scrollBarSize = sz ? sz + 1 : 0;\n    }\n    return bbn.env.scrollBarSize;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/getText.js\nfunction getText(ele) {\n    return ele.innerText().trim();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/getTimeoff.js\n/**\n * Returns the length of time the window has not been focused in seconds.\n * @method   getTimeoff\n * @global\n * @example\n * ``` javascript\n * bbn.fn.getTimeoff();\n * // 0\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction getTimeoff() {\n    if (!bbn.env.isFocused) {\n        return Math.round(new Date().getTime() / 1000 - bbn.env.timeoff);\n    }\n    return 0;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/happy.js\n\n/**\n * Logs the given argument in the browser's console highlighting it with a green background.\n * @method   happy\n * @global\n * @example\n * ``` javascript\n * bbn.fn.happy('I want to log the success of my function');\n * ```\n * @memberof bbn.fn\n * @param    {...any} args\n * @returns\n */\nfunction happy() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.unshift({\n        _bbn_console_level: 3,\n        _bbn_console_style: 'color: white; background: green; font-size: 18px;',\n    });\n    log.apply(this, args);\n    return this;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/hex2rgb.js\n/**\n * Convert an hexadecimmal string to RGB.\n *\n * Converts a string that expresses a color in hexadecimal format into an object with\n * the properties that define the color and the corresponding value.\n *\n * @method   hex2rgb\n * @global\n *\n * @example\n * ```javascript\n * //{r:255, g:0, b:0}\n * bbn.fn.hex2rgb(\"#FF0000\");\n * ```\n *\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction hex2rgb(hex) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n        }\n        : null;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/history.js\nfunction history_history() {\n    return window.history || false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/html2text.js\n/**\n * Convert text in html format to plain text.\n *\n * @method   html2text\n * @global\n *\n * @example\n * ```javascript\n * //\"Hello world!\"\n * bbn.fn.html2text(\"<div><p>Hello <b>world!</b></p></div>\");\n * ```\n * @memberof bbn.fn\n * @param    {String} st\n * @returns {String}\n */\nfunction html2text(st) {\n    var $test = document.createElement(\"div\");\n    $test.innerHTML = st;\n    st = $test.innerText;\n    return st;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/imageToCanvas.js\n/**\n * Draws the given html image nto a canvas.\n * @method   imageToCanvas\n * @example\n * ``` javascript\n * //<canvas width=\"60\" height=\"32\"></canvas>\n * bbn.fn.imageToCanvas('<img src=\"path/myImage.png\">');\n * ```\n * @global\n * @memberof bbn.fn\n * @param {HTMLElement} img\n * @returns {HTMLCanvasElement}\n */\nfunction imageToCanvas(img) {\n    var canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    canvas.getContext('2d').drawImage(img, 0, 0);\n    return canvas;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/imgToBase64.js\n\nfunction imgToBase64(img, type) {\n    if (type === void 0) { type = 'image/png'; }\n    var canvas = imageToCanvas(img);\n    return canvas.toDataURL(type);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/info.js\n\n/**\n * Logs the given argument in the browser's console highlighting it with a blue background.\n * @method   info\n * @global\n * @memberof bbn.fn\n * @param    {...any} args\n * @returns  {*}\n */\nfunction info() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.unshift({\n        //_bbn_console_mode: \"info\",\n        _bbn_console_level: 4,\n        _bbn_console_style: 'color: #EEE; background: blue; font-size: 12px;',\n    });\n    log.apply(this, args);\n    return this;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/treatAjaxArguments.js\n\n\n\n\n/**\n * Transforms unordered arguments into a configuratiuon object for Ajax shortcut functions.\n *\n * The final object will have the following arguments: url, obj, datatype, force, successFn,\n * errorFn, abortFn, e, and ele; The rules are:\n * * The first string found is the URL\n * * The second string found is the datatype\n * * The first function is successFn\n * * The second function is errorFn\n * * The third function is abortFn\n * * A boolean true is force\n * * An Event is e\n * * An HTML element is ele\n *\n * If no object is given the _bbn property will be added in order to always post something\n * and let the bbn server scripts know if a whole DOM is requested or a JSON answer\n *\n * @method   treatAjaxArguments\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.treatAjaxArguments(['my/script', 'json', {a:1, b:2}, () => bbn.fn.log('Hi'), () => bbn.fn.log('Bye'), () => bbn.fn.log('Argh'), true])\n * // {\n * //   \"url\": \"my/script\",\n * //   \"datatype\": \"json\",\n * //   \"obj\": {\n * //     \"a\": 1,\n * //     \"b\": 2\n * //   },\n * //   \"successFn\": () => bbn.fn.log('Hi'),\n * //   \"errorFn\": () => bbn.fn.log('Bye'),\n * //   \"abortFn\": () => bbn.fn.log('Argh'),\n * //   \"force\": true\n * // }\n *\n * bbn.fn.treatAjaxArguments(['my/script?id=1'])\n * // {\n * //   \"url\": \"my/script?id=1\",\n * //   \"obj\": {\n * //     \"_bbn\": \"public\"\n * //   },\n * //   \"datatype\": \"json\"\n * // }\n * ```\n *\n * @param    {*}      args\n *\n * @returns  {Object} The configuration object\n */\nfunction treatAjaxArguments(args) {\n    var cfg = {};\n    var t;\n    var i;\n    if (isObject_isObject(args[0]) && args.length === 1) {\n        return args[0];\n    }\n    for (i = 0; i < args.length; i++) {\n        t = typeof args[i];\n        t = t.toLowerCase();\n        /* Callbacks */\n        if (isFunction_isFunction(args[i])) {\n            if (cfg[\"errorFn\"] && !cfg[\"abortFn\"]) {\n                cfg[\"abortFn\"] = args[i];\n            }\n            if (cfg[\"successFn\"] && !cfg[\"errorFn\"]) {\n                cfg[\"errorFn\"] = args[i];\n            }\n            else if (!cfg[\"successFn\"]) {\n                cfg[\"successFn\"] = args[i];\n            }\n        }\n        else if (args[i] === 1 || args[i] === true) {\n            /* Force */\n            cfg[\"force\"] = true;\n        }\n        else if (t === \"string\") {\n            if (!cfg[\"url\"]) {\n                /* Hash */\n                if (args[i].indexOf(\"#\") === 0 ||\n                    args[i].indexOf(bbn.env.root + \"#\") === 0) {\n                    cfg[\"url\"] = substr(args[i], bbn.env.root.length);\n                }\n                else {\n                    /* Link */\n                    cfg[\"url\"] = args[i];\n                    if (cfg[\"url\"].indexOf(bbn.env.root) === 0) {\n                        cfg[\"url\"] = substr(cfg[\"url\"], bbn.env.root.length);\n                    }\n                }\n            }\n            else {\n                /* Ajax datatype */\n                cfg[\"datatype\"] = args[i];\n            }\n        }\n        else if (args[i] && t === \"object\") {\n            /* Event */\n            if (args[i] instanceof Event) {\n                cfg[\"e\"] = args[i];\n            }\n            else if (!cfg[\"ele\"] && args[i].nodeType === 1) {\n                /* HTML Element */\n                cfg[\"ele\"] = args[i];\n            }\n            else if (t.toLowerCase() === \"object\") {\n                /* An object to post */\n                cfg[\"obj\"] = args[i];\n            }\n        }\n    }\n    if (!cfg[\"url\"] && numProperties(cfg)) {\n        cfg[\"url\"] = bbn.env.path;\n    }\n    if (cfg[\"obj\"] === undefined) {\n        cfg[\"obj\"] = { _bbn: \"public\" };\n    }\n    if (!cfg[\"datatype\"]) {\n        cfg[\"datatype\"] = \"json\";\n    }\n    return cfg;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/setNavigationVars.js\n\n\n\n\n/**\n * Changes the URL and the associated variables and updates the history.\n *\n * @method   setNavigationVars\n * @todo     Add method description for setNavigationVars\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * // Changing URL\n * bbn.fn.setNavigationVars('my/page', 'My page');\n * // Replacing the previous state\n * bbn.fn.setNavigationVars('my/page/deeper', 'My deeper page', null, true);\n * ```\n *\n * @param    {String}  url   The URL which will become the location.href\n * @param    {String}  title The title corresponding to the given URL\n * @param    {Object}  data  The data if any\n * @param    {Boolean} repl  If true the history state object will replace the current one, will be added otherwise\n *\n * @returns  {void}\n */\nfunction setNavigationVars(url, title, data, repl) {\n    if (data === void 0) { data = null; }\n    if (repl === void 0) { repl = false; }\n    // Current path becomes old path\n    bbn.env.old_path = bbn.env.path;\n    // URL includes the domain\n    bbn.env.url = ['https:/', 'http://'].includes(substr(url, 0, 7)) ? url : bbn.env.root + url;\n    // Path does not\n    bbn.env.path = substr(bbn.env.url, bbn.env.root.length);\n    // Params will include each part of the URL\n    bbn.env.params = filter(bbn.env.path.split('/'), function (v) {\n        return v !== '';\n    });\n    // Managing history\n    var h = window.history;\n    if (h) {\n        // Current state\n        var state = h.state;\n        // Future state\n        var obj = {\n            url: bbn.env.path,\n            old_path: bbn.env.old_path || null,\n            data: data || {},\n            reload: false\n        };\n        // If same URL we replace\n        if (state && state.url === bbn.env.path) {\n            if (state.data) {\n                extend_extend(obj.data, state.data);\n            }\n            if (state.title && !title) {\n                title = state.title;\n            }\n            repl = true;\n        }\n        // If no title the global title\n        if (!title) {\n            title = bbn.env.siteTitle;\n        }\n        // Otherwise we add the global title at the end\n        else {\n            title = html2text(title);\n        }\n        // Replacing state\n        if (repl) {\n            obj.reload = true;\n            h.replaceState(obj, title, bbn.env.url);\n        }\n        // Adding state\n        else {\n            h.pushState(obj, title, bbn.env.url);\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/link.js\n\n\n\n\n\n\n\n\n/**\n * Follows a link and if needed by sending the corresponding Ajax request and executing bbn.fn.defaultPreLinkFunction.\n *\n * Once bbn has been initiated this function will be triggered every time a link is clicked.\n * It accepts the same arguments as seen in treatAjaxArguments but will tipically just be called with a URL,\n * the defaultLinkURL functions being in charge of loading the content\n *\n * @method   link\n * @todo     Manage anchors + returned data unclear\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * // Will open in a new window/tab\n * bbn.fn.link('https://nytimes.com');\n * // Will send an Ajax request\n * bbn.fn.link('my/page');\n * // Will open your default email program\n * bbn.fn.link('mailto:postmaster@test.com');\n * ```\n *\n * @returns\n */\nfunction link_link() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var cfg = treatAjaxArguments(args);\n    var ok = 1;\n    if (cfg === true) {\n        return true;\n    }\n    /* If we can't find a correct link we load the current URL */\n    if (!cfg) {\n        return link_link(window.location.href);\n    }\n    /* Just executing the javascript if there is */\n    if (cfg.url.indexOf('javascript:') === 0) {\n        return true;\n    }\n    if (cfg.url.indexOf('data:') === 0) {\n        return true;\n    }\n    if (cfg.url.indexOf('#') === 0) {\n        location.href = bbn.env.url + cfg.url;\n        /*\n        if ( window.history ){\n          bbn.env.historyDisabled = true;\n          let state = h.state;\n          window.history.replaceState(null, state.title, bbn.env.url);\n        }\n        bbn.env.historyDisabled = false;\n        */\n        return true;\n    }\n    else if (cfg.url.indexOf('mailto:') === 0) {\n        /* Mail link */\n        bbn.env.ignoreUnload = true;\n        window.location.href = cfg.url;\n        setTimeout(function () {\n            bbn.env.ignoreUnload = false;\n        }, 0);\n        return false;\n    }\n    if (getLoader(cfg.url)) {\n        return false;\n    }\n    /* Opens an external page in a new window */\n    if ((cfg.url.indexOf('http://') === 0 || cfg.url.indexOf('https://') === 0) &&\n        cfg.url.indexOf(bbn.env.host) !== 0) {\n        if (cfg.e) {\n            cfg.e.preventDefault();\n        }\n        window.open(cfg.url);\n        return false;\n    }\n    else if (cfg.url !== bbn.env.params.join('/') || cfg.force === 1) {\n        /* The URL is fine so go ahead if something is not already loading */\n        /* If a second callback is defined, it is triggered instead of defaultPreLinkFunction */\n        if (cfg.successFn) {\n            ok = cfg.successFn(cfg.url);\n        }\n        else if (bbn.fn.defaultPreLinkFunction) {\n            var tmp = bbn.fn.defaultPreLinkFunction(cfg.url, cfg.force, cfg.ele);\n            if (tmp.data !== undefined) {\n                extend_extend(cfg.obj, tmp.data);\n                ok = 1;\n            }\n            else {\n                ok = tmp;\n            }\n        }\n        if (ok) {\n            if (ok !== 1 && typeof ok === 'string') {\n                cfg.url = ok;\n            }\n            /** todo Do we keep obj in the unique string or do we make that only one concurrent connection to the same address can occur at the same time? */\n            var errSt_1 = bbn._('The Ajax call to') + ' ' + cfg.url + ' ';\n            return ajax(cfg.url, cfg.datatype, cfg.obj, function (res) {\n                if (!res) {\n                    log(errSt_1 + bbn._('returned no answer'));\n                }\n                if (isObject_isObject(res)) {\n                    // If there's nothing in the result, just an empty object, the callback stops here and the URL is not changed\n                    if (Object.keys(res).length === 0) {\n                        log(errSt_1 + bbn._('returned an empty object'));\n                    }\n                    if (res.new_url) {\n                        res.old_path = cfg.url;\n                        cfg.url = res.new_url;\n                    }\n                    else if (res.url && cfg.url !== res.url) {\n                        res.old_path = cfg.url;\n                    }\n                }\n                if (callback(cfg.url, res, cfg.successFn, null, cfg.ele) && res.noNav === undefined) {\n                    // This solution is not very clean (we can't shorten a URL)\n                    if (bbn.env.path.indexOf(cfg.url) !== 0) {\n                        setNavigationVars(cfg.url, (res.title ? res.title + ' - ' : '') + bbn.env.siteTitle);\n                    }\n                }\n            }, cfg.errorFn || null);\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/post.js\n\n\n\n/**\n * Creates a POST XHR through bbn.fn.ajax then launches bbn.fn.callback with the result.\n *\n * URL is the only mandatory argument (see treatAjaxArguments for the arguments).\n *\n * @method   post\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.post('logout').then(() => {\n *   document.location.reload();\n * });\n * // With data\n * bbn.fn.post('login', {user: 'tn', pass: 'xxx'}).then((d) => {\n *  if (d && d.success) {\n *    alert('Welcome!');\n *  }\n * });\n * // With the callback as argument\n * bbn.fn.post('login', {user: 'tn', pass: 'xxx'}, (d) => {\n *  if (d && d.success) {\n *    alert('Welcome!');\n *  }\n * }, (err) => {\n *   bbn.fn.log(err);\n *   mySpecialErrorFunction(err);\n * });\n * ```\n *\n * @returns  {undefined|Promise}\n */\nfunction post() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var cfg = treatAjaxArguments(args);\n    if (cfg.url) {\n        return ajax(cfg.url, cfg.datatype, cfg.obj, function (res) {\n            callback(cfg.url, res, cfg.successFn, null, cfg.ele);\n        }, cfg.errorFn, cfg.abortFn);\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/form/submit.js\n\n\n/**\n * Submit a form's data through an Ajax request.\n *\n * It will also prevent the event if given, and execute the given callback,\n * or look for one in the data-script attribute.\n *\n * @method   submit\n * @global\n * @memberof bbn.fn\n * @fires    {*}\n * @fires    {*}\n *\n * @param    {HTMLElement} form The form to submit\n * @param    {Event}       e    The optional submit event - which will be prevented\n * @param    {Function}    fn   An optional callback function\n *\n * @returns  {*}\n */\nfunction submit_submit(form, e, fn) {\n    var url = form.getAttribute('action') || bbn.env.path;\n    var data;\n    if (url === '') {\n        url = '.';\n    }\n    //if ( (typeof(url) === 'string') && (url.indexOf(\"http\") !== 0 || url.indexOf(window.document.location.hostname) !== -1) && !form.is(\"[target]\") ){\n    if (typeof url === 'string' &&\n        (url.indexOf('http') !== 0 || url.indexOf(window.document.location.hostname) !== -1) &&\n        !form.getAttribute('target')) {\n        if (e) {\n            e.preventDefault();\n        }\n        data = formdata(form);\n        if (data) {\n            //$form.attr(\"action\", null);\n            form.setAttribute('action', null);\n            //$form.data(\"bbnSubmit\", 1);\n            var args = [url, data];\n            if (!fn && form.getAttribute('data-script')) {\n                fn = new Function(form.getAttribute('data-script'));\n                fn = fn();\n            }\n            if (fn) {\n                args.push(fn);\n            }\n            post.apply(void 0, args);\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/resize.js\n\n\nfunction resize() {\n    var diffW = bbn.env.width !== window.innerWidth;\n    var diffH = bbn.env.height !== window.innerHeight;\n    if (diffW || diffH) {\n        if (diffW) {\n            bbn.env.width =\n                window.innerWidth || window.document.documentElement.clientWidth || window.document.body.clientWidth;\n            document.documentElement.style.setProperty('--vw', bbn.env.width * 0.01 + 'px');\n        }\n        if (diffH) {\n            bbn.env.height =\n                window.innerHeight || window.document.documentElement.clientHeight || window.document.body.clientHeight;\n            document.documentElement.style.setProperty('--vh', bbn.env.height * 0.01 + 'px');\n        }\n        var smallWidth = parseInt(getCssVar('mobile-limit')) || 650;\n        var newCls_1 = 'bbn-screen-' + (bbn.env.width < smallWidth ? 'small' : 'regular');\n        var classes_1 = (document.body.className || '').split(' ');\n        var done_1 = false;\n        each(classes_1, function (cls, idx) {\n            var bits = cls.split('-');\n            if (bits.length === 3 && cls.indexOf('bbn-screen-') === 0) {\n                done_1 = true;\n                if (cls !== newCls_1) {\n                    classes_1.splice(idx, 1, newCls_1);\n                }\n                return false;\n            }\n        });\n        if (!done_1) {\n            classes_1.push(newCls_1);\n        }\n        bbn.fn.defaultResizeFunction();\n        document.body.className = classes_1.join(' ');\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/isMobileDevice.js\n\nfunction isMobileDevice() {\n    return getDeviceType() === 'mobile';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/isTabletDevice.js\n\n/**\n  * Returns true if the current device type is a tablet.\n  * @method   isTabletDevice\n  * @global\n  * @example\n  * ``` javascript\n  * bbn.fn.isTabletDevice();\n  * // false\n  * ```\n  * @memberof bbn.fn\n  * @returns  {Boolean}\n  */\nfunction isTabletDevice() {\n    return getDeviceType() === 'tablet';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/isMobile.js\n\n\n/**\n * Returns true if the current browser is on a mobile device (smartphone or tablet).\n * @method   isMobile\n * @global\n * @example\n * ``` javascript\n * bbn.fn.isMobile();\n * // false\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isMobile() {\n    return isMobileDevice() || isTabletDevice();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/init.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Initializes the library bbn basing on the given configuration object.\n * - Gives to the environment the dimension of the window.innerWidth and window.innerHeight\n * - Defines the server's path (difference between the host and the current dir)\n * - Adds the colors contained in bbn.var.colors to define the css classes for background and colors.\n * - Adds the event listener to the document\n * - Activates the history\n * @method   init\n * @global\n * @memberof bbn.fn\n * @param    {Object} cfg\n * @returns\n */\nfunction init(cfg, force) {\n    var parts;\n    if (!bbn.env.isInit || force) {\n        bbn.env.root =\n            document.baseURI.length > 0 ? document.baseURI : bbn.env.host;\n        if (bbn.env.root.length && substr(bbn.env.root, -1) !== \"/\") {\n            bbn.env.root += \"/\";\n        }\n        if (!bbn.env.isInit && typeof dayjs !== \"undefined\") {\n            each([\n                \"advancedFormat\",\n                \"arraySupport\",\n                \"badMutable\",\n                \"buddhistEra\",\n                \"calendar\",\n                \"customParseFormat\",\n                \"dayOfYear\",\n                \"devHelper\",\n                \"duration\",\n                \"isBetween\",\n                \"isLeapYear\",\n                \"isSameOrAfter\",\n                \"isSameOrBefore\",\n                \"isToday\",\n                \"isTomorrow\",\n                \"isYesterday\",\n                \"isoWeek\",\n                \"isoWeeksInYear\",\n                \"localeData\",\n                \"localizedFormat\",\n                \"minMax\",\n                \"objectSupport\",\n                \"pluralGetSet\",\n                \"quarterOfYear\",\n                \"relativeTime\",\n                \"timezone\",\n                \"toArray\",\n                \"toObject\",\n                \"updateLocale\",\n                \"utc\",\n                \"weekOfYear\",\n                \"weekYear\",\n                \"weekday\",\n            ], function (plugin) {\n                if (window[\"dayjs_plugin_\" + plugin]) {\n                    dayjs.extend(window[\"dayjs_plugin_\" + plugin]);\n                }\n            });\n        }\n        /* The server's path (difference between the host and the current dir */\n        if (typeof cfg === \"object\") {\n            extend_extend(true, bbn, cfg);\n        }\n        bbn.env.path = substr(bbn.env.url, bbn.env.root.length);\n        parts = bbn.env.path.split(\"/\");\n        //$.each(parts, function(i, v){\n        each(parts, function (v, i) {\n            v = decodeURI(v.trim());\n            if (v !== \"\") {\n                bbn.env.params.push(v);\n            }\n        });\n        if (bbn.var.colors) {\n            addColors(bbn.var.colors);\n        }\n        if (bbn.env.lang && undefined !== dayjs) {\n            dayjs.locale(bbn.env.lang);\n        }\n        window.onfocus = function () {\n            bbn.env.isFocused = true;\n        };\n        window.onblur = function () {\n            bbn.env.isFocused = false;\n            bbn.env.timeoff = Math.round(new Date().getTime() / 1000);\n        };\n        document.addEventListener(\"focusin\", function (e) {\n            if (e.target instanceof HTMLElement &&\n                !e.target.classList.contains(\"bbn-no\")) {\n                bbn.env.focused = e.target;\n            }\n            bbn.env.last_focus = new Date().getTime();\n        });\n        document.addEventListener(\"click\", function (e) {\n            bbn.env.last_focus = new Date().getTime();\n            if (bbn.env.nav !== \"ajax\") {\n                return;\n            }\n            var target = e.target;\n            if (target instanceof HTMLElement && target.tagName !== \"A\") {\n                var p = target;\n                while (p && p.tagName !== \"A\") {\n                    if (p.tagName === \"BODY\") {\n                        break;\n                    }\n                    p = p.parentElement;\n                }\n                if (p && p.tagName === \"A\") {\n                    target = p;\n                }\n                else {\n                    target = null;\n                }\n            }\n            if (target instanceof HTMLElement &&\n                target.hasAttribute(\"href\") &&\n                !target.hasAttribute(\"target\") &&\n                !target.classList.contains(\"bbn-no\")) {\n                e.preventDefault();\n                e.stopPropagation();\n                link_link(target.getAttribute(\"href\"));\n                return false;\n            }\n        });\n        each(document.querySelectorAll(\"form:not(.bbn-no), form:not(.bbn-form)\"), function (ele) {\n            ele.addEventListener(\"submit\", function (e) {\n                submit_submit(ele, e);\n            });\n        });\n        window.addEventListener(\"hashchange\", function () {\n            bbn.env.hashChanged = new Date().getTime();\n        }, false);\n        window.addEventListener(\"resize\", function () {\n            resize();\n        });\n        window.addEventListener(\"orientationchange\", function () {\n            resize();\n        });\n        resize();\n        if (isMobile()) {\n            document.body.classList.add(\"bbn-mobile\");\n            if (isTabletDevice()) {\n                document.body.classList.add(\"bbn-tablet\");\n            }\n        }\n        if (window.history) {\n            window.onpopstate = function (e) {\n                var h = window.history;\n                if (!bbn.env.historyDisabled && h) {\n                    //e.preventDefault();\n                    if (bbn.fn.defaultHistoryFunction(h.state)) {\n                        var state = h.state;\n                        if (state) {\n                            //link(substr(state.url, bbn.env.root.length), $.extend({title: state.title}, state.data));\n                            link_link(state.url, extend_extend({ title: state.title || bbn.env.siteTitle }, state.data || {}));\n                        }\n                        else if (state && state.data && isFunction_isFunction(state.data.script)) {\n                            state.data.script();\n                        }\n                    }\n                }\n            };\n        }\n        bbn.env.isInit = true;\n        document.dispatchEvent(new Event(\"bbninit\"));\n        if (bbn.env.logging) {\n            log(\"Logging in bbn is enabled\");\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/isActiveInterface.js\n/**\n * Tells if the interface is beeing active for the past x seconds.\n * @method   isActiveInterface\n * @global\n * @example\n * // true\n * ``` javascript\n * bbn.fn.isActiveInterface(54764654);\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isActiveInterface(secs) {\n    if (secs === void 0) { secs = 600; }\n    if (!bbn.env.last_focus) {\n        return false;\n    }\n    var t = new Date().getTime();\n    return t - bbn.env.last_focus < secs * 1000;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isBoolean.js\n/**\n * Returns true if the given argument is a boolean\n * @method   isBoolean\n * @global\n * @example\n * ```javascript\n * const sb = true;\n * bbn.fn.isBoolean(sb); // true\n * const sb = 1;\n * bbn.fn.isBoolean(sb); // false\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isBoolean_isBoolean() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (![true, false].includes(a)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isColor.js\n\n/**\n * Intended to check if the argument provided is a color.\n *\n * It is possible to pass as argument a string with hexadecimal value in rgb or the name of the color.\n *\n * @method   isColor\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.isColor(\"#FF0000\")\n * //true\n * ```\n *\n * @example\n * ```javascript\n * bbn.fn.isColor(\"rgb 255, 0, 0\");\n * //true\n * ```\n *\n * @example\n * ```javascript\n * bbn.fn.isColor(\"red\");\n * //true\n * ```\n * @memberof bbn.fn\n * @param    {String} st\n * @returns  {Boolean}\n */\nfunction isColor() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    var reg = new RegExp(\"^(#[a-f0-9]{6}|#[a-f0-9]{3}|rgb *( *[0-9]{1,3}%? *, *[0-9]{1,3}%? *, *[0-9]{1,3}%? *)|rgba *( *[0-9]{1,3}%? *, *[0-9]{1,3}%? *, *[0-9]{1,3}%? *, *[0-9]{1,3}%? *)|black|green|silver|gray|olive|white|yellow|maroon|navy|red|blue|purple|teal|fuchsia|aqua)$\", \"i\");\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var st = args_1[_a];\n        if (!isString_isString(st)) {\n            return false;\n        }\n        if (!reg.test(st)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isComment.js\n/**\n * Returns true if the given argument is a dom comment;\n * @method   isComment\n * @example\n * ```javascript\n * bbn.fn.isComment(node.childNodes[0]);\n * //true\n * ```\n * @global\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isComment() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!(a instanceof Comment)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/isDesktopDevice.js\n\n/**\n * Returns true if the current device type is a desktop.\n * @method   isDesktopDevice\n * @global\n * @example\n * ``` javascript\n * bbn.fn.isDesktopDevice();\n * // true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isDesktopDevice() {\n    return getDeviceType() === 'desktop';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isValidDimension.js\n\n\n/**\n * Returns true if the given value is a valid CSS dimension string, false otherwise.\n *\n * @method   isValidDimension\n * @global\n * @memberof bbn.fn\n * @param    {String} st\n * @returns\n */\nfunction isValidDimension(st) {\n    if (typeof st === \"string\" &&\n        st.length > 0 &&\n        (st.indexOf(\"calc\") === 0 || isNumber_isNumber(substr(st, 0, 1)))) {\n        var el = document.createElement(\"div\");\n        el.style.width = st;\n        var res = !!el.style.width.length;\n        el.remove();\n        return res;\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isDimension.js\n\n/**\n * Returns true if the given value is a valid CSS dimension string or a number, false otherwise.\n *\n * @method   isDimension\n * @global\n * @memberof bbn.fn\n * @param    {String} st\n * @returns\n */\nfunction isDimension() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var st = args_1[_a];\n        if (typeof st !== \"number\" || st < 0) {\n            return false;\n        }\n        if (!isValidDimension(st)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isEmail.js\n\n/**\n * Intended to check if the argument provided is an e-mail address written correctly\n *\n * @method   isEmail\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.isEmail('test@testorg');\n * //false\n * ```\n *\n * @example\n * ```javascript\n * bbn.fn.isEmail('test@test.org');\n * //true\n * ```\n * @memberof bbn.fn\n * @param    {String} st\n * @returns  {Boolean}\n */\nfunction isEmail() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    var regex = /^([a-zA-Z0-9_.+-])+\\@(([a-zA-Z0-9-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var st = args_1[_a];\n        if (!isString_isString(st)) {\n            return false;\n        }\n        if (!regex.test(st)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isEvent.js\n/**\n * Returns true if the given argument is an event.\n * @method   isEvent\n * @global\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isEvent() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (!(a instanceof Event)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/isFocused.js\n/**\n * Checks whether the given elemet is focused or not.\n *\n * @method   isFocused\n * @global\n * @example\n * ``` javascript\n * bbn.fn.isFocused(document.getElementById('input_name'));\n * // false\n * bbn.fn.isFocused(bbn.sel('.container'));\n * // true\n * ```\n * @memberof bbn.fn\n *\n * @param {Element} ele     The element to be checked for focus\n * @param {Boolean} contain If true will check if the focused element is contained in the given element\n *\n * @returns  {Boolean} True if focused\n */\nfunction isFocused(ele, contain) {\n    if (contain === void 0) { contain = false; }\n    return ele === document.activeElement || (contain && ele.contains && ele.contains(document.activeElement));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isIP.js\n\nfunction isIP() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var st = args_1[_a];\n        if (!isString_isString(st) || !bbn.var.regexp.ip.test(st)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isHostname.js\n\n\nfunction isHostname() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var st = args_1[_a];\n        if (!isString_isString(st)) {\n            return false;\n        }\n        if (!isIP(st) && !bbn.var.regexp.hostname.test(st)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/isInside.js\n\n\n\nfunction isInside(ele, ancestor) {\n    var ancestors = getAncestors(ele);\n    if (ancestors.length) {\n        if (isString_isString(ancestor)) {\n            var ok_1 = false;\n            each(ancestors, function (a) {\n                if (a.matches && a.matches(ancestor)) {\n                    ok_1 = true;\n                    return false;\n                }\n            });\n            return ok_1;\n        }\n        if (ancestor instanceof HTMLElement) {\n            return ancestors.indexOf(ancestor) > -1;\n        }\n    }\n    return false;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/isInViewport.js\nfunction isInViewport(ele, fully) {\n    if (fully === void 0) { fully = false; }\n    var bounding = ele.getBoundingClientRect();\n    if (fully) {\n        return (bounding.top >= 0\n            && bounding.left >= 0\n            && bounding.right <= (window.innerWidth || document.documentElement.clientWidth)\n            && bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight));\n    }\n    var eleHeight = ele.offsetHeight;\n    var eleWidth = ele.offsetWidth;\n    return (bounding.top >= -eleHeight\n        && bounding.left >= -eleWidth\n        && bounding.right <= (window.innerWidth || document.documentElement.clientWidth) + eleWidth\n        && bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) + eleHeight);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isPercent.js\n/**\n * Returns true if the given argument is a percentage.\n * @method   isPercent\n * @global\n * @example\n * ```javascript\n * bbn.fn.isPercent('5%');\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isPercent() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (typeof a !== \"string\" || !a.match(/^\\d+(?:\\.\\d+)?%$/)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isPrimitive.js\n/**\n * Returns true if the given arguments are primitive;\n * @method   isPrimitive\n * @global\n * @example\n * ```javascript\n * bbn.fn.isPrimitive('myString', 6, true);\n * //true\n * bbn.fn.isPrimitive([80,10,22]);\n * //false\n * bbn.fn.isPrimitive({});\n * //false\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isPrimitive() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (a !== null && (typeof a == \"object\" || typeof a == \"function\")) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isPromise.js\n/**\n * Returns true if the given argument is a promise.\n * @global\n * @example\n * ```javascript\n * bbn.fn.isPromise(bbn.fn.post('myUrl'));\n * // true\n * bbn.fn.isPromise(setTimeout(() => {}))\n * // false\n * bbn.fn.isPromise(myVueObject.$nextTick());\n * // true\n * ```\n * @method   isFunction\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isPromise() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object Promise]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isPropSize.js\n\nfunction isPropSize(name) {\n    var isTrue = false;\n    each(['width', 'height', 'gap', 'margin', 'padding', 'top', 'left', 'right', 'bottom'], function (a) {\n        if (name.indexOf(a) !== -1) {\n            isTrue = true;\n            return false;\n        }\n    });\n    return isTrue;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isSQLDate.js\n/**\n * @ignore\n * @method   isSQLDate\n * @todo     Add method description for isSQLDate\n * @global\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isSQLDate() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if (typeof a !== \"string\" ||\n            !a.match(/^([1-2]\\d{3})-((0\\d)|(1[12]))-(([0-2]\\d)|(3[01]))(?:( [0-2]\\d):([0-5]\\d):([0-5]\\d))?$/)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isSymbol.js\n/**\n * Returns true if the given argument is a symbol;\n * @method   isSymbol\n * @global\n * @example\n * ```javascript\n * const sb = Symbol();\n * bbn.fn.isSymbol(sb);\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isSymbol() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var a = args_1[_a];\n        if ({}.toString.apply(a) !== \"[object Symbol]\") {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isURL.js\nfunction isURL() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length)\n        return false;\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var str = args_1[_a];\n        if (!bbn.var.regexp.url.test(str)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isValidName.js\n\n/**\n * Returns true if the given value is a valid name for a function without checking in reserved words, false otherwise\n * @method   isValidName\n * @global\n * @example\n * ```javascript\n * bbn.fn.isValidName('$myFunc_tion')\n * // true\n * ```\n * @example\n * ```javascript\n * bbn.fn.isValidName('7Y')\n * // false\n * ```\n *\n * @example\n * ```javascript\n * bbn.fn.isValidName('function')\n * // true\n * ```\n *\n * @memberof bbn.fn\n * @param    {String} st\n * @returns {Boolean}\n */\nfunction isValidName() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length) {\n        return false;\n    }\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var arg = args_1[_a];\n        if (!isString_isString(arg) || !/^[$A-Z_][0-9A-Z_$]*$/i.test(arg)) {\n            return false;\n        }\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/type/isVue.js\n/**\n * Returns true if the given argumen is a VueJS object.\n *\n * @method   isVue\n * @global\n * @example\n * ```javascript\n * let myObj =  new Vue({});\n * bbn.fn.isVue(myObj);\n * //true\n * ```\n * @memberof bbn.fn\n * @returns  {Boolean}\n */\nfunction isVue() {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (!args.length) {\n        return false;\n    }\n    if (\"vue\" in bbn && window[\"Vue\"]) {\n        if (\"app\" in bbn.vue) {\n            for (var _b = 0, args_1 = args; _b < args_1.length; _b++) {\n                var a = args_1[_b];\n                if (!a || typeof a.render !== \"function\") {\n                    return false;\n                }\n            }\n        }\n        else {\n            for (var _c = 0, args_2 = args; _c < args_2.length; _c++) {\n                var a = args_2[_c];\n                if (!(a instanceof window[\"Vue\"])) {\n                    return false;\n                }\n            }\n        }\n    }\n    if (\"cp\" in bbn &&\n        \"isComponent\" in bbn[\"cp\"] &&\n        typeof bbn[\"cp\"].isComponent === \"function\") {\n        return (_a = bbn.cp).isComponent.apply(_a, args);\n    }\n    return true;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/lightenDarkenHex.js\n/**\n * Takes color in hex format and lightens or darkens it with the given value.\n * @method   lightenDarkenHex\n * @global\n * @example\n * ```javascript\n * //\"#eccb28\"\n * bbn.fn.lightenDarkenHex('#c4a300', 40);\n * ```\n *\n * @example\n * ```javascript\n * //\"#9c7b00\"\n * bbn.fn.lightenDarkenHex(#c4a300', -40);\n * ```\n * @memberof bbn.fn\n * @returns  {String}\n */\nfunction lightenDarkenHex(hex, amt) {\n    if (hex && amt) {\n        var ht = hex[0] === \"#\";\n        hex = ht ? hex.slice(1) : hex;\n        var num = parseInt(hex, 16), r = (num >> 16) + amt, b = ((num >> 8) & 0x00ff) + amt, g = (num & 0x0000ff) + amt;\n        if (r > 255) {\n            r = 255;\n        }\n        else if (r < 0) {\n            r = 0;\n        }\n        if (b > 255) {\n            b = 255;\n        }\n        else if (b < 0) {\n            b = 0;\n        }\n        if (g > 255) {\n            g = 255;\n        }\n        else if (g < 0) {\n            g = 0;\n        }\n        return (ht ? \"#\" : \"\") + (g | (b << 8) | (r << 16)).toString(16);\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/warning.js\n\n/**\n * Logs the given argument in the browser's console highlighting it with a yellow background and red color.\n * @method   warning\n * @global\n * @example\n * ```javascript\n * bbn.fn.warning('whatever you want to log as a warning');\n * ```\n * @memberof bbn.fn\n * @param    {...any} args\n * @returns\n */\nfunction warning(message) {\n    var args = ['BBN: ' + message];\n    var obj = {\n        _bbn_console_mode: 'warn',\n        _bbn_console_level: 2,\n        _bbn_console_style: 'color: #E64141; background: #F7E195; font-size: 14px',\n    };\n    args.unshift(obj);\n    log.apply(this, args);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/makeReactive.js\n\n\n\n\n\n\n\n\nfunction makeReactive(obj, onSet, parent, parentProp) {\n    var parentString = (parent === null || parent === void 0 ? void 0 : parent.$cid) || '';\n    var prefix = '__bbn_' + (parentString ? parentString + '_' : '');\n    if (obj && typeof obj === 'object' && [undefined, Object, Array].includes(obj.constructor)) {\n        if (obj.__bbnIsProxy && obj.__bbnParent === parent) {\n            return obj;\n        }\n        if (parent && parent.$options && parent.$options.name === 'bbn-loadbar') {\n            log(['MAKING bbn-loadbar', obj]);\n        }\n        if (!obj.__bbnWatchers) {\n            Reflect.defineProperty(obj, '__bbnWatchers', {\n                value: createObject(),\n                writable: true,\n                configurable: true,\n                enumerable: false,\n            });\n        }\n        var handler = {\n            get: function (target, key) {\n                var realValue = Reflect.get(target, key);\n                var realTarget = target.__bbnRoot || target;\n                if (isSymbol(key)) {\n                    return Reflect.get(realTarget, key);\n                }\n                var propName = parentProp ? parentProp + '.' + key : key;\n                var hiddenKey = prefix + (isNumber_isNumber(key) ? key.toString() : key);\n                if (['fill', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].includes(key) &&\n                    isArray_isArray(target)) {\n                    return function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        var res = realTarget[key].apply(realTarget, args);\n                        warning('DOING ARRAY STUFF');\n                        log(target.__bbnParent);\n                        onSet(target, 'length', parent);\n                        return res;\n                    };\n                }\n                if (isFunction_isFunction(realValue)) {\n                    return realValue;\n                }\n                if (key === '__bbnRoot') {\n                    var root = obj;\n                    while (root && (root === null || root === void 0 ? void 0 : root.__bbnTarget)) {\n                        root = root.__bbnTarget;\n                    }\n                    return root;\n                }\n                if (key === '__bbnIsProxy') {\n                    return true;\n                }\n                if (key === '__bbnTarget') {\n                    return target;\n                }\n                if (key === '__bbnParent') {\n                    return parent;\n                }\n                if (key === '__bbnWatchers') {\n                    return target.__bbnWatchers;\n                }\n                if (key.indexOf('__bbn_') === 0) {\n                    return Reflect.get(target, key);\n                }\n                if (key === 'length' && isArray_isArray(target.__bbnRoot || target)) {\n                    return realTarget.length;\n                }\n                if (!(key in target)) {\n                    return realValue;\n                }\n                if (realValue &&\n                    typeof realValue === 'object' &&\n                    [undefined, Object, Array].includes(realValue.constructor)) {\n                    if (realValue.__bbnIsProxy && realValue.__bbnParent === parent) {\n                        return realTarget[hiddenKey];\n                    }\n                    if (!(hiddenKey in realTarget)) {\n                        Reflect.defineProperty(realTarget, hiddenKey, {\n                            value: makeReactive(realValue, onSet, parent, propName),\n                            writable: true,\n                            configurable: true,\n                            enumerable: false,\n                        });\n                    }\n                    if (realTarget[hiddenKey].__bbnIsProxy && !realTarget.__bbnWatchers[parentString]) {\n                        realTarget.__bbnWatchers[parentString] = propName;\n                    }\n                    return realTarget[hiddenKey];\n                }\n                return realValue;\n            },\n            set: function (target, key, value) {\n                if (isSymbol(key)) {\n                    return Reflect.get(target, key, value);\n                }\n                var realTarget = target.__bbnRoot || target;\n                var propName = parentProp ? parentProp + '.' + key : key;\n                if (isSymbol(key)) {\n                    return Reflect.get(target, key);\n                }\n                if (parent && parent.$options && parent.$options.name === 'bbn-loadbar') {\n                    log(['Setting proxy prop in ' + parent.$options.name, target, key, value]);\n                }\n                if (!isSame(realTarget[key], value)) {\n                    if (key.indexOf('__bbn_') === 0) {\n                        Reflect.defineProperty(realTarget, key, {\n                            value: makeReactive(value, onSet, parent, propName),\n                            writable: true,\n                            configurable: true,\n                            enumerable: false,\n                        });\n                    }\n                    else {\n                        if (value &&\n                            typeof value === 'object' &&\n                            [undefined, Object, Array].includes(value.constructor)) {\n                            var hiddenKey = prefix + (isNumber_isNumber(key) ? key.toString() : key);\n                            Reflect.defineProperty(realTarget, hiddenKey, {\n                                value: makeReactive(value, onSet, parent, propName),\n                                writable: true,\n                                configurable: true,\n                                enumerable: false,\n                            });\n                            if (realTarget[hiddenKey].__bbnIsProxy && !realTarget.__bbnWatchers[parentString]) {\n                                realTarget.__bbnWatchers[parentString] = propName;\n                            }\n                        }\n                    }\n                    if (parent && parent.$options && parent.$options.name === 'bbn-loadbar') {\n                        log([\n                            'Setting proxy prop in ' +\n                                parent.$options.name +\n                                ' ' +\n                                (isNumber_isNumber(key) ? key.toString() : key),\n                            value,\n                            target,\n                        ]);\n                    }\n                    Reflect.set(realTarget, key, value);\n                    onSet(target, key, parent);\n                }\n                return true;\n            },\n            defineProperty: function (target, key, description) {\n                var realTarget = target;\n                var propName = parentProp ? parentProp + '.' + key : key;\n                if (key === '__bbnWatchers' || isSymbol(key) || key.indexOf('__bbn_') === 0) {\n                    Reflect.defineProperty(realTarget, key, description);\n                }\n                else {\n                    var hiddenKey = prefix + (isNumber_isNumber(key) ? key.toString() : key);\n                    Reflect.defineProperty(realTarget, hiddenKey, {\n                        value: makeReactive(description.value, onSet, parent, propName),\n                        writable: true,\n                        configurable: true,\n                        enumerable: false,\n                    });\n                }\n                onSet(target, key, parent);\n                return true;\n            },\n            deleteProperty: function (target, key) {\n                var realTarget = target;\n                if (key.indexOf('__bbn_') === 0) {\n                    Reflect.deleteProperty(realTarget, key);\n                }\n                else {\n                    var hiddenKey = prefix + (isNumber_isNumber(key) ? key.toString() : key);\n                    Reflect.deleteProperty(realTarget, hiddenKey);\n                    Reflect.deleteProperty(target, key);\n                }\n                return true;\n            },\n        };\n        return new Proxy(obj, handler);\n    }\n    return obj;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/map.js\n\n/**\n * Returns a new array generated by the execution of a function for each item of the given array.\n *\n * The deepProp argument is the name of property which should contain a nested array on which\n * the function should also be applied recursively.\n *\n * @method   map\n * @global\n * @example\n * ```javascript\n * bbn.fn.map([1, 2, 3, 4], a => {\n *   return a + 1;\n * });\n * // [2, 3, 4, 5]\n * ```\n * @example\n * ```javascript\n * bbn.fn.map(\n *   [{\n *     name: \"tools\",\n *     items: [\n *       {\n *          name: \"hammers\"\n *       }, {\n *          name: \"screwdrivers\",\n *          items: [\n *            {name: \"flat screwdrivers\"},\n *            {name: \"slotted screwdrivers\"},\n *            {name: \"Hex screwdrivers\"},\n *          ]\n *       }\n *     ]\n *   }, {\n *     name: \"Kitchenware\"\n *   }],\n *   d => {\n *     d.warranty = d.name === \"Hex screwdrivers\" ? \"10 years\" : \"1 year\";\n *     return d;\n *   },\n *   \"items\"\n * );\n * // [\n * //    {\n * //       name: \"tools\",\n * //       warranty: \"1 year\",\n * //       items: [\n * //         {\n * //            name: \"hammers\",\n * //            warranty: \"1 year\",\n * //         }, {\n * //            name: \"screwdrivers\",\n * //            warranty: \"1 year\",\n * //            items: [\n * //              {name: \"flat screwdrivers\", warranty: \"1 year\"},\n * //              {name: \"slotted screwdrivers\", warranty: \"1 year\"},\n * //              {name: \"Hex screwdrivers\", warranty: \"10 year\"},\n * //            ]\n * //         }\n * //       ]\n * //    }, {\n * //       name: \"Kitchenware\",\n * //       warranty: \"1 year\"\n * //    }\n * // ]\n * ```\n * @memberof bbn.fn\n * @param    {Array}    arr\n * @param    {Function} fn\n * @param    {Boolean}  deepProp\n * @param    {Number}   level\n * @returns  {Array}\n */\nfunction map(arr, fn, deepProp, level) {\n    if (level === void 0) { level = 0; }\n    return arr.map(function (a, i) {\n        a = fn(a, i, level);\n        if (deepProp && a[deepProp] && isArray_isArray(a[deepProp])) {\n            a[deepProp] = map(a[deepProp], fn, deepProp, level + 1);\n        }\n        return a;\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/money.js\n\n/**\n * Returns the given value to money format basing on the given configuration.\n *\n * @method   money\n * @global\n *\n * @example\n * ``` javascript\n * // \"5 856.0 $\"\n * bbn.fn.money(5856, false, '$', false, '.' ,false, 1);\n * ```\n *\n * @memberof bbn.fn\n * @param {String|Number} val The value.\n * @param {Boolean} kilo If the value has to be rendered in kilo.\n * @param {String} currency The currency.\n * @param {String} novalue The string to return if no valid value is given.\n * @param {String} decimal The character to use separate decimals.\n * @param {String} thousands The character to use to separate thounsands.\n * @param {Number} precision The number of decimals places.\n */\nfunction money(val, kilo, currency, novalue, decimal, thousands, precision) {\n    /*\n    money(val, kilo){\n      let decimal = ',',\n          currency = '€',\n          thousands = ' ';\n      if ( (isNaN(val) || !val) ){\n        return '-';\n      }\n      if ( isNaN(val) || !val ){\n        return 0;\n      }\n      if ( kilo && val ){\n        val = val / 1000;\n        if ( currency ){\n          currency = 'K' + currency;\n        }\n      }\n      return parseFloat(val).toFixed(0).replace(/./g, function(c, i, a) {\n        if ( c === '.' ){\n          return decimal;\n        }\n        return i && ((a.length - i) % 3 === 0) ? thousands + c : c;\n      }) + ( currency ? ' ' + currency : '');\n    },\n\n       */\n    if (!decimal) {\n        decimal =\n            decimal === undefined && bbn.env.money && bbn.env.money.decimal !== undefined ? bbn.env.money.decimal : '.';\n    }\n    if (!currency) {\n        currency =\n            currency === undefined && bbn.env.money && bbn.env.money.currency !== undefined\n                ? bbn.env.money.currency\n                : '';\n    }\n    if (!thousands) {\n        thousands =\n            thousands === undefined && bbn.env.money && bbn.env.money.thousands !== undefined\n                ? bbn.env.money.thousands\n                : ' ';\n    }\n    if (!precision) {\n        precision =\n            precision === undefined && bbn.env.money && bbn.env.money.precision !== undefined\n                ? bbn.env.money.precision\n                : 0;\n    }\n    if (!kilo) {\n        kilo = kilo === undefined && bbn.env.money && bbn.env.money.kilo !== undefined ? bbn.env.money.kilo : false;\n    }\n    if (!novalue) {\n        novalue =\n            novalue === undefined && bbn.env.money && bbn.env.money.novalue !== undefined\n                ? bbn.env.money.novalue\n                : false;\n    }\n    if (!isNumber_isNumber(precision)) {\n        precision = kilo ? 3 : 0;\n    }\n    if ((val === 0) && (typeof precision === 'number') && (precision > 0)) {\n        var res = val.toFixed(precision).replace('.', decimal);\n        if (currency) {\n            res += ' ' + (kilo ? 'K' + currency : currency);\n        }\n        return res;\n    }\n    if ((isNaN(val) || !val) && novalue) {\n        return novalue;\n    }\n    if (isNaN(val) || !val) {\n        return 0 + (currency ? ' ' + currency : '');\n    }\n    if (kilo && val) {\n        val = val / 1000;\n        if (currency) {\n            currency = 'K' + currency;\n        }\n    }\n    var v = val.toFixed(precision);\n    var decimalPosition = 0;\n    var decimalIdx = 10000;\n    if (v) {\n        decimalIdx = v.indexOf('.');\n        if (decimalIdx <= 0) {\n            decimalIdx = 10000;\n        }\n        else {\n            decimalPosition = v.length - decimalIdx;\n        }\n    }\n    return (v.replace(/./g, function (c, i, a) {\n        if (c === '.') {\n            return decimal;\n        }\n        return i && (a.length - i - decimalPosition) % 3 === 0 && i < decimalIdx ? thousands + c : c;\n    }) + (currency ? ' ' + currency : ''));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/move.js\n/**\n * Moves an element to a different position within the given array.\n *\n * The same array is returned, with its elements reordered according to the executed movement.\n *\n * @method   move\n * @global\n * @todo     Finish doc\n * @example\n * ```javascript\n * bbbn.fn.move([\n *   {movie: \"Brazil\", year: 1985},\n *   {movie: \"Donnie Darko\", year: 2001},\n *   {movie: \"Out of Africa\", year: 1985}\n * ], 1, 2);\n * // [\n * //   {movie: \"Brazil\", year: 1985},\n * //   {movie: \"Out of Africa\", year: 1985},\n * //   {movie: \"Donnie Darko\", year: 2001}\n * // ]\n * ```\n *  @example\n * ```javascript\n * bbn.fn.move([1, 2, 3, 4], 3, 0);\n * // [4, 1, 2, 3]\n * ```\n * @memberof bbn.fn\n * @param    {Array}  arr       The array\n * @param    {Number} fromIndex The index of the element to move\n * @param    {Number} toIndex   The future index of the element\n * @returns  {Array}  The same array, with elements repositionned.\n */\nfunction move(arr, fromIndex, toIndex) {\n    if (toIndex >= arr.length) {\n        var k = toIndex - arr.length;\n        while (k-- + 1) {\n            arr.push(undefined);\n        }\n    }\n    arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);\n    return arr;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/multiorder.js\n\n/**\n * Sorts an array of objects based on a set of properties.\n *\n * The resulting array is the same object, the order is based on _compareValues function\n * applied for each given properties in orders argument.\n *\n * @method   multiorder\n * @global\n * @example\n * ```javascript\n * let ar = [\n *   {movie: \"Brazil\", year: 1985},\n *   {movie: \"Donnie Darko\", year: 2001},\n *   {movie: \"Out of Africa\", year: 1985},\n *   {movie: \"Ran\", year: 1985},\n *   {movie: \"Back to the future\", year: 1985},\n *   {movie: \"Barry Lindon\", year: 1976}\n * ];\n * bbn.fn.multiorder(ar, [\n *   {field: \"year\", dir: \"desc\"},\n *   {field: \"movie\", dir: \"asc\"}\n * ]);\n * // [\n * //   {movie: \"Donnie Darko\", year: 2001},\n * //   {movie: \"Back to the future\", year: 1985},\n * //   {movie: \"Brazil\", year: 1985},\n * //   {movie: \"Out of Africa\", year: 1985},\n * //   {movie: \"Ran\", year: 1985},\n * //   {movie: \"Barry Lindon\", year: 1976}\n * // ]\n * bbn.fn.multiorder(ar, {year: \"desc\", movie: \"asc\"});\n * // Same result with object shortcut\n * ```\n * @memberof bbn.fn\n * @param    {Array}        arr    The array to order\n * @param    {Array|Object} orders The properties and directions (asc, desc) to order by\n * @returns  {Array}        The same array (arr), ordered differently\n */\nfunction multiorder(arr, orders) {\n    if (!orders) {\n        return arr;\n    }\n    var currentOrders;\n    if (!Array.isArray(orders) && typeof orders === 'object') {\n        currentOrders = [];\n        for (var n in orders) {\n            currentOrders.push({ field: n, dir: orders[n] });\n        }\n    }\n    else {\n        currentOrders = orders;\n    }\n    if (!Array.isArray(currentOrders)) {\n        throw new Error('The orders argument must be an array');\n    }\n    var r = arr.slice();\n    return r.sort(function (a, b) {\n        var res;\n        for (var _i = 0, currentOrders_1 = currentOrders; _i < currentOrders_1.length; _i++) {\n            var order = currentOrders_1[_i];\n            res = _compareValues(a, b, order.field, order.dir);\n            if (res !== 0) {\n                return res;\n            }\n        }\n        return 0;\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/mutateArray.js\n\n\n\n\nfunction mutateArray(a1, a2) {\n    if (!isArray_isArray(a1, a2)) {\n        throw new TypeError('mutateArray can only be called with arrays');\n    }\n    var mapA2 = new Map(a2.map(function (item) { return [hash(item), item]; }));\n    var a1Ordered = [];\n    // Build a1Ordered to have the same order and contents as a2\n    a2.forEach(function (item) {\n        a1Ordered.push(item);\n    });\n    // Remove items from a1 that are not in a2\n    var i = a1.length;\n    while (i--) {\n        if (!mapA2.has(hash(a1[i]))) {\n            a1.splice(i, 1);\n        }\n    }\n    // Insert or move items to match the order of a2\n    for (var j = 0; j < a1Ordered.length; j++) {\n        if ((j >= a1.length) || !isSame(a1[j], a1Ordered[j])) {\n            // Find the index of the item in a1, if it exists\n            var indexInA1 = search(a1, a1Ordered[j]);\n            if (indexInA1 !== -1) {\n                // Move the item to the correct position if it already exists in a1\n                var itemToMove = a1.splice(indexInA1, 1)[0];\n                a1.splice(j, 0, itemToMove);\n            }\n            else {\n                // Insert the new item from a2 into a1\n                a1.splice(j, 0, a1Ordered[j]);\n            }\n        }\n    }\n    // If a1 has extra items at the end (not present in a2), remove them\n    if (a1.length > a1Ordered.length) {\n        a1.splice(a1Ordered.length, a1.length - a1Ordered.length);\n    }\n    return a1;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/nl2br.js\n\n/**\n * Replaces all new line characters '\\ n' with html tag '<br>'.\n *\n * @method   nl2br\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.nl2br('hello \\n world!');\n * //\"hello <br> world!\"\n * ```\n * @memberof bbn.fn\n * @param    {String} st\n * @returns  {String}\n */\nfunction nl2br(st, keepNl) {\n    return replaceAll(\"\\n\", \"<br>\" + (keepNl ? \"\\n\" : \"\"), st);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/form/objectToFormData.js\n\n\n\n\n\n/**\n * @method   objectToFormData\n * @todo     Add method description for objectToFormData\n * @global\n * @memberof bbn.fn\n * @param    {Object|Array|File} obj\n * @param    {String}            key\n * @param    {Array}             ignoreList\n * @returns\n */\nfunction objectToFormData(obj, key, ignoreList) {\n    if (key === void 0) { key = ''; }\n    if (ignoreList === void 0) { ignoreList = null; }\n    var formData = new FormData();\n    var appendFormData = function (data, key) {\n        if (key === void 0) { key = ''; }\n        if (!ignoreList || (isArray_isArray(ignoreList) && !ignoreList.includes(key))) {\n            if (data instanceof File) {\n                formData.append(key, data);\n            }\n            else if (isArray_isArray(data)) {\n                each(data, function (v, i) {\n                    appendFormData(v, key + '[' + i + ']');\n                });\n            }\n            else if (isObject_isObject(data) && Object.keys(data).length) {\n                iterate(data, function (v, i) {\n                    if (i in data) {\n                        appendFormData(v, !key ? i : key + '[' + i + ']');\n                    }\n                });\n            }\n            else {\n                if (!isNull(data) && data !== undefined) {\n                    formData.append(key, data);\n                }\n            }\n        }\n    };\n    appendFormData(obj, key);\n    return formData;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/order.js\n\n/**\n * Sorts an array of objects based on the given property.\n *\n * The resulting array is the same object, the order is based on _compareValues function.\n *\n * @method   order\n * @global\n * @example\n * ```javascript\n * bbn.fn.order([\n *   {movie: \"Brazil\", year: 1985},\n *   {movie: \"Donnie Darko\", year: 2001},\n *   {movie: \"Barry Lindon\", year: 1976}\n * ], 'year', 'DESC')\n * // [\n * //   {movie: \"Donnie Darko\", year: 2001},\n * //   {movie: \"Brazil\", year: 1985},\n * //   {movie: \"Barry Lindon\", year: 1976}\n * // ]\n * ```\n * @memberof bbn.fn\n * @param    {Array}  arr       The array to order\n * @param    {String} prop      The property on which the order is based\n * @param    {String} [dir=asc] The direction of the order (desc or asc by default)\n * @returns  {Array}\n */\nfunction order(arr, prop, dir) {\n    if (dir === void 0) { dir = 'asc'; }\n    if (arr) {\n        return arr.sort(function (a, b) {\n            return _compareValues(a, b, prop, dir);\n        });\n    }\n    return arr;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/html/selector.js\n/**\n * @ignore\n * @method   selector\n * @todo     Add method description for selector\n * @global\n * @memberof bbn.fn\n * @returns  {HTMLElement | undefined}\n */\nfunction selector(ele) {\n    return typeof ele === \"string\" ? document.querySelector(ele) : ele;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/outerHeight.js\n\n/**\n *\n * @ignore\n * @method   outerHeight\n * @todo     Add method description for outerHeight\n * @global\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction outerHeight_outerHeight(ele) {\n    ele = selector(ele);\n    if (ele && \"offsetHeight\" in ele) {\n        var styles = window.getComputedStyle(ele);\n        var margin = parseFloat(styles[\"marginTop\"]) + parseFloat(styles[\"marginBottom\"]);\n        return Math.ceil(ele.offsetHeight + margin);\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/outerWidth.js\n\n/**\n * @ignore\n * @method   outerWidth\n * @todo     Add method description for outerWidth\n * @global\n * @memberof bbn.fn\n * @returns  {*}\n */\nfunction outerWidth_outerWidth(ele) {\n    ele = selector(ele);\n    var styles = window.getComputedStyle(ele);\n    var margin = parseFloat(styles[\"marginLeft\"]) + parseFloat(styles[\"marginRight\"]);\n    return Math.ceil(ele.offsetWidth + margin);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/percent.js\n/**\n * Returns the value of the proportion giving the percentage and the total from where to be calculated.\n * @method   percent\n * @global\n *\n * @example\n * ```javascript\n * //150\n * bbn.fn.percent('15',1000);\n * ```\n *\n * @example\n * ```javascript\n * //75\n * bbn.fn.percent(15,500);\n * ```\n * @memberof bbn.fn\n * @param    {Number|String} percent\n * @param    {Number|String} cent\n * @returns  {Number}\n */\nfunction percent(percent, cent) {\n    return (cent / 100) * percent;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/pickValue.js\nfunction pickValue(arr) {\n    if (Array.isArray(arr) && arr.length) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/setProperty.js\n\n/**\n * Returns the value of the given property from the given object.\n *\n * Looks for the given property in the given object, accepting dot (.) separator\n * for deep property access, and returns its value if found and undefined otherwise.\n *\n * @method   getProperty\n * @global\n * @example\n * ```javascript\n * bbn.fn.getProperty({a: 1, b: 2}, 'b');\n * // 2\n * ```\n * @example\n * ```javascript\n * bbn.fn.getProperty({a: 1, b: {o: {a: 33, h: 5}}}, 'b.o.a');\n * // 33\n * ```\n * @example\n * ```javascript\n * bbn.fn.getProperty({a: 1, b: {o: {a: 33, h: 5}}}, 'b.h.a');\n * // undefined\n * ```\n * @memberof bbn.fn\n * @param    {Object} obj\n * @param    {String} prop\n * @returns  {*}      The property's value or undefined\n */\nfunction setProperty(obj, prop, value, force) {\n    if (typeof obj === 'object' && typeof prop === 'string') {\n        var o_1 = obj;\n        var bits_1 = prop.split('.');\n        each(bits_1, function (v, i) {\n            if (!o_1) {\n                if (!force) {\n                    throw new Error(bbn._('The object is invalid'));\n                }\n                o_1 = {};\n            }\n            if (bits_1.length - 1 === i) {\n                o_1[v] = value;\n            }\n            else {\n                o_1 = o_1[v];\n            }\n        });\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/postOut.js\n\n\n\n/**\n * Posts a request in a new window.\n *\n * @method   postOut\n * @global\n * @memberof bbn.fn\n *\n * @example\n * ```javascript\n * bbn.fn.postOut('https://external-service.com/download/account-2019-06.pdf', {clientId: 547912, token: xxx});\n * ```\n *\n * @param    {String}   url     The url to which the request should be sent\n * @param    {Object}   data    The data to be sent\n * @param    {Function} success A function to execute in case of success\n * @param    {String}   target  The target attribute of the form\n *\n * @returns  {void}\n */\nfunction postOut(url, data, success, target) {\n    if (success === void 0) { success = null; }\n    if (target === void 0) { target = \"\"; }\n    var form = document.body.querySelector(\"form#bbn-form_out\");\n    if (!form) {\n        form = document.createElement(\"form\");\n        form.classList.add(\"bbn-no\");\n        form.setAttribute(\"id\", \"bbn-form_out\");\n        form.setAttribute(\"method\", \"post\");\n        form.setAttribute(\"enctype\", \"multipart/form-data-encoded\");\n        setProperty(form, \"style.display\", \"none\");\n        document.body.appendChild(form);\n    }\n    if (form instanceof HTMLFormElement) {\n        form.innerHTML = \"\";\n        form.setAttribute(\"action\", url);\n        form.setAttribute(\"target\", target || \"_blank\");\n        if (!data) {\n            data = {};\n        }\n        data = createObject(data);\n        if (!data.bbn) {\n            data.bbn = \"public\";\n        }\n        addInputs(form, data);\n        form.submit();\n        if (success) {\n            success();\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/printf.js\n/**\n * @method   printf\n * @todo     Add method description for printf\n * @global\n * @memberof bbn.fn\n * @param    String format\n * @returns  {*}\n */\nfunction printf(format) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return format.replace(/{(\\d+)}/g, function (match, number) {\n        return typeof args[number] != \"undefined\" ? args[number] : match;\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/quotes2html.js\n\n/**\n * Replace quotes in ASCII code\n *\n * @method   quotes2html\n * @global\n *\n * @example\n * ```javascript\n * bbn.fn.quotes2html(\"hello 'world'!\", 's');\n * // hello &#39;world&#39;!\n * ```\n *\n * @example\n * ```javascript\n * bbn.fn.quotes2html('hello \"world\\'s\"!', 'd');\n * // hello &quot;world'sd&quot;!\n * ```\n *\n * @example\n * ```javascript\n * bbn.fn.quotes2html('hello \"world\\'s\"!');\n * // hello &quot;world&#39;sd&quot;!\n * ```\n *\n * @memberof bbn.fn\n * @param    {String} st\n * @returns  {String}\n */\nfunction quotes2html(st, type) {\n    if (!type || type.toLowerCase().indexOf(\"s\") === 0) {\n        st = replaceAll(\"'\", \"&#39;\", st);\n    }\n    if (!type || type.toLowerCase().indexOf(\"d\") === 0) {\n        st = replaceAll('\"', \"&quot;\", st);\n    }\n    return st;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/randomInt.js\n/**\n * Returns a random integer.\n *\n * Generates and returns a random number in a range of numbers defined\n * by passed arguments a minimum and a maximum.\n *\n * @method   randomInt\n * @global\n *\n * @example\n * ```javascript\n * //56\n * bbn.fn.randomInt(1,100);\n * ```\n *\n * @memberof bbn.fn\n * @param    {Number} min\n * @param    {Number} max\n * @returns  {Number}\n */\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/randomString.js\n\n/**\n * Returns a random String with random lenght,\n *\n * Generates a random string from the length of the random number,\n * taken from a range of numbers providing either only the minimum or also the maximum as arguments.\n *\n * @method   randomString\n * @global\n *\n * @example\n * ```javascript\n * //\"U7xXO0Xb\"\n * bbn.fn.randomString(3,10);\n * ```\n *\n * @example\n * ```javascript\n * //\"H8F\"\n * bbn.fn.randomString(3);\n * ```\n *\n * @memberof bbn.fn\n * @param    {Number} length\n * @param    {String} chars\n * @returns  {String}\n */\nfunction randomString(min, max, types) {\n    var length;\n    var type;\n    var chars = {\n        n: \"0123456789\",\n        l: \"abcdefghijklmnopqrstuvwxyz\",\n        u: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n    };\n    if (!types) {\n        types = \"nlu\";\n    }\n    if (!min) {\n        length = randomInt(8, 14);\n    }\n    if (typeof max === \"string\") {\n        types = \"n\";\n        delete chars.l;\n        delete chars.u;\n        chars.n = max;\n        if (!length) {\n            length = min;\n        }\n    }\n    else if (typeof max === \"number\" && min < max) {\n        length = randomInt(min, max);\n    }\n    else if (min) {\n        length = min;\n    }\n    var result = \"\";\n    for (var i = 0; i < length; i++) {\n        // Not a number for the first char\n        if (i === 0) {\n            if (types !== \"n\") {\n                type = types.indexOf(\"u\") === -1 ? \"l\" : \"u\";\n            }\n        }\n        else {\n            type = types[Math.floor(Math.random() * types.length)];\n        }\n        result += chars[type][Math.floor(Math.random() * chars[type].length)];\n    }\n    return result;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/removeEmpty.js\n\n\n\n/**\n * Returns a new array, having removed all elements deemed empty from the given array.\n *\n * Removes all the elements which are empty, i.e. false, 0, null, '', NaN, or undefined.\n *\n * @method   removeEmpty\n * @global\n * @example\n * ```javascript\n * bbn.fn.removeEmpty([{prop1: 10, prop2: 20}, '', {}, null, 1, undefined, 0, false, 25]);\n * // [{prop1: 10, prop2: 20}, 1, 25]\n * ```\n * @memberof bbn.fn\n * @param    {Array} arr\n * @returns  {Array}\n */\nfunction removeEmpty(arr) {\n    var tmp = [];\n    if (isArray_isArray(arr)) {\n        for (var i = 0; i < arr.length; i++) {\n            var ok = false;\n            if (arr[i]) {\n                if (isArray_isArray(arr[i])) {\n                    if (arr[i].length) {\n                        ok = true;\n                    }\n                }\n                else if (isObject_isObject(arr[i])) {\n                    if (numProperties(arr[i])) {\n                        ok = true;\n                    }\n                }\n                else {\n                    ok = true;\n                }\n            }\n            if (ok) {\n                tmp.push(arr[i]);\n            }\n        }\n    }\n    return tmp;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/removeExtraSpaces.js\n/**\n * Removes all group of spaces by one single space.\n * @param {String} str\n * @returns\n */\nfunction removeExtraSpaces(str) {\n    return str.replace(/\\s+/g, \" \").trim();\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/removeTrailingChars.js\n\n/**\n * @method   removeTrailingChars\n * @todo     Add method description for removeTrailingChars\n * @global\n * @memberof bbn.fn\n * @param    {String} st\n * @param    {String} char\n * @returns  {*}\n */\nfunction removeTrailingChars(st, char) {\n    if (!char) {\n        char = \" \";\n    }\n    if (char.length) {\n        while (substr(st, -char.length) === char) {\n            st = substr(st, 0, st.length - char.length);\n        }\n        while (substr(st, 0, char.length) === char) {\n            st = substr(st, char.length);\n        }\n    }\n    return st;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/repeat.js\n/**\n * Returns a string which is the repetition of the first argument for the number passed in the second argument.\n *\n * @method   repeat\n * @global\n *\n * @example\n * ```javascript\n * //\"HelloHelloHello\"\n * bbn.fn.repeat('Hello', 3);\n * ```\n * @memberof bbn.fn\n * @returns  {String}\n */\nfunction repeat(st, num) {\n    return st.repeat(num);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/replaceSelection.js\nfunction replaceSelection(html, selectInserted) {\n    var sel, range, fragment;\n    sel = window.getSelection();\n    // Test that the Selection object contains at least one Range\n    if (sel.getRangeAt && sel.rangeCount) {\n        // Get the first Range (only Firefox supports more than one)\n        range = window.getSelection().getRangeAt(0);\n        range.deleteContents();\n        // Create a DocumentFragment to insert and populate it with HTML\n        // Need to test for the existence of range.createContextualFragment\n        // because it's non-standard and IE 9 does not support it\n        if (range.createContextualFragment) {\n            fragment = range.createContextualFragment(html);\n        }\n        else {\n            // In IE 9 we need to use innerHTML of a temporary element\n            var div = document.createElement('div');\n            var child = void 0;\n            div.innerHTML = html;\n            fragment = document.createDocumentFragment();\n            while ((child = div.firstChild)) {\n                fragment.appendChild(child);\n            }\n        }\n        var firstInsertedNode = fragment.firstChild;\n        var lastInsertedNode = fragment.lastChild;\n        range.insertNode(fragment);\n        sel.removeAllRanges();\n        if (selectInserted) {\n            if (firstInsertedNode) {\n                range.setStartBefore(firstInsertedNode);\n                range.setEndAfter(lastInsertedNode);\n            }\n            sel.addRange(range);\n        }\n        else {\n            range.setStartAfter(lastInsertedNode);\n            sel.addRange(range);\n        }\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/rgb2hex.js\n/**\n * Convert an RGB string to hexadecimal.\n *\n * Passing a string with the format that defines the rgb value as an argument,\n * it will return the corresponding string in hexadecimal format.\n *\n * @method   rgb2hex\n * @global\n *\n * @example\n * ```javascript\n * //\"#ff0000\"\n * bbn.fn.rgb2hex(\"rgb(255, 0, 0)\");\n * ```\n * @memberof bbn.fn\n * @param    {String} rgb\n * @returns  {String}\n */\nfunction rgb2hex(rgb) {\n    rgb = rgb.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    return rgb && rgb.length === 4\n        ? \"#\" +\n            (\"0\" + parseInt(rgb[1], 10).toString(16)).slice(-2) +\n            (\"0\" + parseInt(rgb[2], 10).toString(16)).slice(-2) +\n            (\"0\" + parseInt(rgb[3], 10).toString(16)).slice(-2)\n        : \"\";\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/loop/riterate.js\n\n/**\n * Executes the provided function on each property of the given object.\n *\n * @method   riterate\n * @global\n * @example\n * ```javascript\n * //[\"value1\", 2]\n * let arr = [];\n * bbn.fn.iterate({field1: \"value1\", field2: 2}, (val, idx) => {\n *   arr.push(value);\n * });\n * ```\n * @memberof bbn.fn\n * @param    {(Object|Number)} obj       The object to loop on\n * @param    {Function}        fn        The function, gets the array's element and the index as arguments\n * @param    {Boolean}         noPrivate If set to true the _private_ properties won't be included\n * @returns  {Object}\n */\nfunction riterate(obj, fn, noPrivate) {\n    if (noPrivate === void 0) { noPrivate = false; }\n    return iterate(obj, fn, noPrivate, true);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/roundDecimal.js\n/**\n * @method   roundDecimal\n * @todo     Add method description for roundDecimal\n * @global\n * @memberof bbn.fn\n * @param    {Number} value\n * @param    {Number} decimals\n * @returns  {}\n */\nfunction roundDecimal(value, decimals) {\n    return Math.round(Math.pow(Math.pow(value, decimals), -decimals));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/trim.js\n\nfunction trim_trim(str, hair) {\n    if (hair === void 0) { hair = ' '; }\n    if (hair === ' ') {\n        return str.trim();\n    }\n    if (!hair) {\n        return str;\n    }\n    if (hair === str) {\n        return '';\n    }\n    while (str.indexOf(hair) === 0) {\n        str = substr(str, hair.length);\n    }\n    while (str.lastIndexOf(hair) === str.length - hair.length) {\n        str = substr(str, 0, str.length - hair.length);\n    }\n    return str;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/sanitize.js\n\n\n/**\n * Removes all unacceptable characters in a DOM node.\n *\n * @method   sanitize\n * @global\n *\n * @example\n * ```javascript\n * //\"this_is_a_test\"\n * bbn.fn.sanitize(\"this&is_$a^test\");\n * ```\n *\n * @memberof bbn.fn\n * @returns  {String} str\n */\nfunction sanitize(str, separator) {\n    if (separator === void 0) { separator = \"_\"; }\n    var escaped = [\"[\", \"]\", \"{\", \"}\", \"(\", \")\", \"-\", \"+\", \"*\", \"/\"];\n    var exp = \"[\";\n    for (var i = 0; i < separator.length; i++) {\n        if (escaped.includes(separator[i])) {\n            exp += \"\\\\\";\n        }\n        exp += separator[i];\n    }\n    exp += \"]+\";\n    var re = new RegExp(exp, \"g\");\n    var res = removeAccents(str)\n        .replace(/[^a-z0-9]/gi, separator)\n        .replace(re, separator);\n    return trim_trim(res, separator);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/selectElementText.js\n/**\n * Selects the content of an element.\n *\n * @method   selectElementText\n * @global\n * @example\n * ``` javascript\n * bbn.fn.selectElementText(document.getElementById('my_input_id'));\n * // false\n * bbn.fn.selectElementText(bbn.$('#my_span_id'));\n * // true\n * ```\n * @memberof bbn.fn\n *\n * @param {Element} ele The element in which the text should be selected\n * @param {Boolean} win The window object\n *\n * @returns  {Boolean} True if focused\n */\nfunction selectElementText(ele, win) {\n    if (win === void 0) { win = null; }\n    win = win || window;\n    if (ele instanceof HTMLInputElement) {\n        ele.select();\n        return;\n    }\n    var doc = win.document;\n    var sel;\n    var range;\n    if (win.getSelection && doc.createRange) {\n        sel = win.getSelection();\n        range = doc.createRange();\n        range.selectNodeContents(ele);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else if (('createTextRange' in doc.body) && (typeof doc.body.createTextRange === 'function')) {\n        range = doc.body.createTextRange();\n        range.moveToElementText(ele);\n        range.select();\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/setCookie.js\n/**\n * Creates a cookie and assigns it to document.cookie.\n * @method   setCookie\n * @global\n * @example\n * ``` javascript\n * bbn.fn.setCookie('lang', 'en', 2);\n * ```\n * @memberof bbn.fn\n * @param    {String} name  The name of the cookie.\n * @param    {String} value The value of the cookie.\n * @param    {Number} days  The days before expiration of the cookie.\n * @returns\n */\nfunction setCookie(name, value, days) {\n    var expires = '';\n    if (days) {\n        var date = new Date();\n        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n        expires = '; expires=' + date.toUTCString();\n    }\n    var st = escape(JSON.stringify({ value: value }));\n    document.cookie = name + '=' + st + expires + '; path=/';\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/style/setCssVar.js\n/**\n * Creates a CSS variable\n * @param {String*} varname\n * @param {String*} value\n * @returns\n */\nfunction setCssVar(varname, value) {\n    if (varname.indexOf(\"--\") !== 0) {\n        varname = \"--\" + varname;\n    }\n    /** @todo To Fix */\n    document.documentElement.style.setProperty(varname, value);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/setProp.js\n/**\n * Sets a given property on the given object\n *\n * @param {Object} obj\n * @param {String} prop\n * @param {*} value\n * @param {Boolean} writable\n * @param {Boolean} configurable\n */\nfunction setProp(obj, prop, value, writable, configurable) {\n    if (writable === void 0) { writable = true; }\n    if (configurable === void 0) { configurable = true; }\n    Object.defineProperty(obj, prop, {\n        value: value,\n        writable: writable,\n        configurable: configurable,\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/shorten.js\n\n\n/**\n * Shortens the given string after *len* characters.\n *\n * Provides an abbreviation to the string passed as the first argument,\n * deciding through the second argument the number of characters to keep and the remainder replaced\n * by what is passed as the third argument and if not given a defalut it is: '...'\n *\n * @method   shorten\n * @global\n *\n * @example\n * ```javascript\n * //\"test***\"\n * bbn.fn.shorten('testing', 4, '***');\n * ```\n *  @example\n * ```javascript\n * //\"test...\"\n * bbn.fn.shorten('testing', 4);\n * ```\n * @memberof bbn.fn\n * @param    {String} st\n * @param    {Number} len\n * @returns  {String}\n */\nfunction shorten(st, len, adj) {\n    if (typeof st.toLowerCase() === \"string\") {\n        if (!len) {\n            len = bbn.var.shortenLen;\n        }\n        if (adj === undefined || !isString_isString(adj)) {\n            adj = \"...\";\n        }\n        if (st.length > len) {\n            st = substr(st, 0, len) + adj;\n        }\n    }\n    return st;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/shortenObj.js\n\n\n\n\n/**\n * Shortens all the strings contained in the object properties or element in a array.\n *\n * Modifies directly the given object by cuttin all its too long strings, and adding ellipsis (...) in this case.\n *\n * @method   shortenObj\n * @global\n * @example\n * ```javascript\n * bbn.fn.shortenObj({\n *   title: \"Once upon a time in the west\",\n *   synopsis: \"There's a single piece of land around Flagstone with water on it, and rail baron Morton (Gabriele Ferzetti) aims to have it, knowing the new railroad will have to stop there. He sends his henchman Frank (Henry Fonda) to scare the land's owner, McBain (Frank Wolff), but Frank kills him instead and pins it on a known bandit, Cheyenne (Jason Robards). Meanwhile, a mysterious gunslinger with a score to settle (Charles Bronson) and McBain's new wife, Jill (Claudia Cardinale), arrive in town.\"\n * }, 50)\n * // {\n * //   \"title\": \"Once upon a time in the west\",\n * //   \"synopsis\": \"There's a single piece of land around Flagstone wi...\"\n * // }\n * ```\n * @memberof bbn.fn\n * @param    {(Object|Array)} obj\n * @param    {Number}         [max=100]\n * @returns  {(Object|Array)} The same object, modified\n */\nfunction shortenObj(obj, max) {\n    if (max === void 0) { max = 100; }\n    var o = clone(obj);\n    each(o, function (a, n) {\n        if (isString_isString(a) && a.length > max) {\n            o[n] = shorten(a, max);\n        }\n        else if (a && typeof a === \"object\") {\n            o[n] = shortenObj(a);\n        }\n    });\n    return o;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/shuffle.js\nfunction shuffle(array) {\n    var _a;\n    var currentIndex = array.length, randomIndex;\n    // While there remain elements to shuffle.\n    while (currentIndex != 0) {\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n        // And swap it with the current element.\n        _a = [array[randomIndex], array[currentIndex]], array[currentIndex] = _a[0], array[randomIndex] = _a[1];\n    }\n    return array;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/startChrono.js\n/**\n * Starts a timer and gives it a name.\n * @method   startChrono\n * @global\n * ``` javascript\n * bbn.fn.startChrono('myChrono');\n * ```\n * @memberof bbn.fn\n * @returns\n */\nfunction startChrono(name) {\n    var now = new Date().getTime();\n    var h1 = 3600 * 1000;\n    if (!this.constructor.chronos) {\n        Object.defineProperty(this.constructor, 'chronos', {\n            value: Object.create(null),\n            writable: false,\n            configurable: false,\n        });\n    }\n    this.constructor.chronos[name || 'default'] = now;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/stopChrono.js\n/**\n * @method   stopChrono\n * @global\n * @example\n * ``` javascript\n * bbn.fn.stopChrono('myChrono');\n * // 20162\n * ```\n * @memberof bbn.fn\n * @param {String} name\n * @returns  {Number}\n */\nfunction stopChrono(name) {\n    if (this.constructor.chronos[name || 'default']) {\n        var now = new Date().getTime();\n        var diff = now - this.constructor.chronos[name || 'default'];\n        delete this.constructor.chronos[name || 'default'];\n        return diff;\n    }\n    throw Error(\"No chrono with name \" + (name || 'default'));\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/string2ArrayBuffer.js\nfunction string2ArrayBuffer(str) {\n    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n    var bufView = new Uint16Array(buf);\n    for (var i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/object/sum.js\n\n\n/**\n * Returns the sum of the given property or function for the array's elements matching the filter.\n *\n * The filtering arguments follow the same scheme as bbn.fn.search.\n *\n * @method   sum\n * @global\n * @example\n * ```javascript\n * let invited = [\n *   {name: \"Robert De Niro\", attendees: 2, confirmed: true},\n *   {name: \"Al Pacino\", attendees: 1, confirmed: false},\n *   {name: \"James Caan\", attendees: 4, confirmed: false},\n *   {name: \"Harvey Keitel\", attendees: 5, confirmed: true}\n * ];\n * // No filter\n * bbn.fn.sum(invited, \"attendees\");\n * // 12\n * // Filter\n * bbn.fn.sum(invited, \"attendees\", {confirmed: true});\n * // 7\n * ```\n * @example\n * ```javascript\n * let cart = [\n *    {article: \"Toothpaste\", price: 2.50, quantity: 1},\n *    {article: \"Toothbrush\", price: 6, quantity: 2},\n *    {article: \"Banana\", price: 0.50, quantity: 3},\n *    {article: \"T-shirt\", price: 14, quantity: 3}\n * ];\n * bbn.fn.sum(cart, a => a.price * a.quantity);\n * // 58\n * // Only the items with a quantity equal to 3\n * bbn.fn.sum(cart, a => a.price * a.quantity, {quantity: 3});\n * // 43.5\n * ```\n * @memberof bbn.fn\n * @param    {Array}                    arr        The subject array\n * @param    {(String|Function)}        numberProp The property's name for which the value should be added to the sum, or a function returning the number.\n * @param    {(String|Object|Function)} prop       A property's name or a filter object or function\n * @param    {*}                        val        The value with which comparing the given property\n * @param    {String}                   operator   The operator to use for comparison with the value as used in bbn.fn.compare\n * @returns  {Number}                   The sum\n */\nfunction sum(arr, numberProp, prop, val, operator) {\n    var r = 0;\n    each(filter(arr, prop, val, operator), function (a) {\n        var tmp = typeof numberProp === 'function' ? numberProp(a) : a[numberProp];\n        if (tmp) {\n            r += parseFloat(tmp) || 0;\n        }\n    });\n    return r;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/datetime/timestamp.js\n/**\n * Returns the timestamp of the given seconds if an argument is given, else returns the timestamp of new Date().\n * @method   timestamp\n * @global\n * @example\n * ```javascript\n * //1587031047918\n * bbn.fn.timestamp();\n * ```\n * @memberof bbn.fn\n * @param    {Number} seconds\n * @returns  {Boolean}\n */\nfunction timestamp(seconds) {\n    if (seconds === void 0) { seconds = false; }\n    var r = new Date().getTime();\n    return seconds ? Math.round(r / 1000) : r;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/convert/toCSV.js\n\n\n\n/**\n * Returns a CSV string from the given array of arrays or objects.\n *\n * @method   toCSV\n * @global\n * @example\n * ```javascript\n * bbn.fn.toCSV([['a', 'b', 'c'], ['d', 'e', 'f']]);\n * // \"a\",\"b\",\"c\";\n * // \"d\",\"e\",\"f\"\n * ```\n * @example\n * ```javascript\n * bbn.fn.toCSV([{name: \"Capuche\", fname: \"Marc-Antoine\"}, {name: \"Orfin\", fname: \"Louis\"}]);\n * // \"Capuche\",\"Marc-Antoine\";\n * // \"Orfin\",\"Louis\"\n * ```\n * @memberof bbn.fn\n * @param    {Array}  arr        The array to convert\n * @param    {String} [valSep=,] The value separator character\n * @param    {String} [rowSep=;] The row separator character\n * @param    {String} [valEsc=\"] The string escaper character\n * @returns  {String} A CSV string\n */\nfunction toCSV(arr, valSep, rowSep, valEsc) {\n    if (valSep === void 0) { valSep = \",\"; }\n    if (rowSep === void 0) { rowSep = \"\"; }\n    if (valEsc === void 0) { valEsc = '\"'; }\n    if (!valSep) {\n        valSep = \",\";\n    }\n    if (!valEsc) {\n        valEsc = '\"';\n    }\n    var csvContent = \"\";\n    var total = arr.length;\n    each(arr, function (a, i) {\n        var num = isArray_isArray(a) ? a.length : Object.values(a).length;\n        var j = 0;\n        each(a, function (b) {\n            if (typeof b === \"string\") {\n                csvContent += valEsc + replaceAll(valEsc, \"\\\\\" + valEsc, b) + valEsc;\n            }\n            else if (b === 0) {\n                csvContent += \"0\";\n            }\n            else if (!b) {\n                csvContent += valEsc + valEsc;\n            }\n            else {\n                csvContent += b.toString ? b.toString() : valEsc + valEsc;\n            }\n            j++;\n            if (j < num) {\n                csvContent += valSep;\n            }\n        });\n        if (i < total - 1) {\n            csvContent += rowSep + \"\\n\";\n        }\n    });\n    return csvContent;\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/browser/toggleFullScreen.js\n\nfunction toggleFullScreen() {\n    if ('mozRequestFullScreen' in window.document.documentElement) {\n        if (window.document['mozFullScreen']) {\n            window.document['mozCancelFullScreen']();\n        }\n        else if (typeof window.document.documentElement.mozRequestFullScreen === 'function') {\n            window.document.documentElement.mozRequestFullScreen();\n        }\n    }\n    else if ('webkitRequestFullScreen' in window.document.documentElement) {\n        if (window.document['webkitIsFullScreen']) {\n            window.document['webkitCancelFullScreen']();\n        }\n        else if (typeof window.document.documentElement.webkitRequestFullScreen === 'function') {\n            window.document.documentElement.webkitRequestFullScreen();\n        }\n    }\n    else if ('msRequestFullScreen' in window.document.documentElement) {\n        if (window.document['msFullscreenEnabled']) {\n            window.document['msExitFullscreen']();\n        }\n        else if (typeof window.document.documentElement.msRequestFullScreen === 'function') {\n            window.document.documentElement.msRequestFullScreen();\n        }\n    }\n    else if ('requestFullscreen' in window.document) {\n        if (window.document.fullscreenEnabled) {\n            window.document.exitFullscreen();\n        }\n        else {\n            window.document.documentElement.requestFullscreen();\n        }\n    }\n    setTimeout(function () {\n        resize();\n    }, 0);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/misc/translate.js\n\nfunction translate(o, namespace) {\n    var lng = namespace ? bbn.lng[namespace.indexOf('_') === 0 ? namespace : '_' + namespace] : bbn.lng;\n    iterate(o, function (v, k) {\n        lng[k] = v;\n    });\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/string/uniqString.js\n\n\n\n/**\n * Create a unique string in md5 format.\n *\n * Converts and return all the arguments inserted in a unique string in md5 format.\n *\n * @method   uniqString\n * @global\n *\n * @example\n * ```javascript\n * //\"6cb083da4d4987af9b4fa4ad8ca23bb1\"\n * bbn.fn.uniqString('test',['test'],{id:1, test:2},4);\n * ```\n * @memberof bbn.fn\n * @returns  {String} The unique string in md5 format\n */\nfunction uniqString() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var st = \"\";\n    var _loop_1 = function () {\n        if (!args[i]) {\n            st += \"__bbn_empty__\";\n        }\n        else if (typeof args[i] === \"object\") {\n            if (isArray_isArray(args[i])) {\n                st += JSON.stringify(args[i]);\n            }\n            else {\n                // An object with the same properties, even in different order, should produce the same answer\n                var tmp_1 = {};\n                var ks = Object.keys(args[i]).sort();\n                each(ks, function (k) {\n                    tmp_1[k] = args[i][k];\n                });\n                st += JSON.stringify(tmp_1);\n            }\n        }\n        else if (typeof args[i] !== \"string\") {\n            st += args[i].toString();\n        }\n        else {\n            st += args[i];\n        }\n    };\n    for (var i = 0; i < args.length; i++) {\n        _loop_1();\n    }\n    return md5(st);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn/ajax/upload.js\n\n\n/**\n * Uploads a file synchronously through an XHR indicating progress.\n *\n * @method   upload\n * @todo examples\n * @global\n * @memberof bbn.fn\n *\n * @param {String}   url      The URL to which the file should be uploaded\n * @param {File}     file     A File object or an array of data\n * @param {Function} success  A function to execute after success\n * @param {Function} failure  A function to execute after failure\n * @param {Function} progress A function to execute during progress\n *\n * @returns  {Promise}\n */\nfunction upload(url, file, success, failure, progress) {\n    if (success === void 0) { success = null; }\n    if (failure === void 0) { failure = null; }\n    if (progress === void 0) { progress = null; }\n    var fn = function () {\n        return axios.post(url || bbn.env.path, objectToFormData(file), {\n            headers: {\n                'Content-Type': 'multipart/form-data',\n            },\n            onUploadProgress: function (progressEvent) {\n                if (progress) {\n                    var percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n                    progress(percentCompleted, progressEvent.loaded, progressEvent.total);\n                }\n            },\n        });\n    };\n    if (!success && !failure) {\n        return fn();\n    }\n    else {\n        return fn()\n            .then(function (res) {\n            if (success) {\n                log('SUCCESS', res);\n                success(res);\n            }\n        })\n            .catch(function (err) {\n            if (failure) {\n                log('ERROR', err);\n                failure(err);\n            }\n        });\n    }\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/fn.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const fn = ({\n    _addLoader: _addLoader,\n    _compareValues: _compareValues,\n    _deleteLoader: _deleteLoader,\n    abort: abort,\n    abortURL: abortURL,\n    addColors: addColors,\n    addInputs: addInputs,\n    addStyle: addStyle,\n    adjustHeight: adjustHeight,\n    adjustSize: adjustSize,\n    adjustWidth: adjustWidth,\n    ajax: ajax,\n    analyzeFunction: analyzeFunction,\n    animateCss: animateCss,\n    arrayBuffer2String: arrayBuffer2String,\n    arrayFromProp: arrayFromProp,\n    autoExtend: autoExtend,\n    baseName: baseName,\n    br2nl: br2nl,\n    calendar: calendar_calendar,\n    callback: callback,\n    camelize: camelize,\n    camelToCss: camelToCss,\n    canvasToImage: canvasToImage,\n    center: center,\n    checkProps: checkProps,\n    checkPropsDetails: checkPropsDetails,\n    checkPropsOrDie: checkPropsOrDie,\n    checkType: checkType,\n    circularReplacer: circularReplacer,\n    clone: clone,\n    colorToHex: colorToHex,\n    compare: compare,\n    compareConditions: compareConditions,\n    copy: copy,\n    correctCase: correctCase,\n    count: count,\n    crc32: crc32,\n    createObject: createObject,\n    cssExists: cssExists,\n    date: date,\n    dateSQL: dateSQL,\n    daysInMonth: daysInMonth,\n    deepPath: deepPath,\n    defaultAjaxAbortFunction: defaultAjaxAbortFunction,\n    defaultAjaxErrorFunction: defaultAjaxErrorFunction,\n    defaultAlertFunction: defaultAlertFunction,\n    defaultConfirmFunction: defaultConfirmFunction,\n    defaultEndLoadingFunction: defaultEndLoadingFunction,\n    defaultErrorFunction: defaultErrorFunction,\n    defaultHistoryFunction: defaultHistoryFunction,\n    defaultLinkFunction: defaultLinkFunction,\n    defaultPostLinkFunction: defaultPostLinkFunction,\n    defaultPreLinkFunction: defaultPreLinkFunction,\n    defaultResizeFunction: defaultResizeFunction,\n    defaultStartLoadingFunction: defaultStartLoadingFunction,\n    deleteProp: deleteProp,\n    diffObj: diffObj,\n    dirName: dirName,\n    download: download,\n    downloadContent: downloadContent,\n    each: each,\n    eraseCookie: eraseCookie,\n    error: error,\n    escapeDquotes: escapeDquotes,\n    escapeRegExp: escapeRegExp,\n    escapeSquotes: escapeSquotes,\n    escapeTicks: escapeTicks,\n    escapeUrl: escapeUrl,\n    extend: extend_extend,\n    extendOut: extendOut,\n    fdate: fdate,\n    fdatetime: fdatetime,\n    fieldValue: fieldValue,\n    fileExt: fileExt,\n    filter: filter,\n    filterToConditions: filterToConditions,\n    findAll: findAll,\n    fori: fori,\n    forir: forir,\n    format: format,\n    formatBytes: formatBytes,\n    formatDate: formatDate,\n    formatSize: formatSize,\n    formdata: formdata,\n    fromXml: fromXml,\n    ftime: ftime,\n    getAllTags: getAllTags,\n    getAncestors: getAncestors,\n    getAttributes: getAttributes,\n    getBrowserName: getBrowserName,\n    getBrowserVersion: getBrowserVersion,\n    getCookie: getCookie,\n    getCssVar: getCssVar,\n    getDay: getDay,\n    getDeviceType: getDeviceType,\n    getEventData: getEventData,\n    getField: getField,\n    getFieldValues: getFieldValues,\n    getHtml: getHtml,\n    getHTMLOfSelection: getHTMLOfSelection,\n    getLoader: getLoader,\n    getPath: getPath,\n    getProp: getProp,\n    getProperty: getProperty,\n    getRequestId: getRequestId,\n    getRow: getRow,\n    getScrollBarSize: getScrollBarSize,\n    getText: getText,\n    getTimeoff: getTimeoff,\n    happy: happy,\n    hash: hash,\n    hex2rgb: hex2rgb,\n    history: history_history,\n    html2text: html2text,\n    imageToCanvas: imageToCanvas,\n    imgToBase64: imgToBase64,\n    info: info,\n    init: init,\n    isActiveInterface: isActiveInterface,\n    isArray: isArray_isArray,\n    isBlob: isBlob_isBlob,\n    isBoolean: isBoolean_isBoolean,\n    isCanvas: isCanvas,\n    isColor: isColor,\n    isComment: isComment,\n    isCp: isCp,\n    isDate: isDate_isDate,\n    isDesktopDevice: isDesktopDevice,\n    isDimension: isDimension,\n    isDom: isDom,\n    isEmail: isEmail,\n    isEmpty: isEmpty,\n    isEvent: isEvent,\n    isFocused: isFocused,\n    isFunction: isFunction_isFunction,\n    isHostname: isHostname,\n    isInside: isInside,\n    isInt: isInt,\n    isInViewport: isInViewport,\n    isIP: isIP,\n    isIterable: isIterable,\n    isMobile: isMobile,\n    isMobileDevice: isMobileDevice,\n    isNull: isNull,\n    isNumber: isNumber_isNumber,\n    isObject: isObject_isObject,\n    isPercent: isPercent,\n    isPrimitive: isPrimitive,\n    isPromise: isPromise,\n    isPropSize: isPropSize,\n    isSame: isSame,\n    isSQLDate: isSQLDate,\n    isString: isString_isString,\n    isSymbol: isSymbol,\n    isTabletDevice: isTabletDevice,\n    isURL: isURL,\n    isValidDimension: isValidDimension,\n    isValidName: isValidName,\n    isValue: isValue,\n    isVue: isVue,\n    iterate: iterate,\n    lightenDarkenHex: lightenDarkenHex,\n    link: link_link,\n    log: log,\n    makeReactive: makeReactive,\n    map: map,\n    md5: md5,\n    money: money,\n    move: move,\n    multiorder: multiorder,\n    mutateArray: mutateArray,\n    nl2br: nl2br,\n    numProperties: numProperties,\n    objectToFormData: objectToFormData,\n    order: order,\n    outerHeight: outerHeight_outerHeight,\n    outerWidth: outerWidth_outerWidth,\n    percent: percent,\n    pickValue: pickValue,\n    post: post,\n    postOut: postOut,\n    printf: printf,\n    quotes2html: quotes2html,\n    randomInt: randomInt,\n    randomString: randomString,\n    removeAccents: removeAccents,\n    removeEmpty: removeEmpty,\n    removeExtraSpaces: removeExtraSpaces,\n    removeHtmlComments: removeHtmlComments,\n    removePrivateProp: removePrivateProp,\n    removeTrailingChars: removeTrailingChars,\n    repeat: repeat,\n    replaceAll: replaceAll,\n    replaceSelection: replaceSelection,\n    resize: resize,\n    rgb2hex: rgb2hex,\n    riterate: riterate,\n    roundDecimal: roundDecimal,\n    sanitize: sanitize,\n    search: search,\n    selectElementText: selectElementText,\n    selector: selector,\n    setCookie: setCookie,\n    setCssVar: setCssVar,\n    setNavigationVars: setNavigationVars,\n    setProp: setProp,\n    setProperty: setProperty,\n    shorten: shorten,\n    shortenObj: shortenObj,\n    shuffle: shuffle,\n    simpleHash: simpleHash,\n    simpleHash1: simpleHash1,\n    simpleHash2: simpleHash2,\n    startChrono: startChrono,\n    stopChrono: stopChrono,\n    string2ArrayBuffer: string2ArrayBuffer,\n    submit: submit_submit,\n    substr: substr,\n    sum: sum,\n    timestamp: timestamp,\n    toCSV: toCSV,\n    toggleFullScreen: toggleFullScreen,\n    translate: translate,\n    treatAjaxArguments: treatAjaxArguments,\n    trim: trim_trim,\n    uniqString: uniqString,\n    unique: unique,\n    upload: upload,\n    warning: warning,\n});\n\n;// CONCATENATED MODULE: ./node_modules/@bbn/bbn/dist/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndayjs_min.extend(calendar);\ndayjs_min.extend(dayOfYear);\ndayjs_min.extend(duration);\ndayjs_min.extend(isBetween);\ndayjs_min.extend(isLeapYear);\ndayjs_min.extend(isoWeek);\ndayjs_min.extend(localeData);\ndayjs_min.extend(localizedFormat);\ndayjs_min.extend(minMax);\ndayjs_min.extend(quarterOfYear);\ndayjs_min.extend(relativeTime);\ndayjs_min.extend(timezone);\ndayjs_min.extend(updateLocale);\ndayjs_min.extend(utc);\ndayjs_min.extend(weekday);\ndayjs_min.extend(weekOfYear);\n\n\n\n\n\n\n\nvar dist_bbn = {\n    version: \"1.0.1\",\n    opt: {\n        _cat: {}\n    },\n    app: {},\n    _: _,\n    $: $,\n    lng: lng,\n    var: vars,\n    env: env,\n    db: dist_db,\n    fn: fn\n};\nif ('undefined' !== typeof window) {\n    window.axios = lib_axios;\n    window.dayjs = dayjs_min;\n    window.bbn = dist_bbn;\n}\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/@bbn/bbn/dist/index.js_+_280_modules?");

/***/ }),

/***/ "./node_modules/acorn-loose/dist/acorn-loose.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/acorn-loose/dist/acorn-loose.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LooseParser: () => (/* binding */ LooseParser),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var acorn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! acorn */ \"./node_modules/acorn-loose/node_modules/acorn/dist/acorn.mjs\");\n\n\nfunction noop() {}\n\nvar LooseParser = function LooseParser(input, options) {\n  if ( options === void 0 ) options = {};\n\n  this.toks = this.constructor.BaseParser.tokenizer(input, options);\n  this.options = this.toks.options;\n  this.input = this.toks.input;\n  this.tok = this.last = {type: acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eof, start: 0, end: 0};\n  this.tok.validateRegExpFlags = noop;\n  this.tok.validateRegExpPattern = noop;\n  if (this.options.locations) {\n    var here = this.toks.curPosition();\n    this.tok.loc = new acorn__WEBPACK_IMPORTED_MODULE_0__.SourceLocation(this.toks, here, here);\n  }\n  this.ahead = []; // Tokens ahead\n  this.context = []; // Indentation contexted\n  this.curIndent = 0;\n  this.curLineStart = 0;\n  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n  this.inAsync = false;\n  this.inFunction = false;\n};\n\nLooseParser.prototype.startNode = function startNode () {\n  return new acorn__WEBPACK_IMPORTED_MODULE_0__.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n};\n\nLooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n};\n\nLooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n  if (this.options.locations) {\n    return new acorn__WEBPACK_IMPORTED_MODULE_0__.Node(this.toks, pos[0], pos[1])\n  } else {\n    return new acorn__WEBPACK_IMPORTED_MODULE_0__.Node(this.toks, pos)\n  }\n};\n\nLooseParser.prototype.finishNode = function finishNode (node, type) {\n  node.type = type;\n  node.end = this.last.end;\n  if (this.options.locations)\n    { node.loc.end = this.last.loc.end; }\n  if (this.options.ranges)\n    { node.range[1] = this.last.end; }\n  return node\n};\n\nLooseParser.prototype.dummyNode = function dummyNode (type) {\n  var dummy = this.startNode();\n  dummy.type = type;\n  dummy.end = dummy.start;\n  if (this.options.locations)\n    { dummy.loc.end = dummy.loc.start; }\n  if (this.options.ranges)\n    { dummy.range[1] = dummy.start; }\n  this.last = {type: acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n  return dummy\n};\n\nLooseParser.prototype.dummyIdent = function dummyIdent () {\n  var dummy = this.dummyNode(\"Identifier\");\n  dummy.name = \"✖\";\n  return dummy\n};\n\nLooseParser.prototype.dummyString = function dummyString () {\n  var dummy = this.dummyNode(\"Literal\");\n  dummy.value = dummy.raw = \"✖\";\n  return dummy\n};\n\nLooseParser.prototype.eat = function eat (type) {\n  if (this.tok.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\nLooseParser.prototype.isContextual = function isContextual (name) {\n  return this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name && this.tok.value === name\n};\n\nLooseParser.prototype.eatContextual = function eatContextual (name) {\n  return this.tok.value === name && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name)\n};\n\nLooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n  return this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eof || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR ||\n    acorn__WEBPACK_IMPORTED_MODULE_0__.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n};\n\nLooseParser.prototype.semicolon = function semicolon () {\n  return this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi)\n};\n\nLooseParser.prototype.expect = function expect (type) {\n  if (this.eat(type)) { return true }\n  for (var i = 1; i <= 2; i++) {\n    if (this.lookAhead(i).type === type) {\n      for (var j = 0; j < i; j++) { this.next(); }\n      return true\n    }\n  }\n};\n\nLooseParser.prototype.pushCx = function pushCx () {\n  this.context.push(this.curIndent);\n};\n\nLooseParser.prototype.popCx = function popCx () {\n  this.curIndent = this.context.pop();\n};\n\nLooseParser.prototype.lineEnd = function lineEnd (pos) {\n  while (pos < this.input.length && !(0,acorn__WEBPACK_IMPORTED_MODULE_0__.isNewLine)(this.input.charCodeAt(pos))) { ++pos; }\n  return pos\n};\n\nLooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n  for (var count = 0;; ++pos) {\n    var ch = this.input.charCodeAt(pos);\n    if (ch === 32) { ++count; }\n    else if (ch === 9) { count += this.options.tabSize; }\n    else { return count }\n  }\n};\n\nLooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n  if (this.tok.type === closeTok || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eof) { return true }\n  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n     this.indentationAfter(this.nextLineStart) < indent)\n};\n\nLooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n    var ch = this.input.charCodeAt(p);\n    if (ch !== 9 && ch !== 32) { return false }\n  }\n  return true\n};\n\nLooseParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nLooseParser.prototype.parse = function parse () {\n  this.next();\n  return this.parseTopLevel()\n};\n\nLooseParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nLooseParser.parse = function parse (input, options) {\n  return new this(input, options).parse()\n};\n\n// Allows plugins to extend the base parser / tokenizer used\nLooseParser.BaseParser = acorn__WEBPACK_IMPORTED_MODULE_0__.Parser;\n\nvar lp = LooseParser.prototype;\n\nfunction isSpace(ch) {\n  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || (0,acorn__WEBPACK_IMPORTED_MODULE_0__.isNewLine)(ch)\n}\n\nlp.next = function() {\n  this.last = this.tok;\n  if (this.ahead.length)\n    { this.tok = this.ahead.shift(); }\n  else\n    { this.tok = this.readToken(); }\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart;\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    }\n    this.curIndent = this.indentationAfter(this.curLineStart);\n  }\n};\n\nlp.readToken = function() {\n  for (;;) {\n    try {\n      this.toks.next();\n      if (this.toks.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.dot &&\n          this.input.substr(this.toks.end, 1) === \".\" &&\n          this.options.ecmaVersion >= 6) {\n        this.toks.end++;\n        this.toks.type = acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.ellipsis;\n      }\n      return new acorn__WEBPACK_IMPORTED_MODULE_0__.Token(this.toks)\n    } catch (e) {\n      if (!(e instanceof SyntaxError)) { throw e }\n\n      // Try to skip some text, based on the error message, and then continue\n      var msg = e.message, pos = e.raisedAt, replace = true;\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1);\n        if (/string/.test(msg)) {\n          replace = {start: e.pos, end: pos, type: acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.string, value: this.input.slice(e.pos + 1, pos)};\n        } else if (/regular expr/i.test(msg)) {\n          var re = this.input.slice(e.pos, pos);\n          try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n          replace = {start: e.pos, end: pos, type: acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.regexp, value: re};\n        } else if (/template/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.template,\n            value: this.input.slice(e.pos, pos)\n          };\n        } else {\n          replace = false;\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          var ch = this.input.charCodeAt(pos++);\n          if (ch === 34 || ch === 39 || (0,acorn__WEBPACK_IMPORTED_MODULE_0__.isNewLine)(ch)) { break }\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++;\n        replace = false;\n      } else if (/regular expression/i.test(msg)) {\n        replace = true;\n      } else {\n        throw e\n      }\n      this.resetTo(pos);\n      if (replace === true) { replace = {start: pos, end: pos, type: acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name, value: \"✖\"}; }\n      if (replace) {\n        if (this.options.locations)\n          { replace.loc = new acorn__WEBPACK_IMPORTED_MODULE_0__.SourceLocation(\n            this.toks,\n            (0,acorn__WEBPACK_IMPORTED_MODULE_0__.getLineInfo)(this.input, replace.start),\n            (0,acorn__WEBPACK_IMPORTED_MODULE_0__.getLineInfo)(this.input, replace.end)); }\n        return replace\n      }\n    }\n  }\n};\n\nlp.resetTo = function(pos) {\n  this.toks.pos = pos;\n  var ch = this.input.charAt(pos - 1);\n  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n    /[enwfd]/.test(ch) &&\n    /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n  if (this.options.locations) {\n    this.toks.curLine = 1;\n    this.toks.lineStart = acorn__WEBPACK_IMPORTED_MODULE_0__.lineBreakG.lastIndex = 0;\n    var match;\n    while ((match = acorn__WEBPACK_IMPORTED_MODULE_0__.lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine;\n      this.toks.lineStart = match.index + match[0].length;\n    }\n  }\n};\n\nlp.lookAhead = function(n) {\n  while (n > this.ahead.length)\n    { this.ahead.push(this.readToken()); }\n  return this.ahead[n - 1]\n};\n\nfunction isDummy(node) { return node.name === \"✖\" }\n\nvar lp$1 = LooseParser.prototype;\n\nlp$1.parseTopLevel = function() {\n  var node = this.startNodeAt(this.options.locations ? [0, (0,acorn__WEBPACK_IMPORTED_MODULE_0__.getLineInfo)(this.input, 0)] : 0);\n  node.body = [];\n  while (this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eof) { node.body.push(this.parseStatement()); }\n  this.toks.adaptDirectivePrologue(node.body);\n  this.last = this.tok;\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nlp$1.parseStatement = function() {\n  var starttype = this.tok.type, node = this.startNode(), kind;\n\n  if (this.toks.isLet()) {\n    starttype = acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._var;\n    kind = \"let\";\n  }\n\n  switch (starttype) {\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._break: case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._continue:\n    this.next();\n    var isBreak = starttype === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._break;\n    if (this.semicolon() || this.canInsertSemicolon()) {\n      node.label = null;\n    } else {\n      node.label = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name ? this.parseIdent() : null;\n      this.semicolon();\n    }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._debugger:\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._do:\n    this.next();\n    node.body = this.parseStatement();\n    node.test = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n    this.semicolon();\n    return this.finishNode(node, \"DoWhileStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._for:\n    this.next(); // `for` keyword\n    var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n\n    this.pushCx();\n    this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL);\n    if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi) { return this.parseFor(node, null) }\n    var isLet = this.toks.isLet();\n    if (isLet || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._var || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._const) {\n      var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n      if (init$1.declarations.length === 1 && (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._in || this.isContextual(\"of\"))) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._in) {\n          node.await = isAwait;\n        }\n        return this.parseForIn(node, init$1)\n      }\n      return this.parseFor(node, init$1)\n    }\n    var init = this.parseExpression(true);\n    if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._in || this.isContextual(\"of\")) {\n      if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._in) {\n        node.await = isAwait;\n      }\n      return this.parseForIn(node, this.toAssignable(init))\n    }\n    return this.parseFor(node, init)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._function:\n    this.next();\n    return this.parseFunction(node, true)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._if:\n    this.next();\n    node.test = this.parseParenExpression();\n    node.consequent = this.parseStatement();\n    node.alternate = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._else) ? this.parseStatement() : null;\n    return this.finishNode(node, \"IfStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._return:\n    this.next();\n    if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._switch:\n    var blockIndent = this.curIndent, line = this.curLineStart;\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.pushCx();\n    this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL);\n\n    var cur;\n    while (!this.closes(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR, blockIndent, line, true)) {\n      if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._case || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._default) {\n        var isCase = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) { cur.test = this.parseExpression(); }\n        else { cur.test = null; }\n        this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.colon);\n      } else {\n        if (!cur) {\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          cur.test = null;\n        }\n        cur.consequent.push(this.parseStatement());\n      }\n    }\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.popCx();\n    this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR);\n    return this.finishNode(node, \"SwitchStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._throw:\n    this.next();\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._try:\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL)) {\n        clause.param = this.toAssignable(this.parseExprAtom(), true);\n        this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n      } else {\n        clause.param = null;\n      }\n      clause.body = this.parseBlock();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) { return node.block }\n    return this.finishNode(node, \"TryStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._var:\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._const:\n    return this.parseVar(node, false, kind || this.tok.value)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._while:\n    this.next();\n    node.test = this.parseParenExpression();\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"WhileStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._with:\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"WithStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL:\n    return this.parseBlock()\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi:\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._class:\n    return this.parseClass(true)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._import:\n    if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL) {\n      node.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ExpressionStatement\")\n    }\n\n    return this.parseImport()\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._export:\n    return this.parseExport()\n\n  default:\n    if (this.toks.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(node, true, true)\n    }\n    var expr = this.parseExpression();\n    if (isDummy(expr)) {\n      this.next();\n      if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n      return this.parseStatement()\n    } else if (starttype === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name && expr.type === \"Identifier\" && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.colon)) {\n      node.body = this.parseStatement();\n      node.label = expr;\n      return this.finishNode(node, \"LabeledStatement\")\n    } else {\n      node.expression = expr;\n      this.semicolon();\n      return this.finishNode(node, \"ExpressionStatement\")\n    }\n  }\n};\n\nlp$1.parseBlock = function() {\n  var node = this.startNode();\n  this.pushCx();\n  this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL);\n  var blockIndent = this.curIndent, line = this.curLineStart;\n  node.body = [];\n  while (!this.closes(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR, blockIndent, line, true))\n    { node.body.push(this.parseStatement()); }\n  this.popCx();\n  this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR);\n  return this.finishNode(node, \"BlockStatement\")\n};\n\nlp$1.parseFor = function(node, init) {\n  node.init = init;\n  node.test = node.update = null;\n  if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi) && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi) { node.test = this.parseExpression(); }\n  if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.semi) && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR) { node.update = this.parseExpression(); }\n  this.popCx();\n  this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, \"ForStatement\")\n};\n\nlp$1.parseForIn = function(node, init) {\n  var type = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.popCx();\n  this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, type)\n};\n\nlp$1.parseVar = function(node, noIn, kind) {\n  node.kind = kind;\n  this.next();\n  node.declarations = [];\n  do {\n    var decl = this.startNode();\n    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n    decl.init = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n  } while (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma))\n  if (!node.declarations.length) {\n    var decl$1 = this.startNode();\n    decl$1.id = this.dummyIdent();\n    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n  }\n  if (!noIn) { this.semicolon(); }\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\nlp$1.parseClass = function(isStatement) {\n  var node = this.startNode();\n  this.next();\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name) { node.id = this.parseIdent(); }\n  else if (isStatement === true) { node.id = this.dummyIdent(); }\n  else { node.id = null; }\n  node.superClass = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._extends) ? this.parseExpression() : null;\n  node.body = this.startNode();\n  node.body.body = [];\n  this.pushCx();\n  var indent = this.curIndent + 1, line = this.curLineStart;\n  this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL);\n  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n  while (!this.closes(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR, indent, line)) {\n    if (this.semicolon()) { continue }\n    var method = this.startNode(), isGenerator = (void 0), isAsync = (void 0);\n    if (this.options.ecmaVersion >= 6) {\n      method.static = false;\n      isGenerator = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n    }\n    this.parsePropertyName(method);\n    if (isDummy(method.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma); continue }\n    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n        (this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL)) {\n      method.static = true;\n      isGenerator = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      method.static = false;\n    }\n    if (!method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL &&\n        !this.canInsertSemicolon()) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      isAsync = false;\n    }\n    if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n        this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL) {\n      method.kind = method.key.name;\n      this.parsePropertyName(method);\n      method.value = this.parseMethod(false);\n    } else {\n      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n        method.kind = \"constructor\";\n      } else {\n        method.kind = \"method\";\n      }\n      method.value = this.parseMethod(isGenerator, isAsync);\n    }\n    node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n  }\n  this.popCx();\n  if (!this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n  }\n  this.semicolon();\n  this.finishNode(node.body, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\nlp$1.parseFunction = function(node, isStatement, isAsync) {\n  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n  }\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name) { node.id = this.parseIdent(); }\n  else if (isStatement === true) { node.id = this.dummyIdent(); }\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\nlp$1.parseExport = function() {\n  var node = this.startNode();\n  this.next();\n  if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star)) {\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._default)) {\n    // export default (function foo() {}) // This is FunctionExpression.\n    var isAsync;\n    if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n    } else if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._class) {\n      node.declaration = this.parseClass(\"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n    node.declaration = this.parseStatement();\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifierList();\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\nlp$1.parseImport = function() {\n  var node = this.startNode();\n  this.next();\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.string) {\n    node.specifiers = [];\n    node.source = this.parseExprAtom();\n  } else {\n    var elt;\n    if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name && this.tok.value !== \"from\") {\n      elt = this.startNode();\n      elt.local = this.parseIdent();\n      this.finishNode(elt, \"ImportDefaultSpecifier\");\n      this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma);\n    }\n    node.specifiers = this.parseImportSpecifiers();\n    node.source = this.eatContextual(\"from\") && this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n    if (elt) { node.specifiers.unshift(elt); }\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\nlp$1.parseImportSpecifiers = function() {\n  var elts = [];\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star) {\n    var elt = this.startNode();\n    this.next();\n    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n  } else {\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL);\n    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n    while (!this.closes(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      var elt$1 = this.startNode();\n      if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star)) {\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n        this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n      } else {\n        if (this.isContextual(\"from\")) { break }\n        elt$1.imported = this.parseIdent();\n        if (isDummy(elt$1.imported)) { break }\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n        this.finishNode(elt$1, \"ImportSpecifier\");\n      }\n      elts.push(elt$1);\n      this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma);\n    }\n    this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR);\n    this.popCx();\n  }\n  return elts\n};\n\nlp$1.parseExportSpecifierList = function() {\n  var elts = [];\n  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n  this.pushCx();\n  this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL);\n  if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n  while (!this.closes(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n    if (this.isContextual(\"from\")) { break }\n    var elt = this.startNode();\n    elt.local = this.parseIdent();\n    if (isDummy(elt.local)) { break }\n    elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n    this.finishNode(elt, \"ExportSpecifier\");\n    elts.push(elt);\n    this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma);\n  }\n  this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR);\n  this.popCx();\n  return elts\n};\n\nvar lp$2 = LooseParser.prototype;\n\nlp$2.checkLVal = function(expr) {\n  if (!expr) { return expr }\n  switch (expr.type) {\n  case \"Identifier\":\n  case \"MemberExpression\":\n    return expr\n\n  case \"ParenthesizedExpression\":\n    expr.expression = this.checkLVal(expr.expression);\n    return expr\n\n  default:\n    return this.dummyIdent()\n  }\n};\n\nlp$2.parseExpression = function(noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseMaybeAssign(noIn);\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma) {\n    var node = this.startNodeAt(start);\n    node.expressions = [expr];\n    while (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma)) { node.expressions.push(this.parseMaybeAssign(noIn)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\nlp$2.parseParenExpression = function() {\n  this.pushCx();\n  this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL);\n  var val = this.parseExpression();\n  this.popCx();\n  this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n  return val\n};\n\nlp$2.parseMaybeAssign = function(noIn) {\n  if (this.toks.isContextual(\"yield\")) {\n    var node = this.startNode();\n    this.next();\n    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star && !this.tok.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n      node.argument = this.parseMaybeAssign();\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  }\n\n  var start = this.storeCurrentPos();\n  var left = this.parseMaybeConditional(noIn);\n  if (this.tok.type.isAssign) {\n    var node$1 = this.startNodeAt(start);\n    node$1.operator = this.tok.value;\n    node$1.left = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n    this.next();\n    node$1.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node$1, \"AssignmentExpression\")\n  }\n  return left\n};\n\nlp$2.parseMaybeConditional = function(noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseExprOps(noIn);\n  if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.question)) {\n    var node = this.startNodeAt(start);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    node.alternate = this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\nlp$2.parseExprOps = function(noIn) {\n  var start = this.storeCurrentPos();\n  var indent = this.curIndent, line = this.curLineStart;\n  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n};\n\nlp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n  var prec = this.tok.type.binop;\n  if (prec != null && (!noIn || this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(start);\n      node.left = left;\n      node.operator = this.tok.value;\n      this.next();\n      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n        node.right = this.dummyIdent();\n      } else {\n        var rightStart = this.storeCurrentPos();\n        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n      }\n      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n    }\n  }\n  return left\n};\n\nlp$2.parseMaybeUnary = function(sawUnary) {\n  var start = this.storeCurrentPos(), expr;\n  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n    (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n  ) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.tok.type.prefix) {\n    var node = this.startNode(), update = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.incDec;\n    if (!update) { sawUnary = true; }\n    node.operator = this.tok.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(true);\n    if (update) { node.argument = this.checkLVal(node.argument); }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.ellipsis) {\n    var node$1 = this.startNode();\n    this.next();\n    node$1.argument = this.parseMaybeUnary(sawUnary);\n    expr = this.finishNode(node$1, \"SpreadElement\");\n  } else {\n    expr = this.parseExprSubscripts();\n    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n      var node$2 = this.startNodeAt(start);\n      node$2.operator = this.tok.value;\n      node$2.prefix = false;\n      node$2.argument = this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$2, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.starstar)) {\n    var node$3 = this.startNodeAt(start);\n    node$3.operator = \"**\";\n    node$3.left = expr;\n    node$3.right = this.parseMaybeUnary(false);\n    return this.finishNode(node$3, \"BinaryExpression\")\n  }\n\n  return expr\n};\n\nlp$2.parseExprSubscripts = function() {\n  var start = this.storeCurrentPos();\n  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n};\n\nlp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n  for (;;) {\n    if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n      if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.dot && this.curIndent === startIndent)\n        { --startIndent; }\n      else\n        { return base }\n    }\n\n    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n    if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.dot)) {\n      var node = this.startNodeAt(start);\n      node.object = base;\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine())\n        { node.property = this.dummyIdent(); }\n      else\n        { node.property = this.parsePropertyAccessor() || this.dummyIdent(); }\n      node.computed = false;\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.bracketL) {\n      this.pushCx();\n      this.next();\n      var node$1 = this.startNodeAt(start);\n      node$1.object = base;\n      node$1.property = this.parseExpression();\n      node$1.computed = true;\n      this.popCx();\n      this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.bracketR);\n      base = this.finishNode(node$1, \"MemberExpression\");\n    } else if (!noCalls && this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL) {\n      var exprList = this.parseExprList(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n      if (maybeAsyncArrow && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(start), exprList, true) }\n      var node$2 = this.startNodeAt(start);\n      node$2.callee = base;\n      node$2.arguments = exprList;\n      base = this.finishNode(node$2, \"CallExpression\");\n    } else if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.backQuote) {\n      var node$3 = this.startNodeAt(start);\n      node$3.tag = base;\n      node$3.quasi = this.parseTemplate();\n      base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\nlp$2.parseExprAtom = function() {\n  var node;\n  switch (this.tok.type) {\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._this:\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._super:\n    var type = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._this ? \"ThisExpression\" : \"Super\";\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, type)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name:\n    var start = this.storeCurrentPos();\n    var id = this.parseIdent();\n    var isAsync = false;\n    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n      if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._function))\n        { return this.parseFunction(this.startNodeAt(start), false, true) }\n      if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name) {\n        id = this.parseIdent();\n        isAsync = true;\n      }\n    }\n    return this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.regexp:\n    node = this.startNode();\n    var val = this.tok.value;\n    node.regex = {pattern: val.pattern, flags: val.flags};\n    node.value = val.value;\n    node.raw = this.input.slice(this.tok.start, this.tok.end);\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.num: case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.string:\n    node = this.startNode();\n    node.value = this.tok.value;\n    node.raw = this.input.slice(this.tok.start, this.tok.end);\n    if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._null: case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._true: case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._false:\n    node = this.startNode();\n    node.value = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._null ? null : this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._true;\n    node.raw = this.tok.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL:\n    var parenStart = this.storeCurrentPos();\n    this.next();\n    var inner = this.parseExpression();\n    this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n    if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.arrow)) {\n      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n      var params = inner.expressions || [inner];\n      if (params.length && isDummy(params[params.length - 1]))\n        { params.pop(); }\n      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n    }\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(parenStart);\n      par.expression = inner;\n      inner = this.finishNode(par, \"ParenthesizedExpression\");\n    }\n    return inner\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.bracketL:\n    node = this.startNode();\n    node.elements = this.parseExprList(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.bracketR, true);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL:\n    return this.parseObj()\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._class:\n    return this.parseClass(false)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._new:\n    return this.parseNew()\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.backQuote:\n    return this.parseTemplate()\n\n  case acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes._import:\n    if (this.options.ecmaVersion > 10) {\n      return this.parseDynamicImport()\n    } else {\n      return this.dummyIdent()\n    }\n\n  default:\n    return this.dummyIdent()\n  }\n};\n\nlp$2.parseDynamicImport = function() {\n  var node = this.startNode();\n  this.next();\n  return this.finishNode(node, \"Import\")\n};\n\nlp$2.parseNew = function() {\n  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var start = this.storeCurrentPos();\n  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL) {\n    node.arguments = this.parseExprList(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n  } else {\n    node.arguments = [];\n  }\n  return this.finishNode(node, \"NewExpression\")\n};\n\nlp$2.parseTemplateElement = function() {\n  var elem = this.startNode();\n\n  // The loose parser accepts invalid unicode escapes even in untagged templates.\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.invalidTemplate) {\n    elem.value = {\n      raw: this.tok.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.tok.value\n    };\n  }\n  this.next();\n  elem.tail = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\nlp$2.parseTemplate = function() {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement();\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this.next();\n    node.expressions.push(this.parseExpression());\n    if (this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR)) {\n      curElt = this.parseTemplateElement();\n    } else {\n      curElt = this.startNode();\n      curElt.value = {cooked: \"\", raw: \"\"};\n      curElt.tail = true;\n      this.finishNode(curElt, \"TemplateElement\");\n    }\n    node.quasis.push(curElt);\n  }\n  this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.backQuote);\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\nlp$2.parseObj = function() {\n  var node = this.startNode();\n  node.properties = [];\n  this.pushCx();\n  var indent = this.curIndent + 1, line = this.curLineStart;\n  this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL);\n  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n  while (!this.closes(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR, indent, line)) {\n    var prop = this.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n    if (this.options.ecmaVersion >= 9 && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.ellipsis)) {\n      prop.argument = this.parseMaybeAssign();\n      node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n      this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma);\n      continue\n    }\n    if (this.options.ecmaVersion >= 6) {\n      start = this.storeCurrentPos();\n      prop.method = false;\n      prop.shorthand = false;\n      isGenerator = this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n    }\n    this.parsePropertyName(prop);\n    if (this.toks.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.star);\n      this.parsePropertyName(prop);\n    } else {\n      isAsync = false;\n    }\n    if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma); continue }\n    if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.colon)) {\n      prop.kind = \"init\";\n      prop.value = this.parseMaybeAssign();\n    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenL || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL)) {\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR && this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eq)) {\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n    } else {\n      prop.kind = \"init\";\n      if (this.options.ecmaVersion >= 6) {\n        if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.eq)) {\n          var assign = this.startNodeAt(start);\n          assign.operator = \"=\";\n          assign.left = prop.key;\n          assign.right = this.parseMaybeAssign();\n          prop.value = this.finishNode(assign, \"AssignmentExpression\");\n        } else {\n          prop.value = prop.key;\n        }\n      } else {\n        prop.value = this.dummyIdent();\n      }\n      prop.shorthand = true;\n    }\n    node.properties.push(this.finishNode(prop, \"Property\"));\n    this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma);\n  }\n  this.popCx();\n  if (!this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n  }\n  return this.finishNode(node, \"ObjectExpression\")\n};\n\nlp$2.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseExpression();\n      this.expect(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.bracketR);\n      return\n    } else {\n      prop.computed = false;\n    }\n  }\n  var key = (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.num || this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n  prop.key = key || this.dummyIdent();\n};\n\nlp$2.parsePropertyAccessor = function() {\n  if (this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n};\n\nlp$2.parseIdent = function() {\n  var name = this.tok.type === acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n  if (!name) { return this.dummyIdent() }\n  var node = this.startNode();\n  this.next();\n  node.name = name;\n  return this.finishNode(node, \"Identifier\")\n};\n\nlp$2.initFunction = function(node) {\n  node.id = null;\n  node.params = [];\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\nlp$2.toAssignable = function(node, binding) {\n  if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) ; else if (node.type === \"ParenthesizedExpression\") {\n    this.toAssignable(node.expression, binding);\n  } else if (this.options.ecmaVersion < 6) {\n    return this.dummyIdent()\n  } else if (node.type === \"ObjectExpression\") {\n    node.type = \"ObjectPattern\";\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      this.toAssignable(prop, binding);\n    }\n  } else if (node.type === \"ArrayExpression\") {\n    node.type = \"ArrayPattern\";\n    this.toAssignableList(node.elements, binding);\n  } else if (node.type === \"Property\") {\n    this.toAssignable(node.value, binding);\n  } else if (node.type === \"SpreadElement\") {\n    node.type = \"RestElement\";\n    this.toAssignable(node.argument, binding);\n  } else if (node.type === \"AssignmentExpression\") {\n    node.type = \"AssignmentPattern\";\n    delete node.operator;\n  } else {\n    return this.dummyIdent()\n  }\n  return node\n};\n\nlp$2.toAssignableList = function(exprList, binding) {\n  for (var i = 0, list = exprList; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    this.toAssignable(expr, binding);\n  }\n  return exprList\n};\n\nlp$2.parseFunctionParams = function(params) {\n  params = this.parseExprList(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.parenR);\n  return this.toAssignableList(params, true)\n};\n\nlp$2.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = !!isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\nlp$2.parseArrowExpression = function(node, params, isAsync) {\n  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.toAssignableList(params, true);\n  node.expression = this.tok.type !== acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.braceL;\n  if (node.expression) {\n    node.body = this.parseMaybeAssign();\n  } else {\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n  }\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\nlp$2.parseExprList = function(close, allowEmpty) {\n  this.pushCx();\n  var indent = this.curIndent, line = this.curLineStart, elts = [];\n  this.next(); // Opening bracket\n  while (!this.closes(close, indent + 1, line)) {\n    if (this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma)) {\n      elts.push(allowEmpty ? null : this.dummyIdent());\n      continue\n    }\n    var elt = this.parseMaybeAssign();\n    if (isDummy(elt)) {\n      if (this.closes(close, indent, line)) { break }\n      this.next();\n    } else {\n      elts.push(elt);\n    }\n    this.eat(acorn__WEBPACK_IMPORTED_MODULE_0__.tokTypes.comma);\n  }\n  this.popCx();\n  if (!this.eat(close)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n  }\n  return elts\n};\n\nlp$2.parseAwait = function() {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary();\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\n// Acorn: Loose parser\n\nacorn__WEBPACK_IMPORTED_MODULE_0__.defaultOptions.tabSize = 4;\n\nfunction parse(input, options) {\n  return LooseParser.parse(input, options)\n}\n\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/acorn-loose/dist/acorn-loose.mjs?");

/***/ }),

/***/ "./node_modules/acorn-loose/node_modules/acorn/dist/acorn.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/acorn-loose/node_modules/acorn/dist/acorn.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   SourceLocation: () => (/* binding */ SourceLocation),\n/* harmony export */   TokContext: () => (/* binding */ TokContext),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenType: () => (/* binding */ TokenType),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions),\n/* harmony export */   getLineInfo: () => (/* binding */ getLineInfo),\n/* harmony export */   isIdentifierChar: () => (/* binding */ isIdentifierChar),\n/* harmony export */   isIdentifierStart: () => (/* binding */ isIdentifierStart),\n/* harmony export */   isNewLine: () => (/* binding */ isNewLine),\n/* harmony export */   keywordTypes: () => (/* binding */ keywords$1),\n/* harmony export */   lineBreak: () => (/* binding */ lineBreak),\n/* harmony export */   lineBreakG: () => (/* binding */ lineBreakG),\n/* harmony export */   nonASCIIwhitespace: () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseExpressionAt: () => (/* binding */ parseExpressionAt),\n/* harmony export */   tokContexts: () => (/* binding */ types$1),\n/* harmony export */   tokTypes: () => (/* binding */ types),\n/* harmony export */   tokenizer: () => (/* binding */ tokenizer),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 9.\n  ecmaVersion: 9,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = {};\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\nprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n// Switch to a getter for 7.0.0.\nParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp.strictDirective = function(start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") { return true }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91) { return true } // '['\n  if (context) { return false }\n\n  if (nextCh === 123) { return true } // '{'\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock(true, node)\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40) // '('\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope, node) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (!this.eat(types.braceR)) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  this.strict = oldStrict;\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassElement = function(constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  var allowsDirectSuper = false;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types.comma); }\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(noIn) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n    if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n  var computed = this.eat(types.bracketL);\n  if (computed || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n    if (computed) { this.expect(types.bracketR); }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== \"Import\", false, refDestructuringErrors);\n    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (node$1.callee.type === \"Import\") {\n      if (node$1.arguments.length !== 1) {\n        this.raise(node$1.start, \"import() requires exactly one argument\");\n      }\n\n      var importArg = node$1.arguments[0];\n      if (importArg && importArg.type === \"SpreadElement\") {\n        this.raise(importArg.start, \"... is not allowed in import()\");\n      }\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super Arguments\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  case types._import:\n    if (this.options.ecmaVersion > 10) {\n      return this.parseDynamicImport()\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function() {\n  var node = this.startNode();\n  this.next();\n  if (this.type !== types.parenL) {\n    this.unexpected();\n  }\n  return this.finishNode(node, \"Import\")\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc)\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inNonArrowFunction())\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.options.ecmaVersion > 10 && node.callee.type === \"Import\") {\n    this.raise(node.callee.start, \"Cannot use new with import(...)\");\n  }\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== \"Import\", false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n\n  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types.comma)\n      { elt = null; }\n    else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function(noIn) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$5.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$5.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$5.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$5.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$5.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types._const || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\n\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current () {\n  return this.at(this.pos)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead () {\n  return this.at(this.nextIndex(this.pos))\n};\n\nRegExpValidationState.prototype.advance = function advance () {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true\n  }\n  return false\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$8.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$8.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$8.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$8.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$8.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$8.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$8.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$8.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$8.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$8.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$8.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$8.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$8.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$8.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$8.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$8.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$8.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$8.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$8.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$8.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$8.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      state.switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$8.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$8.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$8.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\npp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue))\n    { state.raise(\"Invalid property name\"); }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$8.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$8.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$8.regexp_classRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$8.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$8.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$8.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$8.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$8.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$8.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$9 = Parser.prototype;\n\n// Move to the next token\n\npp$9.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$9[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$9.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$9.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$9.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$9.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$9.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$9.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$9.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$9.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$9.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$9.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$9.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$9.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$9.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$9.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$9.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$9.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$9.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$9.readInt = function(radix, len) {\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$9.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$9.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var str$1 = this.input.slice(start, this.pos);\n    var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val$1)\n  }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$9.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$9.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$9.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$9.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$9.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$9.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$9.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\nvar version = \"6.4.2\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/acorn-loose/node_modules/acorn/dist/acorn.mjs?");

/***/ }),

/***/ "./node_modules/acorn-walk/dist/walk.mjs":
/*!***********************************************!*\
  !*** ./node_modules/acorn-walk/dist/walk.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ancestor: () => (/* binding */ ancestor),\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   findNodeAfter: () => (/* binding */ findNodeAfter),\n/* harmony export */   findNodeAround: () => (/* binding */ findNodeAround),\n/* harmony export */   findNodeAt: () => (/* binding */ findNodeAt),\n/* harmony export */   findNodeBefore: () => (/* binding */ findNodeBefore),\n/* harmony export */   full: () => (/* binding */ full),\n/* harmony export */   fullAncestor: () => (/* binding */ fullAncestor),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   recursive: () => (/* binding */ recursive),\n/* harmony export */   simple: () => (/* binding */ simple)\n/* harmony export */ });\n// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n    {\n    var quasi = list[i];\n\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n    {\n    var expr = list$1[i$1];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/acorn-walk/dist/walk.mjs?");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn/dist/acorn.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn/dist/acorn.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   SourceLocation: () => (/* binding */ SourceLocation),\n/* harmony export */   TokContext: () => (/* binding */ TokContext),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenType: () => (/* binding */ TokenType),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions),\n/* harmony export */   getLineInfo: () => (/* binding */ getLineInfo),\n/* harmony export */   isIdentifierChar: () => (/* binding */ isIdentifierChar),\n/* harmony export */   isIdentifierStart: () => (/* binding */ isIdentifierStart),\n/* harmony export */   isNewLine: () => (/* binding */ isNewLine),\n/* harmony export */   keywordTypes: () => (/* binding */ keywords$1),\n/* harmony export */   lineBreak: () => (/* binding */ lineBreak),\n/* harmony export */   lineBreakG: () => (/* binding */ lineBreakG),\n/* harmony export */   nonASCIIwhitespace: () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseExpressionAt: () => (/* binding */ parseExpressionAt),\n/* harmony export */   tokContexts: () => (/* binding */ types$1),\n/* harmony export */   tokTypes: () => (/* binding */ types),\n/* harmony export */   tokenizer: () => (/* binding */ tokenizer),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 9.\n  ecmaVersion: 9,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = {};\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\nprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n// Switch to a getter for 7.0.0.\nParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp.strictDirective = function(start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") { return true }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91) { return true } // '['\n  if (context) { return false }\n\n  if (nextCh === 123) { return true } // '{'\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock(true, node)\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40) // '('\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope, node) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (!this.eat(types.braceR)) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  this.strict = oldStrict;\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassElement = function(constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  var allowsDirectSuper = false;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types.comma); }\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(noIn) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n    if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n  var computed = this.eat(types.bracketL);\n  if (computed || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n    if (computed) { this.expect(types.bracketR); }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== \"Import\", false, refDestructuringErrors);\n    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (node$1.callee.type === \"Import\") {\n      if (node$1.arguments.length !== 1) {\n        this.raise(node$1.start, \"import() requires exactly one argument\");\n      }\n\n      var importArg = node$1.arguments[0];\n      if (importArg && importArg.type === \"SpreadElement\") {\n        this.raise(importArg.start, \"... is not allowed in import()\");\n      }\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super Arguments\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  case types._import:\n    if (this.options.ecmaVersion > 10) {\n      return this.parseDynamicImport()\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function() {\n  var node = this.startNode();\n  this.next();\n  if (this.type !== types.parenL) {\n    this.unexpected();\n  }\n  return this.finishNode(node, \"Import\")\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc)\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inNonArrowFunction())\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.options.ecmaVersion > 10 && node.callee.type === \"Import\") {\n    this.raise(node.callee.start, \"Cannot use new with import(...)\");\n  }\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== \"Import\", false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n\n  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types.comma)\n      { elt = null; }\n    else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function(noIn) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$5.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$5.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$5.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$5.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$5.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types._const || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\n\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current () {\n  return this.at(this.pos)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead () {\n  return this.at(this.nextIndex(this.pos))\n};\n\nRegExpValidationState.prototype.advance = function advance () {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true\n  }\n  return false\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$8.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$8.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$8.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$8.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$8.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$8.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$8.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$8.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$8.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$8.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$8.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$8.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$8.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$8.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$8.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$8.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$8.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$8.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$8.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$8.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$8.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      state.switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$8.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$8.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$8.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\npp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue))\n    { state.raise(\"Invalid property name\"); }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$8.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$8.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$8.regexp_classRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$8.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$8.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$8.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$8.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$8.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$8.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$9 = Parser.prototype;\n\n// Move to the next token\n\npp$9.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$9[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$9.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$9.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$9.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$9.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$9.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$9.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$9.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$9.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$9.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$9.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$9.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$9.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$9.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$9.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$9.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$9.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$9.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$9.readInt = function(radix, len) {\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$9.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$9.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var str$1 = this.input.slice(start, this.pos);\n    var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val$1)\n  }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$9.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$9.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$9.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$9.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$9.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$9.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$9.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\nvar version = \"6.4.2\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./node_modules/tern/node_modules/acorn/dist/acorn.mjs?");

/***/ }),

/***/ "./src/cp.js":
/*!********************************!*\
  !*** ./src/cp.js + 60 modules ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ cp)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bbn/bbn/dist/index.js + 280 modules\nvar dist = __webpack_require__(\"./node_modules/@bbn/bbn/dist/index.js\");\n;// CONCATENATED MODULE: ./src/functions/addPrefix.js\n\n\n/**\n * Adds a prefix to the list of known prefixes for component names.\n * Each prefix can have an associated handler function and an array of mixins.\n *\n * Handles component prefixes within the framework. \n * It allows the registration of prefixes along with associated handlers and mixins. \n * The sorting by prefix length ensures that when resolving component names, \n * the most specific prefix is considered first, which is important for accurately \n * identifying components and applying the correct behavior and mixins.\n * \n * Considerations:\n * - Error Handling: Ensure robust error handling, especially if the prefix or handler does not meet the expected criteria.\n * - Performance: Consider the impact of repeatedly sorting the knownPrefixes array, especially if addPrefix is called frequently.\n * - Namespace Pollution: Be cautious of potential namespace pollution or conflicts, especially in a large application with many prefixes.\n * - Mixins Integration: If mixins are a core part of the framework, ensure their integration with prefixes is seamless and well-documented.\n * \n * @param {string} prefix - The prefix to be added.\n * @param {Function} [handler] - Optional handler function associated with the prefix.\n * @param {Array} [mixins] - Optional array of mixins to be used with the prefix.\n */\nfunction addPrefix(prefix, handler, mixins){\n// Ensure the prefix is a string.\n  dist.bbn.fn.checkType(prefix, String, dist.bbn._(\"Prefix must be a string\"));\n\n  // If a handler is provided, ensure it's a function.\n  if (handler) {\n    dist.bbn.fn.checkType(handler, Function, dist.bbn._(\"The addPrefix handler must be a function\"));\n  }\n\n  // Ensure the prefix ends with a hyphen for standardization.\n  if (!prefix.endsWith('-')) {\n    prefix += '-';\n  }\n\n  // Push the new prefix along with its handler and mixins into the known prefixes array.\n  dist.bbn.cp.knownPrefixes.push({\n    prefix,\n    handler,\n    mixins: mixins || []\n  });\n  \n  // Sort the known prefixes array by length in descending order.\n  // This ensures that the most specific (longest) prefix is matched first.\n  dist.bbn.cp.knownPrefixes.sort((a, b) => {\n    return b.prefix.length - a.prefix.length;\n  });\n}\n\n// EXTERNAL MODULE: ./src/functions/addUrlAsPrefix.js\nvar addUrlAsPrefix = __webpack_require__(\"./src/functions/addUrlAsPrefix.js\");\n;// CONCATENATED MODULE: ./src/functions/attributeChangedCallback.js\nfunction attributeChangedCallback(cp, name, oldValue, newValue) {\n  /*\n  if ((oldValue !== newValue) && cp.bbn) {\n    attributeChange(cp.bbn, name, oldValue, newValue);\n  }\n  */\n}\n\n;// CONCATENATED MODULE: ./src/functions/convertClasses.js\n/**\n * Converts a variety of class name formats into a single string of class names.\n * \n * It is designed to process and combine class names provided in various formats \n * (strings, objects, arrays) into a single string. \n * This utility is particularly useful in scenarios where class names are dynamically \n * determined and may come from different sources or formats. The function ensures \n * that the resulting string contains unique, non-empty class names suitable for \n * use in an HTML element's class attribute.\n * \n * Considerations:\n * - Performance: Ensure that the function performs efficiently, especially when handling large arrays or deeply nested structures.\n * - Error Messages: Provide clear error messages to help developers quickly understand and fix issues.\n * - Input Validation: Robust input validation is essential to handle edge cases and prevent potential errors.\n * - Recursion: The recursive handling of arrays is a powerful feature, but ensure that it's well-tested to handle complex cases without leading to performance issues.\n * \n * @param {...(string|Object|Array)} args - Class names in various formats (string, object, array).\n * @returns {string} A single string containing all class names.\n */\nfunction convertClasses(...args) {\n  let arr = [];\n\n  // Iterate over each argument provided to the function.\n  for (let i = 0; i < args.length; i++) {\n    let css = args[i];\n    if (!css) {\n      continue;\n    }\n\n    // Handle string format: split class names by space and add to array.\n    if (bbn.fn.isString(css)) {\n      arr.push(...css.split(' '));\n    }\n    // Handle object format: add keys as class names if their values are truthy.\n    else if (bbn.fn.isObject(css)) {\n      for (let n in css) {\n        if (css[n]) {\n          arr.push(n);\n        }\n      }\n    }\n    // Handle array format: recursively process each item in the array.\n    else if (bbn.fn.isArray(css)) {\n      bbn.fn.each(css, cs => arr.push(...convertClasses(cs).split(' ')));\n    }\n    // If the format is not recognized, log the value and throw an error.\n    else {\n      bbn.fn.log(css);\n      throw Error(bbn._(\"Can't understand classes\"));\n    }\n  }\n\n  // Remove duplicate and empty class names, then join them into a single string.\n  return bbn.fn.removeEmpty(bbn.fn.unique(arr)).join(' ');\n}\n\n;// CONCATENATED MODULE: ./src/functions/convertStyles.js\nconst treatStyleArguments = function (...args) {\n  const final = bbn.fn.createObject();\n  bbn.fn.each(args, arg => {\n    if (bbn.fn.isArray(arg)) {\n      bbn.fn.extend(final, treatStyleArguments(...arg));\n    }\n    else if (bbn.fn.isObject(arg) && bbn.fn.numProperties(arg)) {\n      bbn.fn.extend(final, arg);\n    }\n    else if (bbn.fn.isString(arg)) {\n      let arr = arg.split(';').map(a => a.trim().split(':').map(b => b.trim()));\n      let css = bbn.fn.createObject();\n      bbn.fn.each(arr, a => {\n        if (a[0] && (a[1] !== undefined) && (a[1] !== '')) {\n          css[bbn.fn.camelize(a[0])] = a[1];\n        }\n      });\n      bbn.fn.extend(final, css);\n    }\n  });\n\n  return final;\n};\n\n/**\n * Converts a variety of style formats into a single string for the 'style' attribute in HTML.\n * \n * Considerations:\n * - Robustness and Flexibility: The functions handle a variety of input formats, making them versatile for different use cases.\n * - Performance: Ensure efficient handling, especially when processing large or complex style objects.\n * - Error Handling: Clear error messages and thorough validation can help developers quickly identify and fix issues.\n * - Documentation: Detailed documentation explaining the expected input formats and examples will be beneficial for developers using these functions.\n * - Consistency in Naming Conventions: The use of camelization for CSS property names ensures consistency but might require clear documentation, as it deviates from the standard CSS property naming convention.\n * \n * @param {...(string|Object|Array)} args - Style properties in various formats.\n * @returns {string} A single string containing all style properties.\n */\nfunction convertStyles(...args) {\n  let st = '';\n  // Treat the given arguments to consolidate them into a single object of style properties.\n  const css = treatStyleArguments(...args);\n\n  // Check if the consolidated styles object is valid.\n  if (bbn.fn.isObject(css)) {\n    // Iterate over each style property in the object.\n    for (let n in css) {\n      let prop = bbn.fn.camelToCss(n);  // Convert camelCase names to kebab-case for CSS.\n      let value = css[n];\n\n      // Process and append each style property and its value to the resulting string.\n      if (![undefined, null, false, ''].includes(value)) {\n        // Add 'px' to numeric values for certain properties.\n        if (bbn.fn.isNumber(css[n]) && bbn.fn.isPropSize(prop)) {\n          value = css[n] + 'px';\n        }\n        // Convert non-string values to string.\n        else if (!bbn.fn.isString(value) && value.toString) {\n          value = value.toString();\n        }\n\n        // Append the property and its value to the style string.\n        st += ` ${prop}: ${value};`;\n      }\n    }\n  }\n  else if (css) {\n    // If the styles object is not valid, log the object for debugging and throw an error.\n    bbn.fn.log(\"convertStyles\", css);\n    throw Error(bbn._(\"Can't understand style\"));\n  }\n\n  // Return the consolidated style string.\n  return st;\n}\n\n// EXTERNAL MODULE: ./src/internals/stringToTemplate.js + 2 modules\nvar stringToTemplate = __webpack_require__(\"./src/internals/stringToTemplate.js\");\n// EXTERNAL MODULE: ./src/internals/retrieveSlots.js\nvar retrieveSlots = __webpack_require__(\"./src/internals/retrieveSlots.js\");\n;// CONCATENATED MODULE: ./src/functions/createApp.js\n\n\n\n\n/**\n* Initializes an anonymous component with given element and configuration object.\n * \n * Considerations:\n * - Asynchronous Nature: The function is asynchronous, allowing for dynamic imports and AJAX requests. Ensure that consumers of this function handle its asynchronous nature correctly.\n * - Error Handling: Robust error handling is important, especially in AJAX requests and dynamic imports.\n * - Performance: Consider the performance implications of dynamic imports and AJAX requests, especially if createApp is called frequently.\n * - Component Lifecycle Management: Ensure that the lifecycle of components (especially dynamic ones) is well-managed to avoid memory leaks or dangling references.\n * - Testing: Extensive testing, especially in different environments and with various component configurations, will be crucial for reliability.\n * \n * @param {HTMLElement|string} ele - The target element or its selector for the app creation.\n * @param {Object} obj - The configuration object for the app.\n * @returns {Object} The initialized component.\n*/\nasync function createApp(ele, obj) {\n  // Dynamically import CSS based on the theme.\n  if (!dist.bbn.isTesting) {\n    await __webpack_require__(\"./node_modules/@bbn/bbn-css/dist/css lazy recursive ^\\\\.\\\\/bbn\\\\-css\\\\-.*\\\\.css$\")(\"./bbn-css-\" + (dist.bbn.env.theme || 'default') + \".css\");\n  }\n  \n  // Add prefix handling for component names.\n  // Define how to handle 'bbn-' prefixed components.\n  dist.bbn.cp.addPrefix('bbn-', async components => {\n    const res = dist.bbn.fn.createObject({\n      components: []\n    });\n    //bbn.fn.log(\"COMPONENTS\", components);\n    for (let cp of components) {\n      if (cp === 'bbn-anon') {\n        continue;\n      }\n      // Request needs to be done as a string explicitly\n      // @see https://stackoverflow.com/questions/42908116/webpack-critical-dependency-the-request-of-a-dependency-is-an-expression\n      const definition = await __webpack_require__(\"./src/components lazy recursive ^\\\\.\\\\/.*\\\\/.*\\\\.js$\")(`./${cp.substr(4)}/${cp.substr(4)}.js`);\n      //bbn.fn.log([\"DEFINITION\", definition]);\n      for (let n in definition) {\n        if (n === 'default') {\n          res.components.push(definition.default);\n        }\n        else if (!window[n]) {\n          window[n] = definition[n];\n        }\n      }\n    }\n\n    return res;\n  });\n\n\n  /*\n  bbn.cp.addPrefix('appui-', async components => {\n    const urlPrefix = 'components/';\n    const url = urlPrefix + components.join('/') + '?v=3280&test=1&lang=fr';\n    // Request\n    const d = await bbn.fn.ajax(url, 'text');\n    let tmp;\n    try {\n      if (bbn.fn.isString(d.data)) {\n        tmp = (new Function('return ' + d.data + ';'))();\n      }\n    }\n    catch (e) {\n      throw Error(e);\n    }\n\n    const res = bbn.fn.createObject({\n      components: []\n    });\n\n    if (tmp.components) {\n      bbn.fn.each(tmp.components, obj => {\n        res.components.push(bbn.fn.createObject({\n          name: obj.name,\n          definition: eval(obj.script),\n          template: obj.content,\n          css: obj.css || null\n        }));\n      });\n    }\n\n    return res;\n  });\n  */\n\n  // If 'ele' is a string, find the corresponding HTML element.\n  if (dist.bbn.fn.isString(ele)) {\n    ele = document.body.querySelector(ele);\n  }\n\n  // Check if 'ele' is a valid HTMLElement.\n  dist.bbn.fn.checkType(ele, HTMLElement, \"The createApp function should be given a HTMLElement\");\n  // Its content is its template\n  let tmp = (0,stringToTemplate[\"default\"])(ele.outerHTML, true, 'bbn-anon');\n  const cpTpl = tmp.res;\n  const cpMap = tmp.map;\n  const schema = dist.bbn.fn.clone(cpTpl[0]);\n  delete schema.slots;\n  const placeholder = document.createComment(\"bbn-component placeholder\");\n  const parent = ele.parentNode;\n  let cls = ele.style.cssText;\n  if (cls) {\n    cls = cls.trim();\n  }\n\n  parent.replaceChild(placeholder, ele);\n  \n  // Ensure basicComponent mixin is included.\n  if (!obj.mixins) {\n    obj.mixins = [];\n  }\n  if (!obj.mixins.includes(dist.bbn.cp.mixins.basic)) {\n    obj.mixins.push(dist.bbn.cp.mixins.basic);\n  }\n\n  // Freeze the component configuration.\n  const cpCfg = Object.freeze(dist.bbn.cp.normalizeComponent(obj, 'bbnCpRoot'));\n\n  // Initialize subcomponents if defined.\n  if (cpCfg.components) {\n    for (let n in cpCfg.components) {\n      dist.bbn.cp.define(cpCfg.componentNames[n], cpCfg.components[n], cpCfg.components[n].template);\n    }\n  }\n\n  // Retrieve slots from the template.\n  const slots = (0,retrieveSlots[\"default\"])(cpTpl);\n  if (!slots.default) {\n    slots.default = [];\n  }\n\n  // Create the bbn-anon element and set up its properties.\n  const cp = Object.assign(\n    document.createElement(\"bbn-anon\"),\n    {\n      bbnId: '0',\n      bbnCfg: cpCfg,\n      bbnTpl: cpTpl,\n      bbnSlots: slots,\n      bbnMap: cpMap,\n      bbnSchema: schema,\n      bbnMapped: false\n    }\n  );\n  if (cls) {\n    cp.style.cssText = cls;\n  }\n\n// Replace the placeholder with the new component.\n  parent.replaceChild(cp, placeholder);\n  /*\n  bbn.fn.each(ele.childNodes, node => {\n    cp.appendChild(node);\n  });*/\n\n  // Start the tick process for component updates.\n  dist.bbn.cp.startTick();\n\n  // Return the bbn property of the component.\n  cp.bbn.$connected();\n  return cp.bbn;\n  \n}\n\n// EXTERNAL MODULE: ./src/lib/Cp/private/setUpProp.js\nvar setUpProp = __webpack_require__(\"./src/lib/Cp/private/setUpProp.js\");\n;// CONCATENATED MODULE: ./src/internals/generateCpClass.js\n\n\n/**\n* Create the bbn component class based on the config object.\n * @param {String} publicClass - The name of the class.\n * @param {Object} obj - The component's configuration.\n*/\nfunction generateCpClass(publicClass, obj) {\n  // Convert the class name from camel case to CSS-style (kebab-case).\n  const tag = bbn.fn.camelToCss(publicClass);\n  // Define the prototype name based on the public class.\n  const proto = publicClass + 'Cp';\n  // Default prototype is 'bbnCp'.\n  let originalProto = 'bbnCp';\n\n  // If a tag extension exists, use its prototype.\n  if (obj.tag && bbn.cp.tagExtensions[obj.tag]) {\n    originalProto = bbn.cp.tagExtensions[obj.tag] + 'Cp';\n  }\n\n  // Define accepted attributes for the component.\n  const acceptedAttr = bbn.cp.possibleAttributes\n    .concat(bbn.cp.possibleAttributes.map(a => ':' + a))\n    .concat(Object.keys(obj.props))\n    .concat(Object.keys(obj.props).map(a => ':' + a));\n\n  // Define the component class.\n  window[`${proto}`] = class extends bbnCp {\n    constructor(ele) {\n      super(ele);\n      // Set up component options.\n      const options = bbn.fn.createObject({\n        name: tag,\n        _componentTag: tag,\n        components: bbn.fn.createObject(),\n        // Define a getter for propsData.\n        get propsData() {\n          if (this.$el) {\n            return this.$el.bbnSchema?.props || {};\n          }\n          return {};\n        }\n      });\n\n      // Set the tag if specified in the object.\n      if (obj.tag) {\n        options.tag = obj.tag;\n      }\n\n      // Define $options property.\n      Object.defineProperty(this, '$options', {\n        value: options,\n        writable: false,\n        configurable: false\n      });\n\n      /**\n       * Object of all elements with bbn-model prop.\n       * Indexed by element's id with bbn-model's value as value\n       */\n      Object.defineProperty(this, '$computed', {\n        value: bbn.fn.createObject()\n      });\n\n      // Set up computed properties.\n      if (obj.computed) {\n        for (let n in obj.computed) {\n          bbn.cp.setComputed(this, n, obj.computed[n].get, obj.computed[n].set);\n        }\n      }\n\n    }\n\n    // Set up component properties.\n    $setUpProps() {\n      for (let n in obj.props) {\n        const cfg = obj.props[n];\n        (0,setUpProp[\"default\"])(this, n, cfg);\n      }\n    }\n\n    // Define accepted attributes for the component.\n    static acceptedAttributes = acceptedAttr;\n\n    // Define static methods and properties.\n    static {\n      let res;\n      const iface = bbn.fn.isFunction(obj.iface) ? obj.iface() : obj.iface || {};\n      bbn.fn.each(obj.statics, f => {\n        res = f(iface);\n        if (res) {\n          if (!bbn.fn.isObject(res)) {\n            throw Error(bbn._(\"If the static method returns it must be an object\"));\n          }\n          bbn.fn.iterate(res, (v, n) => {\n            if (this[n] === undefined) {\n              this[n] = bbnData.immunizeValue(v);\n            }\n            else {\n              throw Error(bbn._(\"The static method cannot override an existing property\"));\n            }\n          });\n        }\n      });\n    }\n  };\n\n  // Define $methods property on the prototype.\n  Object.defineProperty(window[proto].prototype, '$methods', {\n    value: obj.methods,\n    writable: false,\n    configurable: false\n  });\n\n  // Define getters for each prop on the prototype.\n  if (obj.props) {\n    for (let n in obj.props) {\n      Object.defineProperty(window[proto].prototype, n, {\n        get() {\n          bbnData.addSequence(this, n, this.$props[n]);\n          return this.$props[n];\n        }\n      });\n    }\n  }\n\n  // Bind methods to the prototype.\n  if (obj.methods) {\n    for (let n in obj.methods) {\n      Object.defineProperty(window[proto].prototype, n, {\n        get() {\n          return this.$methods[n].bind(this);\n        }\n      });\n    }\n  }\n\n  // Return the newly created class.\n  return window[proto];\n}\n\n;// CONCATENATED MODULE: ./src/internals/generateHTMLClass.js\n/**\n * Generates the code for creating the public class.\n * Assumes that tpl, cfg, and others are defined in bbn.cp.statics.\n *\n * @param {String} name - The name of the class to generate.\n * @param {Function} clsExtends - The class to extend, defaults to bbnHTML.\n * @returns {Class} - The dynamically created class.\n */\nfunction generateHTMLClass(name, clsExtends = bbnHTML) {\n  // Convert the class name from camel case to CSS-style (kebab-case).\n  const eleName = bbn.fn.camelToCss(name);\n\n  // Define the new component class, extending from clsExtends.\n  const newCpClass = class extends clsExtends {\n    // Static getter for the bbnTag property.\n    static get bbnTag() {\n      return eleName;\n    }\n\n    // Static getter for the bbnSlots property.\n    static get bbnSlots() {\n      return bbn.cp.statics[eleName].slots;\n    }\n\n    // Static getter for the bbnTpl (template) property.\n    static get bbnTpl() {\n      return bbn.cp.statics[eleName].tpl;\n    }\n\n    // Static getter for the bbnCfg (configuration) property.\n    static get bbnCfg() {\n      return bbn.cp.statics[eleName].cfg;\n    }\n\n    // Static getter for the bbnCls (class) property.\n    static get bbnCls() {\n      return bbn.cp.statics[eleName].cls;\n    }\n\n    // Static getter for the bbnMap property.\n    static get bbnMap() {\n      return bbn.cp.statics[eleName].map;\n    }\n\n    // Static getter for the bbnFn (function) property.\n    static get bbnFn() {\n      return window[name + 'Cp'];\n    }\n\n    // Static property to track if the component is mapped.\n    static bbnMapped = false;\n  }\n\n  // Return the newly created class.\n  return newCpClass;\n}\n\n;// CONCATENATED MODULE: ./src/internals/retrieveModels.js\n/**\n * Recursively retrieves model data from the template structure.\n * \n * @param {Array} tpl - An array of template nodes to analyze.\n * @param {Object} [res] - The result object to accumulate model data.\n * @returns {Object} The updated result object containing model data.\n */\nfunction retrieveModels(tpl, res = bbn.fn.createObject()) {\n  // Iterate over each node in the template.\n  bbn.fn.each(tpl, node => {\n    // Process nodes that have a 'model' property.\n    if (node.model) {\n      // Iterate over each model in the node.\n      bbn.fn.iterate(node.model, (a, name) => {\n        // Check if the model hash is already in the result object.\n        if (!res[a.hash]) {\n          // If not, initialize an object for this model hash.\n          res[a.hash] = bbn.fn.createObject();\n        }\n\n        // Create a structure for this model in the result object.\n        res[a.hash][node.id] = bbn.fn.createObject({\n          [name]: bbn.fn.createObject({\n            _root: bbn.fn.createObject()\n          })\n        });\n      });\n    }\n\n    // Recursively process child nodes and slots, if they exist.\n    if (node.items) {\n      retrieveModels(node.items, res);\n    }\n    if (node.slots) {\n      retrieveModels(node.slots, res);\n    }\n  });\n\n  // Return the accumulated result object.\n  return res;\n}\n\n;// CONCATENATED MODULE: ./src/functions/define.js\n\n\n\n\n\n\n/**\n* Defines a component with the Object config and the HTML template.\n* @param {string} name - The tag name of the component.\n* @param {Object} obj - The Vue-like configuration object for the component.\n* @param {string|array} tplSt - The template as a string or an array from stringToTemplate.\n * @param {string} [css] - Optional CSS string for the component.\n*/\nfunction define_define(name, obj, tplSt, css) {\n  // Prevent redefinition if the component is already known.\n  if (bbn.cp.known.includes(name)) {\n    return;\n  }\n\n  // Mandatory check for the component name.\n  if (!name) {\n    bbn.fn.warning(\"BOO\");\n    bbn.fn.log(obj);\n    throw Error(\"The name of the component is mandatory\");\n  }\n\n  // Convert the template string to a DOM array.\n  let tmp = (0,stringToTemplate[\"default\"])(tplSt, true, obj.tag || name);\n  // Generate a public class name based on the component tag.\n  const publicName = bbn.fn.camelize(name);\n  // The component config (= Vue-like object) that we freeze\n  bbn.fn.iterate(tmp.inlineTemplates, (tpl, tag) => {\n    if (!obj.components[tag]) {\n      bbn.fn.log(Object.keys(cpCfg.components).join(\", \"));\n      throw Error(\"Impossible to find the sub component %s\", tag);\n    }\n    obj.components[tag].template = tpl;\n  });\n  const cpCfg = bbn.cp.normalizeComponent(obj, publicName);\n  Object.freeze(cpCfg);\n\n  // Determine the class to use based on the tag name.\n  const cls = cpCfg.tag && bbn.cp.tagExtensions[cpCfg.tag] ? bbn.cp.tagExtensions[cpCfg.tag] : 'bbnHTML';\n\n  // Store component configuration in bbn.cp.statics.\n  bbn.cp.statics[name] = bbnData.immunizeValue(bbn.fn.createObject({\n    tpl: tmp.res,\n    map: tmp.map,\n    cls: publicName + 'HTML',\n    fn: publicName + 'Cp',\n    cfg: cpCfg,\n    models: retrieveModels(tmp.res),\n    slots: (0,retrieveSlots[\"default\"])(tmp.res),\n    tag: cpCfg.tag,\n  }));\n\n  // Handle default slot initialization.\n  if (!bbn.cp.statics[name].slots.default) {\n    bbn.cp.statics[name].slots.default = [];\n  }\n\n// Inject component-specific CSS if provided.\n  if (css) {\n    const styleSheet = document.createElement('style');\n    const old = document.getElementById(name + \"-bbn-css\");\n    if (old) {\n      document.head.removeChild(old);\n    }\n\n    styleSheet.setAttribute(\"id\", name + \"-bbn-css\");\n    styleSheet.textContent = css;\n    document.head.append(styleSheet);\n  }\n\n  // Initialize subcomponents if defined.\n  if (cpCfg.components) {\n    for (let n in cpCfg.components) {\n      bbn.cp.define(cpCfg.componentNames[n], cpCfg.components[n], cpCfg.components[n].template || '');\n      //cpProto.$options.components[n] = cpCfg.components[n];\n    }\n  }\n  \n  // Generate and globally expose HTML and Cp classes.\n  window[publicName] = generateHTMLClass(publicName, (new Function(`return ${cls};`))());\n  // Generating the code for the private class based on the component config\n  //const privateClassCode = makePrivateClass(privateName, cpCfg);\n  //bbn.fn.log('generateCpClass', publicName);\n  window[publicName + 'Cp'] = generateCpClass(publicName, cpCfg);\n  //bbn.fn.log(\"fnCode\", fnCode);\n  //bbn.fn.log(makePrivateFunction(privateName, cpCfg));\n  // Evaluating that code: defining the private class\n  // Retrieving the class object\n\n  // Define arguments for custom element registration.\n  const args = [name, window[publicName]];\n  if (cpCfg.tag) {\n    args.push({extends: cpCfg.tag});\n  }\n\n  // Register the component and add it to the known components list.\n  bbn.cp.known.push(name);\n  // Assigning the public class to the component's tag\n  customElements.define(...args);\n}\n\n;// CONCATENATED MODULE: ./src/functions/executeQueueItem.js\n/**\n * @method executeQueueItem\n * @memberof bbn.cp\n * @param {Object} item\n */\nfunction executeQueueItem(item){\n  if (item.url) {\n    return axios.get(item.url, {responseType:'json'}).then(r => {\n      if (r.data) {\n        r = r.data;\n        const fnName = bbn.fn.camelize(item.name) + 'Cp';\n        if (this.realDefineComponent(item.name, r, item.mixins) && window[fnName]) {\n          item.resolve(true);\n          return;\n        }\n      }\n\n      item.reject();\n    })\n  }\n  return false;\n}\n;// CONCATENATED MODULE: ./src/functions/executeQueueItems.js\n/**\n * @method executeQueueItems\n * @memberof bbn.cp\n * @param {Array} items\n */\nfunction executeQueueItems(items){\n  if ( items.length ){\n    let url = 'components/';\n    let i = 0;\n    while (items[i] && (url.length < maxUrlLength)) {\n      if (i) {\n        url += '/';\n      }\n\n      url += items[i].name;\n      i++;\n    }\n    url += '?v=' + bbn.version;\n    let prom = axios.get(url, {responseType:'json'}).then(d => {\n      d = d.data;\n      if ( d && d.success && d.components ){\n        bbn.fn.iterate(items, a => {\n          let cp = bbn.fn.getRow(d.components, {name: a.name});\n          const fnName = bbn.fn.camelize(a.name) + 'Cp';\n          if ( cp && this.realDefineComponent(a.name, cp, a.mixins) && window[fnName]) {\n            a.resolve(true);\n          }\n          else{\n            bbn.fn.log(\"PROMISE REJECT OF\" + a.name, a);\n            a.reject();\n            throw Error(bbn._(\"Impossible to load the component\") + ' ' + a.name);\n          }\n        })\n      }\n    });\n\n    if (i < (items.length -1)) {\n      items.splice(0, i);\n      this.executeQueueItems(items);\n    }\n\n    return prom;\n  }\n\n  return false;\n}\n\n// EXTERNAL MODULE: ./src/lib/Cp/private/setExpResult.js\nvar setExpResult = __webpack_require__(\"./src/lib/Cp/private/setExpResult.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/getExpState.js\nvar getExpState = __webpack_require__(\"./src/lib/Cp/private/getExpState.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/getExpValue.js\nvar getExpValue = __webpack_require__(\"./src/lib/Cp/private/getExpValue.js\");\n;// CONCATENATED MODULE: ./src/lib/Builder/Builder.js\n\n\n\n\n\n\n/**\n * Takes care of the data reactivity for non primitive values.\n */\nclass bbnBuilder/* extends EventTarget*/ {\n  constructor(cp, tpl) {\n    if (dist.bbn.fn.numProperties(cp.$fns)) {\n      throw Error(\"The component's functions have already been generated\");\n    }\n\n    this.cp = cp;\n    Object.defineProperty(this, 'tpl', {\n      value: tpl,\n      writable: false,\n      configurable: false\n    });\n    Object.defineProperty(this, 'argNames', {\n      value: [],\n      writable: false,\n      configurable: false\n    });\n    Object.defineProperty(this, 'argValues', {\n      value: [],\n      writable: false,\n      configurable: false\n    });\n    this.environment();\n    dist.bbn.fn.log(this.argNames);\n    let current;\n    const loopVars = {};\n    const expToFn = (a, node) => {\n      if (a.exp) {\n        const deps = [];\n        dist.bbn.fn.each(this.argNames, arg => {\n          if (a.exp.match(new RegExp('\\\\b' + dist.bbn.fn.escapeRegExp(arg) + '\\\\b'))) {\n            deps.push(arg);\n          }\n        });\n        const args = deps.slice();\n        dist.bbn.fn.iterate(loopVars, (v, k) => {\n          if (node.id.indexOf(k) === 0) {\n            args.push(...v);\n          }\n        });\n        a.fn = new Function(...args, 'return ' + a.exp);\n        a.args = args;\n        return args;\n      }\n    };\n\n    dist.bbn.fn.iterate(cp.$currentMap, node => {\n      if (node.loop) {\n        loopVars[node.id] = [\n          ...node.loop.item ? [node.loop.item] : [],\n          ...node.loop.index ? [node.loop.index] : []\n        ];\n      }\n\n      node.dependencies = [];\n      if (node.loop) {\n        const args = expToFn(node.loop, node);\n        node.dependencies.push(...args);\n      }\n\n      if (node.condition) {\n        const args = expToFn(node.condition, node);\n        node.dependencies.push(...args);\n      }\n\n      if (node.attr) {\n        dist.bbn.fn.iterate(node.attr, a => {\n          if (a.exp) {\n            const args = expToFn(a, node);\n            node.dependencies.push(...args);\n          }\n        });\n      }\n      else if (node.exp) {\n        const args = expToFn(node, node);\n        node.dependencies.push(...args);\n      }\n    });\n\n    return;\n\n\n    // If the element merges with its root, it happens here and the template will change\n    const template = this.root(tpl);\n  \n    // Taking care of the whole template\n    this.build(template);\n\n\n  \n    // Inserting root elements last\n    dist.bbn.fn.each($_final, a => {\n      $_this.$insertElement(a.ele, $_this.$el, a.position);\n    })\n    return $_res;\n      \n    const AsyncFunction = async function () {}.constructor;\n    return new AsyncFunction('$_this', x.get(true));\n  \n  }\n\n\n  treat (nodes) {\n    dist.bbn.fn.each(nodes, (a, i) => {\n      a.names = [];\n      if (a.attr) {\n\n      }\n      \n      if (a.items) {\n        this.treat(a.items);\n      }\n    });\n  }\n  \n  sr(_name, _exp, _hash) {\n    return (0,setExpResult[\"default\"])($_this, _name, _exp, _hash);\n  }\n\n  gs(_name, _hash) {\n    return (0,getExpState[\"default\"])($_this, _name, _hash);\n  }\n\n  gv(_name, _hash) {\n    let val = undefined;\n    try {\n      val = (0,getExpValue[\"default\"])($_this, _name, _hash);\n    } catch (e) {\n      dist.bbn.fn.log([\"THERE SHOULD BE AN ERROR\", _name, _t]);\n    }\n    return val;\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/functions/executeTemplate.js\n\n\n/**\n * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not\n * - Updates the component element based on its own schema ($el.bbnSchema)\n * - Updates the schema\n * - Generates/update the DOM when needed\n * \n * @param {Boolean} shadow The content will go to the shadow DOM if true\n * @returns {Promise}\n */\nfunction executeTemplate(cp, tpl) {\n  const builder = new bbnBuilder(cp, tpl);\n}\n\n;// CONCATENATED MODULE: ./src/functions/fetchComponents.js\n\n\n/**\n * Fetches and defines components based on provided names and prefixes.\n * @param {Array<string>} toDefine - Array of component names to fetch and define.\n */\nasync function fetchComponents(toDefine) {\n  dist.bbn.fn.checkType(toDefine, Array, dist.bbn._(\"fetchComponents must be called with an array of component names to fetch\"));\n  // Returning a promise allows the loading for new components definition\n  // No component definitions needed no wait\n  if (!toDefine.length) {\n    return;\n  }\n\n// Grouping components by their prefixes.\n  const groups = dist.bbn.fn.createObject();\n  dist.bbn.fn.each(toDefine, tag => {\n    dist.bbn.fn.checkType(tag, String); // Ensure each tag is a string.\n    let idx = -1;\n    let handlerIdx = -1;\n    let mixins = [];\n\n    // Determine the appropriate handler based on known prefixes.\n    dist.bbn.fn.each(dist.bbn.cp.knownPrefixes, (a, i) => {\n      if (a.prefix && (tag.indexOf(a.prefix) === 0)) {\n        // Adding mixins from the prefix rule.\n        if (a.mixins) {\n          dist.bbn.fn.each(a.mixins, m => {\n            if (!mixins.includes(m)) {\n              mixins.push(m);\n            }\n          });\n        }\n\n        // Selecting the longest matching prefix.\n        if (idx > -1) {\n          if (a.prefix.length > dist.bbn.cp.knownPrefixes[idx].prefix.length) {\n            if (dist.bbn.fn.isFunction(a.handler)) {\n              handlerIdx = i;\n            }\n\n            idx = i;\n          }\n          else if ((handlerIdx === -1) && dist.bbn.fn.isFunction(a.handler)) {\n            handlerIdx = i;\n          }\n        }\n        else {\n          handlerIdx = dist.bbn.fn.isFunction(a.handler) ? i : handlerIdx;\n          idx = i;\n        }\n      }\n    });\n\n    if (handlerIdx === -1) {\n      throw Error(\"Impossible to find a handler for \" + tag);\n    }\n\n    // Group components under the same prefix.\n    if (!groups[dist.bbn.cp.knownPrefixes[idx].prefix]) {\n      groups[dist.bbn.cp.knownPrefixes[idx].prefix] = dist.bbn.fn.createObject({\n        components: [],\n        prefix: dist.bbn.cp.knownPrefixes[idx].prefix\n      });\n      groups[dist.bbn.cp.knownPrefixes[idx].prefix].handler = dist.bbn.cp.knownPrefixes[handlerIdx].handler;\n      groups[dist.bbn.cp.knownPrefixes[idx].prefix].mixins = mixins;\n    }\n\n    // Add mixins to the group.\n    if (mixins) {\n      dist.bbn.fn.each(mixins, m => {\n        if (!groups[dist.bbn.cp.knownPrefixes[idx].prefix].mixins.includes(m)) {\n          groups[dist.bbn.cp.knownPrefixes[idx].prefix].mixins.push(m);\n        }\n      });\n    }\n\n    // Add the component to its group.\n    groups[dist.bbn.cp.knownPrefixes[idx].prefix].components.push(tag);\n  });\n\n  // Process each group of components.\n  for (let prefix in groups) {\n    const rule = groups[prefix];\n    let res = await rule.handler(rule.components);\n    \n    if (dist.bbn.fn.isArray(res.components)) {\n      // Define each component in the group.\n      dist.bbn.fn.each(res.components, obj => {\n        if (!obj.definition || !obj.name) {\n          throw Error(dist.bbn._(\"Impossible to find a definition or a name in %s\", rule.prefix));\n        }\n\n        // Add mixins to the component definition.\n        if (rule.mixins) {\n          obj.definition.mixins = obj.definition.mixins || [];\n          dist.bbn.fn.each(rule.mixins, m => {\n            if (!obj.definition.mixins.includes(m)) {\n              obj.definition.mixins.push(m);\n            }\n          });\n        }\n\n        // Define the component using bbn.cp.define.\n        dist.bbn.cp.define(obj.name, obj.definition, obj.template, obj.css);\n      });\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/functions/getComponent.js\n/**\n * Retrieves a component in the document based on its id.\n * Every instance of bbnComponentObject is registered through its\n * unique ID in the static #components property\n * @param {Symbol} id \n * @returns {bbnCp|null} \n */\nfunction getComponent(id) {\n  return this.componentsIndex.get(id) || null;\n}\n\n;// CONCATENATED MODULE: ./src/functions/initDefaults.js\n/**\n * Sets default object for a component, accessible through bbn.vue.defaults[__COMPONENT_NAME__].\n * \n * @method initDefaults\n * @memberof bbn.cp\n * @param Object defaults \n */\nfunction initDefaults(defaults){\n  if ( typeof defaults !== 'object' ){\n    throw Error(\"The default object sent for defaults is not an object\");\n  }\n\n  bbn.fn.extend(true, bbn.cp.defaults, defaults);\n}\n\n;// CONCATENATED MODULE: ./src/functions/insertDirectives.js\n/**\n * Inserts the given directives to the target element\n * @param {Object} directives\n * @param {HTMLElement} target\n */\nfunction insertDirectives(directives, target) {\n  if (bbn.fn.isObject(directives)\n    && Object.keys(directives).length\n  ) {\n    bbn.fn.iterate(directives, (dir, name) => {\n      // Check if the directive has not already been initialized on target element\n      if (!dir.inserted) {\n        // Check if the \"inserted\" function exists on this directive\n        if (bbn.fn.isFunction(bbn.cp.directives[name].inserted)) {\n          // Set the directive as initialized\n          dir.inserted = true;\n          // Initialize the directive\n          bbn.cp.directives[name].inserted(target, dir);\n        }\n      }\n    });\n  }\n}\n\n// EXTERNAL MODULE: ./src/lib/Cp/Cp.js + 1 modules\nvar Cp = __webpack_require__(\"./src/lib/Cp/Cp.js\");\n;// CONCATENATED MODULE: ./src/functions/isComponent.js\n\n/**\n * Returns true if the given argument is component, under the form of a bbnSchema object, an HTML element or directly a component\n * @param {Object} node \n * @returns \n */\nfunction isComponent(node) {\n  if (!node) {\n    return false;\n  }\n\n  if (node instanceof Cp[\"default\"]) {\n    return true;\n  }\n\n  // HTMLElement\n  if (node.bbnCid) {\n    return true;\n  }\n\n  if (bbn.fn.isObject(node) && node.__bbnComponent) {\n    return true;\n  }\n\n  // Node object\n  if (node.props?.is) {\n    if (bbn.fn.isObject(node.props.is)) {\n      return true;\n    }\n\n    return node.props.is.indexOf('-') > -1;\n  }\n\n  if (node.attr?.is?.value) {\n    return node.attr.is.value.indexOf('-') > -1;\n  }\n\n  if (node.tag) {\n    if (node.tag.indexOf('bbns-') === 0) {\n      return false;\n    }\n\n    return node.tag.indexOf('-') > -1;\n  }\n\n  return false;\n}\n\n;// CONCATENATED MODULE: ./src/functions/isTag.js\n/**\n * Checks if the given element matches a specific tag.\n * @param {string} tag - The tag to check against.\n * @param {HTMLElement|SVGElement} ele - The element to check.\n * @returns {boolean} True if the element matches the tag or 'is' attribute, false otherwise.\n */\nfunction isTag(tag, ele) {\n// Validate that the tag is a string.\n  bbn.fn.checkType(tag, 'string', bbn._(\"Tags must be strings\"));\n\n  // Return false if the element doesn't have a tagName property.\n  if (!ele.tagName) {\n    return false;\n  }\n\n  // Ensure the element is either an HTML or SVG element.\n  bbn.fn.checkType(ele, [HTMLElement, SVGElement], bbn._(\"Elements must be HTML or SVG elements\"));\n\n  // Check if the element's tagName matches the provided tag (case-insensitive).\n  if (ele.tagName.toLowerCase() === tag) {\n    return true;\n  }\n\n// Alternatively, check if the element's 'is' attribute matches the provided tag.\n  if (ele.getAttribute(\"is\") === tag) {\n    return true;\n  }\n\n// Return false if none of the conditions are met.\n  return false;\n}\n\n;// CONCATENATED MODULE: ./src/functions/mapTemplate.js\nfunction mapTemplate(tpl, map) {\n  bbn.fn.checkType(tpl, 'array', bbn._(\"Template must be an array\"));\n  if (!map) {\n    map = [];\n  }\n\n  bbn.fn.each(tpl, el => {\n    el.index = map.length;\n    map.push(el);\n    if (el.items) {\n      bbn.cp.mapTemplate(el.items, map);\n    }\n    if (el.slots) {\n      bbn.cp.mapTemplate(el.slots, map);\n    }\n  });\n\n  return map;\n\n}\n// EXTERNAL MODULE: ./src/lib/Data/Data.js\nvar Data = __webpack_require__(\"./src/lib/Data/Data.js\");\n;// CONCATENATED MODULE: ./src/functions/normalizeComponent.js\n\n\n\n\n/**\n * Normalizes the configuration of a component, ensuring it adheres to the expected structure and types.\n * This function also merges configuration from mixins and adds additional properties necessary for the component's lifecycle.\n * @param {Object} cfg - The Vue-like configuration object for the component.\n * @param {string} clsName - The class name of the component (for logging and error messages).\n * @returns {Object} The normalized configuration object for the component.\n */\nfunction normalizeComponent(cfg, clsName) {\n  // Check if the configuration object is valid.\n  if (!dist[\"default\"].fn.isObject(cfg)) {\n    dist[\"default\"].fn.log(cfg, clsName);\n    throw Error(\"Components definition must be objects\");\n  }\n\n  // Initialize the result object with standard component properties.\n  const res = Data[\"default\"].immunizeValue(dist[\"default\"].fn.createObject({\n    props: dist[\"default\"].fn.createObject(),\n    data: [],\n    computed: Data[\"default\"].immunizeValue(dist[\"default\"].fn.createObject()),\n    methods: dist[\"default\"].fn.createObject(),\n    watch: dist[\"default\"].fn.createObject(),\n    components: dist[\"default\"].fn.createObject(),\n    componentNames: dist[\"default\"].fn.createObject(),\n    model: dist[\"default\"].fn.createObject({\n      prop: \"value\",\n      event: \"input\"\n    }),\n    extension: null,\n    statics: [],\n    __bbnComponent: true // Internal flag to mark as a bbn component.\n  }));\n\n  const cn = clsName || cfg.tag || 'unknown';\n\n  // Process mixins to merge their configurations into the component.\n  if (cfg.mixins) {\n    dist[\"default\"].fn.checkType(cfg.mixins, 'array', dist[\"default\"]._(\"The mixins property must be an array in %s\", cn));\n    cfg.mixins.forEach(mixin => {\n      dist[\"default\"].fn.checkType(mixin, 'object', dist[\"default\"]._(\"A mixin should be an object in %s\", cn));\n      let cp = dist[\"default\"].cp.normalizeComponent(mixin);\n      // Merge each property of the mixin into the component config.\n      dist[\"default\"].fn.each(Object.keys(cp).sort(), name => {\n        // Handle array properties like data and statics.\n        if (dist[\"default\"].fn.isArray(cp[name]) && ['data', 'statics', ...dist[\"default\"].cp.hooks].includes(name)) {\n          res[name] = res[name] || [];\n          res[name].push(...cp[name]);\n        }\n        // Merge object properties.\n        else if ((dist[\"default\"].fn.isObject(cp[name]) && dist[\"default\"].fn.numProperties(cp[name])) || (dist[\"default\"].fn.isArray(cp[name]) && cp[name].length)) {\n          res[name] = res[name] || dist[\"default\"].fn.createObject();\n          Object.assign(res[name], cp[name]);\n        }\n      });\n    });\n  }\n\n  // Process and validate each property of the component configuration.\n  dist[\"default\"].fn.each(Object.keys(cfg).sort(), name => {\n    switch (name) {\n      case 'props':\n        // Normalize and validate props.\n        let props = dist[\"default\"].fn.clone(cfg.props);\n        // Convert array of prop names to object format.\n        if (dist[\"default\"].fn.isArray(props)) {\n          let tmp = props;\n          props = dist[\"default\"].fn.createObject();\n          tmp.forEach(a => {\n            props[a] = dist[\"default\"].fn.createObject();\n          });\n        }\n\n        dist[\"default\"].fn.checkType(props, 'object', dist[\"default\"]._(\"The props property must be an object in %s\", cn));\n        // Process each prop.\n        for (let propName in props) {\n          // Normalize shorthand prop types to object format.\n          if (dist[\"default\"].fn.isArray(props[propName]) || dist[\"default\"].fn.isFunction(props[propName])) {\n            // We transform it into an object\n            props[propName] = dist[\"default\"].fn.createObject({\n              type: props[propName]\n            });\n          }\n          // Now the prop should be an object\n          dist[\"default\"].fn.checkType(props[propName], 'object', `The prop ${propName} for ${clsName} is a ${typeof props[propName]}`);\n          // Ensure type is an array.\n          if (props[propName].type && !dist[\"default\"].fn.isArray(props[propName].type)) {\n            props[propName].type = [props[propName].type];\n          }\n\n          res.props[propName] = props[propName];\n        }\n\n        break;\n\n      case 'data':\n        // Normalize and validate data.\n        if (!dist[\"default\"].fn.isArray(cfg[name])) {\n          cfg[name] = [cfg[name]];\n        }\n        dist[\"default\"].fn.each(cfg[name], (cf) => {\n          // Convert object format to function format.\n          if (!dist[\"default\"].fn.isFunction(cf)) {\n            dist[\"default\"].fn.checkType(cf, 'object', dist[\"default\"]._(\"The data must be an object or a function in %s\", cn));\n            let tmp = cf;\n            cf = function () {\n              return tmp;\n            };\n          }\n          dist[\"default\"].fn.checkType(cf, 'function', dist[\"default\"]._(\"The data must be an object or a function in %s\", cn));\n          res[name].push(cf);\n        });\n        break;\n\n      case 'computed':\n        // Validate computed properties.\n        dist[\"default\"].fn.checkType(cfg.computed, 'object', dist[\"default\"]._(\"The computed must be an object in %s\", cn));\n        for (let computedName in cfg.computed) {\n          if ((typeof (cfg.computed[computedName]) !== 'function') && !cfg.computed[computedName]?.get) {\n            throw Error(dist[\"default\"]._(\"The computed must be a single function or an object with at least a get function (check %s in %s)\", computedName, cn));\n          }\n\n          res.computed[computedName] = dist[\"default\"].fn.createObject({\n            get: cfg.computed[computedName].get || cfg.computed[computedName],\n            set: cfg.computed[computedName].set || null\n          });\n        }\n\n        break;\n\n      case 'methods':\n        // Validate methods.\n        dist[\"default\"].fn.checkType(cfg[name], 'object', dist[\"default\"]._(\"The methods must be an object in %s\", cn));\n        for (let methName in cfg[name]) {\n          dist[\"default\"].fn.checkType(cfg[name][methName], 'function', dist[\"default\"]._(\"Methods must be functions, check %s in %s\", methName, cn));\n          res[name][methName] = cfg[name][methName];\n        }\n        break;\n\n      case 'watch':\n        // Validate watchers.\n        dist[\"default\"].fn.checkType(cfg.watch, 'object', dist[\"default\"]._(\"The watch must be an object in %s\", cn));\n        for (let watchName in cfg.watch) {\n          const tmp = cfg.watch[watchName];\n          dist[\"default\"].fn.checkType(tmp?.handler || tmp, 'function', dist[\"default\"]._(\"Watchers must be functions, see %s in %s\", watchName, cn));\n          res.watch[watchName] = tmp;\n        }\n        break;\n\n      case 'components':\n        // Check if 'components' in the config is an object.\n        dist[\"default\"].fn.checkType(cfg.components, 'object', dist[\"default\"]._(\"The components must be an object in %s\", cn));\n\n        // Iterate over each component defined in the 'components' section.\n        for (let originalName in cfg.components) {\n          // Generate a camelCase version of the component name for internal use.\n          let componentName = dist[\"default\"].fn.camelize(originalName);\n          // Convert the camelCase name to kebab-case for use in templates and registration.\n          let indexName = dist[\"default\"].fn.camelToCss(componentName);\n\n          // Validate that each component's definition is an object.\n          dist[\"default\"].fn.checkType(cfg.components[originalName], 'object', dist[\"default\"]._(\"Components definitions must be objects (check %s in %s)\", componentName, cn));\n\n          // Normalize the component configuration recursively.\n          res.components[componentName] = dist[\"default\"].cp.normalizeComponent(cfg.components[originalName], clsName);\n\n          // Generate a unique tag name for the sub-component.\n          let subName = (clsName || 'bbnsub-' + dist[\"default\"].fn.randomString(10, 20, 'nl')) + dist[\"default\"].fn.substr(componentName, 0, 1).toUpperCase() + dist[\"default\"].fn.camelize(dist[\"default\"].fn.substr(componentName, 1));\n          let subTag = dist[\"default\"].fn.camelToCss(subName);\n\n          // Store the generated tag name in componentNames for reference.\n          res.componentNames[indexName] = subTag;\n          if (indexName !== componentName) {\n            res.componentNames[componentName] = subTag;\n          }\n\n          // Ensure all variations of the component name point to the same tag.\n          if (![indexName, componentName].includes(originalName)) {\n            res.componentNames[originalName] = subTag;\n          }\n        }\n\n        break;\n\n      case 'model':\n        // Validate model configuration.\n        if (cfg.model) {\n          dist[\"default\"].fn.checkType(cfg.model, 'object', dist[\"default\"]._(\"Model configuration must be objects, check %s\", cn));\n          if (!['input', 'change'].includes(cfg.model.event) || !dist[\"default\"].fn.isString(cfg.model.prop)) {\n            throw Error(dist[\"default\"]._(\"The model configuration must have an event (input or change) and a prop (check %s)\", cfg.model, cn));\n          }\n          res.model = cfg.model;\n        }\n        break;\n\n      case 'extension':\n        // Validate extension.\n        if (cfg.extension) {\n          dist[\"default\"].fn.checkType(cfg.extension, 'object', dist[\"default\"]._(\"Extensions must be objects, check %s\", cn));\n          res.extension = cfg.extension;\n        }\n        break;\n\n      case 'render':\n        // Validate render function.\n        dist[\"default\"].fn.checkType(cfg.render, 'function', dist[\"default\"]._(\"Render property must be a function, check %s\", cn));\n        res.render = cfg.render;\n        break;\n\n      case 'template':\n        // Validate template string.\n        dist[\"default\"].fn.checkType(cfg.template, 'string', dist[\"default\"]._(\"The template must be a string, check %s\", cn));\n        res.template = cfg.template;\n        break;\n\n      case 'statics':\n        // Validate and process static properties.\n        if (cfg.statics) {\n          if (!dist[\"default\"].fn.isArray(cfg.statics)) {\n            cfg.statics = [cfg.statics];\n          }\n\n          dist[\"default\"].fn.each(cfg.statics, fn => {\n            dist[\"default\"].fn.checkType(fn, ['object', 'function'], dist[\"default\"]._(\"The statics property must be an object or a function in %s\", cn));\n            res.statics.push(fn);\n          });\n        }\n\n        break;\n\n      case 'iface':\n        if (cfg.iface) {\n          dist[\"default\"].fn.checkType(cfg.iface, ['object', 'function'], dist[\"default\"]._(\"The iface property must be an object or a function in %s\", cn));\n          res.iface = cfg.iface;\n        }\n\n        break;\n\n      /** \n       * @todo Add the possibility to change the tag using Customized built-in elements \n       * See createElement\n       */\n      case 'tag':\n        if (cfg.tag) {\n          dist[\"default\"].fn.checkType(cfg.tag, 'string', dist[\"default\"]._(\"Tags must be strings (check %s)\", cn));\n          res.tag = cfg.tag;\n        }\n\n        break;\n\n      default:\n        if (dist[\"default\"].cp.hooks.includes(name)) {\n          dist[\"default\"].fn.each(dist[\"default\"].fn.isArray(cfg[name]) ? cfg[name] : [cfg[name]], fn => {\n            dist[\"default\"].fn.checkType(fn, 'function')\n            if (!res[name]) {\n              res[name] = [];\n            }\n\n            res[name].push(fn);\n          });\n        }\n        else if (![\"mixins\", \"componentNames\", \"name\", \"__bbnComponent\"].includes(name)) {\n          if (name.indexOf('__bbn') !== 0) {\n            throw Error(dist[\"default\"]._(\"Unrecognized index %s in the config object for %s\", name, cn));\n          }\n        }\n\n    }\n  });\n\n  // If there are no props we add the source prop\n  if (!dist[\"default\"].fn.numProperties(res.props)) {\n    res.props.source = dist[\"default\"].fn.createObject();\n  }\n\n  return res;\n}\n\n// EXTERNAL MODULE: ./src/functions/realDefineComponent.js\nvar realDefineComponent = __webpack_require__(\"./src/functions/realDefineComponent.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/updateWatcher.js\nvar updateWatcher = __webpack_require__(\"./src/lib/Cp/private/updateWatcher.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/propagateDependencyChanges.js\nvar propagateDependencyChanges = __webpack_require__(\"./src/lib/Cp/private/propagateDependencyChanges.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/updateComputed.js\n\n\n\nfunction updateComputed(cp, name, val) {\n  // If the computed property does not exist in cp's options\n  if (!cp.$computed[name]) {\n    throw Error(bbn._(\"The computed %s is not defined in %s\", name, cp.$options.name));\n  }\n\n  //bbn.fn.log(\"UPDATING COMPUTED \" + name + \" IN \" + cp.$options.name, val);\n\n  // Calculate the hash of the new value\n  const hash = bbnData.hash(val);\n  // Get the old value and its hash from the computed property\n  const oldValue = cp.$computed[name].val;\n  const oldHash = cp.$computed[name].hash;\n  // Flag to determine if the computed property needs to be updated\n  let go = ((val !== oldValue) && !bbn.fn.isSame(oldHash, hash))\n    || !bbn.fn.isSame(cp.$computed[name].hash, hash);\n\n  if (go) {\n    let isDifferent = false;\n\n    // Get the new data object and the old data object\n    let newData = bbnData.getObject(val);\n    const oldData = bbnData.getObject(oldValue);\n\n    // If the old value and new value are both arrays, and they're not the same but have the same path and root component\n    if (bbn.fn.isArray(val, oldValue) && !newData && oldData && (oldData.root === cp) && (oldData.path === name)) {\n      // If the old value and new value are not the same, update the old array with the values from the new array\n      if (val !== oldValue) {\n        isDifferent = true;\n        bbn.fn.mutateArray(oldValue, val);\n      }\n    }\n    // If the new value and old value are not the same\n    else if (oldValue !== val) {\n      isDifferent = true;\n      // Remove the old data object from its component's list of data objects\n      if (oldData && oldData.hasComponent(cp, name)) {\n        // bbn.fn.log('Removing 6 data for ' + cp.$cid + ' in ' + cp.$options.name + ' / path: ' + name);\n        oldData.removeComponent(cp, name);\n      }\n      // Update the computed property's value and hash\n      cp.$computed[name].old = oldValue;\n      cp.$computed[name].val = cp.$treatValue(val, name);\n      newData = bbnData.getObject(cp.$computed[name].val);\n      // If there's a new data object, add it to its component's list of data objects\n      if (newData) {\n        newData.addComponent(cp, name);\n      }\n    }\n\n    if (isDifferent) {\n      cp.$computed[name].hash = hash;\n      // If there's a new data object, update it\n      if (newData) {\n        newData.update();\n      }\n      // Update the computed property's watcher and propagate any dependency changes\n      (0,updateWatcher[\"default\"])(cp, name, val);\n      (0,propagateDependencyChanges[\"default\"])(cp, name);\n      /*\n      const done = [];\n      // Iterate over all of the current components in cp's component map\n      bbn.fn.iterate(cp.$currentMap, (node, id) => {\n        // Check if this component has already been updated\n        // If the component hasn't already been updated\n        if (!done.includes(node)) {\n          // Update the computed property in this component\n          let c = node[name];\n          if (c !== val) {\n            // bbn.fn.log([\"UPDATING COMPUTED \" + name + \" IN \" + cp.$options.name, val, oldValue]);\n            node[name] = val;\n            // Add this component to the list of updated components\n            done.push(node);\n          }\n        }\n      });\n      */\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n;// CONCATENATED MODULE: ./src/functions/setComputed.js\n\n\n\n\nfunction setComputed(obj, name, getter, setter) {\n  if (Object.hasOwn(obj, name)) {\n    throw Error(dist[\"default\"]._(\"The computed property %s already exists\", name));\n  }\n\n\n  if (Object.hasOwn(obj.$computed, name)) {\n    throw Error(dist[\"default\"]._(\"The computed property %s already exists\", name));\n  }\n\n  obj.$computed[name] = dist[\"default\"].fn.createObject({\n    old: undefined,\n    val: undefined,\n    hash: undefined,\n    num: 0,\n    hasSetter: setter && dist[\"default\"].fn.isFunction(setter),\n    update: () => {\n      updateComputed(obj, name, getter.bind(obj)());\n    }\n  });\n\n  const def = {\n    get() {\n      if (!this.$isDataSet) {\n        return undefined;\n      }\n\n      if (this.$computed[name].num <= this.$numBuild) {\n        this.$computed[name].update();\n        this.$computed[name].num = this.$numBuild + 1;\n      }\n  \n      bbnData.addSequence(this, name, this.$computed[name].val);\n      return this.$computed[name].val;\n    }\n  };\n  if (setter) {\n    def.set = function(v) {\n      const res = setter.bind(this)(v);\n      this.$computed[name].update();\n      return res;\n    };\n  }\n  Object.defineProperty(obj, name, def);\n  (0,updateWatcher[\"default\"])(obj, name, obj[name], true);\n}\n\n;// CONCATENATED MODULE: ./src/functions/setDefaults.js\n/**\n * @method setDefaults\n * @memberof bbn.cp\n * @param {Object} defaults \n * @param {String} cpName\n */\nfunction setDefaults(defaults, cpName){\n  if ( typeof defaults !== 'object' ){\n    throw Error(\"The default object sent is not an object \" + cpName);\n  }\n  bbn.cp.defaults[cpName] = bbn.fn.extend(bbn.cp.defaults[cpName] || {}, defaults);\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/launch.js + 28 modules\nvar launch = __webpack_require__(\"./src/lib/Cp/private/launch.js\");\n;// CONCATENATED MODULE: ./src/functions/startTick.js\n\n\n/**\n * Starts the ticking process for component updates.\n * Throws an error if the tick process is already running.\n */\nfunction startTick() {\n  // Check if the tick process is already initiated.\n  if (bbn.cp.interval) {\n    throw Error(bbn._(\"The tick is already started\"));\n  }\n\n  let lastUpdate;\n\n  // Set an interval to periodically check and update components.\n  bbn.cp.interval = setInterval(\n    async function() {\n      // Skip if an update is currently running.\n      if (bbn.cp.isRunning) {\n        return;\n      }\n\n      // Using requestAnimationFrame for smooth UI updates.\n      requestAnimationFrame(tst => {\n        // Check if there are updates since the last frame and if the queue has items.\n        if ((tst !== lastUpdate) && bbn.cp.queue.length) {\n          lastUpdate = tst;\n          bbn.cp.isRunning = true;\n\n          // Create a copy of the current queue and clear the original queue.\n          const queue = bbn.cp.queue.splice(0, bbn.cp.queue.length);\n          let i = 0;\n          let time = bbn.fn.timestamp();\n          const todo = [];\n\n          // Process each component in the queue.\n          while (queue[i]) {\n            // Check if the component is not busy and if it's time to update it.\n            if (!queue[i].cp.$isBusy && (queue[i].force || (time - queue[i].cp.$lastLaunch > bbn.cp.tickDelay))) {\n              // Launch the update process for the component.\n              const queueElement = queue.splice(i, 1)[0];\n              (0,launch[\"default\"])(queueElement.cp).then(() => {\n                // Execute any functions associated with the update.\n                queueElement.fns.forEach(fn => {\n                  if (fn) {\n                    fn.bind(queueElement.cp)();\n                  }\n                });\n              });\n            }\n            else {\n              // If the component is busy or not yet due for an update, re-queue it.\n              const queueElement = bbn.fn.getRow(bbn.cp.queue, {cp: queue[i].cp});\n              if (queueElement) {\n                queueElement.fns.unshift(...queue[i].fns);\n              }\n              else {\n                todo.push(queue[i]);\n              }\n              i++;\n            }\n          }\n\n          // Re-add any items that couldn't be processed to the front of the queue.\n          if (todo.length) {\n            bbn.cp.queue.unshift(...todo);\n          }\n\n          // Indicate that the current update cycle is complete.\n          bbn.cp.isRunning = false;\n        }\n      });\n    },\n    // Interval defined by the tick delay.\n    bbn.cp.tickDelay\n  );\n}\n\n;// CONCATENATED MODULE: ./src/functions/stopTick.js\n/**\n * @name bbn.cp.stopTick\n * @package @bbn/bbn-cp\n * \n * @description Stops the tick of the application.\n */\nfunction stopTick() {\n  if (!bbn.cp.interval) {\n    throw Error(bbn._(\"The tick is not started\"));\n  }\n\n  clearInterval(bbn.cp.interval);\n  bbn.cp.interval = null;\n}\n\n;// CONCATENATED MODULE: ./src/functions/updateDirectives.js\n/**\n * Updates the given directives to the target element.\n * \n * This function is designed to update directives on a specified target element. \n * It iterates through each directive, checks if there's an associated update \n * function and if the directive's value has changed since the last update, \n * and then calls the update function. \n * This is typically part of a reactive system where directives need to respond \n * to changes in data or state. The function ensures that each directive is updated \n * as needed, reflecting any changes in the state or properties it's bound to.\n * \n * @param {Object} directives - An object containing the directives to be updated.\n * @param {HTMLElement} target - The DOM element to which the directives are applied.\n */\nfunction updateDirectives(directives, target) {\n  // Check if directives object is valid and has properties.\n  if (bbn.fn.isObject(directives) && Object.keys(directives).length && target.parentNode) {\n    // Iterate over each directive.\n    bbn.fn.iterate(directives, (dir, name) => {\n      // Check if an 'update' function exists for the directive and if the value has changed.\n      if (bbn.fn.isFunction(bbn.cp.directives[name].update) &&\n          !bbn.fn.isSame(dir.value, dir.oldValue)) {\n\n        // Update the 'lastUpdate' property of the directive.\n        dir.lastUpdate = bbn.fn.dateSQL();\n\n        // Call the 'update' function of the directive with the target element and directive info.\n        bbn.cp.directives[name].update(target, dir);\n      }\n    });\n  }\n}\n\n;// CONCATENATED MODULE: ./src/mixins/basic.js\nconst basic = {\n  data() {\n    bbn.cp.uid++;\n    let o = {\n      /**\n       * The change of value of this prop to true emits the event 'ready'.\n       * @data {Boolean} [false] ready\n       * @memberof basicComponent\n       */\n      ready: false,\n      /**\n       * Each basic component will have a unique UID.\n       * @data {Number} uid\n       * @memberof basicComponent\n       */\n      bbnUid: bbn.cp.uid,\n      /**\n       * The classes added to the component.\n       * @data {Array} [['bbn-basic-component']] componentClass\n       * @memberof basicComponent\n       */\n      componentClass: ['bbn-basic-component'],\n      /**\n       * Indicates if we're on a mobile device.\n       * @data {Boolean} isMobile\n       * @memberof basicComponent\n       */\n      isMobile: bbn.fn.isMobile(),\n      /**\n       * Indicates if we're on a tablet device.\n       * @data {Boolean} isTablet\n       * @memberof basicComponent\n       */\n      isTablet: bbn.fn.isTabletDevice(),\n      _currentPopup: null\n    };\n    if (this.$options.name && bbn.cp.defaults[this.$options.name.slice(4)]) {\n      bbn.fn.extend(o, bbn.cp.defaults[this.$options.name.slice(4)]);\n    }\n    return o;\n  },\n  computed: {\n    currentPopup(){\n      if (this._currentPopup === null) {\n        let e = this._retrievePopup(this);\n        if ( e ){\n          this._currentPopup = e;\n        }\n        else {\n          this._currentPopup = false;\n        }\n      }\n\n      if (this._currentPopup) {\n        return this._currentPopup;\n      }\n\n      return null;\n    }\n  },\n  methods: {\n    /**\n     * Retrieves the closest popup component in the Vue tree\n     * @param vm Vue\n     * @returns Vue|false\n     */\n    _retrievePopup(vm) {\n      vm = vm || this;\n      if (vm.$options && (vm.$options.name === 'bbn-popup')) {\n        return vm;\n      }\n      else if ( vm.getRef('popup') ){\n        return vm.getRef('popup');\n      }\n\n      return vm.$parent ? (vm.$parent._retrievePopup ? vm.$parent : this)._retrievePopup(vm.$parent) : false;\n    },\n    /**\n     * Creates a HTML string for recreating the component.\n     * @method exportComponent\n     * @memberof basicComponent\n     * @param  {Boolean}   full \n     * @param  {Number}    level \n     */\n    exportComponent(full, level) {\n      let lv = level || 0;\n      let st = bbn.fn.repeat('  ', lv) + '<' + this.$options._componentTag;\n      bbn.fn.iterate(this.$options.propsData, (a, n) => {\n        if (n === 'value') {\n          st += ' v-model=\"\"';\n        }\n        else if ( !bbn.fn.isFunction(a) && !bbn.fn.isObject(a) && !bbn.fn.isArray(a) ){\n          st += ' ';\n          if (typeof(a) !== 'string') {\n            st += ':';\n          }\n          st += bbn.fn.camelToCss(n) + '=' + '\"' + a + '\"';\n        }\n      });\n      st += '>' + \"\\n\";\n      if (full) {\n        bbn.fn.each(this.$children, a => {\n          if ( a.exportComponent !== undefined ){\n            st += a.exportComponent(true, lv+1);\n          }\n        });\n      }\n      st += bbn.fn.repeat('  ', lv) + '</' + this.$options._componentTag + '>' + \"\\n\";\n      return st;\n    },\n    /**\n    * Opens the closest object popup.\n    * @method getPopup\n    * @return {Object}\n    */\n    getPopup() {\n      let popup = this.currentPopup;\n      if (arguments.length && popup) {\n        let cfg = arguments[0];\n        let args = [];\n        if (bbn.fn.isObject(cfg)) {\n          cfg.opener = this;\n        }\n\n        args.push(cfg);\n        for (let i = 1; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n\n        return popup.open.apply(popup, args);\n      }\n\n      return popup;\n    },\n    /**\n    * Opens a confirmation from the closest popup\n    * @method confirm\n    */\n    confirm() {\n      let popup = this.getPopup();\n      if (arguments.length && popup) {\n        let cfg = arguments[0];\n        let args = [];\n        if (bbn.fn.isObject(cfg)) {\n          cfg.opener = this;\n        }\n\n        args.push(cfg);\n        for (let i = 1; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n\n        if (!bbn.fn.isObject(cfg)) {\n          args.push(this);\n        }\n\n        return popup.confirm.apply(popup, args)\n      }\n    },\n    /**\n    * Opens an alert from the closest popup\n    * @method alert\n    */\n    alert() {\n      let popup = this.getPopup();\n      if (arguments.length && popup) {\n        let cfg = arguments[0];\n        let args = [];\n        if (bbn.fn.isObject(cfg)) {\n          cfg.opener = this;\n        }\n\n        args.push(cfg);\n        for (let i = 1; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n\n        if (!bbn.fn.isObject(cfg)) {\n          args.push(this);\n        }\n\n        return popup.alert.apply(popup, args)\n      }\n    },\n    /**\n    * Executes bbn.fn.post\n    * @method post\n    * @see {@link https://bbn.io/bbn-js/doc/ajax/post|bbn.fn.post} documentation\n    * @todo Stupid idea, it should be removed.\n    * @return {Promise}\n    */\n    post() {\n      let ct = this.closest('bbn-container');\n      let referer = ct ? ct.getFullCurrentURL()\n        : document.location.pathName;\n      let cfg = bbn.fn.treatAjaxArguments(arguments);\n      if (!referer && bbn.env.path) {\n        referer = bbn.env.path;\n      }\n      cfg.obj = bbn.fn.extend({}, cfg.obj || {}, { _bbn_referer: referer, _bbn_key: bbn.fn.getRequestId(cfg.url, cfg.obj, 'json') });\n      return bbn.fn.post(cfg);\n    },\n    /**\n    * Executes bbn.fn.postOut\n    * @method postOut\n    * @see {@link https://bbn.io/bbn-js/doc/ajax/postOut|bbn.fn.postOut} documentation\n    * @todo Stupid idea, it should be removed.\n    * @return {void}\n    */\n    postOut(url, obj, onSuccess, target) {\n      let ct = this.closest('bbn-container');\n      let referer = ct ? ct.getFullCurrentURL()\n        : document.location.pathName;\n      let cfg = bbn.fn.treatAjaxArguments(arguments);\n      if (!referer && bbn.env.path) {\n        referer = bbn.env.path;\n      }\n      obj = bbn.fn.extend({}, obj || {}, { _bbn_referer: referer, _bbn_key: bbn.fn.getRequestId(url, obj, 'json') });\n      return bbn.fn.postOut(url, obj, onSuccess, target);\n    },\n  },\n  /**\n   * If not defined, defines component's template\n   * @memberof basicComponent\n   * @event beforeCreate\n   */\n  beforeCreate() {\n    if ( !this.$options.render && !this.$options.template && this.$options.name ){\n      this.$options.template = '#bbn-tpl-component-' + (this.$options.name.indexOf('bbn-') === 0 ? this.$options.name.slice(4) : this.$options.name);\n    }\n  },\n  /**\n   * Gives to the component the class bbn-basic-component\n   * @event created\n   * @memberof basicComponent\n   */\n  created() {\n    if (this.$options.name && !this.componentClass.includes(this.$options.name)){\n      this.componentClass.push(this.$options.name);\n    }\n  },\n  watch: {\n    /**\n     * Emits the event 'ready' when the value is true.\n     * @watch ready\n     * @emit ready\n     * @memberof basicComponent\n     */\n    ready(newVal) {\n      if (newVal) {\n        let ev = new CustomEvent('subready', {bubbles: true, detail: {cp: this}});\n        this.$el.dispatchEvent(ev);\n        this.$emit('ready', this);\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_basic = (basic);\n\n;// CONCATENATED MODULE: ./src/mixins/browserNotification.js\nconst browserNotification = {\n  /**\n   * @mixin bbn.cp.mixins.serviceWorker\n   * @memberof browserNotificationComponent\n   */\n  props: {\n    /**\n     * @prop {Boolean} [false] browserNotification\n     */\n    browserNotification: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data(){\n    return {\n      /**\n       * @data {Boolean} [false] hasBrowserPermission\n       * @memberof browserNotificationComponent\n       */\n      hasBrowserPermission: false,\n      /**\n       * @data {Object} [{}] browserNotifications\n       * @memberof browserNotificationComponent\n       */\n      browserNotifications: {},\n      /**\n       * @data {String} [''] browserNotificationURL\n       * @memberof browserNotificationComponent\n       */\n      browserNotificationURL: '',\n      /**\n       * @data {Boolean} [false] browserNotificationSW\n       * @memberof browserNotificationComponent\n       */\n      browserNotificationSW: false\n    }\n  },\n  methods: {\n    /**\n       * @method browserNotify\n       * @memberof browserNotificationComponent\n       * @param {String} title\n       * @param {String} text,\n       * @param {Object} options\n       * @fires _postMessage\n       * @fires $set\n       */\n    browserNotify(title, text, options){\n      if (this.ready\n        && this.browserNotification\n        && this.hasBrowserPermission\n        && title\n        && text\n      ) {\n        if (bbn.fn.isObject(text)) {\n          options = text;\n        }\n        else if (bbn.fn.isString(text)) {\n          if (!bbn.fn.isObject(options)) {\n            options = {};\n          }\n          if (!options.body || (options.body !== text)) {\n            options.body = text;\n          }\n        }\n        let date = bbn.fn.date();\n        options.tag = options.tag || options.timestamp || date.getTime();\n        options.timestamp = options.timestamp || date.getTime();\n        if (this.browserNotificationSW && bbn.fn.isFunction(this._postMessage)) {\n          this._postMessage({\n            type: 'notification',\n            data: {\n              title: title,\n              options: options\n            }\n          })\n        }\n        else {\n          options.onclick = this.browserNotificationClick;\n          let n = new Notification(title, options);\n          this.$set(this.browserNotifications, options.tag, n);\n        }\n      }\n    },\n    /**\n     * @method browserNotificationClick\n     * @memberof browserNotificationComponent\n     * @param {Object} options\n     * @fires post\n     * @fires removeBrowserNotification\n     * @fires messageToChannel\n     */\n    browserNotificationClick(options){\n      if (this.browserNotificationURL) {\n        this.post(this.browserNotificationURL + '/actions/read', {id: options.tag}, d => {\n          if (d.success) {\n            this.removeBrowserNotification(options.tag);\n            this.messageToChannel({\n              method: 'removeBrowserNotification',\n              params: [options.tag]\n            });\n          }\n        })\n      }\n      else {\n        this.removeBrowserNotification(options.tag);\n      }\n    },\n    /**\n     * @method removeBrowserNotification\n     * @memberof browserNotificationComponent\n     * @param {String} id\n     * @fires $delete\n     */\n    removeBrowserNotification(id){\n      if (id && (id in this.browserNotifications)){\n        this.$delete(this.browserNotifications, id);\n      }\n    }\n  },\n  /**\n   * Adds the class 'bbn-browser-notification-component' to the component.\n   * @event created\n   * @memberof browserNotificationComponent\n   */\n    created(){\n    this.componentClass.push('bbn-browser-notification-component');\n  },\n  /**\n   * @event mounted\n   */\n  mounted(){\n    if (this.browserNotification) {\n      Notification.requestPermission(perms => {\n        this.hasBrowserPermission = perms === 'granted';\n      })\n    }\n  }\n};\n\n/* harmony default export */ const mixins_browserNotification = (browserNotification);\n\n;// CONCATENATED MODULE: ./src/mixins/close.js\nconst close_close = {\n  /**\n   * Adds the class 'bbn-close-component' to the component.\n   * @event created\n   * @memberof closeComponent\n   */\n  created(){\n    this.componentClass.push('bbn-close-component');\n  },\n  data(){\n    return {\n      /**\n       * Defines if the component's source has been modified. \n       * @data {Boolean}  [false] dirty\n       * @memberof closeComponent\n       */\n      dirty: false\n    }\n  },\n  computed: {\n    /**\n     * If the prop 'dirty' is false the component can be closed. \n     * @computed {Boolean} canClose\n     * @memberof closeComponent\n     */\n    canClose(){\n      return !this.dirty;\n    }\n  },\n  methods: {\n\n  }\n};\n\n/* harmony default export */ const mixins_close = (close_close);\n;// CONCATENATED MODULE: ./src/mixins/componentInside.js\n\n\nconst componentInside = {\n  props: {\n    /**\n     * The component that will be rendered inside the main component.\n     * @prop {String|Object|bbnCp} component\n     * @memberof componentInsideComponent\n     */\n    component: {\n      type: [String, Object, Cp[\"default\"]]\n    },\n    /**\n     * The component's props.\n     * @prop {Object} componentOptions\n     * @memberof componentInsideComponent\n     */\n    componentOptions: {\n      type: Object,\n      default(){\n        return {};\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_componentInside = (componentInside);\n\n;// CONCATENATED MODULE: ./src/mixins/config.js\n\n\nconst config = {\n  statics(iface) {\n    if (!iface.config || !iface.config.name || !iface.config.props || !iface.config.data) {\n      throw Error(dist[\"default\"]._(\"The component must have a configName and a configSource returned by its interface function\"));\n    }\n\n    dist[\"default\"].cp.define(iface.config.name, {props: iface.config.props}, '', iface.config.name + ' { display: none; }');\n    return iface;\n  },\n  beforeCreate() {\n    if (this.$slots.default) {\n      dist[\"default\"].fn.each(this.$slots.default, a => {\n        //bbn.fn.log(['config mixin', a.tagName])\n        if ((a.tagName === this.constructor.config.name.toUpperCase()) && a.bbnSchema) {\n          this[this.constructor.config.data].push(a.bbnSchema.props);\n        }\n      });\n    }\n  }\n};\n\n/* harmony default export */ const mixins_config = (config);\n\n;// CONCATENATED MODULE: ./src/mixins/data.js\nconst data = {\n  methods: {\n    /**\n     * Defines how to render the data.\n     * @method renderData\n     * @param {Object} data\n     * @param {Object} cfg\n     * @memberof dataComponent\n     * @returns {String}\n     */\n    renderData(data, cfg){\n      if (!cfg || !cfg.field || (!bbn.fn.isString(cfg.field) && !bbn.fn.isNumber(cfg.field)) || !data) {\n        return '';\n      }\n\n      let v = data[cfg.field] || '';\n      if ( cfg.icon ){\n        return '<i class=\"' + cfg.icon + '\"> </i>'\n      }\n      else if ( cfg.type ){\n        switch ( cfg.type ){\n          case \"datetime\":\n            if ( window.dayjs && cfg.format ){\n              return v ? (new window.dayjs(v)).format(cfg.format) : '-';\n            }\n            else{\n              return bbn.fn.fdatetime(v, '-');\n            }\n          case \"date\":\n            if ( window.dayjs && cfg.format ){\n              return v ? (new window.dayjs(v)).format(cfg.format) : '-';\n            }\n            else{\n              return bbn.fn.fdate(v, '-');\n            }\n          case \"time\":\n            if ( cfg.format && window.dayjs ){\n              return v ? (new window.dayjs(v)).format(cfg.format) : '-';\n            }\n            else{\n              return v ? bbn.fn.ftime(v) : '-';\n            }\n          case \"email\":\n            return v ? '<a href=\"mailto:' + v + '\">' + v + '</a>' : '-';\n          case \"url\":\n            return v ? '<a href=\"' + v + '\">' + v + '</a>' : '-';\n          case \"percent\":\n            return v ? bbn.fn.money(v * 100, false, \"%\", '-', '.', ' ', 2) : '-';\n          case \"number\":\n            return bbn.fn.money(\n              v,\n              (cfg.precision === -4) || (cfg.format && (cfg.format.toLowerCase() === 'k')),\n              cfg.unit || \"\",\n              '-',\n              '.',\n              ' ',\n              cfg.precision === -4 ? 3 : (cfg.precision || cfg.decimals || 0)\n            );\n          case \"money\":\n            //bbn.fn.log(cfg)\n            return bbn.fn.money(\n              v,\n              (cfg.precision === -4) || (cfg.format && (cfg.format.toLowerCase() === 'k')),\n              cfg.currency || cfg.unit || \"\",\n              !!cfg.novalue ? (bbn.fn.isFunction(cfg.novalue) ? cfg.novalue(data[cfg.field], cfg) : cfg.novalue) : '-',\n              bbn.env?.money?.decimal || ',',\n              bbn.env?.money?.thousands || ' ',\n              cfg.precision === -4 ? 3 : (cfg.precision || cfg.decimals || 0)\n            );\n          case \"bool\":\n          case \"boolean\":\n            return '<i class=\"nf nf-fa-'\n              + (((v && (v !== 'false') && (v !== '0')) && ((cfg.yesvalue === undefined) || (v === cfg.yesvalue))) ? 'check' : 'times')\n              + '\" title=\"'\n              + (((v && (v !== 'false') && (v !== '0')) && ((cfg.yesvalue === undefined) || (v === cfg.yesvalue))) ? bbn._(\"Yes\") : bbn._(\"No\"))\n              + '\"></i>';\n        }\n      }\n      else if ( cfg.source ){\n        if (cfg.source.length) {\n          if (!bbn.fn.isObject(cfg.source[0])) {\n            let idx = cfg.source.indexOf(v);\n            return idx > -1 ? cfg.source[idx] : '-';\n          }\n          else {\n            let filter = {};\n            filter[this.sourceValue || 'value'] = v;\n            let idx = bbn.fn.search(bbn.fn.isFunction(cfg.source) ? cfg.source() : cfg.source, filter);\n            return idx > -1 ? cfg.source[idx][this.sourceText || 'text'] : '-';\n          }\n        }\n      }\n      else {\n        if (bbn.fn.isString(v) && v && cfg.maxVisible) {\n          return bbn.fn.shorten(v, cfg.maxVisible);\n        }\n        return v || '';\n      }          \n    }\n  }\n};\n\n/* harmony default export */ const mixins_data = (data);\n\n;// CONCATENATED MODULE: ./src/mixins/dataEditor.js\nconst dataEditor = {\n  statics() {\n    const editorOperators = {\n      string: {\n        contains: bbn._('Contains'),\n        eq: bbn._('Is'),\n        neq: bbn._('Is not'),\n        startswith: bbn._('Starts with'),\n        doesnotcontain: bbn._('Does not contain'),\n        endswith: bbn._('To end by'),\n        isempty: bbn._('Is empty'),\n        isnotempty: bbn._('Is not empty')\n      },\n      number: {\n        eq: bbn._('Is equal to'),\n        neq: bbn._('Is not equal to'),\n        gte: bbn._('Est supérieur ou égal àIs greater than or equal to'),\n        gt: bbn._('Is greater than'),\n        lte: bbn._('Is less than or equal to'),\n        lt: bbn._('Is inferior to'),\n      },\n      date: {\n        eq: bbn._('Is equal to'),\n        neq: bbn._('Is not equal to'),\n        gte: bbn._('Is greater than or equal to'),\n        gt: bbn._('Is after'),\n        lte: bbn._('Is prior to or equal to'),\n        lt: bbn._('Is older than'),\n      },\n      enums: {\n        eq: bbn._('Is equal to'),\n        neq: bbn._('Is not equal to'),\n      },\n      boolean: {\n        istrue: bbn._('Is true'),\n        isfalse: bbn._('Is false')\n      }\n    };\n  \n    const editorNullOps = {\n      isnull: bbn._('Is null'),\n      isnotnull: bbn._('Is not null')\n    };\n    const editorNoValueOperators = ['', 'isnull', 'isnotnull', 'isempty', 'isnotempty', 'istrue', 'isfalse'];\n    return {\n      editorOperators,\n      editorNullOps,\n      editorNoValueOperators\n    }\n          \n  },\n  methods: {\n    /**\n     * not used\n     * @memberof dataEditorComponent\n     *  editorOperatorType\n     * @param {Object} col \n     */\n    editorOperatorType(col){\n      if ( col.field ){\n\n      }\n    },\n    /**\n     * Returns if true if the editor has no value.\n     * @memberof dataEditorComponent\n     * @method editorHasNoValue\n     * @param {String} operator \n     * @returns {Boolean}\n     */\n    editorHasNoValue(operator){\n      return this.editorNoValueOperators.indexOf(operator) > -1;\n    },\n    /**\n     * Defines the correct editor for the given col.\n     * @method editorGetComponentOptions\n     * @param {Object} col\n     * @memberof dataEditorComponent\n     * @returns {Object}\n     */\n    editorGetComponentOptions(col){\n      let o = {\n        type: 'string',\n        component: 'bbn-input',\n        multi: false,\n        componentOptions:  {}\n      };\n      if ( col && col.field ){\n        o.field = col.field;\n        if ( col.filter ){\n          o.component = col.filter;\n        }\n        else if ( col.source ){\n          o.type = 'enums';\n          o.component = 'bbn-dropdown';\n          o.componentOptions.source = col.source;\n          o.componentOptions.placeholder = bbn._('Choose');\n        }\n        else if ( col.type === 'boolean' ){\n          o.type = 'enums';\n          o.component = 'bbn-dropdown';\n          o.componentOptions.source = [0, 1];\n          o.componentOptions.placeholder = bbn._('Choose');\n        }\n        else if ( col.type ){\n          switch ( col.type ){\n            case 'number':\n            case 'money':\n              o.type = 'number';\n              o.component = 'bbn-numeric';\n              break;\n            case 'date':\n              o.type = 'date';\n              o.component = 'bbn-datepicker';\n              break;\n            case 'time':\n              o.type = 'date';\n              o.component = 'bbn-timepicker';\n              break;\n            case 'datetime':\n              o.type = 'date';\n              o.component = 'bbn-datetimepicker';\n              break;\n          }\n        }\n        if ( col.componentOptions ){\n          bbn.fn.extend(o.componentOptions, col.componentOptions);\n        }\n        if ( o.type && this.editorOperators[o.type] ){\n          o.operators = this.editorOperators[o.type];\n        }\n        o.fields = [col];\n      }\n      return o\n    },\n\n  },\n  computed: {\n    /**\n     * The object containing the text for the different operator values.\n     * @computed editorOperators \n     * @memberof dataEditorComponent\n     * @returns {Object}\n     */\n    editorOperators(){\n      return this.constructor.editorOperators;\n    },\n    /**\n     * The object containing the text for the case null or not null values.\n     * @computed editorNullOps\n     * @memberof dataEditorComponent\n     * \n     */\n    editorNullOps(){\n      return this.constructor.editorNullOps;\n    },\n    /**\n     * The array containing the values of operators when the value of the editor is not defined.\n     * @computed editorNoValueOperators \n     * @memberof dataEditorComponent\n     * @returns {Array}\n     */\n    editorNoValueOperators(){\n      return this.constructor.editorNoValueOperators;\n    }\n  },\n  /**\n   * Adds the class 'bbn-data-editor-component' to the component.\n   * @event created\n   * @memberof dataEditorComponent\n   */\n  created(){\n    this.componentClass.push('bbn-data-editor-component');\n  },\n};\n\n/* harmony default export */ const mixins_dataEditor = (dataEditor);\n\n;// CONCATENATED MODULE: ./src/mixins/dimensions.js\nconst dimensions = {\n  props: {\n    /**\n    * The maximum width of the component.\n    * @prop {Number|String} maxWidth\n    * @memberof dimensionsComponent\n    */\n    maxWidth: {\n      type: [Number, String]\n    },\n    /**\n    * The maximum height of the component.\n    * @prop {Number|String} maxHeight\n    * @memberof dimensionsComponent\n    */\n    maxHeight: {\n      type: [Number, String]\n    },\n    /**\n    * The minimum width of the component.\n    * @prop {Number|String} minWidth\n    * @memberof dimensionsComponent\n    */\n    minWidth: {\n      type: [Number, String]\n    },\n    /**\n    * The minimum height of the component.\n    * @prop {Number|String} maxHeight\n    * @memberof dimensionsComponent\n    */\n    minHeight: {\n      type: [Number, String]\n    },\n    /**\n    * The width of the component.\n    * @memberof dimensionsComponent\n    * @prop {String|Number|Boolean} width\n    */\n    width: {\n      type: [String, Number, Boolean]\n    },\n    /**\n    * The height of the component.\n    * @memberof dimensionsComponent\n    * @prop {String|Number|Boolean} height\n    */\n    height: {\n      type: [String, Number, Boolean]\n    },\n  },\n  data(){\n    return {\n      /**\n      * The current height of the component.\n      * @memberof dimensionsComponent\n      * @data [null] currentHeight\n      */\n      currentHeight: null,\n      /**\n      * The current width of the component.\n      * @data [null] currentWidth\n      */\n      currentWidth: null,\n      /**\n      * The current min-height of the component.\n      * @memberof dimensionsComponent \n      * @data [null] currentMinHeight\n      */\n      currentMinHeight: null,\n      /**\n      * The current min-width of the component.\n      * @memberof dimensionsComponent\n      * @data [null] currentMinWidth\n      */\n      currentMinWidth: null,\n      /**\n      * The current max-height of the component.\n      * @memberof dimensionsComponent\n      * @data [null] currentMaxHeight\n      */\n      currentMaxHeight: null,\n      /**\n      * The current max-width of the component.\n      * @memberof dimensionsComponent\n      * @data [null] currentMaxWidth\n      */\n      currentMaxWidth: null,\n    };\n  }\n};\n\n/* harmony default export */ const mixins_dimensions = (dimensions);\n;// CONCATENATED MODULE: ./src/mixins/dropdown.js\n\n\nconst dropdown = {\n  props: {\n\n    /**\n     * The text corresponding to the value of the component.\n     * @memberof dropdownComponent\n     * @prop {String} [''] textValue\n     */\n    textValue: {\n      type: String,\n      default: ''\n    },\n    /**\n     * @todo description\n     * @memberof dropdownComponent\n     * @prop valueTemplate\n     */\n    valueTemplate: {},\n    /**\n     * Defines the groups for the dropdown menu.\n     * @memberof dropdownComponent\n     * @prop {String} group\n     */\n    group: {\n      type: String\n    },\n    /**\n     * Defines the mode of the dopdown menu.\n     * @memberof dropdownComponent\n     * @prop {String} ['selection'] mode\n     */\n    mode: {\n      type: String,\n      default: 'selection'\n    },\n    /**\n     * The max-height of the component.\n     * @memberof dropdownComponent\n     * @prop {Number|String} maxHeight\n     */\n    maxHeight: {\n      type: [Number, String]\n    },\n    /**\n     * Defines whether or not the component has to suggest a value when start typing.\n     * @memberof dropdownComponent\n     * @prop {Boolean} [false] suggest\n     */\n    suggest: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines whether or not the floater has to be set mobile view.\n     * @memberof dropdownComponent\n     * @prop {Boolean} [false] mobile\n     */\n    mobile: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Preloads the floater\n     * @memberof dropdownComponent\n     * @prop {Boolean} [false] preload\n     */\n    preload: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Adds the close button to floater header\n     * @memberof dropdownComponent\n     * @prop {Boolean} [false] closable\n     */\n    closable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * The floater bottom buttons\n     * @memberof dropdownComponent\n     * @prop {Array} buttons\n     */\n    buttons: {\n      type: Array\n    },\n    /**\n     * The floater title\n     * @memberof dropdownComponent\n     * @prop {String} floaterTitle\n     */\n    floaterTitle: {\n      type: String\n    },\n    /**\n     * Using an external popup component to open the floater\n     * @memberof dropdownComponent\n     * @prop {Boolean|bbnCp} popup\n     */\n    popup: {\n      type: [Boolean, Cp[\"default\"]],\n      default: false\n    },\n    /**\n     * Using the browser native render\n     * @memberof dropdownComponent\n     * @prop {Boolean} native\n     */\n    native: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * The icon representing the arrow up.\n     * @prop {String} ['nf nf-fa-caret_up'] iconUp\n     * @memberof dropdownComponent\n     */\n    iconUp: {\n      type: String,\n      default: 'nf nf-fa-caret_up'\n    },\n    /**\n     * The icon representing the arrow down.\n     * @prop {String} ['nf nf-fa-caret_down'] iconDown\n     * @memberof dropdownComponent\n     */\n    iconDown: {\n      type: String,\n      default: 'nf nf-fa-caret_down'\n    },\n    /**\n     * Convertes the current text from HTML code to pure text.\n     * @prop {Boolean} [false] clearHtml\n     * @memberof dropdownComponent\n     */\n    clearHtml: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @prop {Boolean} [false] groupable\n     * @memberof dropdownComponent\n     */\n    groupable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @prop {String} ['group'] sourceGroup\n     * @memberof dropdownComponent\n     */\n    sourceGroup: {\n      type: String,\n      default: 'group'\n    },\n    /**\n     * @prop {(String|Object|bbnCp)} groupComponent\n     * @memberof dropdownComponent\n     */\n    groupComponent: {\n      type: [String, Object, Cp[\"default\"]]\n    },\n    /**\n     * @prop {String} groupStyle\n     * @memberof dropdownComponent\n     */\n    groupStyle: {\n      type: String\n    },\n    /**\n     * @prop {Number} closeDelay The time it will take for the floater/menu to close when the mouse leaves\n     * @memberof dropdownComponent\n     * This  allows to cancel if the mouse comes back\n     */\n    closeDelay: {\n      type: Number,\n      default: 1000\n    },\n    /**\n     * @prop {String} ['disabled'] sourceDisabled\n     * @memberof dropdownComponent\n     */\n    sourceDisabled: {\n      type: String,\n      default: 'disabled'\n    }\n  },\n  data() {\n    return {\n      /**\n       * True when the user's mouse is over the dropdown element or its list\n       * @data {Bool} [false] isOverDropdown\n       * @memberof dropdownComponent\n       */\n      isOverDropdown: false,\n      /**\n       * The timeout before closing the floater\n       * @data {int} [0] closeTimeout\n       * @memberof dropdownComponent\n       */\n      closeTimeout: 0,\n      /**\n       * True if the floating menu of the component is opened.\n       * @data {Boolean} [false] isOpened\n       * @memberof dropdownComponent\n       */\n      isOpened: false,\n      /**\n       * The text corresponding to the value of the component.\n       * @data {String} [''] currentText\n       * @memberof dropdownComponent\n       */\n      currentText: this.textValue || '',\n      /**\n       * The current width of the component.\n       * @data {Number} [0] currentWidth\n       * @memberof dropdownComponent\n       */\n      currentWidth: 0,\n      /**\n       * The current height of the component.\n       * @data {Number} [0] currentHeight\n       * @memberof dropdownComponent\n       */\n      currentHeight: 0,\n      /**\n       * Whether or not the component is active.\n       * @data {Boolean} false isActive\n       * @memberof dropdownComponent\n       */\n      isActive: false,\n      /**\n       * The floater buttons\n       * @data {Array} [[]] realButtons\n       * @memberof dropdownComponent\n       */\n      realButtons: [],\n      /**\n       * The value of the native select elemenet\n       * @data {String|Number|Boolean} currentSelectValue\n       * @memberof dropdownComponent\n       */\n      currentSelectValue: this.value,\n      /**\n       * The floater component\n       * @data {bbnCp} list\n       * @memberof dropdownComponent\n       */\n      list: null,\n      portalSelector: null,\n      isInsideFloater: false\n    };\n  },\n  computed: {\n    popupComponent() {\n      if (this.popup) {\n        if (this.popup === true) {\n          return this.getPopup();\n        }\n        else {\n          return this.popup;\n        }\n      }\n    },\n    /**\n     * Returns the current 'text' corresponding to the value of the component.\n     * @computed currentTextValue\n     * @memberof dropdownComponent\n     * @returns {String}\n     */\n    currentTextValue() {\n      if ((this.value !== undefined) && !bbn.fn.isNull(this.value) && this.sourceValue && this.sourceText && this.currentData?.length) {\n        let idx = bbn.fn.search(this.currentData, a => {\n          return a.data[this.sourceValue] === this.value;\n        });\n        if (idx > -1) {\n          if (this.clearHtml) {\n            return bbn.fn.html2text(this.currentData[idx].data[this.sourceText]);\n          }\n          return this.currentData[idx].data[this.sourceText];\n        }\n      }\n      else if (this.value && this.textValue) {\n        return this.textValue;\n      }\n      return '';\n    },\n    /**\n     * @computed isSerching\n     * @memberof dropdownComponent\n     * @return {Boolean}\n     */\n    isSearching() {\n      return this.currentText !== this.currentTextValue;\n    },\n    /**\n     * @computed asMobile\n     * @memberof dropdownComponent\n     * @return {Boolean}\n     */\n    asMobile() {\n      return this.isMobile && this.mobile;\n    },\n    /**\n     * @computed currentIcon\n     * @memberof dropdownComponent\n     * @return {String}\n     */\n    currentIcon() {\n      return this.isOpened && !this.isDisabled && !this.readonly && this.filteredData.length ?\n        this.iconUp : this.iconDown;\n    }\n  },\n  methods: {\n    /**\n     * Select the string of text inside of the input.\n     * @method selectText\n     * @memberof dropdownComponent\n     */\n    selectText() {\n      this.getRef('input').selectText();\n    },\n    /**\n   * Handles the resize of the component\n   * @method onResize\n   * @memberof dropdownComponent\n   */\n    onResize() {\n      this.currentWidth = this.$el.offsetWidth;\n      this.currentHeight = this.$el.offsetHeight;\n    },\n    /**\n     * Manages the click\n     * @method click\n     * @memberof dropdownComponent\n     */\n    click() {\n      if (!this.disabled && !this.readonly && !this.native && this.filteredData.length && bbn.fn.isDom(this.$el)) {\n        this.isOpened = !this.isOpened;\n        if (this.writable) {\n          this.$el.querySelector('input:not([type=hidden])').focus();\n        }\n        //this.getRef('input').getRef('element').focus();\n      }\n    },\n    /**\n     * Emits the event 'select' \n     * @method select\n     * @param {Object} item \n     * @param {Number} idx \n     * @param {Number} dataIndex \n     * @param {Event} e \n     * @emit change\n     * @memberof dropdownComponent\n     */\n    onSelect(item, idx, dataIndex, e) {\n      bbn.fn.log([\"SELECT FROM DROPDOWN\", item, idx, dataIndex, e])\n      if (item && (!e || !e.defaultPrevented)) {\n        if (this.sourceAction && item[this.sourceAction] && bbn.fn.isFunction(item[this.sourceAction])) {\n          item[this.sourceAction](item);\n        }\n        else if (item[this.uid || this.sourceValue] !== undefined) {\n          bbn.fn.log([\"SELECT 2 FROM DROPDOWN\", item, idx, dataIndex, e])\n          this.currentSelectValue = item[this.sourceValue];\n        }\n      }\n\n      this.isOpened = false;\n    },\n    attachList() {\n      let list = this.getRef('list');\n      if (list) {\n        this.list = list;\n      }\n    },\n    /**\n     * Defines the behavior of component when the key 'alt' or a common key defined in the object bbn.var.keys is pressed. \n     * @method commonKeydown\n     * @memberof dropdownComponent\n     * @param {Event} e \n     * @return {Boolean}\n     */\n    selectOver() {\n      if (this.list) {\n        let lst = this.list.getRef('list');\n        if (lst && (lst.overIdx > -1)) {\n          this.select(lst.filteredData[lst.overIdx].data);\n        }\n      }\n    },\n    /**\n     * Defines the behavior of component when the key 'alt' or a common key defined in the object bbn.var.keys is pressed. \n     * @method commonKeydown\n     * @memberof dropdownComponent\n     * @param {Event} e \n     * @return {Boolean}\n     */\n    commonKeydown(e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return true;\n      }\n\n      if ((e.key?.length >= 2) && (e.key[0] === 'F')) {\n        return true;\n      }\n\n      if (e.key === 'Tab') {\n        if (this.isOpened) {\n          this.selectOver();\n          return true;\n        }\n        this.resetDropdown();\n        this.isOpened = false;\n        return true;\n      }\n      else if (\n        this.isOpened && (\n          bbn.var.keys.confirm.includes(e.which) || ((e.key === ' ') && !this.isSearching)\n        )\n      ) {\n        e.preventDefault();\n        this.selectOver();\n        return true;\n      }\n\n      return false;\n    },\n    /**\n     * Resets the dropdow to its inizial conditions.\n     * @method resetDropdown\n     * @memberof dropdownComponent\n     */\n    resetDropdown() {\n      this.currentText = this.currentTextValue;\n      this.unfilter();\n      if (this.isOpened) {\n        this.isOpened = false;\n      }\n    },\n    /**\n     * Forces the prop 'ready' to be true.\n     * @method afterUpdate\n     * @memberof dropdownComponent\n     */\n    afterUpdate() {\n      if (!this.ready) {\n        this.ready = true;\n      }\n    },\n    /**\n     * Resets the filters of the dropdown to the initial conditions.\n     * @method unfilter\n     * @memberof dropdownComponent\n     */\n    unfilter() {\n      this.currentFilters.conditions.splice(0, this.currentFilters.conditions.length);\n      if (this.currentFilters.logic && (this.currentFilters.logic.toLowerCase() === 'or')) {\n        this.currentFilters.logic = 'AND';\n      }\n    },\n    /**\n     * Gets the buttons list\n     * @method getRealButtons\n     * @memberof dropdownComponent\n     * @return {Array}\n     */\n    getRealButtons() {\n      let btns = [];\n      if (bbn.fn.isArray(this.buttons)) {\n        bbn.fn.each(this.buttons, btn => {\n          if (bbn.fn.isString(btn)) {\n            if (btn === 'close') {\n              btns.push({\n                text: bbn._('Close'),\n                icon: 'nf nf-fa-times_circle',\n                action: () => {\n                  this.isOpened = false;\n                }\n              });\n            }\n          }\n          else {\n            btns.push(btn);\n          }\n        })\n      }\n      return btns;\n    },\n    /**\n     * Updates the buttons\n     * @method updateButtons\n     * @memberof dropdownComponent\n     */\n    updateButtons() {\n      this.realButtons.splice(0, this.realButtons.length, ...this.getRealButtons());\n    },\n    onFocusOut() {\n      this.isActive = false;\n      if (this.native) {\n        this.isOpened = false;\n      }\n    }\n  },\n  beforeMount() {\n    let ct = this.closest('bbn-container');\n    this.portalSelector = ct ? ct.$el : document.body;\n    this.isInsideFloater = !!this.closest('bbn-floater');\n    this.updateButtons();\n  },\n  watch: {\n    /**\n     * @watch value\n     * @memberof dropdownComponent\n     */\n    value() {\n      this.$nextTick(() => {\n        this.currentText = this.currentTextValue;\n      });\n    },\n    /**\n     * Closes the floater menu of the component.\n     * @method leave\n     * @param element \n     * @memberof dropdownComponent\n     */\n    isOverDropdown(v) {\n      if (v) {\n        clearTimeout(this.closeTimeout);\n      }\n      else {\n        this.closeTimeout = setTimeout(() => {\n          let lst = this.getRef('list');\n          if (lst) {\n            bbn.fn.log(\"SHOULD CLOSE\");\n            lst.close(true);\n          }\n        }, this.closeDelay);\n      }\n    },\n    /**\n      * @watch ready\n      * @memberof dropdownComponent\n      */\n    ready(v) {\n      if (v && this.suggest && !this.value && this.filteredData.length) {\n        this.emitInput(this.filteredData[0].data[this.sourceValue]);\n      }\n    },\n    /**\n      * @watch source\n      * @memberof dropdownComponent\n      */\n    source() {\n      this.updateData().then(() => {\n        if (this.filteredData.length) {\n          this.onResize();\n        }\n      });\n    },\n    /**\n      * @watch buttons\n      * @memberof dropdownComponent\n      */\n    buttons: {\n      deep: true,\n      handler() {\n        this.updateButtons();\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_dropdown = (dropdown);\n\n\n;// CONCATENATED MODULE: ./src/mixins/editableList.js\n\n\nconst editableList = {\n  props: {\n    /**\n     * If defined, the form created for the edit of the table will have this URL as action.\n     * @prop {String} url\n     */\n    url: {\n      type: String\n    },\n    /**\n     * Defines the editor to use when a item is in edit mode.\n     * @prop {String|Object} editor\n     */\n    editor: {\n      type: [String, Object, Function]\n    },\n    /**\n     * Defines the editor options when editor defined.\n     * @prop {Object} editorOptions\n     */\n    editorOptions: {\n      type: Object\n    },\n    /**\n     * The popup that will be used for the editor\n     */\n    popup: {\n      type: Object\n    },\n    /**\n     * Set to true allows to edit inline the fields if no buttons are defined for the table.\n     * @prop {Boolean|String|Function} editable\n     */\n    editable: {\n      type: [Boolean, String, Function],\n      default: false,\n      validator: e => bbn.fn.isFunction(e) || (typeof e === 'boolean') || ['inline', 'popup', 'nobuttons'].includes(e)\n    },\n    /**\n     * Auto saves the row when edit-mode is 'inline'\n     * @prop {Boolean} [false] autoSave\n     */\n    autoSave: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Automatically resets the original values ​​when edit-mode is 'inline'\n     * @prop {Boolean} [false] autoReset\n     */\n    autoReset: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data(){\n    let editable = bbn.fn.isFunction(this.editable) ? this.editable() : this.editable;\n    return {\n      /**\n       * @data {String} editMode\n       */\n      editMode: editable === true ? (this.editor ? 'popup' : 'inline') : (editable === 'popup' ? 'popup' : 'inline'),\n      /**\n       * @data {Boolean|Object} [false] tmpRow\n       */\n      tmpRow: false,\n      /**\n       * @data {Boolean|Object} [false] originalRow\n       */\n      originalRow: false,\n      /**\n       * @data {Boolean|Object} [false] editedRow\n       */\n      editedRow: false,\n      /**\n       * @data {Boolean|Number} [false] editedIndex\n       */\n      editedIndex: false,\n    }\n  },\n  computed: {\n    /**\n     * Return true if the table isn't ajax, is editable and the edit mode is 'inline'.\n     * @computed isBatch\n     * @returns {Boolean}\n     */\n    isBatch() {\n      return this.editable && (this.editMode === 'inline') && !this.isAjax\n    },\n    /**\n     * If the computed isBatch is true, return an array of modified rows.\n     * @computed modifiedRows\n     * @returns {Array}\n     */\n    modifiedRows() {\n      let res = [];\n      if (this.isBatch) {\n        bbn.fn.each(this.currentData, (d, i) => {\n          if (!bbn.fn.isSame(d.data, this.originalData[i])) {\n            res.push(d);\n          }\n        })\n      }\n      return res;\n    },\n  },\n  methods: {\n    _defaultRow(data){\n      return data || {};\n    },\n    /**\n     * Creates the object tmpRow.\n     *\n     * @method _addTmp\n     * @param data\n     * @returns {bbnCp}\n     */\n    _addTmp(data) {\n      this._removeTmp().tmpRow = this._defaultRow(data);\n      this.$emit('addtmp', this.tmpRow);\n      return this;\n    },\n    /**\n     * Changes the values of tmpRow to false.\n     * @method _removeTmp\n     * @returns {bbnCp}\n     */\n    _removeTmp() {\n      if (this.tmpRow) {\n        this.tmpRow = false;\n      }\n      return this;\n    },\n    /**\n     * Returns true if the row corresponding to the given index has changed respect to originalData.\n     * @method isModified\n     * @param {Number} idx\n     * @returns {Boolean}\n     */\n    isModified(idx) {\n      if (!this.originalData) {\n        return false;\n      }\n      let data = [],\n          orig;\n      if (idx === undefined) {\n        data = bbn.fn.map(this.currentData, d => d.data);\n        orig = this.originalData;\n      }\n      else {\n        data = bbn.fn.getField(this.currentData, 'data', {index: idx}),\n        orig = this.originalData[idx];\n      }\n      return JSON.stringify(data) !== JSON.stringify(orig);\n    },\n    /**\n     * Adds the given data to the object tmpRow and opens the popup with the form to insert the row.\n     * @method insert\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Number} index\n     * @fires _addTmp\n     * @fires edit\n     */\n    insert(data, options, index) {\n      let d = data ? bbn.fn.clone(data) : {};\n      if (this.uid && d[this.uid]) {\n        delete d[this.uid];\n      }\n      this._addTmp(d, index);\n      this.edit(this.tmpRow, options, index);\n    },\n    /**\n     * Adds the given data to the object tmpRow and opens the popup with the form to copy the row.\n     * @method copy\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Number} index\n     * @fires _addTmp\n     * @fires edit\n     */\n    copy(data, options, index) {\n      let r = bbn.fn.clone(data);\n      if (this.uid && r[this.uid]) {\n        delete r[this.uid];\n      }\n      this._addTmp(r);\n      this.edit(this.tmpRow, options, index);\n    },\n    /**\n     * Opens the popup containing the form to edit the row.\n     * @method edit\n     * @param {Object} row\n     * @param {String|Object} winOptions\n     * @param {Number} index\n     * @fires _addTmp\n     */\n    edit(row, winOptions, index) {\n      if (!this.editable) {\n        throw Error(_(\"The component is not editable, you cannot use the edit function\"));\n      }\n      if ( !winOptions ){\n        winOptions = {};\n      }\n      if (!row) {\n        this._addTmp();\n        row = this.tmpRow;\n      }\n      this.originalRow = bbn.fn.clone(row);\n      // EditedRow exists from now on the time of the edition\n      this.editedRow = row;\n      this.editedIndex = bbn.fn.isFunction(this.getDataIndex) ? this.getDataIndex(index) : index;\n      if (this.editMode === 'popup') {\n        if (typeof (winOptions) === 'string') {\n          winOptions = {\n            title: winOptions\n          };\n        }\n        if (!winOptions.height) {\n          //winOptions.height = (this.cols.length * 2) + 'rem'\n        }\n        if (winOptions.maximizable === undefined) {\n          winOptions.maximizable = true;\n        }\n        let popup = bbn.fn.extend({\n          source: {\n            row: row,\n            data: bbn.fn.isFunction(this.data) ? this.data() : this.data\n          }\n        }, {\n          title: this.tmpRow ? bbn._('Row insertion') : bbn._('Row edition'),\n        }, winOptions ? winOptions : {});\n        // A component is given as global editor (form)\n        if (this.editor || !!popup.component) {\n          if (!popup.component) {\n            popup.component = bbn.fn.isFunction(this.editor) ? this.editor(row, index) : this.editor;\n          }\n          if (this.editorOptions) {\n            popup.componentOptions = bbn.fn.extend({\n              source: row\n            }, this.editorOptions);\n          }\n        }\n        // A URL is given and in this case the form will be created automatically with this URL as action\n        else if (this.url) {\n          let table = this;\n          let o = bbn.fn.extend({}, this.data, {\n            action: table.tmpRow ? 'insert' : 'update'\n          });\n          popup.component = {\n            data() {\n              let fields = [];\n              table.cols.map(a => {\n                let o = bbn.fn.extend(true, {}, a);\n                if (o.ftitle) {\n                  o.title = o.ftitle;\n                }\n                fields.push(o);\n              });\n              return {\n                // Table's columns are used as native form config\n                fields: fields,\n                data: row,\n                obj: o\n              }\n            },\n            template: `\n<bbn-form action=\"` + table.url + `\"\n        :schema=\"fields\"\n        :scrollable=\"false\"\n        :source=\"data\"\n        :data=\"obj\"\n        @success=\"success\"\n        @failure=\"failure\"\n        @cancel=\"cancel\">\n</bbn-form>`,\n            methods: {\n              success(d, e) {\n                e.preventDefault();\n                if (table.successEdit && table.successEdit(d)) {\n                  table.getPopup().close();\n                }\n              },\n              failure(d) {\n                table.$emit('editfailure', d);\n              },\n              cancel() {\n                if (table && table.cancel) {\n                  table.cancel();\n                }\n              }\n            },\n          };\n        } else {\n          throw Error(bbn._(\"Impossible to open a window if either an editor or a URL is not set\"))\n        }\n        popup.onClose = () => {\n          bbn.fn.log(\"AFTER CLOSER\");\n          //  this.currentData.push(bbn.fn.clone( this.tmpRow)); // <-- Error. This add a new row into table when it's in edit mode\n          this._removeTmp();\n          this.editedRow = false;\n          this.editedIndex = false;\n        };\n        this.getPopup(popup);\n      }\n    },\n    /**\n     * Cancels the changes made on the row data.\n     * @method cancel\n     * @fires _removeTmp\n     */\n    cancel() {\n      if (this.tmpRow) {\n        this._removeTmp();\n      }\n      else if (this.editedRow && this.originalRow) {\n        if (this.currentData[this.editedIndex]) {\n          this.currentData[this.editedIndex].data = this.originalRow;\n        }\n      }\n      this.originalRow = false;\n      this.editedRow = false;\n      this.editedIndex = false;\n    },\n    /**\n     * Insert or update a row in originalData.\n     * @method saveRow\n     * @emit saverow\n     */\n    saveRow() {\n      // New insert\n      let ev = new Event('saverow', {cancelable: true});\n      this.$emit('saverow', this.tmpRow || this.editedRow, ev);\n      if (!ev.defaultPrevented) {\n        if (this.tmpRow) {\n          let row = bbn.fn.clone(this.tmpRow);\n          this.currentData.push({\n            data: row,\n            index: this.currentData.length\n          });\n          if (this.originalData) {\n            this.originalData.push(bbn.fn.clone(row));\n          }\n          if (bbn.fn.isArray(this.source)) {\n            this.source.push(row);\n          }\n\n          this.tmpRow = false;\n        }\n        // Update\n        else if (this.editedRow) {\n          let row = bbn.fn.clone(this.editedRow);\n          this.$set(this.currentData[this.editedIndex], 'data', row);\n          if (this.originalData) {\n            let or = this.originalData.splice(this.editedIndex, 1, bbn.fn.clone(row));\n            if (bbn.fn.isArray(this.source)) {\n              let idx = bbn.fn.search(this.source, or[0]);\n              if (idx > -1) {\n                this.source.splice(idx, 1, row);\n              }\n            }\n          }\n          else if (bbn.fn.isArray(this.source) && this.uid && this.source[this.uid]) {\n            let idx = bbn.fn.search(this.source, {[this.uid]: this.source[this.uid]});\n            if (idx > -1) {\n              this.source.splice(idx, 1, row);\n            }\n          }\n\n          this.editedRow = false;\n        }\n        return true;\n      }\n      return false;\n    },\n    /**\n     * If the prop url of the table is defined makes a post to the url to update or insert the row, else fires the method saveRow to insert or update the row in originalData.\n     * @method saveInline\n     * @fires saveRow\n     *\n     */\n    saveInline() {\n      if (this.tmpRow || this.editedRow) {\n        if (this.url) {\n          let o = bbn.fn.extend({}, this.data, this.tmpRow || this.editedRow, {\n            action: this.tmpRow ? 'insert' : 'update'\n          });\n          this.post(this.url, o, d => {\n            this.successEdit(d);\n          })\n        }\n        else {\n          let d = bbn.fn.clone(this.tmpRow || this.editedRow);\n          if (this.saveRow()) {\n            this.$emit(this.tmpRow ? 'insert' : 'edit', d);\n          }\n        }\n      }\n    },\n    /**\n     * After the post in case of edit of the row, update the row in originalData.\n     *\n     * @method successEdit\n     * @param {Object} d\n     * @emit editSuccess\n     * @fires saveRow\n     * @returns {Boolean}\n     */\n    successEdit(d) {\n      if (bbn.fn.isObject(d)) {\n        if ((d.success !== undefined) && !d.success) {\n          if (window.appui) {\n            let ev = new Event('editfailure', {cancelable: true});\n            this.$emit('editfailure', d, ev);\n            if (!ev.defaultPrevented) {\n              appui.error();\n            }\n          }\n        }\n        else {\n          let ev = new Event('editsuccess', {cancelable: true});\n          this.$emit('editsuccess', d, ev);\n          if (!ev.defaultPrevented) {\n            if (d.data) {\n              bbn.fn.iterate(d.data, (o, n) => {\n                this.editedRow[n] = o;\n              });\n            }\n            this.saveRow();\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    /**\n     * @ignore\n     * @method saveTmp\n     */\n    saveTmp() {},\n    saveEditedRow() {},\n    cancelEditedRow() {},\n  },\n  /**\n   * Adds the class 'bbn-editable-list-component' to the component.\n   * @event created\n   * @memberof editableListComponent\n   */\n  created(){\n    this.componentClass.push('bbn-editable-list-component');\n  },\n  watch: {\n    /**\n     * @watch editedRow\n     */\n    editedRow(newVal) {\n      if (newVal === false) {\n        this.editedIndex = false;\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_editableList = (editableList);\n\n;// CONCATENATED MODULE: ./src/mixins/empty.js\nconst empty = {\n  template: '<template><slot></slot></template>',\n  /**\n   * Adds the class 'bbn-empty-component' to the component's template.\n   * @event created\n   * @memberof emptyComponent\n   */\n  created(){\n    this.componentClass.push('bbn-empty-component');\n  },\n};\n\n/* harmony default export */ const mixins_empty = (empty);\n\n;// CONCATENATED MODULE: ./src/mixins/events.js\nconst events = {\n  props: {\n    /**\n     * @memberof eventsComponent\n     * @prop {Number} [1000] touchHoldTolerance\n     */\n    touchHoldTolerance: {\n      type: Number,\n      default: 1000\n    },\n    /**\n     * @memberof eventsComponent\n     * @prop {Number} [10] touchTapTolerance\n     */\n    touchTapTolerance: {\n      type: Number,\n      default: 10\n    },\n    /**\n     * @memberof eventsComponent\n     * @prop {Number} [30] touchSwipeolerance\n     */\n    touchSwipeTolerance: {\n      type: Number,\n      default: 30\n    }\n  },\n  data(){\n    return {\n      /**\n       * Defines if the component has been changed since its mount.\n       * @memberof eventsComponent\n       * @data {Boolean} [false] isTouched\n       */\n      isTouched: false,\n      /**\n       * True if the component is focused.\n       * @memberof eventsComponent\n       * @data {Boolean} [false] isFocused\n       */\n      isFocused: false,\n      /**\n       * @memberof eventsComponent\n       * @data {Boolean|Event} [false] touchStarted\n       */\n      touchStarted: false,\n      /**\n       * @memberof eventsComponent\n       * @data {Boolean|Event} [false] touchMoved\n       */\n      touchMoved: false,\n      /**\n       * @memberof eventsComponent\n       * @data {Number} [0] touchHoldTimer\n       */\n      touchHoldTimer: 0\n    }\n  },\n  methods: {\n    /**\n     * Emits the click event.\n     * @method click\n     * @param {Event} e \n     * @emit click\n     * @memberof eventsComponent\n     */\n    click(e) {\n      if (bbn.fn.isEvent(e)) {\n        e.stopImmediatePropagation();\n      }\n\n      this.$emit('click', e);\n    },\n    /**\n     * Emits the blur event.\n     * @method blur\n     * @param {Event} e\n     * @emit blur\n     * @memberof eventsComponent\n     */\n    blur(e) {\n      this.isFocused = false;\n      if (bbn.fn.isEvent(e)) {\n        e.stopImmediatePropagation();\n      }\n\n      this.$emit('blur', e);\n    },\n    /**\n     * Emits the event focus\n     * @method focus\n     * @param {Event} e\n     * @return {Function}\n     * @memberof basicComponent\n     */\n    focus(e) {\n      let ele = this.getRef('element');\n      if ( ele && !this.isFocused ){\n        ele.focus();\n        this.isFocused = true;\n      }\n\n      if (bbn.fn.isEvent(e)) {\n        e.stopImmediatePropagation();\n      }\n\n      this.$emit('focus', e);\n    },\n    /**\n     * Emits the keyup event.\n     * @method keyup\n     * @param {Event} e\n     * @memberof eventsComponent\n     * @emit keyup\n     */\n    keyup(e) {\n      if (bbn.fn.isEvent(e)) {\n        e.stopImmediatePropagation();\n      }\n\n      this.$emit('keyup', e);\n    },\n    /**\n     * Emits the keydown event.\n     * @method keydown\n     * @param {Event} e\n     * @memberof eventsComponent\n     * @emit keydown\n     */\n    keydown(e) {\n      if (bbn.fn.isEvent(e)) {\n        e.stopImmediatePropagation();\n      }\n\n      this.$emit('keydown', e)\n    },\n    /**\n     * Emits the over event.\n     * @method over\n     * @param {Event} e\n     * @memberof eventsComponent\n     * @emit over\n     */\n    over(e) {\n      this.$emit('over', e);\n      this.$emit('hover', true, e);\n    },\n    /**\n     * Emits the out event.\n     * @method out\n     * @param {Event} e\n     * @emit out\n     * @memberof eventsComponent\n     * @emit over\n     */\n    out(e) {\n      this.$emit('out', e);\n      this.$emit('hover', false, e);\n    },\n    /**\n     * Sets the prop isTouched to true\n     * @method touchstart\n     * @memberof eventsComponent\n     */\n    touchstart(ev) {\n      this.$emit('touchstart', ev, this);\n      if (!ev.defaultPrevented) {\n        this.isTouched = true;\n        this.touchStarted = ev;\n        clearTimeout(this.touchHoldTimer);\n        this.touchHoldTimer = setTimeout(() => {\n          if (this.isTouched && !this.touchMoved && !ev.defaultPrevented){\n            ev.preventDefault();\n            let event = new Event('contextmenu');\n            this.$el.dispatchEvent(event);\n            this.isTouched = false;\n          }\n        }, this.touchHoldTolerance);\n      }\n    },\n    /**\n     * Sets the prop isTouched to false.\n     * @method touchmove\n     * @memberof eventsComponent\n     */\n    touchmove(ev){\n      this.$emit('touchmove', ev, this);\n      if (!ev.defaultPrevented) {\n        //this.isTouched = false;\n        if ((Math.abs(this.touchStarted.touches[0].clientX - ev.touches[0].clientX) > this.touchTapTolerance)\n          || (Math.abs(this.touchStarted.touches[0].clientY - ev.touches[0].clientY) > this.touchTapTolerance)\n        ) {\n          clearTimeout(this.touchHoldTimer);\n          this.touchMoved = ev;\n        }\n      }\n    },\n    /**\n     * Sets the prop isTouched to false.\n     * @method touchend\n     * @memberof eventsComponent\n     */\n    touchend(ev){\n      this.$emit('touchend', ev, this);\n      if (!ev.defaultPrevented) {\n        if (this.touchStarted && this.touchMoved) {\n          let direction = false,\n              diffY = Math.abs(this.touchStarted.touches[0].clientY - this.touchMoved.touches[0].clientY),\n              diffX = Math.abs(this.touchStarted.touches[0].clientX - this.touchMoved.touches[0].clientX),\n              axisX = diffX > diffY;\n          if (axisX && (diffX > this.touchSwipeTolerance)) {\n            direction = this.touchStarted.touches[0].clientX > this.touchMoved.touches[0].clientX ? 'left' : 'right';\n          }\n          else if (!axisX && (diffY > this.touchSwipeTolerance)) {\n            direction = this.touchStarted.touches[0].clientY > this.touchMoved.touches[0].clientY ? 'top' : 'bottom';\n          }\n          if (!!direction) {\n            this.$emit('swipe', ev, this, direction)\n            this.$emit('swipe' + direction, ev, this)\n          }\n        }\n        this.isTouched = false;\n        this.touchMoved = false;\n        this.touchStarted = false;\n      }\n    },\n    /**\n     * Sets the prop isTouched to false.\n     * @method touchcancel\n     * @memberof eventsComponent\n     */\n    touchcancel(ev){\n      clearTimeout(this.touchHoldTimer);\n      this.isTouched = false;\n      this.touchStarted = false;\n      this.touchMoved = false;\n      this.$emit('touchcancel', ev, this);\n    }\n  },\n  /**\n   * Adds the class 'bbn-events-component' to the component.\n   * @event created\n   * @memberof eventsComponent\n   */\n  created(){\n    this.componentClass.push('bbn-events-component');\n  },\n};\n\n/* harmony default export */ const mixins_events = (events);\n\n\n;// CONCATENATED MODULE: ./src/mixins/field.js\nconst field = {\n  props: {\n    /**\n     * The width of the component.\n     * @prop {String|Number} width\n     * @memberof fieldComponent\n     */\n    width: {\n      type: [String, Number],\n    },\n    /**\n     * The min-width of the component.\n     * @prop {String|Number} minWidth\n     * @memberof fieldComponent\n     */\n    minWidth: {\n      type: [String, Number],\n    },\n    /**\n     * The max-width of the component.\n     * @prop {String|Number} maxWidth\n     * @memberof fieldComponent\n     */\n    maxWidth: {\n      type: [String, Number],\n    },\n    /**\n     * The render of the component.\n     * @prop {String|Function} render\n     * @memberof fieldComponent\n     */\n    render: {\n      type: [String, Function]\n    },\n    /**\n     * The title of the component.\n     * @prop {String|Number} title\n     * @memberof fieldComponent\n     */\n    title: {\n      type: [String, Number]\n    },\n    /**\n     * The full title of the component.\n     * @prop {String} ftitle\n     * @memberof fieldComponent\n     */\n    ftitle: {\n      type: String\n    },\n    /**\n     * @prop {String|Object} tcomponent\n     * @memberof fieldComponent\n     */\n    tcomponent: {\n      type: [String, Object]\n    },\n    /**\n     * The icon of the component.\n     * @prop {String} icon\n     * @memberof fieldComponent\n     */\n    icon: {\n      type: String\n    },\n    /**\n     * The classes added to the component.\n     * @prop {String|Function} cls\n     * @memberof fieldComponent\n     */\n    cls: {\n      type: [String, Function]\n    },\n    /**\n     * The component's type.\n     * @prop {String} type\n     * @memberof fieldComponent\n     */\n    type: {\n      type: String\n    },\n    /**\n     * The component's field.\n     * @prop {String} field\n     * @memberof fieldComponent\n     */\n    field: {\n      type: String\n    },\n    /**\n     * Defines if the component has to be fixed.\n     * @prop {Boolean|String} [false] fixed\n     * @memberof fieldComponent\n     */\n    fixed: {\n      type: [Boolean, String],\n      default: false\n    },\n    /**\n     * Defines if the component has to be hidden.\n     * @prop {Boolean} hidden\n     * @memberof fieldComponent\n     */\n    hidden: {\n      type: Boolean\n    },\n    /**\n     * Defines if the componenent has to be encoded.\n     * @prop {Boolean} [false] encoded\n     * @memberof fieldComponent\n     */\n    encoded: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines if the componenent has to be sortable.\n     * @prop {Boolean|Function} [true] sortable \n     * @memberof fieldComponent\n     */\n    sortable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    /**\n     * Defines if the componenent has to be editable.\n     * @prop {Boolean|Function} [true] editable \n     * @memberof fieldComponent\n     */\n    editable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    /**\n     * Defines if the componenent has to be filterable.\n     * @prop {Boolean|Function} [true] filterable \n     * @memberof fieldComponent\n     */\n    filterable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    /**\n     * Defines if the componenent has to be resizable.\n     * @prop {Boolean|Function} [true] resizable \n     * @memberof fieldComponent\n     */\n    resizable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    /**\n     * Defines if the componenent has to be showable.\n     * @prop {Boolean|Function} [true] showable \n     * @memberof fieldComponent\n     */\n    showable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    /**\n     * Defines if the componenent can have a null value.\n     * @prop {Boolean|Function} nullable \n     * @memberof fieldComponent\n     */\n    nullable: {\n      type: [Boolean, Function],\n    },\n    /**\n     * The buttons of the component.\n     * @prop {Array|Function} buttons \n     * @memberof fieldComponent\n     */\n    buttons: {\n      type: [Array, Function]\n    },\n    /**\n     * The source of the component.\n     * @prop {Array|Object|String|Function} source \n     * @memberof fieldComponent\n     */\n    source: {\n      type: [Array, Object, String, Function]\n    },\n    /**\n     * Defines if the the value of the component is required.\n     * @prop {Boolean|Function} required \n     * @memberof fieldComponent\n     */\n    required: {\n      type: [Boolean, Function]\n    },\n    /**\n     * Defines the precision of the component.\n     * @prop {Number} [0] precision \n     * @memberof fieldComponent\n     */\n    precision: {\n      type: Number\n    },\n    /**\n     * Defines the number of decimals for the component.\n     * @prop {Number} [0] decimals \n     * @memberof fieldComponent\n     */\n    decimals: {\n      type: Number\n    },\n    /**\n     * Defines the precision of the component.\n     * @prop {Number} [0] precision \n     * @memberof fieldComponent\n     */\n    unit: {\n      type: String\n    },\n    /**\n     * Defines the options of the component.\n     * @prop {Object|Function} options\n     * @memberof fieldComponent\n     */\n    options: {\n      type: [Object, Function],\n      default(){\n        return {};\n      }\n    },\n    /**\n     * Defines the editor of the component.\n     * @prop {String|Object} editor\n     * @memberof fieldComponent\n     */\n    editor: {\n      type: [String, Object]\n    },\n    /**\n     * Defines the maxLength of the component.\n     * @prop {Number} maxLength \n     * @memberof fieldComponent\n     */\n    maxLength: {\n      type: Number\n    },\n    /**\n     * Defines the max number of chars visible in reading.\n     * @prop {Number} maxVisible \n     * @memberof fieldComponent\n     */\n    maxVisible: {\n      type: Number\n    },\n    /**\n     * Defines the sqlType of the component.\n     * @prop {String} sqlType \n     * @memberof fieldComponent\n     */\n    sqlType: {\n      type: String\n    },\n    /**\n     * @prop {String|Array} aggregate\n     * @memberof fieldComponent\n     */\n    aggregate: {\n      type: [String, Array]\n    },\n    /**\n     * Define a component to use.\n     * @prop {String|Object} component\n     * @memberof fieldComponent\n     */\n    component: {\n      type: [String, Object]\n    },\n    /**\n     * A function to map the data of the component.\n     * @prop {Function} mapper\n     * @memberof fieldComponent\n     */\n    mapper: {\n      type: Function\n    },\n    /**\n     * Defines the group of the component.\n     * @prop {String} group\n     * @memberof fieldComponent\n     */\n    group: {\n      type: String\n    }\n  },\n};\n\n/* harmony default export */ const mixins_field = (field);\n\n;// CONCATENATED MODULE: ./src/mixins/input.js\n\n\n\nconst input = {\n  props: {\n    /**\n     * The value of the component.\n     * @prop value\n     * @memberof inputComponent\n     */\n    value: {\n      default(){\n        return this.defaultValue !== undefined ? this.defaultValue : ''\n      }\n    },\n    /**\n     * The component's name.\n     * @prop {String} name \n     * @memberof inputComponent\n     */\n    name: {\n      type: String,\n      default(){\n        return dist[\"default\"].fn.randomString(10, 20)\n      }\n    },\n    /**\n     * The component's placeholder.\n     * @prop {String} placeholder\n     * @memberof inputComponent\n     */\n    placeholder: {\n      type: String\n    },\n    /**\n     * Defines if the component has a required value.\n     * @prop {Boolean|Function} [false] required\n     * @memberof inputComponent\n     */\n    required: {\n      type: [Boolean, Function, String],\n      default: false\n    },\n    /**\n     * Defines if the component has to be disabled.\n     * @prop {Boolean|Function} [false] disabled\n     * @memberof inputComponent\n     */\n    disabled: {\n      type: [Boolean, Function],\n      default: false\n    },\n    /**\n     * Defines if the component has to be readonly.\n     * @prop {Boolean|Function} [false] readonly\n     * @memberof inputComponent\n     */\n    readonly: {\n      type: [Boolean, Function, String],\n      default: false\n    },\n    /**\n     * Defines the size of the component.\n     * @prop {Number|String} size\n     * @memberof inputComponent\n     */\n    size: {\n      type: [Number, String]\n    },\n      /**\n     * Defines the maxlength of the value.\n     * @prop {Number|String} maxlength \n     * @memberof inputComponent\n     */\n    maxlength: {\n      type: [String, Number]\n    },\n    /**\n     * A function to validate the value before submit.\n     * @prop {Function} validation\n     * @memberof inputComponent\n     */\n    validation: {\n      type: [Function]\n    },\n    /**\n     * The attribute tabindex of the input component.\n     * @prop {Number} tabindex\n     * @memberof inputComponent\n     */\n    tabindex: {\n      type: [String, Number],\n      default: '0'\n    },\n    /**\n     * @prop {Boolean} [false] nullable\n     * @memberof inputComponent\n     */\n    nullable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @prop {Boolean|String|Object} [''] nullValue\n     * @memberof inputComponent\n     */\n    nullValue: {\n      type: [Boolean, String, Object],\n      default: null\n    },\n    /**\n     * Set it to true if you want to auto-resize the input's width based on its value (in characters).\n     * @prop {Boolean} [false] autosize\n     */\n    autosize: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @prop {Number|String} defaultValue\n     * @memberof inputComponent\n     */\n    defaultValue: {\n      type: [String, Number]\n    },\n    /**\n     * Defines the input mode of this elemenet\n     * @prop {String} inputmode\n     */\n    inputmode: {\n      type: String\n    },\n    /**\n     * If true the element will focus on insert\n     * @prop {Boolean} autofocus\n     */\n    autofocus: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @prop {Boolean} [false] ellipsis\n     */\n    ellipsis: {\n      type: Boolean,\n      default: false\n    },\n    autocapitalize: {\n      type: [Boolean, String]\n    },\n    autocorrect: {\n      type: [Boolean, String]\n    },\n    spellcheck: {\n      type: [Boolean, String]\n    }\n  },\n  data(){\n    let original = this.value;\n    if (dist[\"default\"].fn.isObject(this.value) || dist[\"default\"].fn.isArray(this.value)) {\n      original = dist[\"default\"].fn.clone(this.value);\n    }\n\n    return {\n      /**\n       * True if the component has a value.\n       * @data {Boolean} hasVale\n       */\n      originalValue: original\n    };\n  },\n  computed: {\n    hasValue() {\n      return !!this.value;\n    },\n    /**\n     * Returns true if the component can have a null value.\n     * @computed isNullable\n     * @returns {Boolean}\n     */\n    isNullable(){\n      let isNullable = !!this.nullable;\n      if ( this.nullable === null ){\n        isNullable = !this.required;\n      }\n\n      return isNullable;\n    },\n    /**\n     * Returns true if the component is disabled\n     * @computed isDisabled\n     * @fires closest\n     * @returns {Boolean}\n     */\n    isDisabled(){\n      let form = this.closest('bbn-form');\n      return this.disabled || (dist[\"default\"].cp.isComponent(form) && form.disabled);\n    }\n  },\n  methods: {\n    resetValue(){\n      if (dist[\"default\"].fn.isObject(this.value) || dist[\"default\"].fn.isArray(this.value)) {\n        this.originalValue = dist[\"default\"].fn.clone(this.value);\n      }\n      else {\n        this.originalValue = this.value;\n      }\n    },\n    /**\n     * Select the text of the component.\n     * @method selectText\n     * @memberof inputComponent\n     */\n    selectText(){\n      let ele = this.getRef('element');\n      if (ele) {\n        dist[\"default\"].fn.selectElementText(ele)\n      }\n    },\n    /**\n     * Emits the event input.\n     * @method emitInput\n     * @emit input\n     * @param {Number|String} val \n     * @memberof inputComponent\n     */\n    emitInput(val, name) {\n      let eventName = 'input' + (name ? ':' + name : '');\n      //bbn.fn.log(`Emitting ${eventName} from ${this.$options.name}`, this);\n      this.$emit(eventName, val);\n    },\n    /**\n     * Emits the event change.\n     * @method change\n     * @emit change\n     * @param {Event} e \n     * @memberof inputComponent\n     */\n    change(e){\n      this.$emit('change', e, this.value)\n    },\n    /**\n     * Check the validity of the inserted value.\n     * @method isValid\n     * @param {bbnCp} e \n     * @return {Boolean}\n     * @memberof inputComponent\n     */\n    isValid(e, setError = true){\n      const $this = dist[\"default\"].cp.isComponent(e) ? e : this,\n            ele = $this.$refs.element || false,\n            inp = $this.$refs.input || false,\n            customMessage = $this.$el.hasAttribute('validationMessage') ? $this.$el.getAttribute('validationMessage') : false;\n      let check = elem => {\n        if ( elem && elem.validity ){\n          let validity = elem.validity,\n              $elem = $this.$el,\n              // Default message\n              mess = dist[\"default\"]._('The value you entered for this field is invalid.'),\n              specificCase = false;\n          // If valid or disabled, return true\n          if ( elem.disabled || validity.valid ){\n            //if ( (!!elem.required || !!elem.readOnly) && !elem.value ){\n            if ( elem.required && !elem.value ){\n              specificCase = true;\n            }\n            else {\n              if (this.$el.classList.contains('bbn-state-invalid')) {\n                this.$el.classList.remove('bbn-state-invalid');\n              }\n              return true;\n            }\n          }\n          if ( !validity.valid || specificCase ){\n            // If field is required and empty\n            if ( validity.valueMissing || specificCase ){\n              mess = dist[\"default\"]._('Please fill out this field.');\n            }\n            // If not the right type\n            else if ( validity.typeMismatch ){\n              switch ( elem.type ){\n                // Email\n                case 'email':\n                  mess = dist[\"default\"]._('Please enter a valid email address.');\n                  break;\n                // URL\n                case 'url':\n                  mess = dist[\"default\"]._('Please enter a valid URL.');\n                  break;\n              }\n            }\n            // If too short\n            else if ( validity.tooShort ){\n              mess = dist[\"default\"]._('Please lengthen this text to %d characters or more. You are currently using %d characters.', parseInt(elem.getAttribute('minLength')), elem.value.length);\n            }\n            // If too long\n            else if ( validity.tooLong ){\n              mess = dist[\"default\"]._('Please shorten this text to no more than %d characters. You are currently using %d characters.', parseInt(elem.getAttribute('maxLength')), elem.value.length);\n            }\n            // If number input isn't a number\n            else if ( validity.badInput ){\n              mess = dist[\"default\"]._('Please enter a number.');\n            }\n            // If a number value doesn't match the step interval\n            else if ( validity.stepMismatch ){\n              mess = dist[\"default\"]._('Please select a valid value.');\n            }\n            // If a number field is over the max\n            else if ( validity.rangeOverflow ){\n              mess = dist[\"default\"]._('Please select a value that is no more than %d.', parseInt(elem.getAttribute('max')));\n            }\n            // If a number field is below the min\n            else if ( validity.rangeUnderflow ){\n              mess = dist[\"default\"]._('Please select a value that is no less than %d.', parseInt(elem.getAttribute('min')));\n            }\n            // If pattern doesn't match\n            else if (validity.patternMismatch) {\n              // If pattern info is included, return custom error\n              mess = dist[\"default\"]._('Please match the requested format.');\n            }\n            if (setError) {\n              this.setInvalid(customMessage || mess, $this);\n            }\n            return false;\n          }\n        }\n      };\n      let getLastElement = elem => {\n        if ( dist[\"default\"].cp.isComponent(elem) && elem.$refs && elem.$refs.element ){\n          return getLastElement(elem.$refs.element);\n        }\n        return elem;\n      };\n      if (inp) {\n        return check(getLastElement(inp)) || false;\n      }\n      if (ele) {\n        return check(getLastElement(ele)) || false;\n      }\n      return true;\n    },\n    setInvalid(message, elem){\n      this.$emit('error', message);\n      this.validationID = dist[\"default\"].fn.randomString();\n      if (!!message\n        && message.length\n        && (!elem || !dist[\"default\"].fn.isDom(elem.$el))\n      ) {\n        elem = this;\n      }\n      if (!this.$el.classList.contains('bbn-state-invalid')) {\n        this.$el.classList.add('bbn-state-invalid');\n        if (!!message\n          && message.length\n          && !!elem\n          && dist[\"default\"].fn.isDom(elem.$el)\n        ) {\n          /*\n          let style = document.createElement('style');\n          style.id = this.validationID + '_style';\n          style.innerHTML = `\n            #${this.validationID} .bbn-floater {\n              background-color: var(--red) !important;\n              color: var(--white) !important;\n            }\n            #${this.validationID} .bbn-floater-arrow:after {\n              background-color: var(--red) !important;\n            }`;\n          window.document.head.appendChild(style)\n          let cont = document.createElement('div');\n          cont.id = this.validationID;\n          cont.innerHTML = `\n            <bbn-tooltip source=\"${message}\"\n                          ref=\"tooltip\"\n                          @hook:mounted=\"showContent\"\n                          :icon=\"false\"\n                          position=\"bottomLeft\"\n                          @close=\"removeEle\"\n                          :element=\"element\"/>\n          `;\n          this.$el.appendChild(cont);\n          new Vue({\n            el: `#${this.validationID}`,\n            data(){\n              return {\n                element: elem.$el\n              }\n            },\n            methods: {\n              showContent(){\n                this.getRef('tooltip').show();\n              },\n              removeEle(){\n                style.remove();\n                this.$el.remove();\n              }\n            }\n          })\n          */\n        }\n      }\n      /*\n      this.$once('blur', () => {\n        this.$emit('removevalidation');\n        if (elem && elem.$el) {\n          elem.$el.focus();\n        }\n      });\n      */\n    }\n  },\n  /**\n   * Adds the class 'bbn-input-component' to the component.\n   * @event created\n   * @memberof inputComponent\n   */\n  created(){\n    this.componentClass.push('bbn-input-component');\n    if ( this.autosize ){\n      this.componentClass.push('bbn-auto-width');\n    }\n  },\n  mounted() {\n    if (this.autofocus) {\n      const ele = this.$refs.element || this.$refs.input || this.$el;\n      ele.focus();\n    }\n    this.$on('removevalidation', () => {\n      if (!!this.validationID\n        && this.$el.classList.contains('bbn-state-invalid')\n      ) {\n        this.$el.classList.remove('bbn-state-invalid');\n        if (document.getElementById(this.validationID)) {\n          document.getElementById(this.validationID).remove();\n        }\n        this.validationID = false;\n      }\n    })\n    // I think this code is not necessary, the events are already called. Mirko\n    /* const input = this.getRef('element');\n    if (input && bbn.fn.isFunction(input.addEventListener)) {\n      input.addEventListener('input', e => {\n        e.stopImmediatePropagation();\n        if (this.value !== input.value) {\n          Object.defineProperty(this, 'value', {\n            value: input.value,\n            writable: false,\n            configurable: true\n          });\n          this.currentValue = input.value;\n          this.$emit('input', this.value);\n        }\n      })\n      input.addEventListener('change', e => {\n        this.$emit('change', this.value);\n      })\n    } */\n  },\n  watch: {\n    /**\n     * @watch value\n     * @param newVal \n     * @memberof inputComponent\n     */\n    value(newVal){\n      if (newVal !== this.currentValue) {\n        this.currentValue = newVal;\n      }\n      /*\n      if ( this.widget && (this.widget.value !== undefined) ){\n        if (bbn.fn.isFunction(this.widget.value) ){\n          if ( this.widget.value() !== newVal ){\n            this.widget.value(newVal);\n          }\n        }\n        else{\n          if ( this.widget.value !== newVal ){\n            this.widget.value = newVal;\n          }\n        }\n      }\n      */\n      if ( !!newVal !== this.hasValue ){\n        this.hasValue = !!newVal;\n      }\n    },\n    currentValue(newVal) {\n      if (newVal !== this.currentValue) {\n        this.currentValue = newVal;\n      }\n    },\n  }\n};\n\n/* harmony default export */ const mixins_input = (input);\n\n;// CONCATENATED MODULE: ./src/mixins/keepCool.js\n\n\nconst keepCool =  {\n  data(){\n    return {\n      /**\n       * The obejct containing the cool's timers.\n       * @data {Number} [0] coolTimer\n       * @memberof keepCoolComponent\n       */\n      coolTimers: Data[\"default\"].immunizeValue({}),\n      /**\n       * The interval.\n       * @data {Number} [40] coolInterval\n       * @memberof keepCoolComponent\n       */\n      coolInterval: 40\n    }\n  },\n  methods: {\n    /**\n     * It will prevent the same action to be executed too many times in a row\n     * On the first go the timer will be defined and the action will be executed\n     * On the second go the promise will be created and returned\n     * On the consecutive goes the promise will be returned\n     * Once the promise is executed (after timeout) the promise will be recreated\n     * @method keepCool\n     * @param {Function} fn \n     * @param {Number} idx \n     * @param {Number} timeout \n     * @memberof keepCoolComponent\n     */\n    keepCool(fn, idx, timeout){\n      if ( !idx ){\n        idx = 'default';\n      }\n      let t = (new Date()).getTime();\n      let delay = timeout || this.coolInterval;\n      // First go of the serie: nothing exists\n      if ( !this.coolTimers[idx] ){\n        this.coolTimers[idx] = {\n          time: 0,\n          promise: false\n        };\n      }\n      // If there is a promise it has not yet been executed\n      if ( this.coolTimers[idx].promise ){\n        return this.coolTimers[idx].promise;\n      }\n\n      // Timeout passed, function will have to be executed immediately\n      let diff = delay + this.coolTimers[idx].time - t;\n      if ( (diff > 0) && (diff <= delay) ){\n        delay = diff;\n        this.coolTimers[idx].time = t + delay;\n      }\n      else{\n        delay = 0;\n        this.coolTimers[idx].time = t;\n      }\n      this.coolTimers[idx].promise = new Promise(resolve => {\n        setTimeout(() => {\n          let r = fn();\n          this.coolTimers[idx].time = (new Date()).getTime();\n          resolve(r);\n          this.coolTimers[idx].promise = false;\n        }, delay);\n      });\n      return this.coolTimers[idx].promise;\n    }\n  }\n};\n\n/* harmony default export */ const mixins_keepCool = (keepCool);\n\n;// CONCATENATED MODULE: ./src/mixins/keynav.js\nconst keynav = {\n  methods: {\n    getKeyNavTarget() {\n      let list = this.getRef('list');\n      if (!list && this.$is('bbn-list')) {\n        list = this;\n      }\n      else if (list && !list.$is('bbn-list')) {\n        list = list.getRef('list');\n      }\n      else if (!list) {\n        list = this.find('bbn-list');\n      }\n\n      return list;\n    },\n\n    /**\n     * States the role of the enter button on the dropdown menu.\n     * @memberof keynavComponent\n     * @method keynav\n     * @param {Event} e\n     * @fires widget.select\n     * @fires widget.open\n     *\n     */\n    keynav(e){\n      if (this.filteredData.length && bbn.var.keys.upDown.includes(e.keyCode)) {\n        if (e.preventDefault) {\n          e.preventDefault();\n        }\n        if ( !this.isOpened ){\n          this.isOpened = true;\n          return;\n        }\n\n        let list = this.getKeyNavTarget();\n        if (list) {\n          list.isOver = false;\n          let idx = -1;\n          let d = list.filteredData;\n          if (d.length === 1) {\n            list.overIdx = 0;\n            return;\n          }\n          if (list.overIdx > -1) {\n            idx = list.overIdx;\n          }\n\n          switch ( e.keyCode ){\n            // Arrow down\n            case 40:\n              list.overIdx = d[idx+1] !== undefined ? idx+1 : 0;\n              break;\n            // Arrow Up\n            case 38:\n              list.overIdx = d[idx-1] !== undefined ? idx-1 : d.length - 1;\n              break;\n            // Page down (10)\n            case 34:\n              if (list.overIdx >= (d.length - 1)) {\n                list.overIdx = 0;\n              }\n              else{\n                list.overIdx = d[idx+10] ? idx+10 : d.length - 1;\n              }\n              break;\n            // Page up (10)\n            case 33:\n              if (list.overIdx <= 0) {\n                list.overIdx = d.length - 1;\n              }\n              else{\n                list.overIdx = d[idx-10] ? idx-10 : 0;\n              }\n              break;\n            // End\n            case 35:\n              list.overIdx = d.length - 1;\n              break;\n            // Home\n            case 36:\n              list.overIdx = 0;\n              break;\n\n          }\n          list.$forceUpdate();\n        }\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_keynav = (keynav);\n\n;// CONCATENATED MODULE: ./src/mixins/list.js\n\n\n\nconst list = {\n  props: {\n    /**\n     * A function to transform the data.\n     * @prop {Function} map\n     * @memberof listComponent\n     */\n    map: {\n      type: Function\n    },\n    /**\n     * The limit of rows to be shown in a page of the list.\n     * @prop {Number} [25] limit\n     * @memberof listComponent\n     */\n    limit: {\n      type: Number,\n      default: 25\n    },\n    /**\n     * The array of predefined limits.\n     * @data {Array} {[10, 25, 50, 100, 250, 500]} limits\n     * @memberof listComponent\n     */\n    limits: {\n      type: Array,\n      default() {\n        return [10, 25, 50, 100, 250, 500];\n      },\n    },\n    /**\n     * Set to true will automatically update the data before mount.\n     * @prop {Boolean} [false] autobind\n     * @memberof listComponent\n     */\n    autobind: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Set to true allows the list to divide itself in different pages basing on the property limit.\n     * @prop {Boolean} [false] pageable\n     * @memberof listComponent\n     */\n    pageable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Set to true allows list's columns to be sortable.\n     * @prop {Boolean} [false] sortable\n     * @memberof listComponent\n     */\n    sortable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Set to true allows the columns of the list to be filtered. A filter icon will appear at the top of each column.The property can be given to each column to define different behaviour.\n     * @prop {Boolean} [false] filterable\n     * @memberof listComponent\n     */\n    filterable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Set to true enable the multifilter of the component. An icon will appear on the bottom right of the list. By clicking on the icon a popup with the multifilter will open.\n     * @prop {Boolean} [false] multifilter\n     * @memberof listComponent\n     */\n    multifilter: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * In case of Ajax source, set to true will make an Ajax call for the data when changing page of the list.\n     * @prop {Boolean} [true] serverPaging\n     * @memberof listComponent\n     */\n    serverPaging: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * In case of Ajax source, set to true will make an Ajax call for the sorting of the list.\n     * @prop {Boolean} [true] serverSorting\n     * @memberof listComponent\n     */\n    serverSorting: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * In case of Ajax source, set to true will make an Ajax call for the filter of the list.\n     * @prop {Boolean} [true] serverFiltering\n     * @memberof listComponent\n     */\n    serverFiltering: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Defines the order of the columns in the component.\n     * @prop {Array|Object} [[]] order\n     * @memberof listComponent\n     */\n    order: {\n      type: [Array, Object],\n      default() {\n        return [];\n      }\n    },\n    /**\n     * Defines the filters of the component.\n     * @prop {Object} [{logic: 'AND',conditions: []}] filters\n     * @memberof listComponent\n     */\n    filters: {\n      type: Object,\n      default() {\n        return {\n          logic: 'AND',\n          conditions: []\n        };\n      }\n    },\n    /**\n     * If the prop selection is set to true defines which items has to be selected.\n     * @prop {Array} selected\n     * @memberof listComponent\n     */\n    selected: {\n      type: Array,\n      default() {\n        return [];\n      }\n    },\n    /**\n     * Set to true shows a checkbox in each rows in the first column of the list.\n     * @prop {Boolean|Function} selection\n     * @memberof listComponent\n     */\n    selection: {\n      type: [Boolean, Function],\n      default: false\n    },\n    /**\n     * Set to true selecting an item will unselect any other selected item.\n     * @prop {Boolean} multiple\n     * @memberof listComponent\n     */\n    multiple: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Given to a column that has the property type set to 'money' defines the currency.\n     * @prop {String} currency\n     * @memberof listComponent\n     */\n    currency: {\n      type: String\n    },\n    /**\n     * The data sent in the ajax call.\n     * @prop {String|Function} [{}] data\n     * @memberof listComponent\n     */\n    data: {\n      type: [Object, Function],\n      default() {\n        return {};\n      }\n    },\n    /**\n     * Defines the message to show when the list has no data.\n     * @prop {String} ['No data...'] noData\n     * @memberof listComponent\n     */\n    noData: {\n      type: String,\n      default: dist[\"default\"]._('No data') + '...'\n    },\n    /**\n     * The uid of the list.\n     * @prop {String} uid\n     */\n    uid: {\n      type: String\n    },\n    /**\n     * The source of the component.\n     * @prop {Array|Object|String|Function} source\n     * @memberof listComponent\n     */\n    source: {\n      type: [Array, Object, String, Function],\n      default() {\n        return [];\n      }\n    },\n    /**\n     * The name of the property to be used as text.\n     * @prop {String} ['text'] sourceText\n     * @memberof listComponent\n     */\n    sourceText: {\n      type: String,\n      default: \"text\"\n    },\n    /**\n     * The name of the property to be used as value.\n     * @prop {String} ['value'] sourceValue\n     * @memberof listComponent\n     */\n    sourceValue: {\n      type: String,\n      default: \"value\"\n    },\n    /**\n     * If source is a function this index can be passed to the function.\n     * @prop {Number} sourceIndex\n     * @memberof listComponent\n     */\n    sourceIndex: {\n      type: Number\n    },\n    /**\n     * The name of the property to be used as icon.\n     * @prop {String} sourceIcon\n     * @memberof listComponent\n     */\n    sourceIcon: {\n      type: String\n    },\n    /**\n     * The name of the property to be used as image.\n     * @prop {String} sourceImg\n     * @memberof listComponent\n     */\n    sourceImg: {\n      type: String\n    },\n    /**\n     * The name of the property to be used as class.\n     * @prop {String} sourceCls\n     * @memberof listComponent\n     */\n    sourceCls: {\n      type: String\n    },\n    /**\n     * The name of the property to be used as action to execute when selected.\n     * @prop {String} sourceAction\n     * @memberof listComponent\n     */\n    sourceAction: {\n      type: [String, Function]\n    },\n    /**\n     * The name of the property to be used as URL to go to when selected.\n     * @prop {String} sourceUrl\n     * @memberof listComponent\n     */\n    sourceUrl: {\n      type: [String, Function]\n    },\n    /**\n     * The name of the property to use for children of hierarchical source\n     * @prop {String} [items] children\n     * @memberof listComponent\n     */\n    children: {\n      type: String,\n      default: 'items'\n    },\n    /**\n     * The mode of the component.\n     * Possible values: 'free', 'options', 'selection'.\n     * @prop {String} ['free'] mode\n     */\n    mode: {\n      type: String,\n      default: \"free\",\n      validator: m => ['free', 'options', 'selection'].includes(m)\n    },\n    /**\n     * A component for each element of the list.\n     * @memberof listComponent\n     * @prop {String|Object|bbnCp} component\n     */\n    component: {\n      type: [String, Object, Cp[\"default\"]]\n    },\n    /**\n     * The template to costumize the dropdown menu.\n     * @memberof listComponent\n     * @prop template\n     */\n    template: {},\n    /**\n     * @prop {String} query\n     * @memberof listComponent\n     */\n    query: {\n      type: String\n    },\n    /**\n     * The query values object.\n     * @prop {Object} queryValues\n     * @memberof listComponent\n     */\n    queryValues: {\n      type: Object\n    },\n    /**\n     * @prop {Object} hierarchy\n     * @memberof listComponent\n     */\n    hierarchy: {\n      type: Boolean,\n      default: false\n    },\n    /** \n     *  The tree will be shown on one level, with .. at the top, clicking an element with children will enter it\n     */\n    flat: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Enables the search mode\n     * @prop {Boolean} [false] search\n     */\n    search: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * @todo not used in the component\n     */\n    searchFields: {\n      type: Array\n    },\n    /**\n     * The operator used by filterString filter\n     * @prop {String} ['startswith'] searchOperator\n     */\n    searchOperator: {\n      type: String,\n      default: 'startswith'\n    }\n  },\n  data() {\n    let order = this.order;\n    if (this.sortable && this.order && (typeof this.order === 'object') && !Array.isArray(this.order)) {\n      order = [];\n      for (let n in this.order) {\n        order.push({\n          field: n,\n          dir: this.order[n]\n        });\n      }\n    }\n    return {\n      /**\n       * If true it's the first time the data is loaded.\n       * @data {Boolean} [false] _1strun\n       * @memberof listComponent\n       */\n      _1strun: false,\n      /**\n       * _dataPromise\n       * @memberof listComponent\n       * @data {Boolean, Promise} [false] _dataPromise\n       */\n      _dataPromise: false,\n      /**\n       * If source is a URL and auto is set to true, component will fetch data at mount.\n       * @data {Boolean} [false] auto \n       * @memberof listComponent\n       */\n      auto: true,\n      /**\n       * The current template of the component.\n       * @data {String} [false] currentTemplate\n       * @memberof listComponent\n       */\n      currentTemplate: this.template,\n      /**\n       * The current component of the component.\n       * @data {String|bbnCp|Object} [false] currentComponent\n       * @memberof listComponent\n       */\n      currentComponent: this.component || null,\n      /**\n       * \n       * @data {Boolean} [false] currentIndex\n       * @memberof listComponent\n       */\n      currentIndex: false,\n      /**\n       * @data {Boolean} [false] currentFilter\n       * @memberof listComponent\n       */\n      currentFilter: false,\n      /**\n       * The current filters of the list.\n       * @memberof listComponent\n       * @data {Object} currentFilters\n       */\n      currentFilters: dist[\"default\"].fn.clone(this.filters),\n      /**\n       * The current limit of items in the list.\n       * @memberof listComponent\n       * @data {Number} [25] currentLimit\n       */\n      currentLimit: this.limit,\n      /**\n       * The current start index of the list.\n       * @memberof listComponent\n       * @data {Number} [0] currentStart\n       */\n      currentStart: this.start,\n      /**\n       * The current order of the list.\n       * @memberof listComponent\n       * @data {Object} currentOrder\n       */\n      currentOrder: order,\n      /**\n       * The current data of the list.\n       * @memberof listComponent\n       * @data {Array} [[]] currentData\n       */\n      currentData: [],\n      /**\n       * The current total of items in the list.\n       * @memberof listComponent\n       * @data {Number} [0] currentTotal\n       */\n      currentTotal: 0,\n      /**\n       * The start index.\n       * @data {Number} [0] start\n       * @memberof listComponent\n       */\n      start: 0,\n      /**\n       * The total of items in the list. \n       * @data {Number} [0] total\n       * @memberof listComponent\n       */\n      total: 0,\n      /**\n       * True if the list is loading data.\n       * @data {Boolean} [false] isLoading\n       * @memberof listComponent \n       */\n      isLoading: false,\n      /**\n       * True if the list has been loaded.\n       * @data {Boolean} [false] isLoaded\n       * @memberof listComponent \n       */\n      isLoaded: typeof this.source !== 'string',\n      /**\n       * True if the source of the list is a string.\n       * @data {Boolean} isAjax\n       * @memberof listComponent \n       */\n      isAjax: typeof this.source === 'string',\n      /**\n       * @todo change name\n       * @data {Array} [[]] selectedRows\n       */\n      currentSelected: this.selected.slice(),\n      /**\n       * True if the list is filterable.\n       * @data {Boolean} [false] isFilterable\n       * @memberof listComponent\n       */\n      isFilterable: this.filterable,\n      /**\n       * True if the list has selection enabled.\n       * @data {Boolean} [false] hasSelection\n       */\n      hasSelection: !!this.selection,\n      /**\n       * The original data of the list.\n       * @data [null] originalData\n       * @memberof listComponent\n       */\n      originalData: null,\n      /**\n       * @data {String} filterString\n       * @memberof listComponent\n       */\n      filterString: this.textValue || '',\n      /**\n       * @memberof listComponent\n       * @data {false, Number} filterTimeout\n       */\n      filterTimeout: false,\n      /**\n       * The current query.\n       * @data {String} currentQuery\n       * @memberof listComponent\n       */\n      currentQuery: this.query,\n      /**\n       * The current query values.\n       * @data {Object} currentQueryValues\n       * @memberof listComponent \n       */\n      currentQueryValues: this.queryValues || {},\n      /**\n       * The id of the loading request.\n       * @data {Boolean} [false] loadingRequestID\n       * @memberof listComponent \n       */\n      loadingRequestID: false,\n      /**\n       * If hirarchy and uid and flat will be set to the last entered node UID\n       * @data {false|String} the UID of the last entered node\n       */\n      parentUid: false,\n      /**\n       * @data {null|String} An ID given with the search results\n       */\n      searchId: null,\n      /**\n       * @data {String} [''] searchValue\n       */\n      searchValue: ''\n    };\n  },\n  computed: {\n    /**\n     * The current limits.\n     * @computed currentLimits\n     * @memberof listComponent\n     */\n    currentLimits() {\n      if (!this.pageable) {\n        return [];\n      }\n\n      let pass = false;\n      return dist[\"default\"].fn.filter(this.limits.sort(), a => {\n        if (a > this.total) {\n          if (!pass) {\n            pass = true;\n            return true;\n          }\n          return false;\n        }\n        return true;\n      });\n    },\n    /**\n     * Returns true if a component has been defined for the list.\n     * @computed hasComponent\n     * @memberof listComponent\n     */\n    hasComponent() {\n      return (dist[\"default\"].fn.isString(this.component) || (dist[\"default\"].fn.isObject(this.component) && Object.keys(this.component).length)) || this.currentTemplate ? true : false;\n    },\n    /**\n     * Returns the component object. \n     * @computed realComponent\n     * @memberof listComponent\n     */\n    realComponent() {\n      let cp = dist[\"default\"].fn.isString(this.component) || (dist[\"default\"].fn.isObject(this.component) && Object.keys(this.component).length) ? this.component : null;\n      if (!cp && this.currentTemplate) {\n        cp = dist[\"default\"].cp.normalizeComponent({\n          props: ['source'],\n          data() {\n            return this.source;\n          },\n          template: this.currentTemplate\n        });\n      }\n\n      return cp;\n    },\n    /**\n     * Return the number of pages of the list.\n     * @computed numPages\n     * @memberof listComponent\n     * @return {number}\n     */\n    numPages() {\n      if (this.isAjax) {\n        return Math.ceil(this.total / this.currentLimit);\n      }\n\n      return Math.ceil(this.filteredTotal / this.currentLimit);\n    },\n    /**\n     * Return the current page of the list.\n     * @computed currentPage\n     * @memberof listComponent\n     * @fires updateData\n     * @return {Number}\n     */\n    currentPage: {\n      get() {\n        return Math.ceil((this.start + 1) / this.currentLimit);\n      },\n      set(val) {\n        if (this.ready) {\n          this.start = val > 1 ? (val - 1) * this.currentLimit : 0;\n          this.updateData(!this.serverPaging);\n        }\n      }\n    },\n    filteredData() {\n      if (this.currentData.length && this.currentFilters &&\n        this.currentFilters.conditions &&\n        this.currentFilters.conditions.length &&\n        (!this.serverFiltering || !this.isAjax)\n      ) {\n        return dist[\"default\"].fn.filter(this.currentData, a => {\n          return this._checkConditionsOnItem(this.currentFilters, a.data);\n        });\n      }\n      else {\n        return this.currentData;\n      }\n    },\n    filteredTotal() {\n      return this.filteredData.length;\n    },\n    /** @todo Remove: no sense and not used in any component */\n    valueIndex() {\n      if (this.value || (this.selected && this.selected.length)) {\n        let v = this.value || this.selected[0];\n        if (this.uid) {\n          return dist[\"default\"].fn.search(this.filteredData, a => {\n            return a.data[this.uid] === v;\n          });\n        }\n        else if (this.sourceValue) {\n          return dist[\"default\"].fn.search(this.filteredData, a => {\n            return a.data[this.sourceValue] === v;\n          });\n        }\n      }\n      return -1;\n    },\n    isAutobind() {\n      if (\n        (this.autobind === false) ||\n        (this.isAjax && this.autocomplete && (this.filterString.length < this.minLength))\n      ) {\n        return false;\n      }\n      return true;\n    },\n    hashCfg() {\n      return dist[\"default\"].fn.md5(JSON.stringify(this.currentFilters) + JSON.stringify(this.currentLimit) + JSON.stringify(this.start) + JSON.stringify(this.currentOrder));\n    },\n    /**\n     * Returns the current item icon\n     * @computed currentItemIcon\n     * @memberof listComponent\n     * @return {String}\n     */\n    currentItem() {\n      if ((this.value !== undefined)\n        && !dist[\"default\"].fn.isNull(this.value)\n        && this.sourceValue\n        && this.currentData.length\n      ) {\n        let idx = dist[\"default\"].fn.search(this.currentData, a => {\n          return dist[\"default\"].fn.getProperty(a.data, this.sourceValue) === this.value;\n        });\n        if (idx > -1) {\n          return this.currentData[idx].data;\n        }\n      }\n\n      return null;\n    },\n    /**\n     * Returns the current item icon\n     * @computed currentItemIcon\n     * @memberof listComponent\n     * @return {String}\n     */\n    currentItemIcon() {\n      if (this.currentItem && this.sourceIcon) {\n        return this.currentItem[this.sourceIcon];\n      }\n\n      return '';\n    },\n    /**\n     * Returns the current item image\n     * @computed currentItemImg\n     * @memberof listComponent\n     * @return {String}\n     */\n    currentItemImg() {\n      if (this.currentItem && this.sourceImg) {\n        return this.currentItem[this.sourceImg];\n      }\n\n      return '';\n    },\n    /**\n     * Returns the current item class\n     * @computed currentItemCls\n     * @memberof listComponent\n     * @return {String}\n     */\n    currentItemCls() {\n      if (this.currentItem && this.sourceCls) {\n        return this.currentItem[this.sourceCls];\n      }\n\n      return '';\n    }\n  },\n  methods: {\n    /**\n     * Returns the data changed using the function given in the prop map.\n     * @method _map\n     * @param data\n     */\n    _map(data) {\n      if ( dist[\"default\"].fn.isArray(data) ){\n        if ( data.length && !dist[\"default\"].fn.isObject(data[0]) && !dist[\"default\"].fn.isArray(data[0]) && this.sourceValue && this.sourceText ){\n          data = data.map(a => {\n            let o = {};\n            o[this.sourceValue] = a;\n                o[this.sourceText] = a;\n            return o;\n          });\n        }\n\n        return (this.map ? data.map(this.map) : data).slice();\n      }\n      return [];\n    },\n    /**\n     * Compares the values of the given row basing on the where operator and value.\n     *  \n     * @method _checkConditionsOnItem\n     * @param {Object} where \n     * @param {Object} row \n     * @return {Boolean}\n     */\n    _checkConditionsOnItem(where, row) {\n      let pass = false;\n      if (where.conditions && where.logic && (typeof row === 'object')) {\n        pass = where.logic !== 'OR';\n        for (let i = 0; i < where.conditions.length; i++) {\n          let cond = where.conditions[i],\n            res = true;\n          if (cond.conditions && cond.logic) {\n            res = this._checkConditionsOnItem(cond, row);\n          }\n          else if (cond.field && cond.operator) {\n            res = dist[\"default\"].fn.compare(row[cond.field], cond.value !== undefined ? cond.value : null, cond.operator);\n          }\n          if (!res && where.logic !== 'OR') {\n            pass = false;\n            break;\n          }\n          else if (res && where.logic === 'OR') {\n            pass = true;\n            break;\n          }\n        }\n      }\n      return pass;\n    },\n    /**\n     * Checks if the field's name is valid (0 must be accepted)\n     *\n     * @param {*} field\n     * @return {*} \n     */\n    isValidField(field) {\n      return dist[\"default\"].fn.isString(field) || dist[\"default\"].fn.isNumber(field);\n    },\n    /**\n      * @method select\n      */\n    select() {\n      //this.$emit('select', this.currentIndex);\n    },\n    /**\n      * Pushes the given filter in the currentFilters of the list.\n      * @method onSetFilter\n      * @param {Object} filter \n      */\n    onSetFilter(filter) {\n      if (filter && filter.field && filter.operator) {\n        if (this.multi) {\n          this.currentFilters.conditions.push(filter);\n        }\n        else if (filter.field) {\n          let idx = dist[\"default\"].fn.search(this.currentFilters.conditions, {\n            field: filter.field\n          });\n          if (idx > -1) {\n            this.currentFilters.conditions.splice(idx, 1, filter);\n          }\n          else {\n            this.currentFilters.conditions.push(filter);\n          }\n        }\n      }\n    },\n    /**\n      * Fires the method removeFilter to remove a group of conditions from currentFilters.\n      * @method onUnsetFilter\n      * @param {Object} filter\n      * @fires removeFilter\n      */\n    onUnsetFilter(filter) {\n      //bbn.fn.log(\"onUnset\", filter);\n      this.removeFilter(filter);\n    },\n    /**\n      * Removes a group of conditions from currentFilters.\n      * @method removeFilter\n      * @param {Object} condition\n      * @fires getPopup\n      */\n    removeFilter(condition) {\n      if (condition.time) {\n        //bbn.fn.log(\"There is the time\", condition);\n        let del = arr => {\n          let idx = dist[\"default\"].fn.search(arr, {\n            time: condition.time\n          });\n          //bbn.fn.log(\"Is there the index?\", idx);\n          if (idx > -1) {\n            if (arr[idx].conditions && arr[idx].conditions.length) {\n              this.getPopup().confirm(dist[\"default\"]._(\"Are you sure you want to delete this group of conditions?\"), () => {\n                arr.splice(idx, 1);\n                if (window.appui) {\n                  window.appui.success();\n                }\n              })\n            }\n            else {\n              arr.splice(idx, 1);\n              if (window.appui) {\n                window.appui.success();\n              }\n            }\n            return true;\n          }\n          for (let i = 0; i < arr.length; i++) {\n            if (arr[i].conditions) {\n              if (del(arr[i].conditions)) {\n                return true;\n              }\n            }\n          }\n        };\n        if (del(this.currentFilters.conditions)) {\n          this.$forceUpdate();\n        }\n      }\n    },\n    /**\n      * Unsets the current filter.\n      * @method unsetFilter\n      */\n    unsetFilter() {\n      this.currentFilters = dist[\"default\"].fn.clone(this.filters);\n      this.currentFilter = false;\n      this.editedFilter = false;\n    },\n    /**\n      * Unsets the current filter.\n      * @method unsetCurrentFilter\n      * \n      */\n    unsetCurrentFilter() {\n      if (this.editedFilter) {\n        let idx = dist[\"default\"].fn.search(this.currentFilters.conditions, {\n          time: this.editedFilter.time\n        });\n        if (idx > -1) {\n          this.currentFilters.conditions.splice(idx, 1)\n        }\n      }\n    },\n    getPostData() {\n      if (this.data) {\n        return dist[\"default\"].fn.isFunction(this.data) ? this.data() : this.data;\n      }\n      return {};\n    },\n    beforeUpdate() {\n      let e = new Event('beforeupdate', { cancelable: true });\n      this.$emit('beforeupdate', e);\n      return e.defaultPrevented ? false : true;\n    },\n    afterUpdate() {\n      return true;\n    },\n    getData() {\n      let data = {\n        limit: this.currentLimit,\n        start: this.start,\n        data: this.getPostData()\n      };\n      if (this.sortable) {\n        data.order = this.currentOrder;\n      }\n      if (this.isFilterable) {\n        data.filters = this.currentFilters;\n      }\n      if (this.showable) {\n        data.fields = this.shownFields;\n      }\n      return data;\n    },\n    treatData(data) {\n      if (this.parentUid && this.hierarchy && this.flat && this.uid) {\n        data.unshift({\n          [this.uid]: this.parentUid,\n          [this.sourceText]: \"..\"\n        });\n      }\n      data = this._map(data);\n      return dist[\"default\"].fn.map(data, (a, i) => {\n        /** @todo Is it compatible with the fact of updating the source when given an array */\n        let o = this.hierarchy ? dist[\"default\"].fn.extend(true, a, {\n          index: i,\n          key: this.isAjax ? (i + '-' + this.hashCfg) : i,\n          _bbn: true,\n        }) : {\n          data: a,\n          index: i,\n          key: this.isAjax ? (i + '-' + this.hashCfg) : i,\n          _bbn: true\n        };\n        if (this.children && a[this.children] && a[this.children].length) {\n          o.opened = true;\n        }\n        if (this.hasSelection) {\n          if (this.uid) {\n            o.selected = this.selected.includes(a[this.uid]);\n          }\n          else if ( this.sourceValue ){\n            o.selected = this.selected.includes(a[this.sourceValue]);\n          }\n        }\n        return o;\n      });\n    },\n    async updateData(preventLoad) {\n      if (this.beforeUpdate() !== false) {\n        this._dataPromise = new Promise(resolve => {\n          let prom;\n          let loadingRequestID;\n          if (this.isAjax) {\n            if (this.loadingRequestID) {\n              dist[\"default\"].fn.abort(this.loadingRequestID);\n              setTimeout(() => {\n                this.loadingRequestID = false;\n                this.updateData().then(() => {\n                  resolve();\n                })\n              }, 50);\n              return;\n            }\n\n            if (this._1strun && (preventLoad === true)) {\n              prom = new Promise((resolve) => {\n                setTimeout(() => {\n                  resolve({\n                    data: this.currentData,\n                    total: this.currentTotal\n                  })\n                })\n              })\n\n            }\n            else {\n              this.isLoading = true;\n              this.$emit('startloading');\n              let data = this.getData();\n              loadingRequestID = dist[\"default\"].fn.getRequestId(this.source, data);\n              this.loadingRequestID = loadingRequestID;\n              prom = this.post(this.source, data);\n            }\n\n          }\n          else {\n            prom = new Promise((resolve2) => {\n              let data = [];\n              if (dist[\"default\"].fn.isArray(this.source)) {\n                data = this.source;\n              }\n              else if (dist[\"default\"].fn.isFunction(this.source)) {\n                data = this.source(this.sourceIndex, this.data);\n              }\n              else if (dist[\"default\"].fn.isObject(this.source)) {\n                dist[\"default\"].fn.iterate(this.source, (a, n) => {\n                  let o = {};\n                  o[this.sourceValue] = n;\n                      o[this.sourceText] = a;\n                  data.push(o);\n                });\n              }\n              resolve2({\n                data: data,\n                total: data.length\n              });\n            });\n          }\n          prom.then(d => {\n            if (this.isAjax) {\n              if (!this.loadingRequestID || (this.loadingRequestID !== loadingRequestID)) {\n                this.isLoading = false;\n                this.loadingRequestID = false;\n                throw Error(\"No loading request\");\n              }\n\n              this.isLoading = false;\n              this.loadingRequestID = false;\n\n              if (!d) {\n                return;\n              }\n\n              if (d.status !== 200) {\n                d.data = undefined;\n              }\n              else {\n                d = d.data;\n              }\n\n              this.$emit('datareceived', d);\n            }\n\n            if (d && dist[\"default\"].fn.isArray(d.data)) {\n              if (d.data.length && d.data[0]._bbn) {\n                this.currentData = d.data;\n                this.updateIndexes();\n              }\n              else {\n                this.currentData = this.treatData(d.data);\n              }\n              if (d.query) {\n                this.currentQuery = d.query;\n                this.currentQueryValues = d.queryValues || {};\n              }\n              if (d.order) {\n                this.currentOrder.splice(0, this.currentOrder.length);\n                this.currentOrder.push({\n                  field: d.order,\n                  dir: (d.dir || '').toUpperCase() === 'DESC' ? 'DESC' : 'ASC'\n                });\n              }\n              this.total = d.total || this.filteredData.length;\n              /** @todo Observer part to dissociate */\n              if (d.observer && dist[\"default\"].fn.isFunction(this.observerCheck) && this.observerCheck()) {\n                this._observerReceived = d.observer.value;\n                this.observerID = d.observer.id;\n                this.observerValue = d.observer.value;\n                if (!this._1strun) {\n                  this.observerWatch();\n                }\n              }\n              if (!this._1strun) {\n                this._1strun = true;\n                this.$emit('firstrun');\n              }\n            }\n            this.afterUpdate();\n            resolve(this.currentData);\n            if (!this.isLoaded) {\n              this.isLoaded = true;\n            }\n\n            this.$emit('dataloaded', d);\n          });\n        }).catch(e => {\n          dist[\"default\"].fn.log(\"Better catching should be done here\");\n          this.isLoading = false;\n          this.loadingRequestID = false;\n        });\n        return this._dataPromise;\n      }\n    },\n    updateIndexes() {\n      if (this.currentData.length) {\n        dist[\"default\"].fn.each(this.currentData, (a, i) => {\n          if (a.index !== i) {\n            this.$set(this.currentData[i], 'index', i);\n            //a.index = i;\n          }\n        });\n      }\n    },\n    /**\n      * Deletes all the current data from the view.\n      * @method realDelete\n      * @emit delete\n      * @param {Number} index\n      */\n    emptyData() {\n      if (this.currentData) {\n        this.currentData.splice(0, this.currentData.length);\n      }\n    },\n    /**\n      * Deletes the row defined by param index.\n      * @method realDelete\n      * @emit delete\n      * @param {Number} index\n      */\n    realDelete(index) {\n      if (this.currentData[index]) {\n        let ev = new Event('delete');\n        if (this.url) {\n          this.post(this.url, dist[\"default\"].fn.extend({}, this.data, this.currentData[index].data, {\n            action: 'delete'\n          }), d => {\n            if (d.success) {\n              let data = this.currentData[index].data;\n              this.currentData.splice(index, 1);\n              if (!this.isAjax && dist[\"default\"].fn.isArray(this.source)) {\n                let idx = dist[\"default\"].fn.search(this.source, data);\n                if (idx > -1) {\n                  this.source.splice(idx, 1);\n                }\n              }\n\n              this.total--;\n              this.updateIndexes();\n              this.$emit('delete', data, ev);\n              if (window.appui) {\n                window.appui.success(dist[\"default\"]._('Deleted successfully'))\n              }\n            }\n            else {\n              this.alert(dist[\"default\"]._(\"Impossible to delete the row\"))\n            }\n          })\n        }\n        else {\n          let data = this.currentData[index].data;\n          this.currentData.splice(index, 1);\n          if (!this.isAjax && dist[\"default\"].fn.isArray(this.source)) {\n            let idx = dist[\"default\"].fn.search(this.source, data);\n            if (idx > -1) {\n              this.source.splice(idx, 1);\n            }\n          }\n\n          this.total--;\n          if (this.originalData) {\n            this.originalData.splice(index, 1);\n          }\n          this.updateIndexes();\n          this.$emit('delete', data, ev);\n        }\n      }\n    },\n    /**\n      * Add the given row to currentData\n      * @method add\n      * @param {Object} data\n      * @todo\n      *\n      */\n    add(data) {\n      this.currentData.push({\n        data: data,\n        index: this.currentData.length\n      });\n      if (!this.isAjax && dist[\"default\"].fn.isArray(this.source)) {\n        this.source.push(data);\n      }\n    },\n    /**\n      * Fires the method realDelete to delete the row.\n      * @method delete\n      * @param {Number} index\n      * @param {String} confirm\n      * @fires realDelete\n      * @emit beforedelete\n      */\n    deleteItem(index, confirm) {\n      if (this.filteredData[index]) {\n        let ev = new Event('delete', { cancelable: true });\n        this.$emit('beforedelete', index, this.filteredData[index].data, this, ev);\n        if (!ev.defaultPrevented) {\n          if (confirm === undefined) {\n            confirm = this.confirmMessage;\n          }\n          if (confirm) {\n            this.confirm(confirm, () => {\n              this.realDelete(this.filteredData[index].index);\n            });\n          }\n          else {\n            this.realDelete(this.filteredData[index].index);\n          }\n        }\n      }\n    },\n    /**\n      * Fires the metod updateData to refresh the current data set.\n      * @method reload\n      * @fires updateData\n      */\n    reload() {\n      return this.updateData();\n    },\n    getIndex(filter) {\n      if (!dist[\"default\"].fn.isObject(filter) && this.uid) {\n        filter = { [this.uid]: filter };\n      }\n      let fltr = dist[\"default\"].fn.filterToConditions(filter);\n      let idx = -1;\n\n      dist[\"default\"].fn.each(this.filteredData, (a, i) => {\n        if (dist[\"default\"].fn.compareConditions(a.data, fltr)) {\n          idx = i;\n          return false;\n        }\n      });\n      return idx;\n    },\n    /**\n      * Removes the row defined by the where param from currentData\n      * @method remove\n      * @param {Object} where\n      */\n    remove(where) {\n      let idx;\n      while ((idx = dist[\"default\"].fn.search(this.filteredData, a => {\n        return dist[\"default\"].fn.compareConditions(a.data, where);\n      })) > -1) {\n        this.realDelete(this.filteredData[idx].index, 1);\n      }\n      this.$forceUpdate();\n    },\n    listOnBeforeMount() {\n      if (this.isAutobind) {\n        this.updateData();\n      }\n    }\n  },\n  beforeMount() {\n    this.listOnBeforeMount();\n  },\n  created() {\n    if (!this.component && !this.template && this.$slots.default.length) {\n      if (this.$slots.default[0].bbnSchema.pre) {\n        this.currentTemplate = this.$slots.default[0].bbnSchema.pre;\n      }\n    }\n\n    this.currentComponent = this.realComponent;\n  },\n  watch: {\n    filters: {\n      deep: true,\n      handler() {\n        this.currentFilters = dist[\"default\"].fn.clone(this.filters)\n      }\n    },\n    /**\n      * @watch currentLimit\n      * @fires setConfig\n      */\n    currentLimit() {\n      if (this.ready && dist[\"default\"].fn.isFunction(this.setConfig)) {\n        this.setConfig(true);\n      }\n    },\n    /**\n      * @watch currentFilters\n      * @fires updateData\n      * @fires setConfig\n      */\n    currentFilters: {\n      deep: true,\n      handler() {\n        if (this.ready) {\n          this.currentFilter = false;\n          if (this.pageable && this.start) {\n            this.start = 0;\n          }\n\n          if (this.autobind) {\n            this.updateData();\n          }\n\n          if (dist[\"default\"].fn.isFunction(this.setConfig)) {\n            this.setConfig(true);\n          }\n        }\n      }\n    },\n    /**\n      * @watch currentOrder\n      * @fires setConfig\n      */\n    currentOrder: {\n      deep: true,\n      handler() {\n        if (this.ready) {\n          if (dist[\"default\"].fn.isFunction(this.setConfig)) {\n            this.setConfig(true);\n          }\n          this.$forceUpdate();\n        }\n      }\n    },\n    source: {\n      deep: true,\n      handler() {\n        if (this.ready && !this.editable) {\n          /*\n          this.updateData();\n          */\n        }\n      }\n    },\n    /**\n      * \n      */\n    searchValue(v) {\n      if (this.search) {\n        this.unsetFilter();\n        if (v) {\n          let cond = [];\n          if (this.searchFields) {\n            dist[\"default\"].fn.each(this.searchFields, a => {\n              cond.push({\n                field: a,\n                operator: 'contains',\n                value: v\n              });\n            });\n          }\n          else {\n            dist[\"default\"].fn.each(this.cols, a => {\n              if (a.field && !dist[\"default\"].fn.getRow(cond, { field: a.field })) {\n                cond.push({\n                  field: a.field,\n                  operator: 'contains',\n                  value: v\n                });\n              }\n            });\n          }\n          this.currentFilters.conditions.push({\n            logic: 'OR',\n            conditions: cond\n          });\n        }\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_list = (list);\n\n;// CONCATENATED MODULE: ./src/mixins/localStorage.js\nconst localStorage = {\n  statics() {\n    let _storage = false;\n    if (window.localStorage) {\n      _storage = {\n        get(name){\n          let tmp = window.localStorage.getItem(name);\n          if ( tmp ){\n            tmp = JSON.parse(tmp);\n            return tmp.value;\n          }\n        },\n        set(name, value){\n          return window.localStorage.setItem(name, JSON.stringify({\n            value: value,\n            time: (new Date()).getTime()\n          }));\n        },\n        time(name){\n          let tmp = window.localStorage.getItem(name);\n          if ( tmp ){\n            tmp = JSON.parse(tmp);\n            return tmp.time;\n          }\n          return false;\n        },\n        remove(name){\n          return window.localStorage.removeItem(name);\n        },\n        clear(){\n          return window.localStorage.clear();\n        }\n      };\n    }\n\n    return {\n      _storage\n    };\n  },\n  props: {\n    /**\n     * True if the component has to have storage.\n     * @prop {Boolean} [false] storage\n     * @memberof localStorageComponent\n     */\n    storage: {\n      type: Boolean\n    },\n    /**\n     * The name of the storage.\n     * @prop {String} ['default'] storageName\n     * @memberof localStorageComponent\n     */\n    storageName: {\n      type: String,\n      default: 'default'\n    },\n    /**\n     * The fullname of the storage.\n     * @prop {String} storageFullName\n     * @memberof localStorageComponent\n     */\n    storageFullName: {\n      type: String\n    }\n  },\n  data(){\n    return {\n      storageChangeDate: '2019-01-01 00:00:00'\n    };\n  },\n  computed: {\n    /**\n     *  _storage\n     * @memberof localStorageComponent\n     * \n     */\n    _storage() {\n      return this.constructor._storage;\n\n      if (window.localStorage) {\n        return {\n        }\n      }\n      return false;\n    },\n    /**\n     * Returns if the component has storage.\n     * @memberof localStorageComponent\n     * @computed {Boolean} hasStorage\n     */\n    hasStorage(){\n      if (this.storage === false) {\n        return false;\n      }\n      return (this.storage || (this.storageFullName || (this.storageName !== 'default'))) && !!this._storage;\n    },\n    /**\n     * Returns the storage's default name.\n     * @computed storageDefaultName \n     * @returns {String}\n     */\n    storageDefaultName(){\n      return this._getStorageRealName();\n    }\n  },\n  methods: {\n    /**\n     * Returns the complete path of the storage.\n     * @method _getStorageRealName\n     * @param {String} name \n     * @returns{String}\n     * @memberof localStorageComponent\n     */\n    _getStorageRealName(name){\n      if ( this.storageFullName ){\n        return this.storageFullName;\n      }\n      let st = '';\n      if ( this.$options.name ){\n        st += this.$options.name + '-';\n      }\n      if ( name ){\n        st += name;\n      }\n      else{\n        st += bbn.fn.substr(window.location.pathname, 1) + '-' + this.storageName;\n      }\n      return st;\n    },\n    /**\n     * Returns the computed _storage\n     * @method getStorage\n     * @param {String} name \n     * @param {Boolean} isFullName\n     * @returns {Boolean|String}\n     * @memberof localStorageComponent\n     */\n    getStorage(name, isFullName){\n      if ( this.hasStorage ){\n        return this._storage.get(isFullName ? name : this._getStorageRealName(name))\n      }\n      return false;\n    },\n    /**\n     * Sets the computed _storage.\n     * @method setStorage\n     * @param value \n     * @param {String} name \n     * @param {Boolean} isFullName\n     * @returns {Boolean}\n     * @memberof localStorageComponent\n     */\n    setStorage(value, name, isFullName){\n      if ( this.hasStorage ){\n        return this._storage.set(isFullName ? name : this._getStorageRealName(name), value)\n      }\n      return false;\n    },\n    /**\n     * Unsets the computed _storage.\n     * @method unsetStorage\n     * @param {String} name \n     * @param {Boolean} isFullName\n     * @memberof localStorageComponent\n     */\n    unsetStorage(name, isFullName){\n      if ( this.hasStorage ){\n        return this._storage.remove(isFullName ? name : this._getStorageRealName(name))\n      }\n      return false;\n    }\n  },\n  /**\n   * Adds the class bbn-local-storage-component to the component.\n   * @event created\n   * @memberof localStorageComponent\n   */\n  created(){\n    if ( this.hasStorage ){\n      this.componentClass.push('bbn-local-storage-component');\n    }\n  },\n};\n\n/* harmony default export */ const mixins_localStorage = (localStorage);\n\n;// CONCATENATED MODULE: ./src/mixins/memory.js\nconst memory = {\n  props: {\n    /**\n     * The object memory or a function that returns the object.\n     * @prop {Object|Function} memory\n     * @memberof memoryComponent\n     */\n    memory: {\n      type: [Object, Function]\n    },\n  },\n  /**\n   * Adds the class 'bbn-memory-component' to the component.\n   * @event created\n   * @memberof memoryComponent\n   */\n  created(){\n    this.componentClass.push('bbn-memory-component');\n  }\n};\n\n/* harmony default export */ const mixins_memory = (memory);\n\n;// CONCATENATED MODULE: ./src/mixins/observer.js\nconst observer = {\n  props: {\n    /**\n     * True if the component has to have an observer.\n     * @prop {Boolean} [true] observer\n     * @memberof observerComponent\n     */\n    observer: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data(){\n    return {\n      /**\n       * Integration of the functionnality is done through a watcher on this property\n       * @data {Array} [[]] observersCopy\n       * @memberof observerComponent\n       */\n      observersCopy: [],\n      /**\n       * Integration of the functionnality is done through a watcher on this property\n       * @data {Boolean} observersDirty\n       * @memberof observerComponent\n       */\n      observerDirty: false,\n      /**\n       * The value of the observer.\n       * @memberof observerComponent\n       * @data observerValue\n       */\n      observerValue: null,\n      /**\n       * The array of observers.\n       * @data {Array} observers\n       * @memberof observerComponent\n       */\n      observers: [],\n      /**\n       * The id of the observer.\n       * @data observerID\n       * @memberof observerComponent\n       */\n      observerID: null,\n      /**\n       * The closest ancestor 'bbn-obsever';\n       * @data {bbnCp} observationTower\n       * @memberof observerComponent\n       */\n      observationTower: null,\n      /**\n       * The uid of the observer.\n       * @data {String} observerUID\n       * @memberof observerComponent\n       */\n      observerUID: bbn.fn.randomString().toLowerCase()\n    }\n  },\n  methods: {\n    /**\n     * Returns true if the prop observer is set to true and an observerionTower is found.\n     * @method observerCheck\n     * @return {Boolean}\n     * @memberof observerComponent\n     */\n    observerCheck(){\n      return !!(this.observer && this.observationTower);\n    },\n    /**\n     * Returns true if the observer has a value.\n     * @method isObserved\n     * @return {Boolean}\n     * @memberof observerComponent\n     */\n    isObserved(){\n      return this.observerCheck() && this.observerValue;\n    },\n    /**\n     * Updates the observer.\n     * @method observerWatch\n     * @fires isObserved\n     * @memberof observerComponent\n     */\n    observerWatch(){\n      if ( this.isObserved() ){\n        //bbn.fn.log(\"----------------isObserved--------------\", this.$el);\n        this.observationTower.observerRelay({\n          element: this.observerUID,\n          id: this.observerID,\n          value: this.observerValue\n        });\n        setTimeout(() => {\n          this.observationTower.$on('bbnobserver' + this.observerUID + this.observerID, newVal => {\n            //bbn.fn.log(\"NEW VALUE!\");\n            // Integration of the functionnality is done through a watcher on this property\n            this.observerDirty = true;\n            this.observerValue = newVal;\n          });\n        }, 100);\n      }\n    },\n    /**\n     * @method observerRelay\n     * @memberof observerComponent\n     */\n    observerRelay(obs){\n      if ( this.observer ){\n        //bbn.fn.log(\"----------------observerRelay--------------\", this.$el)\n        let idx = bbn.fn.search(this.observers, {id: obs.id, element: obs.element});\n        if ( idx > -1 ){\n          if ( this.observers[idx].value !== obs.value ){\n            this.observers.splice(idx, 1, obs);\n          }\n        }\n        else{\n          this.observers.push(obs);\n          if ( this.observerCheck() ){\n            this.observationTower.$on('bbnobserver' + obs.element + obs.id, newVal => {\n              this.observerEmit(newVal, obs);\n            });\n          }\n        }\n        if ( this.observerCheck() ){\n          this.observationTower.observerRelay(bbn.fn.clone(obs));\n        }\n      }\n    },\n    /**\n     * Emits the event bbnObs.\n     * @method observerEmit\n     * @param {String|Number} newVal \n     * @param {Object} obs \n     * @emit bbnObs\n     * @memberof observerComponent\n     */\n    observerEmit(newVal, obs){\n      let row = bbn.fn.getRow(this.observers, {id: obs.id, element: obs.element});\n      if ( row && (row.value !== newVal) ){\n        row.value = newVal;\n        this.$emit('bbnobs' + obs.element + obs.id, newVal);\n        return true;\n      }\n    },\n    /**\n     * The called method on the switching to false of the \"observer Dirty\" property value\n     * @method observerClear\n     * @param {Object} obs\n     * @fires observationTower.observerClear\n     */\n    observerClear(obs){\n      if (this.observationTower) {\n        this.observationTower.observerClear(obs);\n      }\n    }\n  },\n  /**\n   * Adds the classes 'bbn-observer-component', 'bbn-observer', 'bbn-observer-' + this.observerUID to the component\n   * @event created\n   * @memberof observerComponent\n   */\n  created(){\n    if ( this.componentClass ){\n      this.componentClass.push('bbn-observer-component', 'bbn-observer', 'bbn-observer-' + this.observerUID);\n    }\n  },\n  /**\n   * Defines the observationTower object.\n   * @event mounted\n   * @memberof observerComponent\n   */\n  mounted(){\n    if ( this.observer ){\n      this.observationTower = this.closest('.bbn-observer');\n      this.observerWatch();\n    }\n  },\n  /**\n   * Removes the observer.\n   * @event beforeDestroy\n   * @memberof observerComponent\n   */\n  beforeDestroy(){\n    if ( this.isObserved() ){\n      let idx = bbn.fn.search(this.observationTower.observers, {element: this.observerUID});\n      if ( idx > -1 ){\n        this.observationTower.observers.splice(idx, 1);\n      }\n      this.observationTower.$off('bbnobserver' + this.observerUID + this.observerID);\n    }\n  },\n  watch: {\n    /**\n     * @watch observerDirty\n     * @param {Boolean} newVal\n     * @fires observerClear\n     */\n    observerDirty(newVal){\n      if (!newVal) {\n        this.observerClear({\n          id: this.observerID,\n          element: this.observerUID,\n          value: this.observerValue\n        });\n      }\n    }\n  }\n};\n\n/* harmony default export */ const mixins_observer = (observer);\n\n;// CONCATENATED MODULE: ./src/mixins/pageable.js\nconst pageable = {\n  props: {\n    /**\n     * The total of items in the list.\n     * @data {Number} [0] total\n     * @memberof listComponent\n     */\n    total: {\n      type: Number,\n      default: 0\n    },\n    /**\n     * The start index.\n     * @data {Number} [0] start\n     * @memberof pageableComponent\n     */\n    start: {\n      type: Number,\n      default: 0\n    },\n    /**\n     * The limit of rows to be shown in a page of the list.\n     * @prop {Number} [25] limit\n     * @memberof pageableComponent\n     */\n    limit: {\n      type: Number,\n      default: 25\n    },\n    /**\n     * The array of predefined limits.\n     * @data {Array} {[10, 25, 50, 100, 250, 500]} limits\n     * @memberof pageableComponent\n     */\n    limits: {\n      type: Array,\n      default() {\n        return [10, 25, 50, 100, 250, 500];\n      },\n    },\n    /**\n     * Set to true allows the list to divide itself in different pages basing on the property limit.\n     * @prop {Boolean} [false] pageable\n     * @memberof pageableComponent\n     */\n    pageable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * The name of the `page` word as used in the pager interface.\n     * @prop {String} ['Page'] pageName\n     */\n    pageName: {\n      type: String,\n      default: bbn._(\"Page\")\n    }\n  },\n  data(){\n    return {\n      /**\n       * The current limit of items in the list.\n       * @memberof pageableComponent\n       * @data {Number} [25] currentLimit\n       */\n      currentLimit: this.limit,\n      /**\n       * The current start index of the list.\n       * @memberof pageableComponent\n       * @data {Number} [0] currentStart\n       */\n      currentStart: this.start,\n      /**\n       * The current total of items in the list.\n       * @memberof pageableComponent\n       * @data {Number} [0] currentTotal\n       */\n      currentTotal: 0\n    };\n  },\n  computed: {\n    /**\n     * Return the number of pages of the list.\n     * @computed numPages\n     * @memberof listComponent\n     * @return {number}\n     */\n    numPages() {\n      return Math.ceil(this.total / this.currentLimit);\n    },\n    /**\n     * Return the current page of the list.\n     * @computed currentPage\n     * @memberof listComponent\n     * @fires updateData\n     * @return {Number}\n     */\n    currentPage: {\n      get() {\n        return Math.ceil((this.start + 1) / this.currentLimit);\n      },\n      set(val) {\n        if ( this.ready ) {\n          this.start = val > 1 ? (val - 1) * this.currentLimit : 0;\n          this.updateData();\n        }\n      }\n    },\n  },\n  methods: {\n  },\n  watch: {\n    /**\n     * @watch currentLimit\n     * @fires setConfig\n     */\n    currentLimit() {\n      if ( this.ready && bbn.fn.isFunction(this.setConfig) ){\n        this.setConfig(true);\n      }\n    },\n  }\n};\n\n/* harmony default export */ const mixins_pageable = (pageable);\n\n;// CONCATENATED MODULE: ./src/mixins/popup.js\n\n\nconst popup = {\n  props: {\n    /**\n     * The object popup of the table.\n     * @prop {bbnCp}\n     */\n    popup: {\n      type: Cp[\"default\"]\n    }\n  },\n  methods: {\n    /**\n     * Retuns the popup object.\n     * @method getPopup\n     * @returns {bbnCp}\n     */\n    /*\n    getPopup(cfg){\n      let popup = this.popup || bbn.cp.getPopup(this);\n      // If no config we return the popup object\n      if (!cfg) {\n        return popup;\n      }\n\n      if (popup) {\n        // Adding opener to the config\n        cfg.opener = this;\n        return popup.open(cfg);\n      }\n\n    },\n    */\n    \n  }\n};\n\n/* harmony default export */ const mixins_popup = (popup);\n\n;// CONCATENATED MODULE: ./src/mixins/position.js\nconst position = {\n  props: {\n    /**\n    * The position 'left'.\n    * @memberof positionComponent\n    * @prop {Number} left\n    */\n    left: {\n      type: Number\n    },\n    /**\n    * The position 'right'.\n    * @memberof positionComponent\n    * @prop {Number} right\n    */\n    right: {\n      type: Number\n    },\n    /**\n    * The position 'top'.\n    * @memberof positionComponent\n    * @prop {Number} top\n    */\n    top: {\n      type: Number\n    },\n    /**\n    * The position 'bottom'.\n    * @memberof positionComponent\n    * @prop {Number} bottom\n    */\n    bottom: {\n      type: Number\n    },\n  }\n};\n\n/* harmony default export */ const mixins_position = (position);\n\n;// CONCATENATED MODULE: ./src/mixins/resizer.js\nconst resizer = {\n  data() {\n    return {\n      /**\n       * The closest resizer parent.\n       * @data {Boolean} [false] parentResizer\n       * @memberof resizerComponent\n       */\n      parentResizer: false,\n      /**\n       * The listener on the closest resizer parent.\n       * @data {Boolean} [false] onParentResizerEmit\n       * @memberof resizerComponent\n       */\n      onParentResizerEmit: false,\n      /**\n       * The ResizeObserver\n       * @data {ResizeObserver} [null] resizerObserver\n       * @memberof resizerObserver\n       */\n      ResizerObserver: null,\n      /**\n       * The height.\n       * @data {Boolean} [false] lastKnownHeight\n       * @memberof resizerComponent\n       */\n      lastKnownHeight: false,\n      /**\n       * The width.\n       * @data {Boolean} [false] lastKnownWidth\n       * @memberof resizerComponent\n       */\n      lastKnownWidth: false,\n      /**\n       * The container height.\n       * @data {Boolean} [false] lastKnownCtHeight\n       * @memberof resizerComponent\n       */\n      lastKnownCtHeight: false,\n      /**\n       * The container width.\n       * @data {Boolean} [false] lastKnownCtWidth\n       * @memberof resizerComponent\n       */\n      lastKnownCtWidth: false,\n      /**\n       * Should be set to true during the resize execution.\n       * @data {Boolean} [false] isResizing\n       * @memberof resizerComponent\n       */\n      isResizing: false,\n      /**\n       * The live computedStyle object for the element.\n       * @data {Object} [null] computedStyle\n       * @memberof resizerComponent\n       */\n      computedStyle: null\n    };\n  },\n  computed: {\n    resizerObserved() {\n      return this.$el;\n    }\n  },\n  methods: {\n    isActiveResizer() {\n      let ct = this.closest('bbn-container');\n      if (ct) {\n        return ct.isVisible;\n      }\n\n      return true;\n    },\n    /**\n     * A function that can be executed just before the resize event is emitted.\n     * @method onResize\n     * @emit resize\n     * @memberof resizerComponent\n     */\n    onResize() {\n      let res = false;\n      //this.$forceUpdate();\n      if (this.$el.style.display !== 'none') {\n        // Setting initial dimensions\n        let ms2 = this.setContainerMeasures();\n        let ms1 = this.setResizeMeasures();\n        if (ms1 || ms2) {\n          //bbn.fn.log([\"DEFAULT ONRESIZE FN FROM \" + this.$options.name, ms1, ms2]);\n          res = true;\n        }\n      }\n\n      return res;\n    },\n    /**\n     * Sets the value of lastKnownHeight and lastKnownWidth basing on the current dimensions of width and height.\n     * @method setResizeMeasures \n     * @returns {Boolean}\n     */\n    setResizeMeasures() {\n      let resize = false;\n      let w = 0;\n      let h = 0;\n      const ele = this.resizerObserved;\n      if (ele) {\n        h = Math.round(ele.clientHeight);\n        w = Math.round(ele.clientWidth);\n        if (h && w) {\n          this.setComputedStyle();\n        }\n      }\n      \n      //bbn.fn.log(ele, h, Math.round(ele.clientHeight), ele.clientHeight, '----');\n      if (this.lastKnownHeight !== h) {\n        this.lastKnownHeight = h;\n        resize = true;\n      }\n      if (this.lastKnownWidth !== w) {\n        this.lastKnownWidth = w;\n        resize = true;\n      }\n\n      return resize;\n    },\n\n\n    setContainerMeasures() {\n      let resize = false;\n      let isAbsolute = this.computedStyle ? ['absolute', 'fixed'].includes(this.computedStyle.position) : false;\n      let offsetParent = this.$el.offsetParent;\n      let ctH;\n      let ctW;\n      if (this.parentResizer && this.parentResizer.lastKnownHeight) {\n        ctH = this.parentResizer.lastKnownHeight;\n        ctW = this.parentResizer.lastKnownWidth;\n      }\n      else if (offsetParent) {\n        ctH = isAbsolute ? bbn.fn.outerHeight(offsetParent) : Math.round(offsetParent.clientHeight);\n        ctW = isAbsolute ? bbn.fn.outerWidth(offsetParent) : Math.round(offsetParent.clientWidth);\n      }\n      else {\n        ctH = bbn.env.height;\n        ctW = bbn.env.width;\n      }\n      if (this.lastKnownCtHeight !== ctH) {\n        this.lastKnownCtHeight = ctH;\n        resize = true;\n      }\n      if (this.lastKnownCtWidth !== ctW) {\n        this.lastKnownCtWidth = ctW;\n        resize = true;\n      }\n\n      /*\n      if (resize) {\n        bbn.fn.log([\"SET CONTAINER ONRESIZE MEASURES\", this.$options.name, ctH, ctW, this.$parent]);\n      }\n      */\n\n      return resize;\n    },\n\n\n    getParentResizer(){\n      let parentResizer = this.closest(\".bbn-resize-emitter\");\n      // In case we have 2 comnponents in one\n      while (parentResizer && (parentResizer.onResize === undefined)) {\n        parentResizer = parentResizer.$parent;\n      }\n      return parentResizer?.onResize !== undefined ? parentResizer : false;\n    },\n\n\n    /**\n     * Defines the resize emitter and launches process when it resizes.\n     * @method setResizeEvent\n     * @fires onParentResizerEmit\n     * @memberof resizerComponent\n     */\n    setResizeEvent() {\n      if (!this.resizerObserver && this.resizerObserved) {\n        this.resizerObserver = new ResizeObserver((entries) => {\n          if (!this.isResizing) {\n            for (const entry of entries) {\n              if (entry.contentBoxSize?.[0]) {\n                this.onResize();\n              }\n              //bbn.fn.log(bbn._(\"RESIZEOBS from %s\", this.$options.name), entry.contentBoxSize);\n            }\n          }\n        });\n        this.resizerObserver.observe(this.resizerObserved);\n      }\n    },\n    /**\n     * Unsets the resize emitter.\n     * @method unsetResizeEvent\n     * @memberof resizerComponent\n     */\n    unsetResizeEvent() {\n      if (this.resizerObserver) {\n        this.resizerObserver.disconnect();\n        this.resizerObserver = null;\n      }\n    },\n    /**\n     * Emits the event resize on the closest parent resizer.\n     * @method selfEmit\n     * @memberof resizerComponent\n     * @param {Boolean} force \n     */  \n    selfEmit(force){\n      /*\n      if ( this.parentResizer ){\n        this.parentResizer.$emit(\"resize\", force);\n      }\n      */\n    },\n    formatSize(...args) {\n      return bbn.fn.formatSize(...args);\n    },\n    setComputedStyle(){\n      if (!this.computedStyle && this.$el && this.$el.clienttWidth) {\n        this.computedStyle = window.getComputedStyle(this.$el);\n      }\n    }\n  },\n  /**\n   * Adds the class 'bbn-resizer-component' to the component.\n   * @event created\n   * @memberof resizerComponent\n   */\n  created(){\n    this.componentClass.push('bbn-resizer-component');\n  },\n  /**\n   * Defines the resize emitter and emits the event ready.\n   * @event mounted\n   * @fires setResizeEvent\n   * @emits ready\n   * @memberof resizerComponent\n   */\n  mounted() {\n    if (!this.ready) {\n      this.$on('ready', this.setResizeEvent);\n    }\n    else {\n      this.setResizeEvent();\n    }\n  },\n  /**\n   * Unsets the resize emitter.\n   * @event beforeDestroy\n   * @fires unsetResizeEvent\n   * @memberof resizerComponent\n   */\n  beforeDestroy(){\n    this.unsetResizeEvent();\n  }\n};\n\n/* harmony default export */ const mixins_resizer = (resizer);\n\n;// CONCATENATED MODULE: ./src/mixins/serviceWorker.js\nconst serviceWorker = {\n  props: {},\n  data(){\n    return {\n      /**\n       * The registered channels list\n       * @data {Array} [[]] registeredChannels\n       * @memberof serviceWorkerComponent\n       */\n      registeredChannels: [],\n      /**\n       * The primary channel\n       * @data {String} [''] primaryChannel\n       * @memberof serviceWorkerComponent\n       */\n    }\n  },\n  methods: {\n    /**\n     * Registers a channel\n     * @method registerChannel\n     * @memberof serviceWorkerComponent\n     * @param {String} channel\n     * @fires _postMessage\n     * @return {Boolean}\n     */\n    registerChannel(channel, primary){\n      if (!this.registeredChannels.includes(channel)\n        && this._postMessage({\n          type: 'registerChannel',\n          channel: channel\n        })\n      ) {\n        this.registeredChannels.push(channel);\n        if (primary) {\n          this.primaryChannel = channel;\n        }\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Unregisters a channel\n     * @method unregisterChannel\n     * @memberof serviceWorkerComponent\n     * @param {String} channel\n     * @fires _postMessage\n     * @return {Boolean}\n     */\n    unregisterChannel(channel){\n      if (this.registeredChannels.includes(channel)\n        && this._postMessage({\n          type: 'unregisterChannel',\n          channel: channel\n        })\n      ) {\n        this.registeredChannels.splice(this.registeredChannels.indexOf(channel), 1);\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Sends a message to a channel\n     * @method messageChannel\n     * @memberof serviceWorkerComponent\n     * @param {String} channel\n     * @param {Object} data\n     * @fires _postMessage\n     * @return {Boolean}\n     */\n    messageChannel(channel, data){\n      if (this.registeredChannels.includes(channel)\n        && this._postMessage({\n          type: 'messageChannel',\n          channel: channel,\n          data: this._encodeMessageData(data)\n        })\n      ) {\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Receives data from a channel\n     * @method messageFromChannel\n     * @memberof serviceWorkerComponent\n     * @param {Object} data\n     */\n    messageFromChannel(data){\n      data = this._decodeMessageData(data);\n      if (data.function){\n        if (bbn.fn.isFunction(data.function)) {\n          data.function(...(data.params || []));\n        }\n        else if (bbn.fn.isFunction(this[data.function])) {\n          this[data.function](...(data.params || []));\n        }\n      }\n    },\n    /**\n     * Emits messageToChannel event\n     * @method messageToChannel\n     * @memberof serviceWorkerComponent\n     * @param {Object} data\n     * @param {String} channel\n     * @emit messageToChannel\n     */\n    messageToChannel(data, channel){\n      this.$emit('messagetochannel', data, channel);\n    },\n    /**\n     * @method _checkSW\n     * @memberof serviceWorkerComponent\n     * @return {Boolean}\n     */\n    _checkSW(){\n      if ('serviceWorker' in navigator) {\n        if (navigator.serviceWorker.controller) {\n          return navigator.serviceWorker.controller.state !== 'redundant';\n        }\n        else {\n          bbn.fn.info(\"NO CONTROLLER FOR SW\");\n        }\n      }\n      else {\n        bbn.fn.info(\"NO SW\");\n      }\n      return false;\n    },\n    /**\n     * Postes the message to the service worker\n     * @method _postMessage\n     * @memberof serviceWorkerComponent\n     * @param {Object}\n     * @fires _checkSW\n     * @return {Boolean}\n     */\n    _postMessage(obj){\n      if (this._checkSW()) {\n        navigator.serviceWorker.controller.postMessage(obj);\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Encodes the data of the message\n     * @method _encodeMessageData\n     * @memberof serviceWorkerComponent\n     * @param {Object} data\n     * @return {String}\n     */\n    _encodeMessageData(data){\n      return JSON.stringify(data, (k, d) => bbn.fn.isFunction(d) ? '/Function(' + d.toString() + ')/' : d);\n    },\n    /**\n     * Decodes the data of the message\n     * @method _decodeMessageData\n     * @memberof serviceWorkerComponent\n     * @param {String} data\n     * @return {Object}\n     */\n    _decodeMessageData(data){\n      return JSON.parse(data, (k, d) => {\n        if (bbn.fn.isString(d)\n          && d.startsWith('/Function(')\n          && d.endsWith(')/')\n        ) {\n          d = d.substring(10, d.length - 2);\n          return (0, eval)('(' + d + ')');\n        }\n        return d;\n      })\n    }\n  },\n  /**\n   * Adds the class 'bbn-service-worker-component' to the component.\n   * @event created\n   * @memberof serviceWorkerComponent\n   */\n    created(){\n    this.componentClass.push('bbn-service-worker-component');\n  },\n};\n\n/* harmony default export */ const mixins_serviceWorker = (serviceWorker);\n\n;// CONCATENATED MODULE: ./src/mixins/toggle.js\nconst toggle = {\n  props: {\n    /**\n     * True if the component has to be visible.\n     * @memberof toggleComponent\n     * @prop {Boolean} [false] true\n     */\n    visible: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * True to focus the component.\n     * @memberof toggleComponent\n     * @prop {Boolean} [true] focused\n     */\n    focused: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data(){\n    return {\n      /**\n       * If an element is focused it returns it.\n       * @data {Element} prevFocused\n       * @memberof toggleComponent\n       */\n      prevFocused: bbn.env.focused,\n      /**\n       * Whether or not the component is currently visible.\n       * @memberof toggleComponent\n       * @data {Boolean} currentVisible\n       */\n      currentVisible: this.visible,\n      /**\n       * The focusable element.\n       * @memberof toggleComponent\n       * @data {HTMLElement} [null] focusable\n       */\n      focusable: null,\n      /**\n       * True when the component has been opened.\n       * @memberof toggleComponent\n       * @data hasBeenOpened {Boolean} [false]\n       */\n      hasBeenOpened: false\n    };\n  },\n  methods: {\n    /**\n     * Shows the slider.\n     * @method show\n     * @fires onResize\n     * @emits show      \n     */\n    show(){\n      let e = new Event('beforeshow', {cancelable: true});\n      this.$emit('beforeshow', e);\n      if (!e.defaultPrevented) {\n        this.currentVisible = true;\n      }\n    },\n    /**\n     * Hides the slider.\n     * @method hide\n     * @emits hide      \n     */\n    hide(){\n      let e = new Event('beforehide', {cancelable: true});\n      this.$emit('beforehide', e);\n      if (!e.defaultPrevented) {\n        this.currentVisible = false;\n      }\n    },\n    /**\n     * Toggles the slider.\n     * @method toggle\n     */\n    toggle(){\n      if (this.currentVisible) {\n        this.hide();\n      }\n      else{\n        this.show();\n      }\n    },\n    /**\n     * Change the focused element.\n     * @param {boolean} v\n     * @memberof toggleComponent \n     */\n    switchFocus(v){\n      if ( this.focused ){\n        if ( v ){\n          if ( this.focusable && this.focusable.focus ){\n            this.focusable.focus();\n          }\n          else if (this.$el && this.$el.focus) {\n            this.$el.focus();\n          }\n        }\n        else if ( this.prevFocused && this.prevFocused.focus ){\n          this.prevFocused.focus();\n        }\n      }\n    },\n    changeVisible(v) {\n      if ( v ){\n        if ( !this.hasBeenOpened ){\n          this.hasBeenOpened = true;\n        }\n        if ( bbn.env.focused && (bbn.env.focused !== this.prevFocused) ){\n          this.prevFocused = bbn.env.focused;\n        }\n      }\n      /*\n      if ( this.onResize !== undefined ){\n        if ( v ){\n          this.onResize();\n        }\n        else{\n          this.isResized = false;\n        }\n      }\n      */\n      this.switchFocus(v);\n    }\n  },\n  /**\n   * If not defined, defines the focusable element.\n   * @event mounted\n   * @memberof focusComponent\n   */\n  mounted(){\n    this.$nextTick(() => {\n      if ( !this.focusable ){\n        this.focusable = this.$el;\n      }\n      if ( this.currentVisible && this.focused ){\n        this.switchFocus(true);\n      }\n    });\n  },\n  /**\n   * Returns the focus on the previously focused element.\n   * @event beforeDestroy\n   * @memberof focusComponent\n   */\n  beforeDestroy(){\n    if (!bbn.fn.isMobile()) {\n      this.switchFocus(false);\n    }\n  },\n  watch: {\n    /**\n     * Emits the event 'open' or 'close'\n     * @watch currentVisible\n     * @param {Boolean} v \n     * @emits open\n     * @emits close\n     * @fires switchFocus\n     * @memberof toggleComponent\n     */\n    currentVisible: {\n      handler(v) {\n        this.$emit(v ? 'show' : 'hide');\n        this.changeVisible(v);\n      },\n      immediate: true\n    }\n  }\n};\n\n/* harmony default export */ const mixins_toggle = (toggle);\n\n;// CONCATENATED MODULE: ./src/mixins/url.js\nconst url = {\n  props: {\n    /** \n     * The baseUrl.\n     * @prop {String} baseUrl\n     * @memberof urlComponent\n     */\n    baseUrl: {\n      type: String\n    }\n  },\n  data(){\n    return {\n      /**\n       * @data currentURL\n       * @memberof urlComponent\n       */\n      currentURL: null,\n      /**\n       * @data title\n       * @memberof urlComponent\n       */\n      title: null\n    }\n  },\n  methods: {\n    /**\n     * Updates the url.\n     * @method updateUrl\n     * @memberof urlComponent\n     */\n    updateUrl(){\n      if ( this.baseUrl && (bbn.env.path.indexOf(this.baseUrl) === 0) && (bbn.env.path.length > (this.baseUrl.length + 1)) ){\n        let url = this.baseUrl + (this.currentURL ? '/' + this.currentURL : '');\n        bbn.fn.setNavigationVars(\n          url,\n          (this.currentURL ? bbn.fn.getField(this.source, this.sourceText, this.sourceValue, this.currentURL) + ' < ' : '') + document.title,\n          {\n            script: () => {\n              //bbn.fn.log(\"updateUrl & EXEC SCRIPT\");\n              let idx = bbn.fn.search(this.source, this.sourceValue, this.currentURL);\n              if ( idx > -1 ){\n                this.widget.select(idx);\n                this.widget.trigger(\"change\");\n              }\n            }\n          },\n          !this.ready)\n      }\n    }\n  },\n  /**\n   * Adds the class 'bbn-url-component' to the component\n   * @event created \n   * @memberof urlComponent\n   */\n  created(){\n    this.componentClass.push('bbn-url-component');\n  },\n};\n\n/* harmony default export */ const mixins_url = (url);\n\n;// CONCATENATED MODULE: ./src/mixins/view.js\n\n\nconst view = {\n  props: {\n    /**\n     * The source of the component.\n     * @prop {Object|Function} source\n     * @memberof viewComponent\n     */\n    source: {\n      type: [Array, Object, String, Function],\n    },\n    /**\n     * The title of the component.\n     * @prop {String|Number} ['Untitled'] title\n     * @memberof viewComponent\n     */\n    title: {\n      type: [String, Number],\n      default: bbn._(\"Untitled\")\n    },\n    /**\n     * The options object of the component.\n     * @prop {Object} options\n     * @memberof viewComponent\n     */\n    options: {\n      type: Object,\n      default(){\n        return {}\n      }\n    },\n    /**\n     * Defines if the component has to be cached.\n     * @prop {Boolean} [false] cached\n     * @memberof viewComponent\n     */\n    cached: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines if the component has to be scrollable.\n     * @prop {Boolean} [true] scrollable\n     * @memberof viewComponent\n     */\n    scrollable: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines the component to use.\n     * @prop component\n     * @memberof viewComponent\n     */\n    component: {\n      type: [String, Object, Function]\n    },\n    /**\n     * Defines the icon.\n     * @prop {String|Boolean} icon\n     * @memberof viewComponent\n     */\n    icon: {\n      type: [String, Boolean],\n    },\n    /**\n     * Defines if the component can have a text.\n     * @prop {Boolean} [false] notext\n     * @memberof viewComponent\n     */\n    notext: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines the component's content.\n     * @prop {String} [''] content\n     * @memberof viewComponent\n     */\n    content: {\n      type: String,\n      default: \"\"\n    },\n    /**\n     * Defines the menu.\n     * @prop {Array|Function} menu\n     * @memberof viewComponent\n     */\n    menu: {\n      type: [Array, Function, Boolean]\n    },\n    /**\n     * Defines if the component is loaded.\n     * @prop {Boolean} loaded\n     * @memberof viewComponent\n     */\n    loaded: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Tells if the component is currently loading.\n     * @prop {Boolean} loading\n     * @memberof viewComponent\n     */\n    loading: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines the component's fcolor.\n     * @prop {String} fcolor\n     * @memberof viewComponent\n     */\n    fcolor: {\n      type: String\n    },\n    /**\n     * Defines the component's bcolor.\n     * @prop {String} bcolor\n     * @memberof viewComponent\n     */\n    bcolor: {\n      type: String\n    },\n    /**\n     * @prop {Boolean} [false] load\n     * @memberof viewComponent\n     */\n    load: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Defines if the component has to be selected.\n     * @prop {Boolean|Number} [false] selected\n     * @memberof viewComponent\n     */\n    selected: {\n      type: [Boolean, Number],\n      default: false\n    },\n    /**\n     * Defines the css string for the component.\n     * @prop {String} [''] css\n     * @memberof viewComponent\n     */\n    css: {\n      type: String,\n      default: \"\"\n    },\n    /**\n     * @prop {String|bbnCp} advert\n     * @memberof viewComponent\n     */\n    advert: {\n      type: [String, Cp[\"default\"]]\n    },\n    /**\n     * @prop {String} help\n     * @memberof viewComponent\n     */\n    help: {\n      type: String\n    },\n    /**\n     * @prop {Array} imessages\n     * @memberof viewComponent\n     */\n    imessages: {\n      type: [Array, Function],\n      default() {\n        return []\n      }\n    },\n    /**\n     * @prop script\n     * @memberof viewComponent\n     */\n    script: {},\n    /**\n     * Defines if the component has to be static.\n     * @prop {Boolean|Number} [false] static\n     * @memberof viewComponent\n     */\n    static: {\n      type: [Boolean, Number],\n      default: false\n    },\n    /**\n     * Defines\n     if the component has to be pinned.\n      * @prop {Boolean|Number} [false] pinned\n      * @memberof viewComponent\n      */\n    pinned: {\n      type: [Boolean, Number],\n      default: false\n    },\n    /**\n     * Defines the url.\n     * @prop {String|Number} url\n     * @memberof viewComponent\n     */\n    url: {\n      type: [String, Number]\n    },\n    /**\n     * @prop current\n     * @prop {String|Number} current\n     * @memberof viewComponent\n     */\n    current: {\n      type: [String, Number]\n    },\n    /**\n     * @prop {Boolean} [true] real\n     * @memberof viewComponent\n     */\n    real: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * The object of configuration for the component\n     * @prop {Object} cfg\n     * @memberof viewComponent\n     */\n    cfg: {\n      type: Object\n    },\n    /**\n     * @prop {Object} events\n     * @memberof viewComponent\n     */\n    events: {\n      type: Object,\n      default(){\n        return {}\n      }\n    },\n    /**\n     * Defines if the component is disabled.\n     * @prop {Boolean} [false] disabled\n     */\n    disabled: {\n      type: [Boolean, Function],\n      default: false\n    },\n    /**\n     * Defines if the component is hidden.\n     * @prop {Boolean} [false] hidden\n     */\n    hidden: {\n      type: [Boolean, Function],\n      default: false\n    }\n  }\n};\n\n/* harmony default export */ const mixins_view = (view);\n\n;// CONCATENATED MODULE: ./src/directives/draggable.js\n/* harmony default export */ function draggable() {\n  var isDragging = false;\n  var currentEle = false;\n\n  const fnClick = e => {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n  };\n\n  const fnDrag = e => {\n    drag(e, currentEle);\n  };\n\n  const fnEnd = e => {\n    endDrag(e, currentEle);\n    document.removeEventListener('mousemove', fnDrag);\n    setTimeout(() => {\n      document.removeEventListener('click', fnClick, {once: true, capture: true});\n    }, 100);\n    isDragging = false;\n  };\n\n  const fnUp = () => {\n    isDragging = false;\n  };\n\n  const startDrag = (e, ele) => {\n    if (!!ele.bbnDirectives.draggable.active\n      && !isDragging\n    ) {\n      isDragging = true;\n      currentEle = ele;\n      var options = ele.bbnDirectives.draggable.options;\n      let ev = new CustomEvent('dragstart', {\n        cancelable: true,\n        bubbles: true,\n        detail: options\n      });\n      ele.dispatchEvent(ev);\n      if (!ev.defaultPrevented) {\n        ev.stopImmediatePropagation();\n        let isMove = !!options.mode && (options.mode === 'move'),\n            isSelf = !!options.mode && (options.mode === 'self'),\n            helper = isMove ? false : (isSelf ? ele : ele.cloneNode(true)),\n            rect = ele.getBoundingClientRect();\n        options.originalElement = ele;\n        options.originalParent = ele.parentElement;\n        options.originalNextElement = ele.nextElementSibling;\n        options.helper = options.helperElement || ele;\n        if (!options.container) {\n          options.container = bbn.fn.isDom(options.originalParent) ? options.originalParent : document.body;\n        }\n        if (!isMove) {\n          if (options.component) {\n            helper = document.createElement('component');\n            helper.setAttribute(bbn.fn.isString(options.component) ? 'is' : ':is', options.component);\n            if (bbn.fn.isObject(options)\n              && bbn.fn.isObject(options.componentOptions)\n            ) {\n              helper.setAttribute('v-bind', JSON.stringify(options.componentOptions));\n            }\n          }\n          if (!!options.helperElement) {\n            rect = options.helperElement.getBoundingClientRect();\n            helper = isSelf ? options.helperElement : options.helperElement.cloneNode(true)\n          }\n          options.helper = document.createElement('div');\n          options.helper.setAttribute('id', 'bbn-draggable-current');\n          options.helper[isSelf ? 'appendChild' : 'append'](helper);\n          options.helper.style.left = e.pageX + 'px';\n          options.helper.style.top = e.pageY + 'px';\n          options.helper.style.position = 'fixed';\n          options.helper.style.zIndex = '1000';\n          options.helper.style.opacity = 0.7;\n          options.helper.style.width = rect.width + 'px';\n          options.helper.style.height = rect.height + 'px';\n          options.container[isSelf ? 'appendChild' : 'append'](options.helper);\n          //bbn.cp.createApp(document.querySelector('#bbn-draggable-current > *'));\n        }\n        ele.bbnDirectives.draggable.pointerEvents = window.getComputedStyle(options.helper).pointerEvents;\n        options.helper.style.pointerEvents = 'none';\n        document.addEventListener('click', fnClick, {once: true, capture: true});\n        document.addEventListener('mouseup', fnEnd, {once: true});\n        document.addEventListener('mousemove', fnDrag);\n      }\n    }\n  };\n\n  const drag = (e, ele) => {\n    if (!!ele.bbnDirectives.draggable.active) {\n      // we prevent default from the event\n      e.stopImmediatePropagation();\n      e.preventDefault();\n      var options = ele.bbnDirectives.draggable.options;\n      if (options.mode === 'move') {\n        let rectContainer = options.container.getBoundingClientRect(),\n            rectHelper = options.helper.getBoundingClientRect(),\n            rectEle = ele.getBoundingClientRect(),\n            x = bbn.fn.roundDecimal(e.x, 0),\n            y = bbn.fn.roundDecimal(e.y, 0),\n            minLeft = bbn.fn.roundDecimal(-rectHelper.width + (rectHelper.right - rectEle.right) + 20, 0),\n            minLeftPos = bbn.fn.roundDecimal(rectContainer.left + minLeft - (rectEle.left - rectHelper.left), 0),\n            maxLeft = bbn.fn.roundDecimal(rectContainer.width - (rectEle.left - rectHelper.left) - 20, 0),\n            maxLeftPos = bbn.fn.roundDecimal((rectEle.left + rectEle.width - rectHelper.left) + rectContainer.left + maxLeft, 0),\n            minTop = bbn.fn.roundDecimal(-rectHelper.height + (rectHelper.bottom - rectEle.bottom) + 20, 0),\n            minTopPos = bbn.fn.roundDecimal(rectContainer.top + minTop - (rectEle.top - rectHelper.top), 0),\n            maxTop = bbn.fn.roundDecimal(rectContainer.height - (rectEle.top - rectHelper.top) - 20, 0),\n            maxTopPos = bbn.fn.roundDecimal((rectEle.top + rectEle.height - rectHelper.top) + rectContainer.top + maxTop, 0),\n            left = options.helper.offsetLeft - (ele.bbnDirectives.draggable.mouseX - x),\n            top = options.helper.offsetTop - (ele.bbnDirectives.draggable.mouseY - y);\n\n        if ((x < minLeftPos) || (options.helper.offsetLeft < minLeft)) {\n          left = minLeft;\n        }\n        else if ((options.helper.offsetLeft > maxLeft)\n          || ((x > (maxLeftPos - 20))\n            && (options.helper.offsetLeft === maxLeft)\n          )\n        ) {\n          left = maxLeft;\n        }\n        if ((y < minTopPos) || (options.helper.offsetTop < minTop)) {\n          top = minTop;\n        }\n        else if ((options.helper.offsetTop > maxTop)\n          || ((y > (maxTopPos - 20))\n            && (options.helper.offsetTop === maxTop)\n          )\n        ) {\n          top = maxTop;\n        }\n        if ((options.helper.offsetLeft === minLeft)) {\n          if (ele.bbnDirectives.draggable.mouseMinX === undefined) {\n            ele.bbnDirectives.draggable.mouseMinX = x;\n          }\n          else if (x >= minLeftPos) {\n            if (x >= ele.bbnDirectives.draggable.mouseMinX) {\n              delete ele.bbnDirectives.draggable.mouseMinX;\n            }\n            else {\n              left = minLeft;\n            }\n          }\n        }\n        if ((options.helper.offsetLeft === maxLeft)) {\n          if (ele.bbnDirectives.draggable.mouseMaxX === undefined) {\n            ele.bbnDirectives.draggable.mouseMaxX = x;\n          }\n          else if (x <= maxLeftPos) {\n            if (x <= ele.bbnDirectives.draggable.mouseMaxX) {\n              delete ele.bbnDirectives.draggable.mouseMaxX;\n            }\n            else {\n              left = maxLeft;\n            }\n          }\n        }\n        if ((options.helper.offsetTop === minTop)) {\n          if (ele.bbnDirectives.draggable.mouseMinY === undefined) {\n            ele.bbnDirectives.draggable.mouseMinY = y;\n          }\n          else if (y >= minTopPos) {\n            if (y >= ele.bbnDirectives.draggable.mouseMinY) {\n              delete ele.bbnDirectives.draggable.mouseMinY;\n            }\n            else {\n              top = minTop;\n            }\n          }\n        }\n        if ((options.helper.offsetTop === maxTop)) {\n          if (ele.bbnDirectives.draggable.mouseMaxY === undefined) {\n            ele.bbnDirectives.draggable.mouseMaxY = y;\n          }\n          else if (y <= maxTopPos) {\n            if (y <= ele.bbnDirectives.draggable.mouseMaxY) {\n              delete ele.bbnDirectives.draggable.mouseMaxY;\n            }\n            else {\n              top = maxTop;\n            }\n          }\n        }\n        if (left < minLeft) {\n          left = minLeft;\n        }\n        if (top < minTop) {\n          top = minTop;\n        }\n        if (left > maxLeft) {\n          left = maxLeft;\n        }\n        if (top > maxTop) {\n          top = maxTop;\n        }\n        options.helper.style.left = left + 'px';\n        options.helper.style.top = top + 'px';\n        let style = window.getComputedStyle(options.helper);\n        if ((style.position !== 'absolute')\n          && (style.position !== 'fixed')\n        ) {\n          options.helper.style.position = 'absolute';\n        }\n        ele.bbnDirectives.draggable.mouseX = x;\n        ele.bbnDirectives.draggable.mouseY = y;\n      }\n      else {\n        options.helper.style.left = e.pageX + 'px';\n        options.helper.style.top = e.pageY + 'px';\n      }\n      let scroll = e.target.closest('.bbn-scroll');\n          options.scroll = !!scroll && (scroll.bbn !== undefined) ? scroll.bbn : false;\n      if (!!options.scroll\n        && (options.scroll.hasScrollY || options.scroll.hasScrollX)\n        && !options.scroll.isScrolling\n      ) {\n        let getDiff = axis => {\n          let coord = options.scroll.$el.getBoundingClientRect(),\n              client = 'client' + axis.toUpperCase(),\n              dim = axis === 'y' ? 'height' : 'width',\n              step = Math.ceil(coord[dim] / 20),\n              margin = step * 4,\n              diff = 0;\n          if (e[client] < (coord[axis] + margin)) {\n            diff = e[client] - coord[axis] - margin;\n          }\n          else if (e[client] > (coord[axis] + coord[dim] - margin)) {\n            diff = e[client] - (coord[axis] + coord[dim] - margin);\n          }\n          if (diff) {\n            let approachLevel = Math.round(diff/step);\n            return Math.round(options.scroll.$el['offset' + dim.charAt(0).toUpperCase() + dim.slice(1)] / 5) * approachLevel + 1;\n          }\n        };\n        if (options.scroll.hasScrollY) {\n          let diff = getDiff('y');\n          if (diff) {\n            options.scroll.addVertical(diff);\n          }\n        }\n        if (options.scroll.hasScrollX) {\n          let diff = getDiff('x');\n          if (diff) {\n            options.scroll.addHorizontal(diff);\n          }\n        }\n      }\n      if (options.mode !== 'move') {\n        let target = e.target;\n        if (target.dataset.bbn_droppable !== 'true') {\n          target = target.closest('[data-bbn_droppable=true]');\n        }\n        if (target\n          && (target !== ele)\n          && !target.classList.contains('bbn-undroppable')\n          && !!target.bbnDirectives?.droppable?.active\n        ) {\n          let ev = new CustomEvent('dragoverdroppable', {\n            cancelable: true,\n            bubbles: true,\n            detail: options\n          });\n          target.dispatchEvent(ev)\n        }\n      }\n    }\n  };\n\n  const endDrag = (e, ele) => {\n    if (!!ele.bbnDirectives.draggable.active\n      && isDragging\n    ) {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      var options = ele.bbnDirectives.draggable.options;\n      options.helper.style.pointerEvents = ele.bbnDirectives.draggable.pointerEvents;\n      let target = options.mode !== 'move' ? e.target : false;\n      if (bbn.fn.isDom(target)\n        && (target.dataset.bbn_droppable_over !== 'true')\n      ) {\n        target = target.closest('[data-bbn_droppable_over=true]');\n      }\n      if (bbn.fn.isDom(target)\n        && !target.classList.contains('bbn-undroppable')\n        && !!target.bbnDirectives?.droppable?.active\n      ) {\n        let ev = new CustomEvent('beforedrop', {\n          cancelable: true,\n          bubbles: true,\n          detail: options\n        });\n        target.dispatchEvent(ev);\n      }\n      else {\n        let ev = new CustomEvent('dragend', {\n          cancelable: true,\n          bubbles: true,\n          detail: options\n        });\n        ele.dispatchEvent(ev);\n        if (!ev.defaultPrevented) {\n          if (!!options.mode && (options.mode === 'self')) {\n            options.originalParent.insertBefore(options.originalElement, options.originalNextElement);\n          }\n        }\n      }\n      document.removeEventListener('click', fnClick, {once: true, capture: true});\n      document.removeEventListener('mouseup', fnEnd, {once: true});\n      document.removeEventListener('mousemove', fnDrag);\n      document.removeEventListener('mouseup', fnUp, {once: true});\n      if (options.mode !== 'move') {\n        options.helper.remove();\n      }\n      else {\n        delete ele.bbnDirectives.draggable.mouseX;\n        delete ele.bbnDirectives.draggable.mouseY;\n        delete ele.bbnDirectives.draggable.mouseMinX;\n        delete ele.bbnDirectives.draggable.mouseMaxX;\n        delete ele.bbnDirectives.draggable.mouseMinY;\n        delete ele.bbnDirectives.draggable.mouseMaxY;\n      }\n    }\n  };\n\n  const inserted = (el, binding) => {\n    //bbn.fn.warning(\"DRAGGABLE INSERTED\");\n    if (analyzeValue(el, binding)) {\n      // Add the events listener to capture the long press click and start the drag\n      let clickTimeout = 0,\n          holdClick = false;\n      el.bbnDirectives.draggable.onmousedown = ev => {\n        if (!!el.bbnDirectives.draggable.active) {\n          el.bbnDirectives.draggable.mouseX = ev.x;\n          el.bbnDirectives.draggable.mouseY = ev.y;\n          if (clickTimeout) {\n            clearTimeout(clickTimeout);\n          }\n          if (ev.button === 0) {\n            holdClick = true;\n            clickTimeout = setTimeout(() => {\n              if (holdClick) {\n                startDrag(ev, el);\n              }\n            }, 150);\n          }\n        }\n      };\n      el.addEventListener('mousedown', el.bbnDirectives.draggable.onmousedown);\n      el.bbnDirectives.draggable.onmouseup = ev => {\n        if (!!el.bbnDirectives.draggable.active) {\n          holdClick = false;\n        }\n      };\n      el.addEventListener('mouseup', el.bbnDirectives.draggable.onmouseup);\n    }\n  };\n\n  const analyzeValue = (el, binding)  => {\n    if (el.bbnDirectives === undefined) {\n      el.bbnDirectives = bbn.fn.createObject();\n    }\n    if (el.bbnDirectives.draggable === undefined) {\n      el.bbnDirectives.draggable = bbn.fn.createObject();\n    }\n    if ((binding.value !== false)\n      && !el.classList.contains('bbn-undraggable')\n    ) {\n      el.dataset.bbn_draggable = true;\n      el.bbnDirectives.draggable = bbn.fn.createObject({\n        active: true\n      });\n      if (!el.classList.contains('bbn-draggable')) {\n        el.classList.add('bbn-draggable');\n      }\n      let options = bbn.fn.createObject(),\n          asArg = !!binding.arg && binding.arg.length,\n          asMods = bbn.fn.isArray(binding.modifiers) && binding.modifiers.length,\n          asComponentFromMods = asMods && binding.modifiers.includes('component'),\n          asContainerFromMods = asMods && binding.modifiers.includes('container'),\n          asModeFromMods = asMods && binding.modifiers.includes('mode'),\n          asDataFromMods = asMods && binding.modifiers.includes('data'),\n          asHelperFromMods = asMods && binding.modifiers.includes('helper'),\n          component = false,\n          container = false,\n          mode = 'clone',\n          data = bbn.fn.createObject(),\n          helper = false;\n\n      if (asArg) {\n        switch (binding.arg) {\n          case 'component':\n            component = binding.value;\n            break;\n          case 'container':\n            container = binding.value;\n            break;\n          case 'data':\n            data = binding.value;\n            break;\n          case 'mode':\n            mode = binding.value;\n            break;\n          case 'helper':\n            helper = binding.value;\n            break;\n        }\n      }\n      else {\n        if (bbn.fn.isObject(binding.value)) {\n          options = binding.value;\n          if (asComponentFromMods) {\n            if ((options.component === undefined)\n              || (bbn.fn.isObject(options.component)\n                && !bbn.fn.numProperties(options.component))\n              || (bbn.fn.isString(options.component)\n                && !options.component.length)\n            ) {\n              bbn.fn.error(bbn._('No \"component\" property found'));\n              throw bbn._('No \"component\" property found');\n            }\n            component = options.component;\n          }\n          if (asContainerFromMods) {\n            if ((options.container === undefined)\n              || !bbn.fn.isDom(options.container)\n            ) {\n              bbn.fn.error(bbn._('No \"container\" property found or not a DOM element'));\n              throw bbn._('No \"container\" property found or not a DOM element');\n            }\n            container = options.container;\n          }\n          if (asDataFromMods) {\n            if ((options.data === undefined)\n              || !bbn.fn.isObject(options.data)\n            ) {\n              bbn.fn.error(bbn._('No \"data\" property found or not an object'));\n              throw bbn._('No \"data\" property found or not an object');\n            }\n            data = options.data;\n          }\n          if (asModeFromMods) {\n            if ((options.mode === undefined)\n              || !bbn.fn.isString(options.mode)\n            ) {\n              bbn.fn.error(bbn._('No \"mode\" property found or not a string'));\n              throw bbn._('No \"mode\" property found or not a string');\n            }\n            mode = options.mode;\n          }\n          if (asHelperFromMods) {\n            if ((options.helper === undefined)\n              || (!bbn.fn.isString(options.helper)\n                && !bbn.fn.isDom(options.helper))\n            ) {\n              bbn.fn.error(bbn._('No \"helper\" property found or not a string or not a DOM element'));\n              throw bbn._('No \"helper\" property found or not a string or not a DOM element');\n            }\n            helper = options.helper;\n          }\n        }\n        else if (bbn.fn.isString(binding.value)) {\n          switch (binding.value) {\n            case 'clone':\n            case 'move':\n            case 'self':\n              mode = binding.value;\n              break;\n            default:\n              // The helper is a component name\n              component = binding.value;\n              break;\n          }\n        }\n      }\n      if (component) {\n        options.component = component;\n      }\n      options.container = container;\n      options.data = data;\n      options.mode = mode;\n      if (helper) {\n        options.helperElement = helper;\n      }\n      el.bbnDirectives.draggable.options = options;\n      return true;\n    }\n    else {\n      el.dataset.bbn_draggable = false;\n      el.bbnDirectives.draggable = bbn.fn.createObject({\n        active: false\n      });\n      return false;\n    }\n  };\n\n  const setOff = el => {\n    el.dataset.bbn_draggable = false;\n    if (el.bbnDirectives.draggable === undefined) {\n      el.bbnDirectives.draggable = bbn.fn.createObject();\n    }\n    if (!!el.bbnDirectives.draggable.active) {\n      if (bbn.fn.isFunction(el.bbnDirectives.draggable.onmousedown)) {\n        el.removeEventListener('mousedown', el.bbnDirectives.draggable.onmousedown);\n      }\n      if (bbn.fn.isFunction(el.bbnDirectives.draggable.onmouseup)) {\n        el.removeEventListener('mouseup', el.bbnDirectives.draggable.onmouseup);\n      }\n    }\n    el.bbnDirectives.draggable = bbn.fn.createObject({\n      active: false\n    });\n    if (el.classList.contains('bbn-draggable')) {\n      el.classList.remove('bbn-draggable');\n    }\n  };\n\n  bbn.cp.directives['bbn-draggable'] = bbn.fn.createObject({\n    inserted: inserted,\n    update: (el, binding) => {\n      //bbn.fn.warning(\"DRAGGABLE UPDATED\");\n      if ((binding.value !== false)\n        && !el.classList.contains('bbn-undraggable')\n      ) {\n        if (binding.oldValue === false) {\n          inserted(el, binding);\n        }\n        else if (!isDragging){\n          analyzeValue(el, binding);\n        }\n      }\n      else {\n        setOff(el);\n      }\n    }\n  });\n};\n\n;// CONCATENATED MODULE: ./src/directives/droppable.js\n/* harmony default export */ function droppable() {\n  var dragOver = false;\n  var mouseOver = false;\n\n  const inserted = (el, binding) => {\n    if (analyzeValue(el, binding)) {\n      el.bbnDirectives.droppable.onmouseenter = e => {\n        if (!!el.bbnDirectives.droppable.active) {\n          mouseOver = true;\n        }\n      };\n      el.addEventListener('mouseenter', el.bbnDirectives.droppable.onmouseenter);\n      el.bbnDirectives.droppable.onmouseleave = e => {\n        if (!!el.bbnDirectives.droppable.active) {\n          let ev = new CustomEvent('dragleave', {\n            cancelable: true,\n            bubbles: true,\n            detail: dragOver\n          });\n          mouseOver = false;\n          dragOver = false;\n          el.dispatchEvent(ev);\n          if (!ev.defaultPrevented) {\n            if (el.classList.contains('bbn-droppable-over')) {\n              el.classList.remove('bbn-droppable-over');\n            }\n\n            el.bbnDirectives.droppable.over = false;\n            delete el.dataset.bbn_droppable_over;\n          }\n        }\n      };\n      el.addEventListener('mouseleave', el.bbnDirectives.droppable.onmouseleave);\n      el.bbnDirectives.droppable.ondragoverdroppable = e => {\n        if (!!el.bbnDirectives.droppable.active\n          && !e.defaultPrevented\n          && !dragOver\n          && !!mouseOver\n        ) {\n          dragOver = bbn.fn.createObject({\n            from: e.detail,\n            to: el.bbnDirectives.droppable.options\n          });\n          let ev = new CustomEvent('dragover', {\n            cancelable: true,\n            bubbles: true,\n            detail: dragOver\n          });\n          el.dispatchEvent(ev);\n          if (!ev.defaultPrevented) {\n            if (!el.classList.contains('bbn-droppable-over')) {\n              el.classList.add('bbn-droppable-over');\n            }\n\n            el.bbnDirectives.droppable.over = true;\n            el.dataset.bbn_droppable_over = true;\n          }\n        }\n      };\n      el.addEventListener('dragoverdroppable', el.bbnDirectives.droppable.ondragoverdroppable);\n      el.bbnDirectives.droppable.onbeforedrop = e => {\n        if (!!el.bbnDirectives.droppable.active) {\n          if (el.classList.contains('bbn-droppable-over')) {\n            el.classList.remove('bbn-droppable-over');\n          }\n          if (!e.defaultPrevented && !!dragOver) {\n            let ev = new CustomEvent('drop', {\n              cancelable: true,\n              bubbles: true,\n              detail: dragOver\n            });\n            el.dispatchEvent(ev);\n            if (!ev.defaultPrevented) {\n              el.appendChild(e.detail.originalElement);\n            }\n            else {\n              let ev = new CustomEvent('dragend', {\n                cancelable: true,\n                bubbles: true,\n                detail: dragOver\n              });\n              e.detail.originalElement.dispatchEvent(ev);\n              if (!ev.defaultPrevented) {\n                if (!!e.detail.mode && (e.detail.mode === 'self')) {\n                  e.detail.originalParent.insertBefore(e.detail.originalElement, e.detail.nextElement);\n                }\n              }\n            }\n          }\n        }\n      };\n      el.addEventListener('beforedrop', el.bbnDirectives.droppable.onbeforedrop);\n    }\n  };\n\n  const analyzeValue = (el, binding) => {\n    if (el.bbnDirectives === undefined) {\n      el.bbnDirectives = bbn.fn.createObject();\n    }\n\n    if (el.bbnDirectives.droppable === undefined) {\n      el.bbnDirectives.droppable = bbn.fn.createObject();\n    }\n\n    if ((binding.value !== false)\n      && !el.classList.contains('bbn-undroppable')\n    ) {\n      el.dataset.bbn_droppable = true;\n      el.bbnDirectives.droppable = bbn.fn.createObject({\n        active: true,\n        over: false\n      });\n      if (!el.classList.contains('bbn-droppable')) {\n        el.classList.add('bbn-droppable');\n      }\n\n      let options = bbn.fn.createObject(),\n          asArg = !!binding.arg && binding.arg.length,\n          asMods = bbn.fn.isArray(binding.modifiers) && binding.modifiers.length,\n          asDataFromMods = asMods && binding.modifiers.includes('data'),\n          data = bbn.fn.createObject();\n      if (asArg) {\n        if (binding.arg === 'data') {\n          data = binding.arg;\n        }\n      }\n      else if (bbn.fn.isObject(binding.value)) {\n        options = binding.value;\n        if (asDataFromMods) {\n          if ((options.data === undefined)\n            || !bbn.fn.isObject(options.data)\n          ) {\n            bbn.fn.error(bbn._('No \"data\" property found or not an object'));\n            throw bbn._('No \"data\" property found or not an object');\n          }\n          data = options.data;\n        }\n      }\n\n      options.data = data;\n      el.bbnDirectives.droppable.options = options;\n      return true;\n    }\n    else {\n      el.dataset.bbn_droppable = false;\n      el.bbnDirectives.droppable = bbn.fn.createObject({\n        active: false\n      });\n      return false;\n    }\n  };\n\n  const setOff = el => {\n    el.dataset.bbn_droppable = false;\n    if (el.bbnDirectives === undefined) {\n      el.bbnDirectives = bbn.fn.createObject();\n    }\n\n    if (el.bbnDirectives.droppable === undefined) {\n      el.bbnDirectives.droppable = bbn.fn.createObject();\n    }\n\n    if (!!el.bbnDirectives.droppable.active) {\n      if (bbn.fn.isFunction(el.bbnDirectives.droppable.onmouseenter)) {\n        el.removeEventListener('mouseenter', el.bbnDirectives.droppable.onmouseenter);\n      }\n      if (bbn.fn.isFunction(el.bbnDirectives.droppable.onmouseleave)) {\n        el.removeEventListener('mouseleave', el.bbnDirectives.droppable.onmouseleave);\n      }\n      if (bbn.fn.isFunction(el.bbnDirectives.droppable.ondragoverdroppable)) {\n        el.removeEventListener('dragoverdroppable', el.bbnDirectives.droppable.ondragoverdroppable);\n      }\n      if (bbn.fn.isFunction(el.bbnDirectives.droppable.onbeforedrop)) {\n        el.removeEventListener('beforedrop', el.bbnDirectives.droppable.onbeforedrop);\n      }\n    }\n\n    el.bbnDirectives.droppable = bbn.fn.createObject({\n      active: false\n    });\n    if (el.classList.contains('bbn-droppable')) {\n      el.classList.remove('bbn-droppable');\n    }\n  };\n\n  bbn.cp.directives['bbn-droppable'] = bbn.fn.createObject({\n    inserted: inserted,\n    update: (el, binding) => {\n      if ((binding.value !== false)\n        && !el.classList.contains('bbn-undroppable')\n      ) {\n        if (binding.oldValue === false) {\n          inserted(el, binding);\n        }\n        else if (!el.bbnDirectives.droppable.over) {\n          analyzeValue(el, binding);\n        }\n      }\n      else {\n        setOff(el);\n      }\n    }\n  });\n};\n;// CONCATENATED MODULE: ./src/directives/focused.js\n/* harmony default export */ function focused() {\n  bbn.cp.directives['bbn-focused'] = bbn.fn.createObject({\n    inserted(el, binding) {\n      if (binding.value === false) {\n        return;\n      }\n\n      setTimeout(() => {\n        el.focus();\n        bbn.env.focused = el;\n        if (binding.modifiers.includes('selected')) {\n          bbn.fn.selectElementText(el);\n        }\n      }, 250);\n    }\n  });\n}\n\n;// CONCATENATED MODULE: ./src/directives/portal.js\n/* harmony default export */ function portal() {\n  const moveToTarget = (el, target) => {\n    if (el.parentNode !== target) {\n      target.appendChild(el);\n    }\n  };\n\n  const treatBinding = (el, binding, force) => {\n    if (!force && (binding.value === binding.oldValue)) {\n      return;\n    }\n\n    if (bbn.fn.isString(binding.value)) {\n      const target = document.querySelector(binding.value);\n      if (target) {\n        return moveToTarget(el, target);\n      }\n    }\n    else if (bbn.fn.isDom(binding.value)) {\n      return moveToTarget(el, binding.value);\n    }\n    else {\n      return moveToTarget(el, document.body);\n    }\n  };\n\n  bbn.cp.directives['bbn-portal'] = bbn.fn.createObject({\n    inserted: (el, binding) => {\n      el.bbnDirectives.portal = bbn.fn.createObject({\n        originalParent: el.parentNode\n      });\n\n      if (binding.value) {\n        treatBinding(el, binding, true);\n      }\n    },\n    update: (el, binding) => {\n      if (binding.value) {\n        treatBinding(el, binding);\n      }\n      else {\n        moveToTarget(el, el.bbnDirectives.portal.originalParent);\n      }\n    }\n  });\n}\n\n;// CONCATENATED MODULE: ./src/directives/resizable.js\n/* harmony default export */ function resizable() {\n  var isDragging = false;\n  var currentEle = false;\n  var lastMouseUp = null;\n\n  const fnDrag = e => {\n    drag(e, currentEle);\n  };\n\n  const fnEnd = e => {\n    lastMouseUp = e.timeStamp;\n    endDrag(e, currentEle);\n    document.removeEventListener('mousemove', fnDrag);\n    isDragging = false;\n  };\n\n  const fnClick = e => {\n    if (e.target.timeStamp === lastMouseUp) {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n    }\n  };\n\n  const startDrag = (e, ele) => {\n    if (!isDragging\n      && !!ele.bbnDirectives.resizable.active\n      && !ele.bbnDirectives.resizable.resizing\n      && !!ele.bbnDirectives.resizable.modes\n      && bbn.fn.numProperties(ele.bbnDirectives.resizable.modes)\n    ) {\n      isDragging = true;\n      currentEle = ele;\n      ele.bbnDirectives.resizable.resizing = true;\n      let cursor = '',\n          modes = ele.bbnDirectives.resizable.modes;\n      if (!!modes.left) {\n        cursor = !!modes.top ? 'nwse-resize' : (!!modes.bottom ? 'nesw-resize' : 'ew-resize');\n      }\n      else if (!!modes.right) {\n        cursor = !!modes.top ? 'nesw-resize' : (!!modes.bottom ? 'nwse-resize' : 'ew-resize');\n      }\n      else if (!!modes.top) {\n        cursor = !!modes.right ? 'nesw-resize' : (!!modes.left ? 'nwse-resize' : 'ns-resize');\n      }\n      else if (!!modes.bottom) {\n        cursor = !!modes.right ? 'nwse-resize' : (!!modes.left ? 'nesw-resize' : 'ns-resize');\n      }\n\n      ele.bbnDirectives.resizable.cursor = window.getComputedStyle(document.body).cursor;\n      document.body.style.cursor = cursor;\n      ele.classList.add('bbn-resizable-resizing');\n      ele.bbnDirectives.resizable.mouseX = bbn.fn.roundDecimal(e.x, 0);\n      ele.bbnDirectives.resizable.mouseY = bbn.fn.roundDecimal(e.y, 0);\n      if (!ele.bbnDirectives.resizable.container) {\n        ele.bbnDirectives.resizable.container = bbn.fn.isDom(ele.parentElement) ? ele.parentElement : document.body;\n      }\n\n      let ev = new CustomEvent('userresizestart', {\n        cancelable: true,\n        bubbles: true,\n        detail: ele.bbnDirectives.resizable\n      });\n      ele.dispatchEvent(ev);\n      /* if (ele.bbn !== undefined) {\n        ele.bbn.$emit('userresizestart', ev);\n      } */\n\n      if (!ev.defaultPrevented) {\n        ev.stopImmediatePropagation();\n        ele.addEventListener('click', fnClick, {once: true});\n        document.addEventListener('mouseup', fnEnd, {once: true});\n        document.addEventListener('mousemove', fnDrag);\n      }\n      else {\n        endDrag(e, ele, true);\n        isDragging = false;\n      }\n    }\n  };\n\n  const drag = (e, ele) => {\n    if (!!ele.bbnDirectives.resizable.active\n      && !!ele.bbnDirectives.resizable.resizing\n    ) {\n      // we prevent default from the event\n      e.stopImmediatePropagation();\n      e.preventDefault();\n      let rectCont = ele.bbnDirectives.resizable.container.getBoundingClientRect(),\n          rectEle = ele.getBoundingClientRect(),\n          styleEle = window.getComputedStyle(ele),\n          styleContainer = window.getComputedStyle(ele.bbnDirectives.resizable.container),\n          x = bbn.fn.roundDecimal(e.x, 0),\n          y = bbn.fn.roundDecimal(e.y, 0),\n          modes = ele.bbnDirectives.resizable.modes,\n          xMovement = bbn.fn.roundDecimal(ele.bbnDirectives.resizable.mouseX - x, 0),\n          yMovement = bbn.fn.roundDecimal(ele.bbnDirectives.resizable.mouseY - y, 0),\n          width = rectEle.width + (!!modes.left ? xMovement : -xMovement),\n          height = rectEle.height + (!!modes.top ? yMovement : -yMovement),\n          isAbs = styleEle.position === 'absolute',\n          isFixed = styleEle.position === 'fixed',\n          toSetAbs = false,\n          element = {\n            minWidth: ((parseFloat(styleEle.paddingLeft) || 0) +\n              (parseFloat(styleEle.paddingRight) || 0) +\n              (parseFloat(styleEle.borderLeft) || 0) +\n              (parseFloat(styleEle.borderRight) || 0)) || 1,\n            maxWidth: rectCont.width,\n            minHeight: ((parseFloat(styleEle.paddingTop) || 0) +\n              (parseFloat(styleEle.paddingBottom) || 0) +\n              (parseFloat(styleEle.borderTop) || 0) +\n              (parseFloat(styleEle.borderBottom) || 0)) || 1,\n            maxHeight: rectCont.height,\n            margin: {\n              top: parseFloat(styleEle.marginTop) || 0,\n              right: parseFloat(styleEle.marginRight) || 0,\n              bottom: parseFloat(styleEle.marginBottom) || 0,\n              left: parseFloat(styleEle.marginLeft) || 0,\n            },\n            padding : {\n              top: parseFloat(styleEle.paddingTop) || 0,\n              right: parseFloat(styleEle.paddingRight) || 0,\n              bottom: parseFloat(styleEle.paddingBottom) || 0,\n              left: parseFloat(styleEle.paddingLeft) || 0\n            },\n            border : {\n              top: parseFloat(styleEle.borderTop) || 0,\n              right: parseFloat(styleEle.borderRight) || 0,\n              bottom: parseFloat(styleEle.borderBottom) || 0,\n              left: parseFloat(styleEle.borderLeft) || 0\n            }\n          },\n          container = {\n            margin: {\n              top: parseFloat(styleContainer.marginTop) || 0,\n              right: parseFloat(styleContainer.marginRight) || 0,\n              bottom: parseFloat(styleContainer.marginBottom) || 0,\n              left: parseFloat(styleContainer.marginLeft) || 0,\n            },\n            padding : {\n              top: parseFloat(styleContainer.paddingTop) || 0,\n              right: parseFloat(styleContainer.paddingRight) || 0,\n              bottom: parseFloat(styleContainer.paddingBottom) || 0,\n              left: parseFloat(styleContainer.paddingLeft) || 0\n            },\n            border : {\n              top: parseFloat(styleContainer.borderTop) || 0,\n              right: parseFloat(styleContainer.borderRight) || 0,\n              bottom: parseFloat(styleContainer.borderBottom) || 0,\n              left: parseFloat(styleContainer.borderLeft) || 0\n            }\n          };\n      element.margin.totalX = element.margin.left + element.margin.right;\n      element.margin.totalY = element.margin.top + element.margin.bottom;\n      container.margin.totalX = container.margin.left + container.margin.right;\n      container.margin.totalY = container.margin.top + container.margin.bottom;\n      container.padding.totalX = container.padding.left + container.padding.right;\n      container.padding.totalY = container.padding.top + container.padding.bottom;\n      if (element.maxWidth > (rectCont.width - container.padding.totalX - element.margin.totalX)) {\n        element.maxWidth = rectCont.width - container.padding.totalX - element.margin.totalX;\n      }\n\n      if (element.maxHeight > (rectCont.height - container.padding.totalY - element.margin.totalY)) {\n        element.maxHeight = rectCont.height - container.padding.totalY - element.margin.totalY;\n      }\n\n      width = width < element.minWidth ?\n        element.minWidth :\n        (width > element.maxWidth ? element.maxWidth : width);\n      height = height < element.minHeight ?\n        element.minHeight :\n        (height > element.maxHeight ? element.maxHeight : height);\n      if ((!!modes.left || !!modes.right) && xMovement) {\n        if (!!modes.left) {\n          const minLeft = rectCont.left +\n            container.padding.left +\n            container.border.left +\n            element.margin.left;\n          var tmpLeft = rectEle.left - xMovement;\n          if (tmpLeft < minLeft) {\n            xMovement = minLeft - tmpLeft;\n            width -= xMovement;\n            tmpLeft = minLeft;\n          }\n        }\n\n        if (width !== rectEle.width) {\n          let ev = makeEvent(!!modes.left ? 'left' : 'right', xMovement, width, rectEle.width);\n          ele.dispatchEvent(ev);\n          if (!ev.defaultPrevented) {\n            if (!!modes.left && xMovement) {\n              if (!isAbs && !isFixed) {\n                toSetAbs = true;\n                isAbs = true;\n              }\n              if (isAbs) {\n                tmpLeft -= rectCont.left;\n              }\n              ele.style.left = tmpLeft - element.margin.left + 'px';\n            }\n            setSize(ele, null, width + 'px', toSetAbs, ev);\n          }\n        }\n      }\n      if ((!!modes.top || !!modes.bottom) && yMovement) {\n        if (!!modes.top) {\n          const minTop = rectCont.top +\n            container.padding.top +\n            container.border.top +\n            element.margin.top;\n          var tmpTop = rectEle.top - yMovement;\n          if (tmpTop < minTop) {\n            yMovement = minTop - tmpTop;\n            height -= yMovement;\n            tmpTop = minTop;\n          }\n        }\n\n        if (height !== rectEle.height) {\n          let ev = makeEvent(!!modes.top ? 'top' : 'bottom', yMovement, height, rectEle.height);\n          ele.dispatchEvent(ev);\n          if (!ev.defaultPrevented) {\n            if (!!modes.top && yMovement) {\n              if (!isAbs && !isFixed) {\n                toSetAbs = true;\n                isAbs = true;\n              }\n              if (isAbs) {\n                tmpTop -= rectCont.top;\n              }\n              ele.style.top = tmpTop - element.margin.top + 'px';\n            }\n            setSize(ele, height + 'px', null, toSetAbs, ev);\n          }\n        }\n      }\n      ele.bbnDirectives.resizable.mouseX = x;\n      ele.bbnDirectives.resizable.mouseY = y;\n    }\n  };\n\n  const makeEvent = (from, movement, size, oldSize) => {\n    return new CustomEvent('userresize', {\n      cancelable: true,\n      bubbles: true,\n      detail: bbn.fn.createObject({\n        from: from,\n        movement: movement,\n        size: size,\n        oldSize: oldSize\n      })\n    });\n  };\n\n  const setSize = (ele, height, width, abs, ev) => {\n    if (!bbn.fn.isNull(height)) {\n      ele.style.height = height;\n    }\n\n    if (!bbn.fn.isNull(width)) {\n      ele.style.width = width;\n    }\n\n    if (abs) {\n      ele.style.position = 'absolute';\n    }\n\n    if (ele.bbn !== undefined) {\n      //ele.bbn.$emit('userresize', ev);\n      if (!ev.defaultPrevented\n        && (ele.bbn.parentResizer !== undefined)\n        && bbn.fn.isFunction(ele.bbn.parentResizer.onResize)\n      ) {\n        ele.bbn.parentResizer.onResize();\n      }\n    }\n  };\n\n  const endDrag = (e, ele, force = false) => {\n    if (isDragging\n      && !!ele.bbnDirectives.resizable.active\n      && !!ele.bbnDirectives.resizable.resizing\n    ) {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      if (!force) {\n        let ev = new CustomEvent('userresizeend', {\n          cancelable: true,\n          bubbles: true,\n          detail: ele.bbnDirectives.resizable\n        });\n        ele.dispatchEvent(ev);\n        /* if (ele.bbn !== undefined) {\n          ele.bbn.$emit('userresizestart', ev);\n        } */\n        document.removeEventListener('mouseup', fnEnd, {once: true});\n        document.removeEventListener('mousemove', fnDrag);\n        delete ele.bbnDirectives.resizable.mouseX;\n        delete ele.bbnDirectives.resizable.mouseY;\n      }\n\n      ele.classList.remove('bbn-resizable-resizing');\n      document.body.style.cursor = ele.bbnDirectives.resizable.cursor;\n      setTimeout(() => {\n        ele.bbnDirectives.resizable.resizing = false;\n      }, 100);\n\n    }\n  };\n\n  const inserted = (el, binding) => {\n    if (analyzeValue(el, binding)) {\n      el.bbnDirectives.resizable.onmousemove = ev => {\n        if (!!el.bbnDirectives.resizable.active\n          && !el.bbnDirectives.resizable.resizing\n        ) {\n          let rect = el.getBoundingClientRect(),\n              modes = el.bbnDirectives.resizable.enabledModes,\n              m = bbn.fn.createObject();\n          if (modes.left\n            && (ev.x >= (rect.left - 2))\n            && (ev.x <= (rect.left + 2))\n          ) {\n            m.left = true;\n            el.classList.add('bbn-resizable-over-left');\n          }\n          else {\n            el.classList.remove('bbn-resizable-over-left');\n          }\n          if (modes.right\n            && (ev.x >= (rect.left + rect.width - 2))\n            && (ev.x <= (rect.left + rect.width + 2))\n          ) {\n            m.right = true;\n            el.classList.add('bbn-resizable-over-right');\n          }\n          else {\n            el.classList.remove('bbn-resizable-over-right');\n          }\n          if (modes.top\n            && (ev.y >= (rect.top - 2))\n            && (ev.y <= (rect.top + 2))\n          ) {\n            m.top = true;\n            el.classList.add('bbn-resizable-over-top');\n          }\n          else {\n            el.classList.remove('bbn-resizable-over-top');\n          }\n          if (modes.bottom\n            && (ev.y >= (rect.top + rect.height - 2))\n            && (ev.y <= (rect.top + rect.height + 2))\n          ) {\n            m.bottom = true;\n            el.classList.add('bbn-resizable-over-bottom');\n          }\n          else {\n            el.classList.remove('bbn-resizable-over-bottom');\n          }\n          if (!el.bbnDirectives.resizable.resizing) {\n            el.bbnDirectives.resizable.modes = m;\n          }\n        }\n      };\n      el.addEventListener('mousemove', el.bbnDirectives.resizable.onmousemove);\n\n      el.bbnDirectives.resizable.onmouseleave = ev => {\n        if (!!el.bbnDirectives.resizable.active\n          && !el.bbnDirectives.resizable.resizing\n          && !isDragging\n        ) {\n          if (el.classList.contains('bbn-resizable-over-left')) {\n            el.classList.remove('bbn-resizable-over-left');\n          }\n\n          if (el.classList.contains('bbn-resizable-over-right')) {\n            el.classList.remove('bbn-resizable-over-right');\n          }\n\n          if (el.classList.contains('bbn-resizable-over-top')) {\n            el.classList.remove('bbn-resizable-over-top');\n          }\n\n          if (el.classList.contains('bbn-resizable-over-bottom')) {\n            el.classList.remove('bbn-resizable-over-bottom');\n          }\n        }\n      };\n      el.addEventListener('mouseleave', el.bbnDirectives.resizable.onmouseleave);\n\n      // Add the events listener to capture the long press click and start the drag\n      let clickTimeout = 0,\n          holdClick = false;\n      el.bbnDirectives.resizable.onmousedown = ev => {\n        if (clickTimeout) {\n          clearTimeout(clickTimeout);\n        }\n        if (!!el.bbnDirectives.resizable.active\n          && !el.bbnDirectives.resizable.resizing\n          && !!el.bbnDirectives.resizable.modes\n          && bbn.fn.numProperties(el.bbnDirectives.resizable.modes)\n        ) {\n          if (ev.button === 0) {\n            holdClick = true;\n            clickTimeout = setTimeout(() => {\n              if (holdClick) {\n                startDrag(ev, el);\n              }\n            }, 150);\n          }\n        }\n      };\n      el.addEventListener('mousedown', el.bbnDirectives.resizable.onmousedown);\n      el.bbnDirectives.resizable.onmouseup = ev => {\n        if (!!el.bbnDirectives.resizable.active) {\n          holdClick = false;\n        }\n      };\n      el.addEventListener('mouseup', el.bbnDirectives.resizable.onmouseup);\n    }\n  };\n\n  const analyzeValue = (el, binding) => {\n    if (el.bbnDirectives.resizable === undefined) {\n      el.bbnDirectives.resizable = bbn.fn.createObject();\n    }\n    if ((binding.value !== false)\n      && !el.classList.contains('bbn-unresizable')\n    ) {\n      let options = bbn.fn.createObject(),\n          asMods = bbn.fn.isArray(binding.modifiers) && binding.modifiers.length,\n          asContainerFromMods = asMods && binding.modifiers.includes('container'),\n          asArg = !!binding.arg && binding.arg.length,\n          modes = bbn.fn.createObject({\n            top: !asMods || binding.modifiers.includes('top'),\n            right: !asMods || binding.modifiers.includes('right'),\n            bottom: !asMods || binding.modifiers.includes('bottom'),\n            left: !asMods || binding.modifiers.includes('left')\n          }),\n          container = false;\n      el.dataset.bbn_resizable = true;\n      el.bbnDirectives.resizable.active = true;\n      el.bbnDirectives.resizable.enabledModes = modes;\n      el.bbnDirectives.resizable.resizing = !!el.bbnDirectives.resizable.resizing;\n      if (!el.classList.contains('bbn-resizable')) {\n        el.classList.add('bbn-resizable');\n      }\n\n      if (asArg) {\n        switch (binding.arg) {\n          case 'container':\n            container = binding.value;\n            break;\n        }\n      }\n      else {\n        if (bbn.fn.isObject(binding.value)) {\n          options = binding.value;\n          if (asContainerFromMods) {\n            if ((options.container === undefined)\n              || !bbn.fn.isDom(options.container)\n            ) {\n              bbn.fn.error(bbn._('No \"container\" property found or not a DOM element'));\n              throw bbn._('No \"container\" property found or not a DOM element');\n            }\n            container = options.container;\n          }\n        }\n      }\n      el.bbnDirectives.resizable.container = container;\n      el.bbnDirectives.resizable.options = options;\n      return true;\n    }\n    else {\n      el.dataset.resizable = false;\n      el.bbnDirectives.resizable = bbn.fn.createObject({\n        active: false\n      });\n      return false;\n    }\n  };\n\n  const setOff = el => {\n    el.dataset.bbn_resizable = false;\n    if (el.bbnDirectives === undefined) {\n      el.bbnDirectives = bbn.fn.createObject();\n    }\n\n    if (el.bbnDirectives.resizable === undefined) {\n      el.bbnDirectives.resizable = bbn.fn.createObject();\n    }\n\n    if (!!el.bbnDirectives.resizable.active) {\n      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmousedown)) {\n        el.removeEventListener('mousedown', el.bbnDirectives.resizable.onmousedown);\n      }\n\n      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmouseup)) {\n        el.removeEventListener('mouseup', el.bbnDirectives.resizable.onmouseup);\n      }\n\n      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmousemove)) {\n        el.removeEventListener('mousemove', el.bbnDirectives.resizable.onmousemove);\n      }\n\n      if (bbn.fn.isFunction(el.bbnDirectives.resizable.onmouseleave)) {\n        el.removeEventListener('mouseleave', el.bbnDirectives.resizable.onmouseleave);\n      }\n    }\n    el.bbnDirectives.resizable = bbn.fn.createObject({\n      active: false\n    });\n    if (el.classList.contains('bbn-resizable')) {\n      el.classList.remove('bbn-resizable');\n    }\n\n    if (el.classList.contains('bbn-resizable-over-left')) {\n      el.classList.remove('bbn-resizable-over-left');\n    }\n\n    if (el.classList.contains('bbn-resizable-over-right')) {\n      el.classList.remove('bbn-resizable-over-right');\n    }\n\n    if (el.classList.contains('bbn-resizable-over-top')) {\n      el.classList.remove('bbn-resizable-over-top');\n    }\n\n    if (el.classList.contains('bbn-resizable-over-bottom')) {\n      el.classList.remove('bbn-resizable-over-bottom');\n    }\n  };\n\n  bbn.cp.directives['bbn-resizable'] =  bbn.fn.createObject({\n    inserted: inserted,\n    update: (el, binding) => {\n      if ((binding.value !== false)\n        && !el.classList.contains('bbn-unresizable')\n      ) {\n        if (binding.oldValue === false) {\n          inserted(el, binding);\n        }\n        else if (!isDragging){\n          analyzeValue(el, binding);\n        }\n      }\n      else {\n        setOff(el);\n      }\n    }\n  });\n}\n\n;// CONCATENATED MODULE: ./src/cp.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst possibleAttributes = [\n  'is',\n  'source',\n  'ref',\n  'slot',\n  'id',\n  'class',\n  'style',\n  'key'\n];\n/** Custom elements polyfill */\n!function(){\"use strict\";var e=(e,t)=>{const n=e=>{for(let t=0,{length:n}=e;t<n;t++)o(e[t])},o=({target:e,attributeName:t,oldValue:n})=>{e.attributeChangedCallback(t,n,e.getAttribute(t))};return(r,l)=>{const{observedAttributes:s}=r.constructor;return s&&e(l).then((()=>{new t(n).observe(r,{attributes:!0,attributeOldValue:!0,attributeFilter:s});for(let e=0,{length:t}=s;e<t;e++)r.hasAttribute(s[e])&&o({target:r,attributeName:s[e],oldValue:null})})),r}};\n/*! (c) Andrea Giammarchi - ISC */const t=!0,n=!1,o=\"querySelectorAll\",r=\"querySelectorAll\",{document:l,Element:s,MutationObserver:c,Set:a,WeakMap:i}=self,u=e=>r in e,{filter:f}=[];var h=e=>{const h=new i,d=(t,n)=>{let o;if(n)for(let r,l=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(t),s=0,{length:c}=p;s<c;s++)l.call(t,r=p[s])&&(h.has(t)||h.set(t,new a),o=h.get(t),o.has(r)||(o.add(r),e.handle(t,n,r)));else h.has(t)&&(o=h.get(t),h.delete(t),o.forEach((o=>{e.handle(t,n,o)})))},g=(e,t=!0)=>{for(let n=0,{length:o}=e;n<o;n++)d(e[n],t)},{query:p}=e,m=e.root||l,y=((e,r=document,l=MutationObserver,s=[\"*\"])=>{const c=(n,r,l,s,a,i)=>{for(const u of n)(i||o in u)&&(a?l.has(u)||(l.add(u),s.delete(u),e(u,a)):s.has(u)||(s.add(u),l.delete(u),e(u,a)),i||c(u[o](r),r,l,s,a,t))},a=new l((e=>{if(s.length){const o=s.join(\",\"),r=new Set,l=new Set;for(const{addedNodes:s,removedNodes:a}of e)c(a,o,r,l,n,n),c(s,o,r,l,t,n)}})),{observe:i}=a;return(a.observe=e=>i.call(a,e,{subtree:t,childList:t}))(r),a})(d,m,c,p),{attachShadow:w}=s.prototype;return w&&(s.prototype.attachShadow=function(e){const t=w.call(this,e);return y.observe(t),t}),p.length&&g(m[r](p)),{drop:e=>{for(let t=0,{length:n}=e;t<n;t++)h.delete(e[t])},flush:()=>{const e=y.takeRecords();for(let t=0,{length:n}=e;t<n;t++)g(f.call(e[t].removedNodes,u),!1),g(f.call(e[t].addedNodes,u),!0)},observer:y,parse:g}};const{document:d,Map:g,MutationObserver:p,Object:m,Set:y,WeakMap:w,Element:b,HTMLElement:E,Node:v,Error:S,TypeError:M,Reflect:O}=self,{defineProperty:A,keys:N,getOwnPropertyNames:q,setPrototypeOf:C}=m;let T=!self.customElements;const D=e=>{const t=N(e),n=[],{length:o}=t;for(let r=0;r<o;r++)n[r]=e[t[r]],delete e[t[r]];return()=>{for(let r=0;r<o;r++)e[t[r]]=n[r]}};if(T){const{createElement:L}=d,P=new g,$=new g,k=new g,I=new g,x=[],H=(e,t,n)=>{const o=k.get(n);if(t&&!o.isPrototypeOf(e)){const t=D(e);R=C(e,o);try{new o.constructor}finally{R=null,t()}}const r=(t?\"\":\"dis\")+\"connectedCallback\";r in o&&e[r]()},{parse:_}=h({query:x,handle:H});let R=null;const V=e=>{if(!$.has(e)){let t,n=new Promise((e=>{t=e}));$.set(e,{$:n,_:t})}return $.get(e).$},j=e(V,p);function W(){const{constructor:e}=this;if(!P.has(e))throw new M(\"Illegal constructor\");const t=P.get(e);if(R)return j(R,t);const n=L.call(d,t);return j(C(n,e.prototype),t)}A(self,\"customElements\",{configurable:!0,value:{define:(e,t)=>{if(I.has(e))throw new S(`the name \"${e}\" has already been used with this registry`);P.set(t,e),k.set(e,t.prototype),I.set(e,t),x.push(e),V(e).then((()=>{_(d.querySelectorAll(e))})),$.get(e)._(t)},get:e=>I.get(e),whenDefined:V}}),A(W.prototype=E.prototype,\"constructor\",{value:W}),A(self,\"HTMLElement\",{configurable:!0,value:W}),A(d,\"createElement\",{configurable:!0,value(e,t){const n=t&&t.is,o=n?I.get(n):I.get(e);return o?new o:L.call(d,e)}}),\"isConnected\"in v.prototype||A(v.prototype,\"isConnected\",{configurable:!0,get(){return!(this.ownerDocument.compareDocumentPosition(this)&this.DOCUMENT_POSITION_DISCONNECTED)}})}else if(T=!self.customElements.get(\"extends-li\"),T)try{function F(){return self.Reflect.construct(HTMLLIElement,[],F)}F.prototype=HTMLLIElement.prototype;const U=\"extends-li\";self.customElements.define(\"extends-li\",F,{extends:\"li\"}),T=d.createElement(\"li\",{is:U}).outerHTML.indexOf(U)<0;const{get:z,whenDefined:B}=self.customElements;A(self.customElements,\"whenDefined\",{configurable:!0,value(e){return B.call(this,e).then((t=>t||z.call(this,e)))}})}catch(G){}if(T){const J=self.customElements,{createElement:K}=d,{define:Q,get:X,upgrade:Y}=J,{construct:Z}=O||{construct(e){return e.call(this)}},ee=new w,te=new y,ne=new g,oe=new g,re=new g,le=new g,se=[],ce=[],ae=e=>le.get(e)||X.call(J,e),ie=(e,t,n)=>{const o=re.get(n);if(t&&!o.isPrototypeOf(e)){const t=D(e);pe=C(e,o);try{new o.constructor}finally{pe=null,t()}}const r=(t?\"\":\"dis\")+\"connectedCallback\";r in o&&e[r]()},{parse:ue}=h({query:ce,handle:ie}),{parse:fe}=h({query:se,handle(e,t){ee.has(e)&&(t?te.add(e):te.delete(e),ce.length&&me.call(ce,e))}}),{attachShadow:he}=b.prototype;he&&(b.prototype.attachShadow=function(e){const t=he.call(this,e);return ee.set(this,t),t});const de=e=>{if(!oe.has(e)){let t,n=new Promise((e=>{t=e}));oe.set(e,{$:n,_:t})}return oe.get(e).$},ge=e(de,p);let pe=null;function me(e){const t=ee.get(e);ue(t.querySelectorAll(this),e.isConnected)}q(self).filter((e=>/^HTML.*Element$/.test(e))).forEach((e=>{const t=self[e];function n(){const{constructor:e}=this;if(!ne.has(e))throw new M(\"Illegal constructor\");const{is:n,tag:o}=ne.get(e);if(n){if(pe)return ge(pe,n);const t=K.call(d,o);return t.setAttribute(\"is\",n),ge(C(t,e.prototype),n)}return Z.call(this,t,[],e)}C(n,t),A(n.prototype=t.prototype,\"constructor\",{value:n}),A(self,e,{value:n})})),A(d,\"createElement\",{configurable:!0,value(e,t){const n=t&&t.is;if(n){const t=le.get(n);if(t&&ne.get(t).tag===e)return new t}const o=K.call(d,e);return n&&o.setAttribute(\"is\",n),o}}),A(J,\"get\",{configurable:!0,value:ae}),A(J,\"whenDefined\",{configurable:!0,value:de}),A(J,\"upgrade\",{configurable:!0,value(e){const t=e.getAttribute(\"is\");if(t){const n=le.get(t);if(n)return void ge(C(e,n.prototype),t)}Y.call(J,e)}}),A(J,\"define\",{configurable:!0,value(e,t,n){if(ae(e))throw new S(`'${e}' has already been defined as a custom element`);let o;const r=n&&n.extends;ne.set(t,r?{is:e,tag:r}:{is:\"\",tag:e}),r?(o=`${r}[is=\"${e}\"]`,re.set(o,t.prototype),le.set(e,t),ce.push(o)):(Q.apply(J,arguments),se.push(o=e)),de(e).then((()=>{r?(ue(d.querySelectorAll(o)),te.forEach(me,[o])):fe(d.querySelectorAll(o))})),oe.get(e)._(t)}})}}();  \n\nconst cpObj = dist.bbn.fn.createObject({\n  tickDelay: 25,\n  uid: 0,\n  mixins: dist.bbn.fn.createObject({\n    basic: mixins_basic,\n    browserNotification: mixins_browserNotification,\n    close: mixins_close,\n    componentInside: mixins_componentInside,\n    config: mixins_config,\n    data: mixins_data,\n    dataEditor: mixins_dataEditor,\n    dimensions: mixins_dimensions,\n    dropdown: mixins_dropdown,\n    editableList: mixins_editableList,\n    empty: mixins_empty,\n    events: mixins_events,\n    field: mixins_field,\n    input: mixins_input,\n    keepCool: mixins_keepCool,\n    keynav: mixins_keynav,\n    list: mixins_list,\n    localStorage: mixins_localStorage,\n    memory: mixins_memory,\n    observer: mixins_observer,\n    pageable: mixins_pageable,\n    popup: mixins_popup,\n    position: mixins_position,\n    resizer: mixins_resizer,\n    serviceWorker: mixins_serviceWorker,\n    toggle: mixins_toggle,\n    url: mixins_url,\n    view: mixins_view\n  }),\n  defaults: dist.bbn.fn.createObject(),\n  version: 1,\n  spaceHash: dist.bbn.fn.hash(' '),\n  queue: [],\n  known: [],\n  interval: null,\n  statics: dist.bbn.fn.createObject(),\n  /** @var {Array} directives List of existing directives */\n  directives: dist.bbn.fn.createObject(),\n  conditionalExp: ['bbn-if', 'bbn-elseif', 'bbn-else'],\n  badCaseAttributes: {\n    accesskey: 'accessKey',\n    autocapitalize: 'autoCapitalize',\n    autocorrect: 'autoCorrect',\n    tabindex: 'tabIndex',\n    readonly: 'readOnly',\n    contenteditable: 'contentEditable',\n    crossorigin: 'crossOrigin',\n    for: 'htmlFor',\n  },\n  hooks: [\n    'beforeCreate',\n    'created',\n    'updated',\n    'beforeMount',\n    'mounted',\n    'beforeDestroy',\n    'destroyed'\n  ],\n  tagExtensions: {\n    'button': 'bbnButtonHTML',\n    'div': 'bbnDivHTML',\n    'form': 'bbnFormHTML',\n    'ul': 'bbnListHTML',\n    'li': 'bbnElementHTML',\n    'span': 'bbnSpanHTML',\n    'tr': 'bbnRowHTML',\n    'td': 'bbnCellHTML',\n    'th': 'bbnCellHTML'\n  },\n  knownPrefixes: [],\n  queue: [],\n  queueTimer: null,\n  loadDelay: 100,\n  possibleAttributes,\n  forbidden: ['bbn-forget', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else'],\n  /** @var {Object} components All the components in the DOM are referenced in this object through their CID */\n  componentsIndex: new Map(),\n  addPrefix: addPrefix,\n  addUrlAsPrefix: addUrlAsPrefix[\"default\"],\n  attributeChangedCallback: attributeChangedCallback,\n  convertClasses: convertClasses,\n  convertStyles: convertStyles,\n  createApp: createApp,\n  define: define_define,\n  executeQueueItem: executeQueueItem,\n  executeQueueItems: executeQueueItems,\n  executeTemplate: executeTemplate,\n  fetchComponents: fetchComponents,\n  getComponent: getComponent,\n  initDefaults: initDefaults,\n  insertDirectives: insertDirectives,\n  isComponent: isComponent,\n  isTag: isTag,\n  mapTemplate: mapTemplate,\n  normalizeComponent: normalizeComponent,\n  realDefineComponent: realDefineComponent[\"default\"],\n  setComputed: setComputed,\n  setDefaults: setDefaults,\n  startTick: startTick,\n  stopTick: stopTick,\n  updateDirectives: updateDirectives,\n});\n\ndist.bbn.fn.autoExtend('cp', cpObj);\n\ndraggable();\ndroppable();\nfocused();\nportal();\nresizable();\n\n/* harmony default export */ const cp = (cpObj);\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/cp.js_+_60_modules?");

/***/ }),

/***/ "./src/functions/addUrlAsPrefix.js":
/*!*****************************************!*\
  !*** ./src/functions/addUrlAsPrefix.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ addUrlAsPrefix)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\n/**\n * Adds a prefix to the list of known prefixes for component names.\n * Each prefix can have an associated handler function and an array of mixins.\n *\n * Handles component prefixes within the framework. \n * It allows the registration of prefixes along with associated handlers and mixins. \n * The sorting by prefix length ensures that when resolving component names, \n * the most specific prefix is considered first, which is important for accurately \n * identifying components and applying the correct behavior and mixins.\n * \n * Considerations:\n * - Error Handling: Ensure robust error handling, especially if the prefix or handler does not meet the expected criteria.\n * - Performance: Consider the impact of repeatedly sorting the knownPrefixes array, especially if addPrefix is called frequently.\n * - Namespace Pollution: Be cautious of potential namespace pollution or conflicts, especially in a large application with many prefixes.\n * - Mixins Integration: If mixins are a core part of the framework, ensure their integration with prefixes is seamless and well-documented.\n * \n * @param {string} prefix - The prefix to be added.\n * @param {Function} [handler] - Optional handler function associated with the prefix.\n * @param {Array} [mixins] - Optional array of mixins to be used with the prefix.\n */\nfunction addUrlAsPrefix(prefix, url, mixins){\n  return _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.cp.addPrefix(prefix, async components => {\n    if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.substr(url, -1) !== '/') {\n      url += '/';\n    }\n    if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.substr(prefix, -1) !== '-') {\n      prefix += '/';\n    }\n    \n    const furl = url + components.join('/') \n        + '?v=' + _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.cp.version\n        + '&test=' + (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.env.isDev ? '1' : '0')\n        + '&lang=' + _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.env.lang;\n    // Request\n    const d = await _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.ajax(furl, 'text');\n    let tmp;\n    try {\n      if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.isString(d.data)) {\n        tmp = (new Function('return ' + d.data + ';'))();\n      }\n    }\n    catch (e) {\n      throw Error(e);\n    }\n\n    const res = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.createObject({\n      components: []\n    });\n\n    if (tmp.components) {\n      _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.each(tmp.components, obj => {\n        let definition;\n        try {\n          definition = eval(obj.script);\n        }\n        catch (e) {\n          throw Error(e);\n        }\n        if (!_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.isEmpty(mixins) && definition) {\n          if (!definition.mixins) {\n            definition.mixins = [];\n          }\n\n          definition.mixins.push(...(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.isObject(mixins) ? [mixins] : mixins));\n        }\n\n        res.components.push(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.createObject({\n          name: obj.name,\n          definition,\n          template: obj.content,\n          css: obj.css || null\n        }));\n      });\n    }\n\n    return res;\n  });\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/functions/addUrlAsPrefix.js?");

/***/ }),

/***/ "./src/functions/realDefineComponent.js":
/*!**********************************************!*\
  !*** ./src/functions/realDefineComponent.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ realDefineComponent)\n/* harmony export */ });\n/**\n * @method _realDefineComponent\n * @memberof bbn.cp\n * @param {String} name \n * @param {Object} r\n * @param {Array} mixins\n */\nfunction realDefineComponent(name, r, mixins){\n  bbn.fn.warning(\"REAL DEFINE COMPONENT\");\n  bbn.fn.log(name, r, mixins);\n  if ( r && r.script ){\n    if ( r.css ){\n      let el = document.createElement('style');\n      el.innerHTML = r.css;\n      document.head.insertAdjacentElement('beforeend', el)\n    }\n    let tpl = false;\n    if ( r.content ){\n      tpl = 'bbn-tpl-component-' + name;\n      while (document.getElementById(tpl)) {\n        tpl = bbn.fn.randomString();\n      }\n      let script = document.createElement('script');\n      script.innerHTML = r.content;\n      script.setAttribute('id', tpl);\n      script.setAttribute('type', 'text/x-template');\n      document.body.insertAdjacentElement('beforeend', script)\n    }\n    let data = r.data || {};\n    let res;\n    try {\n      res = eval(r.script);\n    }\n    catch (e) {\n      bbn.fn.log(r.script)\n      throw Error(\"Impossible to evaluate the content of tha component \" + name);\n    }\n    if ( typeof res === 'object' ){\n      if ( !res.mixins ){\n        res.mixins = [];\n      }\n      if (!res.template && tpl){\n        res.template = '#' + tpl;\n      }\n      if ( !res.props ){\n        res.props = bbn.fn.createObject();\n      }\n      if ( !res.props.source ){\n        res.props.source = bbn.fn.createObject();\n      }\n      if ( !res.name ){\n        res.name = name;\n      }\n      if ( res.mixins && !bbn.fn.isArray(res.mixins) ){\n        res.mixins = [res.mixins];\n      }\n      if ( mixins ){\n        if ( !bbn.fn.isArray(mixins) ){\n          mixins = [mixins];\n        }\n        if ( res.mixins ){\n          bbn.fn.each(mixins, b => {\n            res.mixins.push(b);\n          })\n        }\n        else{\n          res.mixins = mixins;\n        }\n      }\n      let bits = res.name.split('-'),\n          st = '';\n      bbn.fn.each(bits, b => {\n        st += (b + '-');\n        let idx = bbn.fn.search(this.knownPrefixes, {prefix: st});\n        if ( (idx > -1) && this.knownPrefixes[idx].mixins ){\n          if ( bbn.fn.isArray(this.knownPrefixes[idx].mixins) ){\n            bbn.fn.each(this.knownPrefixes[idx].mixins.reverse(), m => {\n              res.mixins.unshift(m)\n            })\n          }\n          else{\n            res.mixins.unshift(this.knownPrefixes[idx].mixins)\n          }\n        }\n      });\n      if ( Object.keys(data).length ){\n        res.props.source.default = () => {\n          return data;\n        }\n      }\n      //bbn.fn.log(name, res);\n      alert(\"This shouldn't be called\")\n      Vue.component(name, res);\n      return true;\n    }\n  }\n  return false;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/functions/realDefineComponent.js?");

/***/ }),

/***/ "./src/index.js":
/*!***********************************!*\
  !*** ./src/index.js + 63 modules ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  axios: () => (/* reexport */ dist.axios),\n  bbn: () => (/* reexport */ dist.bbn),\n  bbnAnon: () => (/* reexport */ Anon_bbnAnon),\n  bbnAnonCp: () => (/* reexport */ bbnAnonCp),\n  bbnButtonHTML: () => (/* reexport */ bbnButtonHTML),\n  bbnCellHTML: () => (/* reexport */ bbnCellHTML),\n  bbnCp: () => (/* reexport */ Cp[\"default\"]),\n  bbnData: () => (/* reexport */ Data[\"default\"]),\n  bbnDivHTML: () => (/* reexport */ bbnDivHTML),\n  bbnElementHTML: () => (/* reexport */ bbnElementHTML),\n  bbnFormHTML: () => (/* reexport */ bbnFormHTML),\n  bbnHTML: () => (/* reexport */ Html_bbnHTML),\n  bbnListHTML: () => (/* reexport */ bbnListHTML),\n  bbnRowHTML: () => (/* reexport */ bbnRowHTML),\n  bbnSpanHTML: () => (/* reexport */ bbnSpanHTML),\n  dayjs: () => (/* reexport */ dist.dayjs)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bbn/bbn/dist/index.js + 280 modules\nvar dist = __webpack_require__(\"./node_modules/@bbn/bbn/dist/index.js\");\n// EXTERNAL MODULE: ./src/lib/Data/Data.js\nvar Data = __webpack_require__(\"./src/lib/Data/Data.js\");\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/addComponent.js\n\n\n/**\n * Adds a component to the original bbnData object linked to it\n * @param {bbnCp} component \n * @param {String} path \n * @returns {Boolean}\n */\nData[\"default\"].prototype.addComponent = function(component, path, parent) {\n  if (!(component instanceof bbnCp)) {\n    throw Error(bbn._(\"bbnData hasComponent must be called with a bbn component\"));\n  }\n\n  if (!bbn.fn.count(this.refs, {component, path})) {\n    this.refs.unshift({\n      component,\n      path,\n      parent\n    });\n  }\n\n  if (!component.$values.includes(this.id)) {\n    component.$values.push(this.id);\n  }\n};\n\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/getImpacted.js\n\n\n/**\n * Identifies all components impacted by changes to a given data key.\n * This method traverses the component's data reference tree to build a list of affected components\n * and the path to the changed data within those components.\n * \n * @param {string} key - The data key whose impact is being assessed. This could be the name of a property or path within the data object.\n * @returns {Array} - An array of objects, each containing a component (`cp`) and the path (`path`) to the affected data within that component.\n */\nData[\"default\"].prototype.getImpacted = function(key) {\n  // Initialize an array to hold the sequence of keys leading to the impacted data.\n  const seq = []; \n  if (key) {\n    // If a specific key is being checked, start the sequence with it.\n    seq.push(key); \n  }\n  // Initialize an array to collect the impact results.\n  const res = []; \n\n  // Iterate over each reference to this data object within components.\n  bbn.fn.each(this.refs, it => {\n    // Create a copy of the initial key sequence.\n    let bits = seq.slice(); \n    // Prepend the current reference's path to the sequence.\n    bits.unshift(it.path); \n\n    // If the current data object has a parent, recursively identify impacts in the parent's context.\n    if (it.parent) {\n      let all = it.parent.getImpacted();\n      bbn.fn.each(all, a => {\n        // For each impacted path in the parent, concatenate it with the current path and add to results.\n        res.push({\n          // The impacted component.\n          cp: a.cp,\n          // The full path to the impacted data within the component.\n          path: a.path.concat(bits) \n        });\n      });\n    }\n    else {\n      // If there's no parent, this is a direct impact on the current component.\n      res.push({\n        // The directly impacted component.\n        cp: it.component, \n        // The path to the impacted data within the component.\n        path: bits \n      });\n    }\n  });\n\n  // Return the list of impacted components and paths.\n  return res; \n};\n\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/hasComponent.js\n\n\n/**\n * \n * @param {bbnCp} component \n * @returns \n */\nData[\"default\"].prototype.hasComponent = function(component, path) {\n  if (!(component instanceof bbnCp)) {\n    throw Error(\"bbnData hasComponent must be called with a bbn component\");\n  }\n\n  return !!bbn.fn.count(this.refs, {component, path});\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/isSame.js\n\n\nData[\"default\"].prototype.isSame = function(obj) {\n  if (obj?.__bbnProxy) {\n    return bbn.fn.isSame(obj, this.value);\n  }\n  else if (obj?.__bbnData) {\n    return bbn.fn.isSame(obj, this.data);\n  }\n\n  return false;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/removeComponent.js\n\n\n/**\n * Removes a component from the data object\n * @param {bbnCp} component \n */\nData[\"default\"].prototype.removeComponent = function(component, path) {\n  if (!(component instanceof bbnCp)) {\n    throw Error(\"bbnData hasComponent must be called with a bbn component\");\n  }\n\n  if (path) {\n    const idx = bbn.fn.search(this.refs, {component, path});\n    if (idx === -1) {\n      throw Error(\"The component is not in the list of components\");\n    }\n    else {\n      if (this.refs[idx].root) {\n        this.unset();\n      }\n      else {\n        this.refs.splice(idx, 1);\n        if (!bbn.fn.count(this.refs, {component})) {\n          let idx = component.$values.indexOf(this.id);\n          if (idx === -1) {\n            throw Error(\"Bha on remove component\")\n          }\n          else {\n            component.$values.splice(idx, 1);\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (this.refs.length === 1) {\n      this.unset();\n    }\n    else if (bbn.fn.getRow(this.refs, {component, root: true})) {\n      this.unset();\n    }\n    else {\n      const idx = bbn.fn.search(this.refs, {component});\n      if (idx === -1) {\n        throw Error(\"The component is not in the list of components\");\n      }\n      else {\n        this.refs.splice(idx, 1);\n        if (!bbn.fn.count(this.refs, {component})) {\n          let idx = component.$values.indexOf(this.id);\n          if (idx === -1) {\n            throw Error(\"Bha on remove component\")\n          }\n          else {\n            component.$values.splice(idx, 1);\n          }\n        }\n      }\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/unset.js\n\n\n/**\n * Deletes all references to the data object and its children\n */\nconst err = \"Impossible to find the data object in the values of the component %s with CID %s\";\nData[\"default\"].prototype.unset = function(noParent) {\n  const id = this.id;\n\n  // Unsetting the children\n  bbn.fn.each(this.children, subObj => {\n    subObj.unset(true);\n  });\n  const done = [];\n  // Unsetting the data in each component, root is last\n  bbn.fn.each(this.refs, it => {\n    const cp = it.component;\n    if (cp) {\n      let idx = cp.$values.indexOf(id);\n      if (idx > -1) {\n        cp.$values.splice(idx, 1);\n        done.push(cp.$cid);\n      }\n      else if (!done.includes(cp.$cid) && cp.$isInit) {\n        bbn.fn.warning(bbn._(err, cp.$options.name, cp.$cid));\n        bbn.fn.log([this, cp, it]);\n        return;\n        //throw Error(bbn._(err, cp.$options.name, cp.$cid));\n      }\n      \n      if (it.parent) {\n        let idx = it.parent.children.indexOf(this);\n        if (idx > -1) {\n          //bbn.fn.log([\"UPDATE ON UNSET\", this, it.parent, cp, it]);\n          it.parent.children.splice(idx, 1);\n          it.parent.update();\n        }\n      }\n\n      if (!cp.$isDestroyed) {\n        cp.$tick();\n      }\n    }\n    else {\n      throw Error(bbn._(\"Impossible to find the component %s\", cp.$cid));\n    }\n  });\n\n  /*\n\n  if (!noParent && root.parent) {\n    let dataObj = this;\n    while (dataObj.parent) {\n      dataObj = dataObj.parent;\n      bbn.fn.iterate(Object.keys(dataObj.components), cid => {\n        bbn.cp.getComponent(cid).bbn.$tick();\n      });\n      dataObj.root.$tick();\n    }\n  }\n  */\n\n  Data[\"default\"].inventory.delete(id);\n  delete this.data.__bbnData;\n};\n\n  \n// EXTERNAL MODULE: ./src/lib/Cp/private/updateWatcher.js\nvar updateWatcher = __webpack_require__(\"./src/lib/Cp/private/updateWatcher.js\");\n;// CONCATENATED MODULE: ./src/lib/Data/prototype/update.js\n\n\n\n\nconst recurse = (refs, exclude, res = []) => {\n  dist[\"default\"].fn.each(refs, rf => {\n    if (rf.parent && (rf.parent !== exclude) && !res.includes(rf.parent)) {\n      res.push(rf.parent);\n      if (rf.parent.refs) {\n        recurse(rf.parent.refs, rf.parent, res);\n      }\n    }\n  });\n\n  return res;\n};\n\n/**\n * Update all the components linked to the data object\n * @param {Boolean} deep \n */\nData[\"default\"].prototype.update = function(noParent, key) {\n  const impacted = this.getImpacted(key);\n  const cpToUpdate = [];\n  const dataToUpdate = [this];\n  dist[\"default\"].fn.each(impacted, it => {\n    if (it.cp.$isInit) {\n      let data = this;\n      let bits = it.path.slice();\n      let name = bits.join(\".\");\n      let lev = 0;\n      let isWatched = false;\n      if (it.cp.$watcher?.[name]) {\n        if (key || it.cp.$watcher[name].deep) {\n          (0,updateWatcher[\"default\"])(it.cp, name, dist[\"default\"].fn.getProperty(it.cp, name + '.' + key));\n          isWatched = true;\n        }\n      }\n\n      if (key) {\n        bits.pop();\n        name = bits.join(\".\");\n        if (it.cp.$watcher?.[name]) {\n          (0,updateWatcher[\"default\"])(it.cp, name, data.value);\n          isWatched = true;\n        }\n      }\n\n      if (!isWatched && !cpToUpdate.includes(it.cp)) {\n        cpToUpdate.push(it.cp);\n      }\n\n      bits.pop();\n      if (!noParent && bits.length) {\n        dataToUpdate.push(...recurse(data.refs, this));\n      }\n    }\n  });\n\n  dataToUpdate.shift();\n  dataToUpdate.forEach(d => d.update(true));\n  cpToUpdate.forEach(cp => cp.$tick());\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/retrieve.js\n\n\n/**\n * Retrieves a bbnData object from its unique id\n * \n * @param {Symbol} id \n * @returns \n */\nData[\"default\"].retrieve = function(id) {\n  return Data[\"default\"].inventory.get(id);\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/getObject.js\n\n\n\n/**\n * Returns the bbnData object from a value\n * @param {Object} value \n * @returns {bbnData|null}\n */\nData[\"default\"].getObject = function(value) {\n  if (value && (typeof value === 'object') && value.__bbnData) {\n    return this.retrieve(value.__bbnData);\n  }\n\n  return null;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/getValue.js\n\n\n/**\n * Gets the value stored in the bbnData object\n * @param {bbnData} obj \n * @param {Boolean} original if true returns the original value, no the proxy\n * @returns {Object} The reactive value or the original value\n */\nData[\"default\"].getValue = function(obj, original) {\n  if (obj && (typeof obj === 'object') && (obj instanceof Data[\"default\"])) {\n    return obj[original ? 'data' : 'value'];\n  }\n\n  throw Error(bbn._(\"The argument is not a bbnData object\"))\n\n  return obj;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/immunizeValue.js\n\n\n/**\n * Add a special property to an object in order to prevent it from being reactive\n * @param {Object} value The value to immunize\n * @returns {Object} The immunized value\n */\nData[\"default\"].immunizeValue = function(value, deep) {\n  if (value && (typeof value === 'object') && [undefined, Object, Array].includes(value.constructor)) {\n    // Removing data object if any\n    if (value.__bbnData) {\n      const dataObj = this.getObject(value);\n      if (dataObj) {\n        dataObj.unset();\n      }\n    }\n\n    // Adding the special property\n    Object.defineProperty(value, '__bbnNoData', {\n      value: true,\n      enumerable: false,\n      configurable: false,\n      writable: false\n    });\n\n    if (deep) {\n      bbn.fn.iterate(value, (v, i) => {\n        try {\n          value[i] = this.immunizeValue(v, true);\n        }\n        catch (e) {\n          bbn.fn.warning(\"ERROR IN IMMUNIZE\");\n          bbn.fn.log(e);\n        }\n      });\n    }\n  }\n    \n\n  return value;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxy.js\n\n\n\n/**\n * Returns a set of functions to be used by the proxy of bbnData objects\n * @param {*} component \n * @param {*} path \n * @param {*} targetObj \n * @returns \n */\nData[\"default\"].proxy = function(component, path, targetObj) {\n  const t = this;\n  return {\n    get(target, key) {\n      let realValue = target[key];\n      if (key === 'constructor') {\n        return realValue;\n      }\n\n      if (key?.indexOf && (key.indexOf('__bbn') === 0)) {\n        if (key === '__bbnProxy') {\n          return true;\n        }\n\n        return realValue;\n      }\n\n      if (dist[\"default\"].fn.isFunction(realValue)) {\n        if (targetObj && targetObj.isArray && dist[\"default\"].fn.isString(key)) {\n          const fnName = dist[\"default\"].fn.camelize('proxy-' + key);\n          if (dist[\"default\"].fn.isFunction(Data[\"default\"][fnName])) {\n            return t[fnName](target, component, path);\n          }\n        }\n      }\n      else if (realValue) {\n        realValue = t.treatValue(realValue, component, key, targetObj);\n      }\n\n      Data[\"default\"].addSequence(component, key, targetObj);\n      return realValue;\n    },\n    set(target, key, value) {\n      if (key?.indexOf && (key.indexOf('__bbn') === 0)) {\n        target[key] = newVal;\n        return true;\n      }\n\n      const oldValue = target[key];\n      const oldObj = t.getObject(oldValue);\n      let mod = false;\n\n      if (oldObj && !oldObj.isSame(value)) {\n        const newObj = t.getObject(value);\n        //bbn.fn.log([\"UNSET\", key, oldValue, value, oldObj.path, newObj?.path, oldObj.parent?.value?.length, newObj?.parent?.value?.length]);\n        oldObj.unset();\n        mod = true;\n      }\n      else if (!oldObj && !dist[\"default\"].fn.isSame(oldValue, value)) {\n        mod = true;\n      }\n      \n      if (mod) {\n        const newVal = t.treatValue(value, component, key, targetObj);\n        target[key] = newVal;\n        const dataObj = t.getObject(newVal);\n        //bbn.fn.log([\"SET\", targetObj, key, newVal, oldValue, target, '------']);\n\n        if (dataObj) {\n          dataObj.update(false);\n        }\n        else {\n          targetObj.update(false, key);\n        }\n\n      }\n\n      return true;\n    },\n    defineProperty(target, key, description) {\n      if (key.indexOf('__bbn') === 0) {\n        Object.defineProperty(target, key, description);\n        return true;\n      }\n\n      const oldValue = target[key];\n      const oldObj = t.getObject(oldValue);\n      if (oldObj) {\n        oldObj.unset();\n      }\n\n      if (description.value) {\n        description.value = t.treatValue(description.value, component, key, targetObj);\n      }\n\n      Object.defineProperty(target, key, description);\n      if (targetObj) {\n        targetObj.update(false, key);\n      }\n      else {\n        dist[\"default\"].fn.log(target, key, description);\n        dist[\"default\"].fn.warning(\"Impossible to get the target object\");\n      }\n      return true;\n    },\n    deleteProperty(target, key) {\n      const dataObj = t.getObject(target[key]);\n      if (dataObj) {\n        dataObj.unset();\n      }\n\n      delete target[key];\n      targetObj.update();\n      return true;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxyPop.js\n\n\n/**\n * Pops the last element of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxyPop = function(target) {\n  return () => {\n    // The bbnData object of the target array\n    const targetObj = this.getObject(target);\n    const len = target.length;\n    if (len) {\n      const subObj = this.getObject(target[len - 1]);\n      if (subObj) {\n        subObj.unset();\n      }\n    }\n    const res = target.pop();\n    if (targetObj) {\n      //bbn.fn.log(\"POP\");\n      targetObj.update();\n    }\n    else {\n      bbn.fn.log([\"Impossible to find the data object in pop\", target]);\n    }\n    return res;\n  };\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxyPush.js\n\n\n/**\n * Pushes one or more elements to the end of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxyPush = function(target, component) {\n  return (...args) => {\n    // The bbnData object of the target array\n    const targetObj = this.getObject(target);\n    let newArgs = [];\n    bbn.fn.each(args, (a, i) => {\n      const idx = target.length + i;\n      const newVal = this.treatValue(a, component, idx, targetObj);\n      newArgs.push(newVal);\n    });\n    const res = target.push(...newArgs);\n    if (targetObj) {\n      //bbn.fn.log(\"PUSH\");\n      targetObj.update();\n    }\n    else {\n      bbn.fn.log([\"Impossible to find the data object in push\", target]);\n    }\n\n    return res;\n  };\n}\n\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxyReverse.js\n\n\n/**\n * Reverses the order of the elements of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxyReverse = function(target) {\n  return (...args) => {\n    const res = target.reverse(...args);\n    const targetObj = this.getObject(target);\n    if (targetObj) {\n      targetObj.update();\n    }\n    else {\n      bbn.fn.log([\"Impossible to find the data object in reverse\", target]);\n    }\n\n    return res;\n  };\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxyShift.js\n\n\n/**\n * Shifts the first element of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxyShift = function(target) {\n  return () => {\n    // The bbnData object of the target array\n    const targetObj = this.getObject(target);\n    if (target.length) {\n      const subObj = this.getObject(target[0]);\n      if (subObj) {\n        subObj.unset();\n      }\n    }\n    const res = target.shift();\n    if (targetObj) {\n      //bbn.fn.log(\"SHIFT\");\n      targetObj.update();\n    }\n    else {\n      bbn.fn.log([\"Impossible to find the data object in shift\", target]);\n    }\n\n    return res;\n  };\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxySort.js\n\n\n/**\n * Sorts the elements of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxySort = function(target) {\n  return (...args) => {\n    const res = target.sort(...args);\n    const targetObj = this.getObject(target);\n    if (targetObj) {\n      bbn.fn.warning(\"SORT\");\n      targetObj.update();\n    }\n    else {\n      bbn.fn.log([\"Impossible to find the data object in sort\", target]);\n    }\n\n    return res;\n  };\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxySplice.js\n\n\n\n/**\n * Splices the elements of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxySplice = function(target, component) {\n  return (index, numDelete, ...args) => {\n    const targetObj = this.getObject(target);\n    if (!targetObj) {\n      dist[\"default\"].fn.log([\"Impossible to find the data object\", target]);\n    }\n    let newArgs = [];\n    dist[\"default\"].fn.each(args, (a, i) => {\n      const idx = target.length + i;\n      const newVal = this.treatValue(a, component, idx, targetObj);\n      newArgs.push(newVal);\n    });\n    const res = numDelete === undefined ? target.splice(index) : target.splice(index, numDelete, ...newArgs);\n    dist[\"default\"].fn.each(res, t => {\n      let subObj = this.getObject(t);\n      if (subObj) {\n        subObj.unset();\n      }\n    });\n    if (targetObj) {\n      //bbn.fn.log(\"SPLICE\");\n      targetObj.update();\n    }\n    else {\n      dist[\"default\"].fn.log([\"Impossible to find the data object in splice\", target]);\n    }\n\n    return res;\n  };\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/proxyUnshift.js\n\n\n/**\n * Unshifts one or more elements to the beginning of an array and updates the data object\n * @param {Array} target \n * @param {*} component \n * @param {*} path \n * @returns \n */\nData[\"default\"].proxyUnshift = function(target, component) {\n  return (...args) => {\n    // The bbnData object of the target array\n    const targetObj = this.getObject(target);\n    let newArgs = [];\n    bbn.fn.each(args, (a, i) => {\n      const idx = target.length + i;\n      const newVal = this.treatValue(a, component, idx, targetObj);\n      newArgs.push(newVal);\n    });\n    const res = target.unshift(...newArgs);\n    if (targetObj) {\n      //bbn.fn.log([dataObj.path, path]);\n      //bbn.fn.warning(\"UNSHIFT\");\n      targetObj.update();\n    }\n    else {\n      bbn.fn.log([\"Impossible to find the data object in unshift\", target]);\n    }\n\n    return res;\n  };\n}\n\n;// CONCATENATED MODULE: ./src/lib/Data/static/treatValue.js\n\n\n/**\n * Creates a new bbnData object if the given value is not primitive or already reactive, returns the value\n * @param {*} value \n * @param {*} component \n * @param {*} path \n * @param {*} parent \n * @returns {*} The original value or the reactive value\n */\nData[\"default\"].treatValue = function(value, component, path, parent) {\n  if (component.$isDestroyed) {\n    return value;\n  }\n\n  if (value && (typeof value === 'object') && [undefined, Object, Array].includes(value.constructor) && !value.__bbnNoData) {\n    if (value.__bbnData) {\n      const dataObj = this.retrieve(value.__bbnData);\n      if (!dataObj) {\n        bbn.fn.log(value);\n        bbn.fn.warning(bbn._(\"The data inventory does not contain the data object\"));\n        throw Error(bbn._(\"The data inventory does not contain the data object\"));\n      }\n\n      dataObj.addComponent(component, path, parent);\n\n      return dataObj.value;\n    }\n\n    if (value.__bbnComponent) {\n      throw Error(bbn._(\"The data object is a component definition\"));\n    }\n\n    const dataObj = new Data[\"default\"](value, component, path, parent);\n\n    return dataObj.value;\n  }\n\n  return value;\n}\n\n// EXTERNAL MODULE: ./src/cp.js + 60 modules\nvar cp = __webpack_require__(\"./src/cp.js\");\n;// CONCATENATED MODULE: ./src/internals/connectedCallback.js\n/**\n * Launches the component's connectedCallback\n * @param {bbnCp} cp \n */\nfunction connectedCallback(ele) {\n  if (ele.bbnId && !ele.bbn) {\n    ele.bbn = new (ele.bbnFn || ele.constructor.bbnFn)(ele);\n    if (ele.bbnConnected) {\n      ele.bbn.$connected();\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/internals/removeComponent.js\n\n\n/**\n * Removes a component from the global components index.\n * \n * @param {string} cid - The component ID to be removed.\n * @throws {Error} If the component ID is not provided or the component does not exist.\n */\nfunction removeComponent(cid) {\n  // Validate that the component ID is provided.\n  if (!cid) {\n    throw Error(\"The component doesn't have a component ID\");\n  }\n\n  // Retrieve the component from the global components index using the provided ID.\n  const cp = dist[\"default\"].cp.componentsIndex.get(cid);\n\n  // Check if the component exists in the index.\n  if (!cp) {\n    // Throw an error if the component is not found in the index.\n    throw Error(\"The component is already removed\");\n  }\n\n  // If the component exists, remove it from the global components index.\n  dist[\"default\"].cp.componentsIndex.delete(cid);\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/onHook.js\nasync function onHook(cp, hook) {\n  if (cp.$cfg[hook]?.length) {\n    for (let i = 0; i < cp.$cfg[hook].length; i++) {\n      await cp.$cfg[hook][i].bind(cp)();\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/unregisterChild.js\n/**\n * Unregister the given child of the component from the $children array\n */\nfunction unregisterChild(cp, child) {\n  let idx = cp.$children.indexOf(child);\n  if (idx > -1) {\n    cp.$children.splice(idx, 1);\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/disconnected.js\n\n\n\n\n\n/**\n * Shuts everything down\n * @returns \n */\nfunction disconnected(cp) {\n  //bbn.fn.log(\"Before disconnected callback from \" + cp.$el.tagName + ' / ' + cp.$el.bbnSchema.id);\n  if (!cp.$el.isConnected && !cp.$isDestroyed && cp.$isInit) {\n    Object.defineProperty(cp, '$isInit', {\n      value: false,\n      writable: false,\n      configurable: true\n    });\n    //bbn.fn.log(\"Disconnected callback from \" + cp.$el.tagName);\n    // Sending beforeDestroy event\n    const beforeDestroy = new Event('hook:beforedestroy');\n    onHook(cp, 'beforeDestroy');\n    cp.$el.dispatchEvent(beforeDestroy);\n    \n    if (cp.$parent) {\n      unregisterChild(cp.$parent, cp);\n    }\n    Object.defineProperty(cp, '$isDestroyed', {\n      value: true,\n      writable: false,\n      configurable: true\n    });\n    // Sending destroyed event through a timeout\n    // Deleting from elements prop\n    while (cp.$values.length) {\n      let id = cp.$values[cp.$values.length -1];\n      const data = bbnData.retrieve(id);\n      if (!data) {\n        throw Error(dist[\"default\"]._(\"Impossible to find a piece of data in %s\", cp.$options.name));\n      }\n      else {\n        //bbn.fn.log('Removing 1 loop data for ' + cp.$cid + ' in ' + cp.$options.name + ' / path: ' + data.path);\n        data.removeComponent(cp);\n      }\n    }\n\n    removeComponent(cp.$el.bbnCid);\n    // Setting back $isinit\n    const destroyed = new Event('hook:destroyed');\n    onHook(cp, 'destroyed');\n    cp.$el.dispatchEvent(destroyed);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/internals/disconnectedCallback.js\n\n\n/**\n * Launches the component's disconnectedCallback\n * @param {HTMLElement} ele \n */\nfunction disconnectedCallback(ele) {\n  if (ele.bbn) {\n    disconnected(ele.bbn)\n  }\n}\n\n;// CONCATENATED MODULE: ./src/internals/createCid.js\n/**\n * Creates a unique ID for a component\n */\nfunction createCid() {\n  let cid = 'bbncp-' + bbn.fn.randomString(24, 32).toLowerCase();\n  while (bbn.cp.componentsIndex.has(cid)) {\n    cid = 'bbncp-' + bbn.fn.randomString(24, 32).toLowerCase();\n  }\n\n  return cid;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Html.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass Html_bbnHTML extends HTMLElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Button.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnButtonHTML extends HTMLButtonElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n\n;// CONCATENATED MODULE: ./src/lib/Cell.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnCellHTML extends HTMLTableCellElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n;// CONCATENATED MODULE: ./src/lib/Div.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnDivHTML extends HTMLDivElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n;// CONCATENATED MODULE: ./src/lib/Element.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnElementHTML extends HTMLLIElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n;// CONCATENATED MODULE: ./src/lib/Form.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnFormHTML extends HTMLFormElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n\n;// CONCATENATED MODULE: ./src/lib/List.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnListHTML extends HTMLUListElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n;// CONCATENATED MODULE: ./src/lib/Row.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnRowHTML extends HTMLTableRowElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n;// CONCATENATED MODULE: ./src/lib/Span.js\n\n\n\n\n\n/**\n * Create the bbn component class which extends the HTMLElement class\n */\nclass bbnSpanHTML extends HTMLSpanElement\n{\n  bbnCid;\n\n  constructor() {\n    super();\n    Object.defineProperty(this, 'bbnCid', {\n      value: createCid(),\n      writable: false,\n      configurable: false\n    });\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  bbnUpdate(newSchema) {\n    return bbn.cp.bbnUpdate(this, newSchema);\n  }\n\n}\n\n// EXTERNAL MODULE: ./src/lib/Cp/Cp.js + 1 modules\nvar Cp = __webpack_require__(\"./src/lib/Cp/Cp.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/addNamespace.js\nvar addNamespace = __webpack_require__(\"./src/lib/Cp/private/addNamespace.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/init.js\n\n\n\n/**\n * Starts everything up\n * @returns \n */\nfunction init(cp) {\n  if (Object.hasOwn(cp, '$isInit')) {\n    throw Error(\"Illegal init call\");\n  }\n\n  /**\n   * A reference to the component Object (cp)\n   */\n  Object.defineProperty(cp, '_self', {\n    confifurable: false,\n    writable: false,\n    value: cp.$el.bbn\n  });\n\n\n  // This will hold all the reactive data\n  Object.defineProperty(cp, '$values', {\n    value: [],\n    writable: false,\n    configurable: false\n  });\n\n  // This will become true after all is mounted\n  Object.defineProperty(cp, '$isInit', {\n    value: false,\n    writable: false,\n    configurable: true\n  });\n\n  // This will become true after the data functions are launched and the data is set\n  Object.defineProperty(cp, '$isDataSet', {\n    value: false,\n    writable: false,\n    configurable: true\n  });\n\n  // This will be true during the construction process (updateComponent)\n  Object.defineProperty(cp, '$isCreating', {\n    value: false,\n    writable: true,\n    configurable: true\n  });\n\n  // This will be true during the construction process (updateComponent)\n  Object.defineProperty(cp, '$isUpdating', {\n    value: null,\n    writable: true,\n    configurable: true\n  });\n\n  Object.defineProperty(cp, '$isCreated', {\n    value: false,\n    writable: true,\n    configurable: true\n  });\n\n  Object.defineProperty(cp, '$isDestroyed', {\n    value: false,\n    writable: true,\n    configurable: true\n  });\n\n  Object.defineProperty(cp, '$isMounted', {\n    value: false,\n    writable: true,\n    configurable: true\n  });\n\n  // This will be true during the construction process (updateComponent)\n  Object.defineProperty(cp, '$isUpdatingComputed', {\n    value: false,\n    writable: true,\n    configurable: true\n  });\n  // This will be true during the construction process (updateComponent)\n  Object.defineProperty(cp, '$tagUsed', {\n    value: [],\n    writable: false,\n    configurable: true\n  });\n\n\n  /**\n   * Object of all the instance properties available directly in the HTML templates.\n   * Indexed by name, the value being the type (data, prop, method, computed)\n   * @return {Object}\n   */\n  Object.defineProperty(cp, '$namespaces', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n\n  /**\n   * Template array\n  */\n  Object.defineProperty(cp, '$tpl', {\n    value: cp.$el.bbnTpl || cp.$el.constructor.bbnTpl,\n    writable: false,\n    configurable: false\n  });\n\n  if (cp.$el.bbnSchema.model?._default_) {\n    const modelProp = cp.$cfg.model?.prop || 'value';\n    cp.$el.bbnSchema.model[modelProp] = cp.$el.bbnSchema.model._default_;\n    delete cp.$el.bbnSchema.model._default_;\n    if (cp.$el.bbnSchema.props?._default_) {\n      cp.$el.bbnSchema.props[modelProp] = cp.$el.bbnSchema.props._default_;\n      delete cp.$el.bbnSchema.props._default_;\n    }\n  }\n\n  const _t = cp;\n\n  Object.defineProperty(cp.$options, 'propsData', {\n    get() {\n      return _t.$el.bbnSchema?.props || {};\n    }\n  });\n\n  Object.defineProperty(cp.$options, 'components', {\n    get() {\n      return _t.$cfg.components || {};\n    }\n  });\n\n  Object.defineProperty(cp, '$props', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * Object of all available slots nodes in the template.\n   * Indexed by name with id as value\n   */\n  Object.defineProperty(cp, '$availableSlots', {\n    get() {\n      return cp.$el.bbnSlots || bbnHTML.availableSlots;\n    }\n  });\n\n  /**\n   * Is true if is creating or updating\n   */\n  Object.defineProperty(cp, '$currentComputed', {\n    value: null,\n    writable: false,\n    configurable: true\n  });\n\n  /**\n   * Is true if is creating or updating\n   */\n  Object.defineProperty(cp, '$currentExpression', {\n    value: null,\n    writable: false,\n    configurable: true\n  });\n\n  /**\n   * Is true if is creating or updating\n   */\n  Object.defineProperty(cp, '$isBusy', {\n    get() {\n      return cp.$isCreating || cp.$isUpdating;\n    }\n  });\n\n  /**\n   * Object of all available slots nodes in the template.\n   * Indexed by name with id as value\n   */\n  Object.defineProperty(cp, '$hash', {\n    get() {\n      return cp.$el?.bbnHash || '';\n    }\n  });\n\n\n  // Setting $eval with the retrived/generated function\n  Object.defineProperty(cp, '$oldValues', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n\n  Object.defineProperty(cp, '$watcher', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false\n  });\n\n  dist[\"default\"].fn.iterate(cp.$cfg.watch, (a, name) => {\n    cp.$watch(name, a);\n  });\n\n  /**\n   * Object referencing all the content for each available slot.\n   * Indexed by slot's name (default is default), it contains an array of nodes which are the content\n   * @return {Object}\n   */\n  Object.defineProperty(cp, '$slots', {\n    get() {\n      return cp.$el.bbnSlots;\n    }\n  });\n\n  /**\n   * The ID of the component, corresponding ot its ID in the template.\n   * Components inside a loop have all the same id\n   */\n  Object.defineProperty(cp, '$id', {\n    value: cp.$el.bbnId,\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * Unique ID for each component, used for global registration\n   */\n  Object.defineProperty(cp, '$cid', {\n    value: cp.$el.bbnCid,\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * Unique ID for each component, used for global registration\n   */\n  Object.defineProperty(cp, '$origin', {\n    value: cp.$el.bbnComponentId && (cp.$el.bbnComponentId !== cp.$cid) ? dist[\"default\"].cp.getComponent(cp.$el.bbnComponentId)?.bbn || cp : cp,\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * Object of DOM building functions indexed on the template ids\n   */\n  Object.defineProperty(cp, '$fns', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * The class constructor\n   */\n  Object.defineProperty(cp, '$cls', {\n    value: cp.$el.constructor,\n    writable: false,\n    configurable: false\n  });\n\n  Object.defineProperty(cp, '$events', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n  /**\n * Array of bbnComponentObject instances direct descendants of the current one\n * @return {Array}\n */\n  Object.defineProperty(cp, '$children', {\n    value: [],\n    writable: false,\n    configurable: false\n  });\n\n  Object.defineProperty(cp, '$elements', {\n    value: dist[\"default\"].fn.createObject({\n      '0': cp.$el\n    }),\n    writable: false,\n    configurable: false\n  });\n\n  /** @var {Object} $dataValues The content of the data */\n  Object.defineProperty(cp, '$dataValues', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n  Object.defineProperty(cp, '$refsElements', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n\n  Object.defineProperty(cp, '$deps', {\n    value: dist[\"default\"].fn.createObject({\n      __bbnDataRegister: new Map()\n    }),\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * Counts the number of times the component has been repainted through the method updateComponent\n   */\n  Object.defineProperty(cp, '$numBuild', {\n    value: 0,\n    writable: true,\n    configurable: true\n  });\n\n  //Object.defineProperty\n  //cp.$event = null;\n  //cp.$cls = cp.$el.constructor;\n  /**\n   * Object referencing all the elements with ref prop\n   * Indexed by name, value being the bbnComponentObject if it's a component a HTMLElement otherwise\n   * @return {Object}\n   */\n  Object.defineProperty(cp, '$refs', {\n    configurable: false,\n    writable: false,\n    value: new Proxy(cp.$refsElements, {\n      get(target, propName) {\n        let tmp = target[propName];\n        if (tmp) {\n          if (dist[\"default\"].fn.isArray(tmp)) {\n            return tmp.filter(a => a.isConnected)\n              .map(a => a.bbn || a);\n          }\n\n          return tmp.isConnected ? (tmp.bbn || tmp) : null;\n        }\n      }\n    })\n  });\n\n  // Setting up $parent prop\n  const parentNode = cp.$el.parentNode;\n  // host is for shadow DOM (not used)\n  const parent = parentNode.host ? parentNode.host.closest(\".bbn-component\") : parentNode.closest(\".bbn-component\");\n\n  // $parent will always remain the same, it should only be null for root\n  Object.defineProperty(cp, '$parent', {\n    value: parent ? parent.bbn : null,\n    writable: false,\n    configurable: false\n  });\n  /**\n   * The highest component in the document's hierarchy\n   */\n  Object.defineProperty(cp, '$root', {\n    value: cp.$parent?.$root || cp,\n    writable: false,\n    configurable: false\n  });\n\n  Object.defineProperty(cp, '$connectors', {\n    value: [],\n    writable: false,\n    configurable: false\n  });\n\n  /**\n   * The directives on the root element of the template\n   */\n  Object.defineProperty(cp, '$directives', {\n    value: dist[\"default\"].fn.createObject(),\n    writable: false,\n    configurable: false\n  });\n  \n  Object.defineProperty(cp, '$queue', {\n    value: cp.$root === cp ? [] : cp.$root.$queue,\n    writable: false,\n    configurable: false\n  });\n  /*\n  Object.defineProperty(cp, '$queue', {\n    value: [],\n    writable: false,\n    configurable: false\n  });\n  */\n\n  if (cp === cp.$root) {\n    cp.$fetchTimeout = null;\n    Object.defineProperty(cp, '$unknownComponents', {\n      value: [],\n      writable: false,\n      configurable: false\n    });\n  }\n  Object.defineProperty(cp, '$currentMap', {\n    get() {\n      return cp.$el.bbnMap || cp.$cls.bbnMap;\n    }\n  });\n  Object.defineProperty(cp, '$expResults', {\n    configurable: false,\n    writable: false,\n    value: dist[\"default\"].fn.createObject()\n  });\n  Object.defineProperty(cp, '$schema', {\n    configurable: false,\n    writable: false,\n    value: []\n  });\n  /**\n   * The latest timestamp of the last update launch\n   */\n  Object.defineProperty(cp, '$lastLaunch', {\n    value: 0,\n    writable: true\n  });\n\n  // Setting up available props for HTML templates\n  (0,addNamespace[\"default\"])(cp, '$props', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$el', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$root', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$cid', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$event', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$parent', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$options', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$namespaces', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$children', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$refs', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$slots', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$isCreated', 'internal');\n  (0,addNamespace[\"default\"])(cp, '$isMounted', 'internal');\n  (0,addNamespace[\"default\"])(cp, '_self', 'internal');\n  (0,addNamespace[\"default\"])(cp, '_', 'method');\n  (0,addNamespace[\"default\"])(cp, '$emit', 'method');\n  (0,addNamespace[\"default\"])(cp, '$is', 'method');\n  (0,addNamespace[\"default\"])(cp, '$isComponent', 'method');\n  (0,addNamespace[\"default\"])(cp, '$nextTick', 'method');\n  (0,addNamespace[\"default\"])(cp, '$off', 'method');\n  (0,addNamespace[\"default\"])(cp, '$on', 'method');\n  (0,addNamespace[\"default\"])(cp, '$once', 'method');\n  (0,addNamespace[\"default\"])(cp, '$retrieveComponent', 'method');\n  (0,addNamespace[\"default\"])(cp, '$retrieveElement', 'method');\n  (0,addNamespace[\"default\"])(cp, 'ancestors', 'method');\n  (0,addNamespace[\"default\"])(cp, 'closest', 'method');\n  (0,addNamespace[\"default\"])(cp, 'extend', 'method');\n  (0,addNamespace[\"default\"])(cp, 'find', 'method');\n  (0,addNamespace[\"default\"])(cp, 'findAll', 'method');\n  (0,addNamespace[\"default\"])(cp, 'findAllByKey', 'method');\n  (0,addNamespace[\"default\"])(cp, 'findByKey', 'method');\n  (0,addNamespace[\"default\"])(cp, 'getChildByKey', 'method');\n  (0,addNamespace[\"default\"])(cp, 'getComponentName', 'method');\n  (0,addNamespace[\"default\"])(cp, 'getComponents', 'method');\n  (0,addNamespace[\"default\"])(cp, 'getRef', 'method');\n  dist[\"default\"].fn.iterate(bbnCp.prototype, (a, n) => {\n    if (dist[\"default\"].fn.isFunction(a)) {\n      (0,addNamespace[\"default\"])(cp, n, 'method');\n    }\n  });\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/registerChild.js\n/**\n * Register the given child of the component into the $children array\n */\nfunction registerChild(cp, child) {\n  bbn.fn.checkType(child, Object, \"The child must be an object\");\n  cp.$children.push(child);\n  if (cp.onRegisterChild) {\n    cp.onRegisterChild(child);\n  }\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/propagateDependencyChanges.js\nvar propagateDependencyChanges = __webpack_require__(\"./src/lib/Cp/private/propagateDependencyChanges.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/setData.js\n\n\n\n/**\n * Set the data properties of the object\n */\nfunction setData(cp, name, v) {\n  //bbn.fn.log([\"SET DATA\", cp, name, v]);\n  // In the case the function is called litterally it creates \n  \n  if (!Object.hasOwn(cp, name)) {\n    return setUpData(cp, name, v);\n  }\n\n  v = cp.$treatValue(v, name);\n  if (cp.$dataValues[name] !== v) {\n    let isMod = true;\n    // Getting the bbnData object\n    let oldDataObj = bbnData.getObject(cp.$dataValues[name]);\n    if (oldDataObj) {\n      if (oldDataObj.isSame(v)) {\n        isMod = false;\n      }\n      else {\n        //bbn.fn.log([\"REMOVING COMPONENT FROM DATA\", cp, oldV, v]);\n        oldDataObj.removeComponent(cp, name);\n      }\n    }\n\n    if (isMod) {\n      cp.$dataValues[name] = v;\n      (0,updateWatcher[\"default\"])(cp, name, v);\n      (0,propagateDependencyChanges[\"default\"])(cp, name);\n      cp.$tick();\n    }\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/setUpData.js\n\n\n\n\nfunction setUpData(cp, name, value) {\n  \n  if (!Object.hasOwn(cp, name)) {\n    // The data will remain the same if not simple Obj/Array\n    cp.$dataValues[name] = cp.$treatValue(value, name);\n    const def = {\n      get() {\n        /*\n        if (cp.$currentComputed && !cp.$computed[cp.$currentComputed].dependencies.includes(name)) {\n          cp.$computed[cp.$currentComputed].dependencies.push(name);\n        }\n        */\n        bbnData.addSequence(cp, name, this.$dataValues[name]);\n        return cp.$dataValues[name];\n      },\n      set(v) {\n        return setData(cp, name, v);\n      }\n    };\n    Object.defineProperty(cp, name, def);\n    (0,addNamespace[\"default\"])(cp, name, 'data');\n    if ((cp.$options.name === 'bbn-widget') && (name === 'dashboard')){\n      bbn.fn.log([\"SETTING UP DATA\", value, Object.hasOwn(cp, name), cp.$namespaces.currentItems, cp.$numBuild, cp.$isCreated, cp.$isMounted])\n    }\n    if (cp.$numBuild) {\n      (0,updateWatcher[\"default\"])(cp, name, cp.$dataValues[name], true);\n    }\n    if (cp.$isMounted) {\n      cp.$tick();\n    }\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/updateData.js\n\n\n/**\n * Update the data property with the dataSource Array\n */\nfunction updateData(cp) {\n  if (cp.$isDataSet) {\n    return;\n  }\n\n  if (cp.$cfg.data.length) {\n    bbn.fn.iterate(\n      bbn.fn.extend(bbn.fn.createObject(), ...cp.$cfg.data.map(a => a.apply(cp))),\n      (v, n) => {\n        setUpData(cp, n, v);\n      }\n    );\n  }\n\n  Object.defineProperty(cp, '$isDataSet', {\n    value: true,\n    writable: false,\n    configurable: false\n  });\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/launch.js + 28 modules\nvar launch = __webpack_require__(\"./src/lib/Cp/private/launch.js\");\n;// CONCATENATED MODULE: ./src/internals/mapDependencies.js\n/**\n * Converts an expression into a function for dynamic value resolution.\n * @param {bbnCp} cp - The component instance.\n * @param {Object} loopVars - The loop variables in the current context.\n * @param {Object} a - The attribute or property object.\n * @param {Object} node - The current node in the template.\n * @param {boolean} type - Indicates if the function is for an event.\n * @returns {Function} A function to evaluate the expression.\n */\nconst expToFn = (cp, loopVars, a, node, type) => {\n  if (a.exp) {\n    const deps = [];\n    bbn.fn.each(Object.keys(cp.$namespaces), arg => {\n      if (a.exp.match(new RegExp((arg.indexOf('$') === 0 ? '' : '\\\\b') + bbn.fn.escapeRegExp(arg) + '\\\\b'))) {\n        deps.push(arg);\n      }\n    });\n    const args = deps.slice();\n    bbn.fn.iterate(loopVars, (v, k) => {\n      if (node.id.indexOf(k) === 0) {\n        args.push(...v);\n      }\n    });\n    if (type === 'event') {\n      let stFn = 'const $_bbnData = {';\n      bbn.fn.each(args, arg => {\n        stFn += `  ${arg}: bbn.fn.hash(${arg}),\\n`;\n      });\n      stFn += `};\\n`;\n      stFn += `if (bbnData.isWatching) {bbnData.watchStarted = true;}\\n`;\n      stFn += `${a.exp}\\n`;\n      stFn += `if (bbnData.watchStarted) {bbnData.watchStarted = false;}\\n`;\n      bbn.fn.each(args, arg => {\n        stFn += `if ($_bbnData['${arg}'] !== bbn.fn.hash(${arg})) {\\n`;\n        if (loopVars[arg]) {\n        }\n        else if (Object.hasOwn(cp, arg)) {\n          stFn += `  this['${arg}'] = ${arg};\\n`;\n        }\n        stFn += `}\\n`;\n      });\n      a.fn = new Function(...args, stFn);\n    }\n    else {\n      let stFn = `if (bbnData.isWatching) {bbnData.watchStarted = true;}\\n`;\n      stFn += 'const $_bbnRes = (' + (a.exp || (node.type === 'else' ? 'true' : '')) + ')\\n';\n      stFn += `if (bbnData.watchStarted) {bbnData.watchStarted = false;}\\n`;\n      stFn += `return $_bbnRes;\\n`;\n      a.fn = new Function(...args, stFn);\n      if (type === 'model') {\n        a.setter = new Function('bbnValue', ...args, a.exp + ' = bbnValue; return bbnValkue;');\n      }\n    }\n\n    a.args = args;\n    return args;\n  }\n\n  return [];\n};\n\n\n/**\n * Processes the template of a component and maps dependencies.\n * It adds functions and necessary argument names to resolve dynamic values.\n * \n * @param {bbnCp} cp - The component instance to process.\n */\nfunction mapDependencies(cp) {\n  const elemSrc = cp.$el.constructor === bbnAnon ? cp.$el : cp.$el.constructor;\n  // Avoid remapping if already done for the component.\n  if (elemSrc.bbnMapped) {\n    return;\n  }\n\n  // Object to store loop variables for each node.\n  const loopVars = {};\n\n  // Iterate over each node in the component's map.\n  bbn.fn.iterate(cp.$currentMap, node => {\n    const deps = [];\n\n    // Process loop-related attributes.\n    if (node.loop) {\n      const args = expToFn(cp, loopVars, node.loop, node);\n      deps.push(...args);\n      loopVars[node.id] = [\n        ...node.loop.item ? [node.loop.item] : [],\n        ...node.loop.index ? [node.loop.index] : []\n      ];\n\n      expToFn(cp, loopVars, node.loopItem, node);\n      if (node.loopIndex) {\n        expToFn(cp, loopVars, node.loopIndex, node);\n      }\n    }\n    // Process condition-related attributes.\n    if (node.condition) {\n      const args = expToFn(cp, node.condition.type === 'else' ? {} : loopVars, node.condition, node);\n      deps.push(...args);\n    }\n\n    if (node.forget) {\n      const args = expToFn(cp, loopVars, node.forget, node);\n      deps.push(...args);\n    }\n\n    if (node.attr) {\n      bbn.fn.iterate(node.attr, a => {\n        if (a.exp) {\n          const args = expToFn(cp, loopVars, a, node);\n          deps.push(...args);\n        }\n      });\n    }\n    else if (node.exp) {\n      node.exp = '`' + node.exp + '`';\n      const args = expToFn(cp, loopVars, node, node);\n      deps.push(...args);\n    }\n\n    if (node.events) {\n      bbn.fn.iterate(node.events, a => {\n        if (a.exp) {\n          const args = expToFn(cp, loopVars, a, node, 'event');\n          deps.push(...args);\n        }\n      });\n    }\n\n    if (node.model) {\n      bbn.fn.iterate(node.model, a => {\n        if (a.exp) {\n          const args = expToFn(cp, loopVars, a, node, 'model');\n          deps.push(...args);\n        }\n      });\n    }\n\n    if (node.directives) {\n      bbn.fn.iterate(node.directives, a => {\n        if (a.exp) {\n          const args = expToFn(cp, loopVars, a, node);\n          deps.push(...args);\n        }\n      });\n    }\n\n    // Store unique dependencies for each node.\n    node.dependencies = bbn.fn.unique(deps);\n    Object.freeze(node);\n  });\n\n  Object.defineProperty(elemSrc, 'bbnMapped', {\n    value: true,\n    writable: false,\n    configurable: false\n  });\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/connected.js\n\n\n\n\n\n\n\n\n\n/**\n * Starts everything up when the component enters the DOM\n * - Adds itself tyo the global static 'components'\n * - Sets up the props\n * - Triggers beforecreate\n * - Sets $parent\n * - Launches $addToElements in order to add the element to the $elements property\n * - Sets $root\n * - Adds namespaces for computed and methods\n * - Sets up the properties based on attributes\n * - Sets up the data\n * - Triggers created\n * - Creates the DOM\n * - Triggers beforemount\n * - Sets $isInit to true\n * - Triggers mounted\n * - Sets $isMOunted to true\n * - Starts tick interval\n * \n * @returns {undefined}\n */\n\nCp[\"default\"].prototype.$connected = async function () {\n  // Check we are in the DOm\n  //bbn.fn.warning(\"CALLBACK ON \" + this.$options.name + \" / \" + this.$el.bbnSchema.id + \" INIT: \" + this.$isInit + \" MOUNTED: \" + this.$isMounted);\n  if (!this.$el.isConnected) {\n    bbn.fn.log(\"CONNECTED CALLBACK: not connected or already initialized\", this.$el.isConnected, bbn.cp.getComponent(this.$el.bbnCid));\n    return;\n  }\n  if (Object.hasOwn(this, '$isInit')) {\n    bbn.fn.log(\"WTF \" + this.constructor.name);\n    throw Error(\"WTF \" + this.constructor.name);\n  }\n\n  init(this);\n\n  // An anon component won't have props nor this method\n  /** @todo check if the above assertion is true (source?) */\n  this.$setUpProps();\n\n  // Sending beforeCreate event\n  const beforeCreate = new Event('hook:beforecreate');\n  await onHook(this, 'beforeCreate');\n  this.$el.dispatchEvent(beforeCreate);\n\n  // Setting up the config\n  const cfg = this.$cfg;\n  // Setting up the namespace for the methods\n  if (cfg.methods) {\n    bbn.fn.each(Object.keys(cfg.methods), n => (0,addNamespace[\"default\"])(this, n, 'method'));\n  }\n  // Setting up the namespace for the computed\n  if (cfg.computed) {\n    bbn.fn.each(Object.keys(cfg.computed), n => (0,addNamespace[\"default\"])(this, n, 'computed'));\n  }\n\n  // Setting up data\n  if (this.$cfg.data) {\n    // Proper to the specific private class: sets all the datasource\n    Object.defineProperty(this, '$dataSource', {\n      writable: false,\n      configurable: false,\n      value: this.$cfg.data\n    });\n    // Setting up all the data properties\n    updateData(this);\n  }\n\n  // Generates the evaluator function, will happen only once\n  /*\n  if (!this.$el.bbnEval && !this.$el.constructor.bbnEval) {\n    // The template is not a one-shot (it is defined in the constructor)\n    if (!this.$el.bbnTpl) {\n      // The function has never been generated for this component\n      if (!this.$el.constructor.bbnEval) {\n        // Generating\n        const fn = templateToFunction(this, this.$el.constructor.bbnTpl);\n        if (!fn) {\n          throw Error(bbn._(\"Impossible to create the template evaluator\"));\n        }\n        // Setting in component's constructor\n        this.$el.constructor.prototype.bbnEval = fn;\n      }\n    }\n    // The template is a one-shot, bbnAnon\n    else {\n      // Generating\n      const fn = templateToFunction(this, this.$el.bbnTpl);\n      if (!fn) {\n        throw Error(bbn._(\"Impossible to create the template evaluator\"));\n      }\n      // Setting in component's property\n      Object.defineProperty(this.$el, 'bbnEval', {\n        value: fn,\n        writable: false,\n        configurable: false\n      });\n    }\n  }\n  */\n  mapDependencies(this);\n\n  // Setting $eval with the retrived/generated function\n  Object.defineProperty(this, '$eval', {\n    value: this.$el.bbnEval || this.$el.constructor.bbnEval,\n    writable: false,\n    configurable: false\n  });\n\n\n  // Sending created event\n  if (!this.$isCreated) {\n    const created = new Event('hook:created');\n    await onHook(this, 'created');\n    this.$el.dispatchEvent(created);\n    Object.defineProperty(this, '$isCreated', {\n      value: true,\n      writable: false, \n      configurable: false\n    });\n  }\n\n  // Sets the current template schema and creates the DOM\n  await (0,launch[\"default\"])(this);\n\n  // registering current object to parent and setting root\n  if (this.$parent) {\n    registerChild(this.$parent, this);\n  }\n\n  // Sending beforeMount event\n  const beforeMount = new Event('hook:beforemount');\n  await onHook(this, 'beforeMount');\n  this.$el.dispatchEvent(beforeMount);\n\n  // $isInit, defined in constructor  is made writable before being set to true\n  Object.defineProperty(this, '$isInit', {\n    value: true,\n    writable: false,\n    configurable: true\n  });\n  this.$el.dispatchEvent(new CustomEvent('connected'));\n\n  if (!this.$isMounted) {\n    // Sending mounted event\n    const mounted = new Event('hook:mounted');\n    await onHook(this, 'mounted');\n    this.$el.dispatchEvent(mounted);\n    Object.defineProperty(this, '$isMounted', {\n      value: true,\n      writable: false, \n      configurable: false\n    });\n  }\n\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/delete.js\n\n\n/**\n * Deletes the given property from the given object using static method\n * @param {*} obj \n * @param {*} prop \n * @returns \n */\nCp[\"default\"].prototype.$delete = function (obj, prop) {\n  return delete obj[prop];\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/removeDOM.js + 1 modules\nvar removeDOM = __webpack_require__(\"./src/lib/Cp/private/removeDOM.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/destroy.js\n\n\n\nCp[\"default\"].prototype.$destroy = function(){\n  (0,removeDOM[\"default\"])(this.$root, this.$el);\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/emit.js\n\n\n\n/**\n * Emits a new event with variable arguments\n */\nCp[\"default\"].prototype.$emit = function (eventName, ...args) {\n  dist[\"default\"].fn.checkType(eventName, String);\n\n  if (dist[\"default\"].env.loggingLevel > 5) {\n    dist[\"default\"].fn.log(dist[\"default\"]._(\"Event %s emitted by %s\", eventName, this.$options.name));\n  }\n\n  if (!args.length) {\n    dist[\"default\"].fn.each(args, a => {\n      if (!dist[\"default\"].fn.isPrimitive(a)\n          && (a instanceof CustomEvent)\n          && a.detail\n          && a.detail.__bbnEvent\n      ) {\n        if (a.detail.args) {\n          args = a.detail.args;\n        }\n      }\n    });\n  }\n\n  const ev = new CustomEvent(eventName, dist[\"default\"].fn.createObject({\n    detail: {\n      __bbnEvent: true,\n      args: args\n    }\n  }));\n  this.$el.dispatchEvent(ev);\n  return ev;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/forceUpdate.js\n\n\n\nCp[\"default\"].prototype.$forceUpdate = async function (fn) {\n  if (!this.$isBusy) {\n    const prom = (0,launch[\"default\"])(this);\n    if (fn) {\n      return prom.then(() => fn);\n    }\n\n    return prom;\n  }\n  else {\n    return new Promise(resolve => {\n      let idx = bbn.fn.search(bbn.cp.queue, {cp: this});\n      let tmp;\n      if (idx > -1) {\n        tmp = bbn.cp.queue.splice(idx, 1)[0];\n      }\n      else {\n        tmp = {\n          cp: this,\n          fns: [],\n          force: true\n        };\n      }\n\n      tmp.fns.push(resolve);\n      if (fn && bbn.fn.isFunction(fn)) {\n        tmp.fns.push(fn);\n      }\n\n      if (!tmp.force) {\n        tmp.force = true;\n      }\n\n      bbn.cp.queue.unshift(tmp);\n\n    });\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/get.js\n\n\n/**\n * Gets the given property from the given object using static method\n * @param {*} obj \n * @param {*} prop \n * @returns \n */\nCp[\"default\"].prototype.$get = function (obj, prop) {\n  return obj[prop];\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/has.js\n\n\n/**\n * Checks if the component has a property (or whatever) with the given name\n * @method has\n * @fires bbn.cp.has\n * @param {String} propName\n * @return {Function}\n */\nCp[\"default\"].prototype.$has = function(propName){\n  return Object.hasOwn(this.$namespaces, propName);\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/is.js\n\n\n/**\n * Checks if the component corresponds to the selector\n * @method is\n * @fires bbn.cp.is\n * @param {String} selector \n * @return {Function}\n */\nCp[\"default\"].prototype.$is = function(selector){\n    return this.$el.matches(selector);\n  }\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/isComponent.js\n\n\nCp[\"default\"].prototype.$isComponent = function (node) {\n  if (node.tag && this.$cfg.componentNames[node.tag]) {\n    return true;\n  }\n\n  return bbn.cp.isComponent(node);\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/nextTick.js\n\n\nCp[\"default\"].prototype.$nextTick = async function(fn){\n  const cp = this;\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      if (fn) {\n        fn.bind(cp)();\n      }\n\n      resolve();\n    }, bbn.cp.tickDelay);\n  });\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/off.js\n\n\n/**\n * Removes an event listener on the element set with $on\n * @param {String} event \n * @param {Function} handler \n */\nCp[\"default\"].prototype.$off = function (event, handler, bound) {\n  bbn.fn.checkType(event, String, bbn._(\"Events must be strings for \\$off / %s in %s\", event, this.$options.name));\n  bbn.fn.checkType(handler, Function, bbn._(\"Events handlers must be functions for \\$off / %s in %s\", event, this.$options.name));\n  const fn = bbn.fn.analyzeFunction(handler);\n  const hash = bbn.fn.md5((bound || this).$cid + '-' + event + '-' + handler.toString());\n  if (this.$events[event]?.[hash]) {\n    this.$el.removeEventListener(event, this.$events[event][hash]);\n    delete this.$events[event][hash];\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/on.js\n\n\n/**\n * Sets an event listener for the given event with the given handler on the component's element\n * @param {String} event \n * @param {Function} handler \n */\nCp[\"default\"].prototype.$on = function (event, handler, remove, bound) {\n  if (!bound) {\n    bound = this;\n  }\n\n  bbn.fn.checkType(event, String, bbn._(\"Events must be strings for \\$on in %s\", this.$options.name));\n  bbn.fn.checkType(handler, Function, bbn._(\"Events handlers must be functions for \\$on in %s\", this.$options.name));\n  const fn = bbn.fn.analyzeFunction(handler);\n  const hash = bbn.fn.md5((bound || this).$cid + '-' + fn.hash);\n  if (!this.$events[event]) {\n    this.$events[event] = bbn.fn.createObject();\n  }\n\n  if (!remove && this.$events[event][hash]) {\n    //throw Error(bbn._(\"The event %s is already set in %s\", event, this.$options.name));\n  }\n\n  this.$events[event][hash] = (ev) => {\n    const args = [];\n    if (ev.detail?.args) {\n      args.push(...ev.detail.args);\n    }\n    /*\n    else {\n      args.push(ev);\n    }\n    */\n\n    handler.bind(bound)(...args);\n  }\n\n  const opt = {};\n  if (remove) {\n    opt.once = true;\n  }\n\n  this.$el.addEventListener(event, this.$events[event][hash], opt);\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/once.js\n\n\nCp[\"default\"].prototype.$once = function(event, handler){\n    this.$off(event, handler);\n    this.$on(event, handler, true);\n  }\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/retrieveComponent.js\n\n\nCp[\"default\"].prototype.$retrieveComponent = function (id, hash, index = -1, loopObj) {\n  const ele = this.$retrieveElement(...arguments);\n  return ele?.bbn || null;\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/retrieveElement.js\n\n\nCp[\"default\"].prototype.$retrieveElement = function (id, hash, index = -1, loopObj) {\n  let res = this.$elements[id] || null;\n  if (res && hash) {\n    return res[hash] || null;\n  }\n\n  return res;\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/setProp.js\nvar setProp = __webpack_require__(\"./src/lib/Cp/private/setProp.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/set.js\n\n\n\n\n/**\n * Sets the given property on the given object using static method\n * @param {Object} obj \n * @param {String} prop \n * @param {*} value \n * @param {Boolean} writable \n * @param {Boolean} configurable \n * @returns \n */\nCp[\"default\"].prototype.$set = function (obj, prop, value, writable = true, configurable = true) {\n  // Case where it's the prop or data of a component\n  if (bbn.cp.isComponent(obj)) {\n    //  It already exists\n    if (obj.$namespaces[prop]) {\n      // New treated value\n      const dataObj = obj.$treatValue(value, prop);\n      // The value is different\n      if (!bbn.fn.isSame(dataObj, obj[prop])) {\n        // It's a prop\n        if (obj.$namespaces[prop] === 'props') {\n          (0,setProp[\"default\"])(obj, prop, value);\n        }\n        // It's a data\n        else {\n          obj[prop] = value;\n        }\n      }\n    }\n    // Creating a new data\n    else {\n      setUpData(obj, prop, value);\n    }\n  }\n  else {\n    // Creating or updating if possible a property to the given object\n    Object.defineProperty(obj, prop, {\n      value,\n      writable,\n      configurable\n    });\n  }\n\n  return this;\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/tick.js\n\n\n/**\n * Add delay before another function call\n */\nCp[\"default\"].prototype.$tick = function (fn) {\n  return new Promise(resolve => {\n    let idx = bbn.fn.search(bbn.cp.queue, {cp: this});\n    let fns = [];\n    if (idx === -1) {\n      bbn.cp.queue.push({cp: this, fns});\n      idx = bbn.cp.queue.length - 1;\n    }\n    else {\n      fns = bbn.cp.queue[idx].fns;\n    }\n\n    fns.push(() => {\n      if (fn) {\n        fn();\n      }\n\n      resolve();\n    });\n  });\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/treatValue.js\n\n\nCp[\"default\"].prototype.$treatValue = function(value, name){\n    return bbnData.treatValue(value, this, name);\n  }\n;// CONCATENATED MODULE: ./src/lib/Cp/prototype/watch.js\n\n\n/**\n * Set the watcher for the given property.\n * \n * @param {Number} index The loop index if any\n * @returns {undefined}\n */\nCp[\"default\"].prototype.$watch = function (name, a) {\n  const cp = this;\n\n  const val = bbn.fn.getProperty(cp, name);\n  let tmp = bbn.fn.createObject({\n    handler: (bbn.fn.isFunction(a) ? a : a.handler).bind(cp),\n    immediate: a.immediate || false,\n    deep: a.deep || false,\n    value: val,\n    hash: bbnData.hash(val),\n    num: 0\n  });\n  //bbn.fn.log([\"WATCHING \" + name, val, tmp])\n\n  cp.$watcher[name] = tmp;\n\n  // Returns a function to cancel the watcher\n  return () => {\n    delete cp.$watcher[name];\n  }\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/setUpProp.js\nvar setUpProp = __webpack_require__(\"./src/lib/Cp/private/setUpProp.js\");\n;// CONCATENATED MODULE: ./src/lib/AnonCp.js\n\n\n\n\nclass bbnAnonCp extends Cp[\"default\"] {\n  $options = bbn.fn.createObject({\n    name: 'bbn-anon'\n  });\n\n  constructor(ele) {\n    super(ele);\n    Object.defineProperty(this, '$options', {\n      value: {\n        name: ele.tagName.toLowerCase(),\n        _componentTag: ele.tagName.toLowerCase(),\n        components: bbn.fn.createObject(),\n        get propsData() {\n          if (this.$el) {\n            return this.$el.bbnSchema?.props || {};\n          }\n\n          return {};\n        }\n      },\n      writable: false,\n      configurable: false\n    });\n    Object.defineProperty(this, '$computed', {\n      value: bbn.fn.createObject(),\n      writable: false,\n      configurable: false\n    });\n\n}\n\n  async $connected() {\n    //bbn.fn.log(\"ANON!!! \",this.$el.bbnSchema.props?.is);\n    if (!this.$el.bbnTpl) {\n      this.$el.bbnTpl = bbnAnon.bbnTpl;\n      const tpl = this.$el.innerHTML.trim();\n      if (tpl) {\n        this.$el.bbnTpl.slots = tpl;\n      }\n    }\n\n    const cfg = this.$cfg;\n    /*\n    if (cfg.components) {\n      for (let n in cfg.components) {\n        //bbn.fn.log(\"DEFINING COMPONENT\", n, cfg.components[n], cfg.components[n].template);\n        bbn.cp.define(cfg.componentNames[n], cfg.components[n], cfg.components[n].template);\n      }\n    }\n    */\n\n    if (cfg && cfg.computed) {\n      bbn.fn.iterate(cfg.computed, (computed, name) => {\n        if (name.substr(0, 1) === '$') {\n          throw Error(bbn._(\"Properties starting with the dollar sign are reserved\"));\n        }\n\n        bbn.cp.setComputed(this, name, computed.get, computed.set);\n      });\n    }\n\n    if (cfg && cfg.methods) {\n      Object.defineProperty(this, '$methods', {\n        value: cfg.methods,\n        writable: false,\n        configurable: false\n      });\n      bbn.fn.iterate(cfg.methods, (fn, name) => {\n        if (name.substr(0, 1) === '$') {\n          throw Error(bbn._(\"Properties starting with the dollar sign are reserved\"));\n        }\n\n        if (this[name] === undefined) {\n          Object.defineProperty(this, name, {\n            writable: false,\n            configurable: false,\n            value: fn\n          });\n        }\n      });\n    }\n\n    //bbn.fn.log(\"CONNCTRED CALLED IN ANON\", this.$el);\n    await Cp[\"default\"].prototype.$connected.apply(this);\n  }\n\n  get source() {\n    return this.$props[\"source\"];\n  }\n\n  $setUpProps() {\n    if (!this.$cfg.props.source) {\n      this.$cfg.props.source = bbn.fn.createObject({\n        type: [String, Object, Array],\n      });\n    }\n\n    bbn.fn.each(this.$cfg.props, (prop, name) => {\n      (0,setUpProp[\"default\"])(this, name, prop);\n      Object.defineProperty(this, name, {\n        get() {\n          return this.$props[name];\n        }\n      });\n    });\n  }\n\n  static acceptedAttributes = ['bbn-cfg', 'bbn-tpl', 'bbn-map', 'bbn-cls', 'bbn-fn', 'is', 'source', 'ref', 'key', 'index', 'slot'];\n\n}\n\n// EXTERNAL MODULE: ./src/internals/stringToTemplate.js + 2 modules\nvar stringToTemplate = __webpack_require__(\"./src/internals/stringToTemplate.js\");\n;// CONCATENATED MODULE: ./src/lib/Anon.js\n\n\n\n\n\n\n\nconst tmp = (0,stringToTemplate[\"default\"])('<slot/>', true, 'bbn-anon');\n\nclass Anon_bbnAnon extends Html_bbnHTML\n{\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    return connectedCallback(this);\n  } \n\n  disconnectedCallback() {\n    return disconnectedCallback(this);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    return bbn.cp.attributeChangedCallback(this, name, oldValue, newValue);\n  }\n\n  static bbnFn = bbnAnonCp;\n\n  static bbnCls = 'bbnAnon';\n\n  static bbnTpl = tmp.res;\n\n  static bbnMap = tmp.map;\n\n  static bbnCfg = bbn.cp.normalizeComponent({\n    mixins: [bbn.cp.mixins.basic],\n    props: {\n      is: {\n        type: [String, Object],\n        default: 'div'\n      },\n      source: bbn.fn.createObject()\n    }\n  }, 'bbnAnon');\n\n  static get bbnCls() {\n    return bbnAnonCp;\n  }\n\n}\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncustomElements.define('bbn-anon', Anon_bbnAnon);\n\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/index.js_+_63_modules?");

/***/ }),

/***/ "./src/internals/retrieveSlots.js":
/*!****************************************!*\
  !*** ./src/internals/retrieveSlots.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ retrieveSlots)\n/* harmony export */ });\n/**\n * Recursively retrieves slot information from the template structure.\n * \n * @param {Array} tpl - An array of template nodes to analyze for slots.\n * @param {Object} [res] - The result object to accumulate slot information.\n * @returns {Object} The updated result object containing slot information.\n */\nfunction retrieveSlots(tpl, res = bbn.fn.createObject()) {\n  // Iterate over each node in the template.\n  bbn.fn.each(tpl, node => {\n    // Check if the node is a 'slot' tag.\n    if (node.tag && (node.tag === 'slot')) {\n      // Determine the name of the slot, defaulting to 'default' if not specified.\n      let idx = node.attr && node.attr.name ? node.attr.name.value : 'default';\n      if (!idx) {\n        // Throw an error if the slot name is invalid.\n        throw Error(bbn._(\"Invalid slot name\"));\n      }\n\n      // Initialize an array for the slot if it's not already present in the result object.\n      res[idx] = res[idx] || [];\n      // Store the slot's ID.\n      res[idx].id = node.id;\n    }\n\n    // Recursively process child nodes if they exist.\n    if (node.items) {\n      retrieveSlots(node.items, res);\n    }\n  });\n\n  // Return the accumulated result object containing slot information.\n  return res;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/internals/retrieveSlots.js?");

/***/ }),

/***/ "./src/internals/stringToTemplate.js":
/*!*******************************************************!*\
  !*** ./src/internals/stringToTemplate.js + 2 modules ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ stringToTemplate)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bbn/bbn/dist/index.js + 280 modules\nvar dist = __webpack_require__(\"./node_modules/@bbn/bbn/dist/index.js\");\n;// CONCATENATED MODULE: ./src/internals/removeSelfClosing.js\n/**\n * Remove the self closing tags and return an HTML string\n * @return {String}\n */\nfunction removeSelfClosing(html) {\n  const rxhtmlTag = new RegExp('<([A-z0-9-_]+)((([^>\"]+\"[^\"]*\")*)|([ˆ>]*))\\\\s*/>', 'gm');\n  return html ? html.replace(rxhtmlTag, \"<$1$2></$1>\") : '';\n}\n\n;// CONCATENATED MODULE: ./src/internals/analyzeElement.js\n\n\n\nconst eventInstructions = ['stop', 'prevent', 'passive'];\nconst parser = new DOMParser();\nconst noSpaceTags = [\n  'table',\n  'tr',\n  'td',\n  'th',\n  'thead',\n  'tbody',\n  'tfoot',\n  'ul',\n  'ol',\n  'li',\n  'dl',\n  'dt',\n  'dd',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'footer',\n  'section',\n  'article',\n  'aside',\n  'nav',\n  'main',\n  'div',\n  'hr',\n  'p',\n  'pre',\n  'blockquote',\n  'address',\n  'figure',\n  'figcaption',\n  'legend',\n  'caption',\n  'details',\n  'summary',\n  'menu',\n  'dialog',\n  'script',\n  'style',\n  'noscript',\n  'iframe',\n  'code'\n];\n\n\n/**\n * Creates a template object based on the HTML element\n * @var {HTMLElement} ele - The HTML element to analyze\n * @var {Object} inlineTemplates - An object passing inline templates\n * @var {String} idx - The unique index of the element\n * @return {Object} res - An object representing the node\n */\nfunction analyzeElement(ele, inlineTemplates, idx, componentName) {\n  if (!ele.getAttributeNames) {\n    throw Error(dist[\"default\"]._(\"Only tags can be analyzed (check %s)\", componentName));\n  }\n\n  dist[\"default\"].fn.checkType(inlineTemplates, 'object', \"Inline templates must be an object\");\n  dist[\"default\"].fn.checkType(idx, 'string', \"The index must be a string\");\n\n  const attr = ele.getAttributeNames().sort();\n\n  if (!inlineTemplates) {\n    inlineTemplates = dist[\"default\"].fn.createObject();\n  }\n\n  let res = dist[\"default\"].fn.createObject({\n    id: idx,\n    tag: ele.tagName.toLowerCase(),\n    attr: dist[\"default\"].fn.createObject(),\n    events: dist[\"default\"].fn.createObject(),\n    items: []\n  });\n\n  if ((res.tag === 'component') && (attr.indexOf(':is') > -1)) {\n    let is = ele.getAttribute(':is').trim();\n    const bits = is.split('.');\n    if ((bits[0] === '$options')\n      && (bits[1] === 'components')\n      && (bits.length === 3)\n    ) {\n      res.tag = bits[2];\n      attr.splice(attr.indexOf(':is'), 1);\n    }\n  }\n\n  attr.forEach(attrName => {\n    const main = attrName.indexOf(':') > 0 ? attrName.split(':') : [attrName];\n    const modifiers = main[0].split('.');\n    let modelValue = main.length > 1 ? main[1] : '_default_';\n    if (main[1] === '_default_') {\n      throw Error(_(\"The name '_default_' is reserved for the default value of the model (check %s)\", componentName));\n    }\n\n    if ((modelValue === '_default_') && ['input', 'select', 'textarea'].includes(res.tag)) {\n      modelValue = 'value';\n    }\n\n    let a = dist[\"default\"].fn.camelToCss(modifiers.splice(0, 1)[0]);\n    // replaces v- by bbn-\n    if (a.indexOf('v-') === 0) {\n      a = 'bbn-' + a.substr(2);\n    }\n    // replaces else-if by elseif\n    if ('bbn-else-if' === a) {\n      a = 'bbn-elseif';\n    }\n    if (a === 'bbn-on') {\n      a = '@' + main[1];\n    }\n\n    let value = ele.getAttribute(attrName).trim();\n\n    // Events\n    if (a.indexOf('@') === 0) {\n      let o = dist[\"default\"].fn.createObject({id: res.id + '-' + a, modifiers: []});\n      dist[\"default\"].fn.each(modifiers, modifier => {\n        if (eventInstructions.includes(modifier)) {\n          o[modifier] = true;\n        }\n        else {\n          o.modifiers.push(modifier);\n        }\n      });\n      o.exp = value;\n      if (o.exp.indexOf('=>') > -1) {\n        let analyzed;\n        try {\n          analyzed = dist[\"default\"].fn.analyzeFunction(o.exp);\n        }\n        catch (e) {}\n        if (analyzed && analyzed.isArrow) {\n          o.exp = '(' + o.exp + ')(' + (analyzed.argString || '') + ')';\n        }\n      }\n      let eventName = a.substr(1);\n      if (main[1]) {\n        eventName += ':' + main[1];\n      }\n\n      res.events[eventName] = o;\n      return;\n    }\n\n    /** @var {String} name The attribute's real name */\n    let tmp = a.indexOf(':') === 0 ? a.substr(1) : a;\n    const name = tmp.indexOf('bbn-') === 0 ? tmp : dist[\"default\"].fn.camelize(tmp);\n    if (res.attr[name] !== undefined) {\n      dist[\"default\"].fn.warning(dist[\"default\"]._(\"The attribute %s can't be defined more than once (check %s)\", name, componentName));\n      return;\n    }\n    // create the attribute object\n    if (!['bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget', 'bbn-model'].includes(a)) {\n      res.attr[name] = dist[\"default\"].fn.createObject({\n        id: idx + '-' + name\n      });\n    }\n\n\n    // Dynamic attributes\n    if (a.indexOf(':') === 0) {\n      res.attr[name].exp = value;\n      res.attr[name].hash = dist[\"default\"].fn.hash(value);\n    }\n    // Special attributes\n    else if (a.indexOf('bbn-') === 0) {\n      const hash = dist[\"default\"].fn.hash(value);\n      switch (a) {\n        case 'bbn-for':\n          if (attr['bbn-elseif'] || attr['bbn-else']) {\n            throw Error(dist[\"default\"]._(\"bbn-for can't be used with bbn-else-if or bbn-else (check %s)\", componentName));\n          }\n\n          // Retrieving the expression used by loop\n          const match = value.match(/\\s(in|of)\\s/);\n          if (!match) {\n            throw Error(dist[\"default\"]._(\"Invalid loop expression (check %s)\", componentName));\n          }\n    \n          const itemExp = value.substr(0, match.index).trim();\n          const valueExp = value.substr(match.index + match[0].length).trim();\n          /** @var {Object} args An object with the name of the loop argument(s) used by the function */\n          let args = dist[\"default\"].fn.createObject();\n          /** @todo Could do better! */\n          // The first part of the expression is between parenthesis\n          // which should mean there are 2 variables\n          if (itemExp.indexOf(')') > -1) {\n            /** @var {Array} tmp first part of the expression without the parenthesis and split by coma */\n            let tmp = dist[\"default\"].fn.substr(itemExp, 1, -1).split(',');\n            // There's at least one expression\n            if (!tmp.length) {\n              throw Error(dist[\"default\"]._(\"Invalid loop expression (check %s)\", componentName));\n            }\n    \n            // That would be the value's name'\n            args.value = tmp[0].trim();\n            // There is a second expression\n            if (tmp.length === 2) {\n              // The index name variable used by the function\n              args.index = tmp[1].trim();\n            }\n          }\n          // No parenthesis, there is just the value's name\n          else {\n            args.value = itemExp;\n          }\n\n          // No value no chocolate\n          if (!args.value) {\n            throw Error(dist[\"default\"]._(\"Invalid loop expression (check %s)\", componentName));\n          }\n\n          res.loop = dist[\"default\"].fn.createObject({\n            exp: valueExp,\n            id: res.id + '-loop',\n            item: args.value,\n            index: args.index || null,\n            hash: dist[\"default\"].fn.hash(valueExp),\n            original: value\n          });\n          \n          res.loopItem = dist[\"default\"].fn.createObject({\n            exp: args.value,\n            id: res.id + '-loop-item',\n            hash: dist[\"default\"].fn.hash(args.value),\n            original: args.value\n          });\n          if (args.index) {\n            res.loopIndex = dist[\"default\"].fn.createObject({\n              exp: args.index,\n              id: res.id + '-loop-index',\n              hash: dist[\"default\"].fn.hash(args.index),\n              original: args.index\n            });\n          }\n          break;\n        case 'bbn-if':\n        case 'bbn-elseif':\n        case 'bbn-else':\n          if (res.condition) {\n            throw Error(dist[\"default\"]._(\"There can't be more than one conditional expressions on the same tag (check %s)\", componentName));\n          }\n\n          let type = a.substr(4);\n          res.condition = dist[\"default\"].fn.createObject({\n            type,\n            id: res.id + '-bbn-condition',\n            exp: a === 'bbn-else' ? 'true' : value,\n            // Adding prefix as conditions can be set to false even when the expression is not\n            hash: 'CONDITION' + idx.toString() + '-' + hash\n          });\n          if (!value && (type !== 'else')) {\n            throw Error(dist[\"default\"]._(\"The condition must have an expression (check %s)\", componentName));\n          }\n\n          break;\n        case 'bbn-model':\n          if (!res.model) {\n            res.model = dist[\"default\"].fn.createObject();\n          }\n          res.model[modelValue] = dist[\"default\"].fn.createObject({\n            id: res.id + '-model-' + modelValue,\n            exp: value,\n            hash,\n            modifiers: modifiers\n          });\n          break;\n        case 'bbn-cloak':\n          res.cloak = dist[\"default\"].fn.createObject({\n            id: res.id + '-cloak',\n            exp: value,\n            hash\n          });\n          break;\n        case 'bbn-pre':\n          res.pre = ele.innerHTML;\n          break;\n        case 'bbn-forget':\n          res.forget = dist[\"default\"].fn.createObject({\n            id: res.id + '-forget',\n            exp: value,\n            hash\n          });\n          break;\n        default:\n          if (dist[\"default\"].cp.directives[a]) {\n            if (!res.directives) {\n              res.directives = dist[\"default\"].fn.createObject();\n            }\n\n            let directiveArg = attrName.match(new RegExp(/\\:{1}([a-z]+)/g));\n            let directiveMod = attrName.match(new RegExp(/\\.{1}([a-z]+)/g));\n            res.directives[a] = dist[\"default\"].fn.createObject({\n              id: res.id + '-directive-' + a,\n              exp: value,\n              hash: dist[\"default\"].fn.hash(value),\n              modifiers: !!directiveMod ? dist[\"default\"].fn.map(directiveMod, m => dist[\"default\"].fn.substr(m, 1)) : [],\n              arg: !!directiveArg ? dist[\"default\"].fn.substr(directiveArg[0], 1) : null,\n              oldValue: undefined,\n              lastUpdate: null\n            });\n\n          }\n          else {\n            res.attr[name].exp = value;\n            res.attr[name].hash = dist[\"default\"].fn.hash(value);\n          }\n      }\n    }\n    // Regular attributes\n    else {\n      res.attr[name].value = value;\n    }\n  });\n\n\n  let childNodes;\n  if (Object.hasOwn(res.attr, 'inlineTemplate')) {\n    if (!inlineTemplates[res.tag]) {\n      inlineTemplates[res.tag] = ele.innerHTML;\n      delete res.attr.inlineTemplate;\n    }\n    childNodes = [];\n  }\n  else if (res.tag === 'svg') {\n    childNodes = [];\n    res.content = ele.innerHTML;\n  }\n  else if (res.pre) {\n    childNodes = [];\n  }\n  else if (ele.tagName === 'TEMPLATE') {\n    let before = '<body>';\n    let after = '</body>';\n    let target = 'body';\n    let tpl = removeSelfClosing(ele.innerHTML);\n    let tag1 = tpl.match(/<([a-zA-Z-]+)(>|.*?[^?]>)/s);\n    if (tag1 && tag1[1]) {\n      switch (tag1[1].toLowerCase()) {\n        case 'thead':\n        case 'tbody':\n        case 'tfoot':\n        case 'tr':\n          before += '<table>';\n          after = '</table>' + after;\n          target = 'table';\n          break;\n        case 'td':\n        case 'th':\n          before += '<table><tr>';\n          after = '</tr></table>' + after;\n          target = 'tr';\n          break;\n        case 'col':\n          before += '<table><colgroup>';\n          after = '</colgroup></table>' + after;\n          target = 'colgroup';\n          break;\n        case 'li':\n          before += '<ul>';\n          after = '</ul>' + after;\n          target = 'ul';\n          break;\n      }\n    }\n    const doc = parser.parseFromString(\n      // There shouldn't be self-closing in the embedded HTML except if in template\n      before + tpl + after,\n      \"text/html\"\n    );\n    childNodes = doc.documentElement.querySelector(target).childNodes;\n  }\n  else {\n    childNodes = ele.childNodes;\n  }\n  \n  let num = 0;\n  let lastEmpty = false;\n  let prevTag;\n  const div = document.createElement('div');\n  dist[\"default\"].fn.each(childNodes, (node, i) => {\n    if (node instanceof Comment) {\n      return;\n    }\n\n    if (node && node.getAttributeNames) {\n      let tmp = analyzeElement(node, inlineTemplates, idx + '-' + num, componentName);\n      if (!childNodes[i+1]?.getAttributeNames && childNodes[i+1]?.textContent && !dist[\"default\"].fn.removeExtraSpaces(childNodes[i+1].textContent)) {\n        tmp.spaced = true;\n      }\n\n      prevTag = tmp.res.tag;\n      res.items.push(tmp.res);\n      num++;\n      lastEmpty = false;\n    }\n    // No text nodes in the slots\n    else if (node.textContent) {\n      const n2 = node.cloneNode(true);\n      div.appendChild(n2);\n      const txt = div.innerHTML\n                  // escaping dollars\n                  //.replace(/\\$/g, (_, g) => '\\\\$')\n                  // replacing double curly braces by dollar and single\n                  .replace(/{{(.+?)}}/gs, (_, g1) => '${' + g1 + '}')\n                  .replace(/\\n/g, '')\n                  .replace(/\\t/g, '');\n      div.removeChild(n2);\n      const isEmpty = !dist[\"default\"].fn.removeExtraSpaces(txt);\n      if (!isEmpty || (!lastEmpty && prevTag && !noSpaceTags.includes(prevTag))) {\n        let isDynamic = txt.indexOf('${') > -1;\n        lastEmpty = isEmpty;\n        const item = dist[\"default\"].fn.createObject({\n          id: idx + '-' + num,\n          text: isEmpty ? ' ' : txt.replace(/&nbsp;/g, '\\u00A0'),\n          hash: isEmpty ? dist[\"default\"].cp.spaceHash : dist[\"default\"].fn.hash(txt),\n          empty: isEmpty\n        });\n        if (isDynamic) {\n          item.exp = txt;\n        }\n\n        res.items.push(item);\n        num++;\n      }\n      else {\n        lastEmpty = isEmpty;\n      }\n    }\n    else {\n      dist[\"default\"].fn.log(\"Unknown node\", node)\n      lastEmpty = false;\n    }\n  });\n  let isIf = false;\n  let conditionId = null;\n  while (res.items.length && res.items[res.items.length - 1].empty) {\n    res.items.pop();\n  }\n\n  for (let i = 0; i < res.items.length; i++) {\n    let item = res.items[i];\n    if (item.condition) {\n      if (item.condition.type === 'if') {\n        conditionId = dist[\"default\"].fn.randomString(32);\n        item.conditionId = conditionId;\n        isIf = true;\n      }\n      else if (!isIf) {\n        throw Error(dist[\"default\"]._(\"There can't be an elseif or an else without an if (check %s)\", componentName));\n      }\n      else {\n        item.conditionId = conditionId;\n      }\n      if (item.condition.type === 'else') {\n        isIf = false;\n      }\n    }\n    else if (isIf) {\n      if (item.empty) {\n        res.items.splice(i, 1);\n        i--;\n      }\n      else {\n        isIf = false;\n      }\n    }\n  }\n\n  if (res.condition) {\n    res.conditionId = dist[\"default\"].fn.randomString(32);\n  }\n  return {\n    res,\n    inlineTemplates\n  };\n}\n\n;// CONCATENATED MODULE: ./src/internals/stringToTemplate.js\n\n\n\n\n/**\n * Create a new DOM parser and parse the given HTML string.\n * @return {HTMLElement}\n */\nconst stringToTemplate_parser = new DOMParser();\nconst createMap = (map, items) => {\n  dist[\"default\"].fn.each(items, a => {\n    map[a.id] = a;\n    if (a.items) {\n      createMap(map, a.items);\n    }\n  });\n};\n\nconst updateRoot = (ar, lower) => {\n  dist[\"default\"].fn.each(ar, a => {\n    if (lower) {\n      if (a.id.indexOf('0-')) {\n        throw Error(\"The root element cannot have a lower id\");\n      }\n      a.id = a.id.substr(2);\n    }\n    else {\n      a.id = '0-' + a.id;\n    }\n    dist[\"default\"].fn.iterate(a, (value, prop) => {\n      if (['attr', 'model', 'directives'].includes(prop)) {\n        dist[\"default\"].fn.iterate(value, v => {\n          v.id = lower ? v.id.substr(2) : '0-' + v.id;\n        });\n      }\n      else if (['loop', 'condition', 'forget'].includes(prop)) {\n        value.id = lower ? value.id.substr(2) : '0-' + value.id;\n      }\n    });\n\n    if (a.items) {\n      a.items = updateRoot(a.items);\n    }\n  });\n\n  return ar;\n};\n\n\n/**\n * Transforms a HTML string into a template array\n * \n * @param {String} str \n * @returns {Array}\n */\nfunction stringToTemplate(str, withMap, name) {\n  const map = dist[\"default\"].fn.createObject();\n  const inlineTemplates = dist[\"default\"].fn.createObject();\n\n  if (dist[\"default\"].fn.isString(str)) {\n    str = str.trim();\n  }\n\n  if (!str) {\n    if (withMap) {\n      return {\n        res: [],\n        map,\n        inlineTemplates\n      }\n    }\n\n    return [];\n  }\n  const doc = stringToTemplate_parser.parseFromString(\n    // There shouldn't be self-closing in the embedded HTML except if in template\n    removeSelfClosing(str),\n    \"text/html\"\n  );\n  const errorNode = doc.querySelector(\"parsererror\");\n\n  // If the HTML string cannot be parsed, It throw an error\n  if (errorNode) {\n    throw Error(\"Impossible to parse the template\");\n  }\n\n  let num = 0;\n  let res = Array.from(\n    doc.documentElement.querySelector('body').childNodes\n  )\n  .filter(n => n.tagName && (n.tagName.toLowerCase() !== 'script'))\n  .map(a => {\n    const tmp = analyzeElement(a, inlineTemplates, num.toString(), name);\n    num++;\n    return tmp.res;\n  });\n\n  if ((res.length === 1) && (res[0]?.tag === 'template')) {\n    dist[\"default\"].fn.log(\"TEMPLATE\", res);\n    //res = updateRoot(res[0].items, true);\n  }\n\n  if ((res.length > 1)\n    || (res.length\n        && (res[0].attr?.['bbn-if']\n            || res[0].attr?.['bbn-for']\n            || res[0].attr?.['bbn-model']\n            || res[0].attr?.['bbn-forget']\n            || (dist[\"default\"].cp.isComponent(res[0]) && (res[0].tag !== name))\n            || (!dist[\"default\"].cp.isComponent(res[0]) && !['div', 'span', name].includes(res[0].tag))\n        )\n    )\n  ) {\n    res = [{\n      id: '0',\n      tag: 'div',\n      items: updateRoot(res)\n    }];\n  }\n\n  if (withMap) {\n    const map = dist[\"default\"].fn.createObject();\n    createMap(map, res);\n\n    return {\n      res,\n      map,\n      inlineTemplates\n    }\n  }\n\n  return res;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/internals/stringToTemplate.js_+_2_modules?");

/***/ }),

/***/ "./src/lib/Cp/Cp.js":
/*!**************************************!*\
  !*** ./src/lib/Cp/Cp.js + 1 modules ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ bbnCp)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bbn/bbn/dist/index.js + 280 modules\nvar dist = __webpack_require__(\"./node_modules/@bbn/bbn/dist/index.js\");\n// EXTERNAL MODULE: ./src/cp.js + 60 modules\nvar cp = __webpack_require__(\"./src/cp.js\");\n;// CONCATENATED MODULE: ./src/internals/addComponent.js\n/**\n * Adds a new component to the static global #components property\n * @var {HTMLElement} ele\n * @return void\n */\nfunction addComponent(ele) {\n  const cid = ele.bbnCid;\n  if (!cid) {\n    throw Error(\"The component doesn't have a component ID\")\n  }\n\n  const cp = bbn.cp.componentsIndex.get(cid);\n  if (cp) {\n    if (cp !== ele) {\n      bbn.fn.log(ele, cp);\n      throw Error(\"The component already exists\")\n    }\n  }\n  else {\n    bbn.cp.componentsIndex.set(cid, ele);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/Cp.js\n\n\n\nclass bbnCp {\n\n  constructor(el) {\n    // Setting up basic props\n    Object.defineProperty(this, '$el', {\n      value: el,\n      writable: false,\n      configurable: false\n    });\n0\n    /**\n     * Component configuration object\n     */\n    Object.defineProperty(this, '$cfg', {\n      value: this.$el.bbnCfg || this.$el.constructor.bbnCfg,\n      writable: false,\n      configurable: false\n    });\n  \n    // Adding itself to the global static #components\n    addComponent(this.$el);\n  }\n\n  /**\n   * Return the function bbn._ for the strings' translation.\n   * @method _\n   * @return {Function}\n   */\n  _() {\n    return dist.bbn._(...arguments);\n  }\n\n\n  /**\n  * Returns the given ref (will return $refs[name] or $refs[name][0])\n  * @method getRef\n  * @param {String} name\n  * @fires bbn.cp.getRef\n  * @return {Function}\n  */\n  getRef(name) {\n    return dist.bbn.fn.isArray(this.$refs[name]) ? this.$refs[name][0] : this.$refs[name];\n  }\n\n\n  /**\n  * Returns the closest component matching the given selector\n  * @method closest\n  * @param {String} selector\n  * @param {Boolean} checkEle\n  * @return {Function}\n  */\n  closest(selector, checkEle) {\n    let ele = checkEle ? this.$el : this.$el.parentNode;\n    let letters = selector.split('');\n    if (!['.', '#', '[', ':'].filter(c => letters.includes(c)).length) {\n      selector += ',*[is=' + selector + ']';\n    }\n\n    while (ele instanceof HTMLElement) {\n      if (ele.matches(selector)) {\n        return ele.bbn || ele;\n      }\n      \n      ele = ele.bbnPortal || ele.parentNode || null;\n    }\n  }\n\n\n  /**\n  * Returns an array of parent components until $root\n  * @method ancestors\n  * @param {String} selector\n  * @param {Boolean} checkEle\n  * @return {Function}\n  */\n  ancestors(selector, checkEle) {\n    let res = [];\n    let ele = this.closest(selector, checkEle);\n    while (ele) {\n      res.push(ele);\n      ele = ele.closest(selector);\n    }\n\n    return res;\n  }\n\n\n  /**\n  * Fires the function bbn.cp.getChildByKey.\n  * @method getChildByKey\n  * @param {String} key\n  * @param {String} selector\n  * @return {Function}\n  */\n  getChildByKey(key, selector) {\n    //to do?\n  }\n\n\n  /**\n  * Fires the function bbn.cp.findByKey.\n  * @method findByKey\n  * @param {String} key\n  * @param {String} selector\n  * @param {Array} ar\n  * @return {Function}\n  */\n  findByKey(key, selector, ar) {\n    // to do?\n  }\n\n\n  /**\n  * Fires the function bbn.cp.findAllByKey.\n  * @method findAllByKey\n  * @param {String} key\n  * @param {String} selector\n  * @return {Function}\n  */\n  findAllByKey(key, selector) {\n    // to do?,\n  }\n\n\n  /**\n  * Fires the function bbn.cp.find.\n  * @method find\n  * @param {String} selector\n  * @param {Number} index\n  * @return {Function}\n  */\n  find(selector, index) {\n    const letters = selector.split('');\n    if (!['.', '#', '[', ':'].filter(c => letters.includes(c)).length) {\n      selector += ',*[is=' + selector + ']';\n    }\n\n    if (index) {\n      selector += ':nth-of-type(' + index + ')';\n    }\n\n    return this.$el.querySelector(selector)?.bbn;\n  }\n\n\n  /**\n  * Fires the function bbn.cp.findAll.\n  * @method findAll\n  * @param {String} selector \n  * @param {Boolean} only_children \n  * @return {Function}\n  */\n  findAll(selector, only_children) {\n    const letters = selector.split('');\n    if (!['.', '#', '[', ':'].filter(c => letters.includes(c)).length) {\n      selector += ',*[is=' + selector + ']';\n    }\n\n    if (only_children) {\n      let res = [];\n      Array.from(this.childNodes).forEach(a => {\n        if (a.tagName && a.matches(selector)) {\n          res.push(a.bbn);\n        }\n      });\n      return res;\n    }\n\n    return Array.from(this.$el.querySelectorAll(selector)).map(a => a.bbn);\n  }\n\n\n  /**\n  * @method extend\n  * @param {Boolean} selector\n  * @param {Object} source The object to be extended\n  * @param {Object} obj1\n  * @return {Object}\n  */\n  extend(deep, src, obj1) {\n    // to do?\n  }\n\n\n  /**\n  * Fires the function bbn.cp.getComponents.\n  * @method getComponents\n  * @param {Array} ar \n  * @param {Boolean} only_children \n  * @return {Function}\n  */\n  getComponents(ar, only_children) {\n    if (only_children) {\n      return Array.from(this.childNodes).filter(a => !!a._bbn);\n    }\n    else {\n      return this.querySelectAll('*').filter(a => !!a._bbn);\n    }\n  }\n\n\n  /**\n   * Returns a component name based on the name of the given component and a path.\n   * @method getComponentName\n   * @memberof bbn.cp\n   */\n  getComponentName() {\n    return this.$options.name;\n  }\n\n}\n\n\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/Cp.js_+_1_modules?");

/***/ }),

/***/ "./src/lib/Cp/private/addNamespace.js":
/*!********************************************!*\
  !*** ./src/lib/Cp/private/addNamespace.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ addNamespace)\n/* harmony export */ });\n/**\n * Check if there is no conflict between attributes/methods and\n * add list all the public methods and attributes that can be used by the component\n * \n * @param {bbnCp} cp - The component instance to which the namespace is being added.\n * @param {string} name - The name of the property or method being added to the namespace.\n * @param {string} type - The type of the namespace being added (e.g., 'prop', 'method').\n */\nfunction addNamespace(cp, name, type) {\n  bbn.fn.checkType(cp, bbnCp, \"No component in addNamespace\");\n  bbn.fn.checkType(name, String, \"Incorrect name in addNamespace\");\n  bbn.fn.checkType(type, String, \"Incorrect type in addNamespace\");\n\n  // Ensures that the type is defined\n  if (!type) {\n    throw Error(bbn._(\"Type must be defined for %s\", name));\n  }\n\n  // Checks if the name is among the list of reserved names in the bbn.var.reserved array\n  if (bbn.var.reserved.includes(name)) {\n    throw Error(bbn._(\"The name %s is reserved\", name));\n  }\n\n  // Checks for namespace conflicts: if the namespace already exists and is of a different type\n  if (cp.$namespaces[name] && (cp.$namespaces[name] !== type)) {\n    // Logs the conflict details for debugging purposes\n    bbn.fn.log([\n      \"The namespace already exists\",\n      \"Component name: \" + cp.$options.name,\n      \"Prop name: \" + name,\n      cp.$namespaces,\n      name\n    ]);\n    // Throws an error indicating the conflict\n    throw Error(bbn._(\"The name %s in %s is already used by %s in %s\", name, type, cp.$namespaces[name], cp.$options.name));\n  }\n\n  // If no conflicts, adds the name to the $namespaces object with its type\n  cp.$namespaces[name] = type;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/addNamespace.js?");

/***/ }),

/***/ "./src/lib/Cp/private/checkPropValue.js":
/*!**********************************************!*\
  !*** ./src/lib/Cp/private/checkPropValue.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ checkPropValue)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\n/**\n * Validates the value of a property against the provided configuration.\n * \n * @param {Object} cp - The component instance.\n * @param {string} name - The name of the property to check.\n * @param {Object} cfg - Configuration object for the property, including type, default value, etc.\n * @param {*} value - The value to be validated against the property's configuration.\n * @returns {*} The validated value of the property.\n * @throws {Error} Throws an error if the property configuration is missing, \n *                 if default value for an object is not returned by a function, \n *                 if the property is required but not defined or has an invalid value, \n *                 if the property value is of the wrong type, \n *                 or if the property fails custom validation.\n */\nfunction checkPropValue(cp, name, cfg, value) {\n  // Checking if the property configuration exists.\n  if (!cfg) {\n    throw Error(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"The property %s is not defined in component %s\", name, cp.$options.name));\n  }\n\n  // Determining if the property is explicitly defined in the component's data.\n  let isDefined = Object.hasOwn(cp.$options.propsData, name) && (cp.$options.propsData[name] !== undefined);\n  let v = undefined;\n\n  // If a value is provided, use it and mark the property as defined.\n  if (value !== undefined) {\n    v = value;\n    isDefined = true;\n  }\n  // If not provided, use the value from the component's data if it exists.\n  else if (isDefined) {\n    v = cp.$options.propsData[name];\n  }\n\n  // Handling default values for properties not set and not in the building process.\n  if (!cp.$numBuild && !isDefined && (cfg.default !== undefined)) {\n    // Ensuring that default object values are returned by a function.\n    if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isObject(cfg.default) || _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isArray(cfg.default)) {\n      throw Error(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"A function must be used to return object default values in %s\", name));\n    }\n\n    // Assigning default value; if it's a function, execute the function to get the value.\n    v = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(cfg.default) ? cfg.default.bind(cp)() : cfg.default;\n    isDefined = true;\n  }\n\n  // Check if the property is required and not properly defined or has an empty value.\n  if (cfg.required && (!isDefined || [null, undefined, ''].includes(v))) {\n    throw Error(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"The property %s is required in component %s\", name, cp.$options.name));\n  }\n\n  // Type checking for the property value.\n  if (cfg.type && isDefined && ![null, undefined, ''].includes(v)) {\n    _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.checkType(v, cfg.type, _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Wrong type for %s in component %s\", name, cp.$options.name));\n  }\n\n  // Custom validation for the property.\n  if (isDefined && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(cfg.validator) && !cfg.validator(v)) {\n    _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.log(\"GIVEN VALUE\", v);\n    throw Error(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"The property %s is invalid in component %s\", name, cp.$options.name));\n  }\n\n  // Returning the validated value.\n  return v;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/checkPropValue.js?");

/***/ }),

/***/ "./src/lib/Cp/private/getExpState.js":
/*!*******************************************!*\
  !*** ./src/lib/Cp/private/getExpState.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getExpState)\n/* harmony export */ });\nfunction getExpState(cp, _name, _hash) {\n  if (!_hash) {\n    _hash = '_root';\n  }\n  if (!cp.$expResults[_name]?.[_hash]) {\n    bbn.fn.log(\"STATE\", cp.$expResults);\n    throw Error(_name + '  ---  ' + _hash + ' are not defined in ' + cp.$options.name);\n  }\n\n  return cp.$expResults[_name][_hash].state;\n}\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/getExpState.js?");

/***/ }),

/***/ "./src/lib/Cp/private/getExpValue.js":
/*!*******************************************!*\
  !*** ./src/lib/Cp/private/getExpValue.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getExpValue)\n/* harmony export */ });\nfunction getExpValue(cp, _name, _hash) {\n  if (!_hash) {\n    _hash = '_root';\n  }\n  if (!cp.$expResults[_name]?.[_hash]) {\n    bbn.fn.log(\"VALUE\", cp.$expResults);\n    throw Error(_name + '  --- ' + _hash + ' are not defined in ' + cp.$options.name);\n  }\n\n  return cp.$expResults[_name][_hash].value;\n}\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/getExpValue.js?");

/***/ }),

/***/ "./src/lib/Cp/private/launch.js":
/*!***************************************************!*\
  !*** ./src/lib/Cp/private/launch.js + 28 modules ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ launch)\n});\n\n// EXTERNAL MODULE: ./src/lib/Cp/private/updateWatcher.js\nvar updateWatcher = __webpack_require__(\"./src/lib/Cp/private/updateWatcher.js\");\n// EXTERNAL MODULE: ./node_modules/@bbn/bbn/dist/index.js + 280 modules\nvar dist = __webpack_require__(\"./node_modules/@bbn/bbn/dist/index.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/setExpResult.js\nvar setExpResult = __webpack_require__(\"./src/lib/Cp/private/setExpResult.js\");\n// EXTERNAL MODULE: ./src/lib/Cp/private/getExpState.js\nvar getExpState = __webpack_require__(\"./src/lib/Cp/private/getExpState.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatProperties.js\n\n\n\n\n/**\n * Processes and resolves properties for a given node in the context of a web component.\n * It handles dynamic expressions, bindings, and special cases like 'class' and 'style' attributes.\n * \n * @param {Object} cp - The context provider (component instance) containing methods and properties.\n * @param {Object} props - Object to store processed properties.\n * @param {string} id - The identifier of the node whose properties are being processed.\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {Object} data - Additional data that might be required for processing the properties.\n * @param {boolean} [go=false] - A flag indicating whether the element needs to be updated.\n * @returns {Object} An object containing the flag 'go' and the processed properties 'props'.\n */\nfunction treatProperties(cp, node, hash, data, go = false) {\n  if (!node.props) {\n    node.props = dist[\"default\"].fn.createObject();\n  }\n\n  const props = node.props; // Initialize the properties object for the node.\n\n  // Process the node's attributes if any are defined.\n  if (dist[\"default\"].fn.numProperties(node.attr)) {\n    let bindValue;\n\n    // Handle 'bbn-bind' attribute which allows binding multiple attributes.\n    if (node.attr['bbn-bind']) {\n      const attr = node.attr['bbn-bind'];\n      bindValue = (0,setExpResult[\"default\"])(cp, attr, hash, data); // Resolve the binding value.\n\n      // Check if the binding's internal state is not 'OK', indicating an update is needed.\n      if ((0,getExpState[\"default\"])(cp, attr.hash, hash) !== 'OK') {\n        go = true;\n      }\n    }\n\n    // Iterate over each attribute of the node.\n    for (let n in node.attr) {\n      // Skip specific attributes that are handled separately.\n      if (['bbn-bind', 'bbn-for', 'bbn-if', 'bbn-elseif', 'bbn-else', 'bbn-forget'].includes(n)) {\n        continue;\n      }\n\n      const attr = node.attr[n];\n      // Process attributes with expressions.\n      if (attr.exp) {\n        let attrValue = (0,setExpResult[\"default\"])(cp, attr, hash, data); // Resolve the attribute value.\n        if (attrValue !== props[n]) {\n          props[n] = attrValue; // Assign the resolved value to the properties object.\n        }\n\n        // Check if the attribute's internal state is not 'OK', indicating an update is needed.\n        if ((0,getExpState[\"default\"])(cp, attr.hash, hash) !== 'OK') {\n          go = true;\n        }\n      }\n      else if (props[n] !== attr.value) {\n        // Directly assign static attribute values.\n        props[n] = attr.value;\n      }\n    }\n\n    // If 'bbn-bind' is used, extend the properties with the resolved binding value.\n    if (bindValue) {\n      dist[\"default\"].fn.iterate(bindValue, (v, p) => {\n        if (!Object.hasOwn(node.attr, p) && (props[p] !== v)) {\n          props[p] = v;\n        }\n      });\n    }\n\n    // Special handling for 'class' attribute to merge classes properly.\n    if (Object.hasOwn(props, 'class')) {\n      const v = dist[\"default\"].cp.convertClasses(\n        bindValue?.['class'] && (props['class'] !== bindValue['class']) ? \n            [bindValue['class'], props['class']]\n            : props['class']\n      );\n      if (v !== props['class']) {\n        props['class'] = v;\n      }\n    }\n\n    // Special handling for 'style' attribute to merge styles properly.\n    if (Object.hasOwn(props, 'style')) {\n      const v = dist[\"default\"].cp.convertStyles(\n        bindValue?.style && props.style !== bindValue.style ? \n            [bindValue.style, props.style]\n            : props.style\n      );\n      if (v !== props.style) {\n        props.style = v;\n      }\n    }\n  }\n\n  if (node.model) {\n    dist[\"default\"].fn.iterate(node.model, (m, name) => {\n      props[name] = (0,setExpResult[\"default\"])(cp, m, hash, data);\n      if (!go && ((0,getExpState[\"default\"])(cp, m.hash, hash) !== \"OK\")) {\n        go = true;\n      }\n    });\n  }\n\n  if (dist[\"default\"].fn.numProperties(node.directives)) {\n    for (let n in node.directives) {\n      if (node.directives[n].exp) {\n        (0,setExpResult[\"default\"])(cp, node.directives[n], hash, data);\n        if (!go && ((0,getExpState[\"default\"])(cp, node.directives[n].hash, hash, data) !== \"OK\")) {\n          go = true;\n        }\n      }\n    }\n  }\n\n  // Return the flag indicating if an update is needed and the processed properties.\n  return go;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/getIdBefore.js\n/**\n * Retrieves the string of the ID used before the given one, at the same level\n * \n * @param {bbnCp} cp - The component instance from which we fetch the ID.\n * @param {string} id - The id of the origin element.\n * @returns {string|null} The id of the element before the one with the given id, null otherwise.\n */\nfunction getIdBefore(cp, id) {\n  bbn.fn.checkType(cp, bbnCp, \"No component in getIdBefore\");\n  bbn.fn.checkType(id, String, \"Incorrect id in getIdBefore\");\n\n  // Ensures that the ID exists\n  if (!cp.$currentMap[id]) {\n    throw Error(bbn._(\"The ID is invalid in getIdBefore for %s\", cp.$options.name));\n  }\n\n  const bits = id.split(\"-\");\n  let last = parseInt(bits.pop());\n  while (last > 0) {\n    last--;\n    if (cp.$currentMap[bits.join(\"-\") + \"-\" + last]) {\n      return bits.join(\"-\") + \"-\" + last;\n    }\n  }\n\n  return null;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/cloneNode.js\n\n\nconst allowed = ['id', 'args', 'attr', 'condition', 'conditionId', 'dependencies', 'directives', 'events', 'exp', 'fn', 'forget', 'hash', 'loop', 'loopIndex', 'loopItem', 'model', 'pre', 'tag', 'text'];\nfunction cloneNode(cp, id)\n{\n  const element = cp.$currentMap[id];\n  if (!element) {\n    throw Error(\"Impossible to find the element \" + id + \" in \" + cp.$options.name);\n  }\n\n  const clone = dist[\"default\"].fn.createObject();\n  dist[\"default\"].fn.each(allowed, a => {\n    if (Object.hasOwn(element, a)) {\n      clone[a] = dist[\"default\"].fn.isObject(element[a]) ? dist[\"default\"].fn.clone(element[a]) : element[a];\n    }\n  });\n  if (cp.$cfg.componentNames[clone.tag]) {\n    clone.tag = cp.$cfg.componentNames[clone.tag];\n  }\n  clone.props = dist[\"default\"].fn.createObject();\n  clone.comment = false;\n\n  return clone;\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/removeDOM.js + 1 modules\nvar removeDOM = __webpack_require__(\"./src/lib/Cp/private/removeDOM.js\");\n// EXTERNAL MODULE: ./src/internals/retrieveSlots.js\nvar retrieveSlots = __webpack_require__(\"./src/internals/retrieveSlots.js\");\n// EXTERNAL MODULE: ./src/internals/stringToTemplate.js + 2 modules\nvar stringToTemplate = __webpack_require__(\"./src/internals/stringToTemplate.js\");\n;// CONCATENATED MODULE: ./src/internals/templateToMap.js\n/**\n * Recursively maps template items to a map object.\n * \n * @param {Object} map - The map object to populate.\n * @param {Array} items - The array of template items to map.\n */\nconst createMap = (map, items) => {\n  // Iterate over each item in the template array.\n  bbn.fn.each(items, a => {\n    // Add each item to the map with its ID as the key.\n    map[a.id] = a;\n\n    // If the item has child items, recursively map them as well.\n    if (a.items) {\n      createMap(map, a.items);\n    }\n  });\n};\n\n/**\n * Converts a template structure into a map for easier access and manipulation.\n * \n * @param {Array} tpl - The template array to convert.\n * @returns {Object} A map object representing the template structure.\n */\nfunction templateToMap(tpl) {\n  // Create an empty object to hold the map.\n  const map = bbn.fn.createObject();\n\n  // Populate the map using the `createMap` function.\n  createMap(map, tpl);\n\n  // Return the populated map.\n  return map;\n}\n\n// EXTERNAL MODULE: ./src/lib/Cp/private/setProp.js\nvar setProp = __webpack_require__(\"./src/lib/Cp/private/setProp.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/setRef.js\nfunction setRef(cp, ref, ele) {\n  if (cp.$refsElements[ref] && (cp.$refsElements[ref] !== ele)) {\n    if (!bbn.fn.isArray(cp.$refsElements[ref])) {\n      if (!cp.$refsElements[ref].isConnected) {\n        cp.$refsElements[ref] = ele;\n      }\n      else {\n        cp.$refsElements[ref] = [cp.$refsElements[ref]]\n      }\n    }\n    if (bbn.fn.isArray(cp.$refsElements[ref])) {\n      cp.$refsElements[ref].push(ele);\n    }\n  }\n  else {\n    cp.$refsElements[ref] = ele;\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/applyPropsOnElement.js\n\n\n\n\n\n/**\n * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not\n * - Updates the component element based on its own schema ($el.bbnSchema)\n * - Updates the schema\n * - Generates/update the DOM when needed\n * \n * @param {Boolean} shadow The content will go to the shadow DOM if true\n * @returns {Promise}\n */\nfunction applyPropsOnElement (cp, node, ele) {\n  dist[\"default\"].fn.checkType(cp, bbnCp, \"No component in applyPropsOnElement\");\n  dist[\"default\"].fn.checkType(node, \"object\", \"Props must be an object in applyPropsOnElement\");\n  if (node.bbn) {\n    throw Error(\"Props cannot contain a bbn property in applyPropsOnElement\");\n  }\n  \n  if (node.comment) {\n    return;\n  }\n  \n  dist[\"default\"].fn.checkType(ele, [HTMLElement, SVGElement], \"Elements should be HTML elements or text nodes in applyPropsOnElement\");\n\n  /** @constant {Object} props */\n  const props = node.props || dist[\"default\"].fn.createObject();\n  /** @constant {Boolean} isComponent */\n  const isComponent = (node.id !== '0') && cp.$isComponent(node);\n  /** @var {Object} attr The attributes of the element to be built */\n  const attr = dist[\"default\"].fn.createObject();\n  let isChanged = false;\n  if (node.id !== '0') {\n    // Other normal props are prioritarian\n    for (let n in props) {\n      let v = props[n];\n      switch (n) {\n        case 'ref':\n          dist[\"default\"].fn.checkType(props.ref, 'string', dist[\"default\"]._(\"Refs must be strings in %s\", cp.$options.name));\n          setRef(cp, props.ref, ele);\n          break;\n        case 'class':\n          if (!isComponent && (ele !== cp.$el)) {\n            if (ele.className !== v) {\n              ele.className = v;\n            }\n          }\n          attr.class = v;\n          break;\n        case 'style':\n          if (!isComponent && (ele !== cp.$el)) {\n            const args = [v];\n            if (Object.hasOwn(props, 'bbn-show')) {\n              args.push({display: props['bbn-show'] ? '' : 'none'});\n            }\n            const styles = dist[\"default\"].cp.convertStyles(...args);\n            if (styles !== ele.style.cssText) {\n              ele.style.cssText = styles;\n            }\n          }\n          break;\n        case 'bbn-show':\n          if (!props.style) {\n            if (v && (ele.style.display === 'none')) {\n              ele.style.removeProperty('display');\n            }\n            else if (!v && (ele.style.display !== 'none')) {\n              ele.style.display = 'none';\n            }\n          }\n\n          break;\n        default:\n          if (n.indexOf('bbn-') !== 0) {\n            attr[n] = props[n];\n          }\n      }\n    }\n  }\n\n  if (node.model) {\n    for (let n in node.model) {\n      let isC = false;\n      if (isComponent) {\n        if ((n !== '_default_') && ele.bbn && Object.hasOwn(ele.bbnSchema.props || {}, n) && (ele.bbnSchema.props?.[n] !== ele.bbn[n])) {\n          ele.bbnSchema.props[n] = node.model[n].value;\n          isChanged = true;\n          isC = true;\n        }\n      }\n      else if ((ele[n] !== undefined) && (ele[n] !== (dist[\"default\"].fn.isString(node.model[n].value) ? node.model[n].value : (node.model[n].value?.toString ? node.model[n].value.toString() : '')))) {\n        isChanged = true;\n        isC = true;\n        ele[n] = node.model[n].value;\n      }\n    }\n  }\n  else if (Object.hasOwn(props, 'bbn-html') && (ele.innerHTML !== props['bbn-html'])) {\n    ele.innerHTML = props['bbn-html'];\n    isChanged = true;\n  }\n  else if (Object.hasOwn(props, 'bbn-text') && (ele.innerText !== props['bbn-text'])) {\n    ele.innerText = props['bbn-text'];\n    isChanged = true;\n  }\n\n  // Setting up attributes\n  dist[\"default\"].fn.iterate(attr, (value, name) => {\n    if (!isComponent) {\n      if (dist[\"default\"].fn.isPrimitive(value)) {\n        let propName = name;\n        if (dist[\"default\"].cp.badCaseAttributes[name]) {\n          propName = dist[\"default\"].cp.badCaseAttributes[name];\n        }\n\n        const isAttr = (ele[propName] !== undefined);\n        const current = ele[propName];\n        if (isAttr) {\n          if (current !== value) {\n            if (!value) {\n              ele.removeAttribute(name);\n              // for SVG\n              if ({}.toString.apply(ele[propName]).substr(0, 7) !== '[object') {\n                ele[propName] = '';\n              }\n              isChanged = true;\n            }\n            else if (!node.attr[name] || node.attr[name].exp || (ele.getAttribute(name) === null)) {\n              // for SVG\n              const type = {}.toString.apply(ele[propName]);\n              if ((type === '[object String]') || (type.substr(0, 7) !== '[object')) {\n                ele[propName] = value;\n              }\n              ele.setAttribute(name, value);\n              isChanged = true;\n            }\n          }\n        }\n      }\n    }\n    else if (ele.bbnSchema.props[name] !== value) {\n      ele.bbnSchema.props[name] = value;\n      isChanged = true;\n    }\n  });\n  if (!isChanged && isComponent) {\n    dist[\"default\"].fn.iterate(ele.bbnSchema.attr, (attr, name) => {\n      if (attr.exp && !['OK', 'TMP'].includes((0,getExpState[\"default\"])(cp, attr.hash, ele.bbnSchema.loopHash))) {\n        isChanged = true;\n      }\n    });\n  }\n\n  if (isChanged && isComponent && ele.bbn?.$isMounted) {\n    ele.bbn.$tick();\n    /** @todo Understand why the form needs tick to be called twice */\n    setTimeout(() => {\n      ele.bbn.$tick();\n    }, 50);\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/fetchComponents.js\n/**\n * Deletes the given property from the given object using static method\n * @returns {Array|null}\n */\nasync function fetchComponents (cp) {\n  if (cp.$root.$unknownComponents.length) {\n    let unknown = cp.$root.$unknownComponents.splice(0, cp.$root.$unknownComponents.length);\n    const res = await bbn.cp.fetchComponents(unknown);\n    return res;\n  }\n\n  return false;\n}\n// EXTERNAL MODULE: ./src/lib/Cp/private/treatArgument.js\nvar treatArgument = __webpack_require__(\"./src/lib/Cp/private/treatArgument.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatEvents.js\n\n\n/**\n * Attaches event listeners to a specified element based on defined events and configurations.\n * It processes each event, applies any specified modifiers, and binds the event handler to the component.\n * \n * @param {Object} cp - The context provider (component instance) containing methods and properties.\n * @param {HTMLElement} ele - The HTML element to which the event listeners will be attached.\n */\nfunction treatEvents(cp, ele, data) {\n  // Determine the id for the element, defaulting to '0' if it's the component's root element.\n  let id = ele.bbnId;\n  if (ele === cp.$el) {\n    id = '0';\n  }\n\n  // Iterate over each event defined for the element.\n  dist[\"default\"].fn.iterate(cp.$currentMap[id].events, (ev, n) => {\n    // Configuration object for the event listener.\n    let cfg = {};\n    if (ev.once) {\n      cfg.once = true;\n    }\n    if (ev.passive) {\n      cfg.passive = true;\n    }\n    if (ev.capture) {\n      cfg.capture = true;\n    }\n\n    // Add the event listener to the element.\n    ele.addEventListener(n, e => {\n      // Check for any specified modifiers and apply them.\n      if (ev.modifiers.length) {\n        if (n.indexOf('key') === 0) {\n          // For keyboard events, check if the key matches any specified modifiers.\n          if (!e.key || !ev.modifiers.includes(e.key.toLowerCase())) {\n            return;\n          }\n        }\n        else if (n.indexOf('mouse') === 0) {\n          // For mouse events, check for specific button modifiers (right or left click).\n          if (ev.modifiers.includes('right') && e.button !== 2) {\n            return;\n          }\n          else if (ev.modifiers.includes('left') && e.button !== 0) {\n            return;\n          }\n        }\n      }\n\n      // If specified, prevent the default action for the event.\n      if (ev.prevent) {\n        e.preventDefault();\n      }\n\n      // If specified, stop the propagation of the event.\n      if (ev.stop) {\n        e.stopImmediatePropagation();\n      }\n\n      // If an expression is defined for the event, execute it.\n      if (ev.fn) {\n        const args = [];\n        // Process each argument for the event handler.\n        if (ev.args?.length) {\n          dist[\"default\"].fn.each(ev.args, a => {\n            if (a === '$event') {\n              args.push(e); // Pass the event object itself.\n            }\n            else {\n              // Process and push other arguments.\n              args.push((0,treatArgument[\"default\"])(cp, a, ele.bbnSchema.loopHash, data));\n            }\n          });\n        }\n        else if (ev.detail.args) {\n          args.push(...ev.detail.args);\n        }\n\n        if (cp.$namespaces[ev.exp] === 'method') {\n          if (e.detail?.args) {\n            cp.$methods[ev.exp].bind(cp)(...e.detail.args);\n          }\n          else {\n            cp.$methods[ev.exp].bind(cp)(e);\n          }\n        }\n        else {\n          // Bind the event handler to the component and execute it with the processed arguments.\n          ev.fn.bind(cp)(...args);\n        }\n        //bbn.fn.log(['on Event ' + e.type, cp.$namespaces[ev.exp] === 'method', cp.$options.name + ' ' + cp.$cid]);\n      }\n    }, cfg);\n  });\n}\n\n// EXTERNAL MODULE: ./src/lib/Data/Data.js\nvar Data = __webpack_require__(\"./src/lib/Data/Data.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatModel.js\n\n\n\n\n/**\n * Processes an element in the virtual DOM of a web component.\n * It handles the creation and updating of elements, binding properties and events,\n * processing slots, text nodes, and more.\n * \n * @param {Object} cp - The component instance containing methods and properties.\n * @param {Object} node - The virtual DOM node to be processed.\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {HTMLElement} parent - The parent element where the processed element will be appended.\n * @param {Object} data - Additional data that might be required for processing the element.\n * @param {boolean} [go=false] - A flag indicating whether the element needs to be updated.\n * @returns {HTMLElement|null} The processed element or null if no element is processed.\n */\nasync function treatModel(cp, node, hash, ele, data) {\n  if (node.model) {\n    for (let name in node.model) {\n      const eventName = node.model[name].modifiers.includes('lazy') ? 'change' : 'input';\n      ele.addEventListener(eventName, async e => {\n        const cpSource = dist[\"default\"].cp.getComponent(ele.bbnComponentId).bbn;\n        if (!cp.$isMounted) {\n          //return;\n        }\n        \n        if (name === '_default_') {\n          name = ele?.bbn?.$cfg?.model?.prop || 'value';\n        }\n\n        let eventValue = e.detail?.args ? e.detail.args[0] : e.target?.value;\n        let m = node.model[name];\n        if (eventValue && m.modifiers?.length) {\n          for (let i = 0; i < m.modifiers.length; i++) {\n            switch (m.modifiers[i]) {\n              case 'decimal':\n                eventValue = parseFloat(eventValue);\n                break;\n              case 'number':\n                eventValue = parseInt(eventValue);\n                break;\n              case 'trim':\n                eventValue = eventValue.trim();\n                break;\n              case 'lowercase':\n              case 'lower':\n                eventValue = eventValue.toLowerCase();\n                break;\n              case 'uppercase':\n              case 'upper':\n              case 'capitalize':\n                eventValue = eventValue.toUpperCase();\n                break;\n            }\n          }\n        }\n\n        let modelValue = m.value;\n        let oldValue = modelValue;\n        if (oldValue !== eventValue) {\n          //bbn.fn.log(['Modfel change', oldValue, m, m.exp, JSON.stringify(Object.keys(node.model)), eventValue, name, cpSource.$namespaces[m.exp]])\n          if (Object.hasOwn(data, m.exp)) {\n            data[m.exp] = eventValue;\n          }\n          else if (Object.hasOwn(cpSource.$namespaces, m.exp)) {\n            switch (cpSource.$namespaces[m.exp]) {\n              case 'props':\n                (0,setProp[\"default\"])(cpSource, m.exp, eventValue);\n                break;\n              case 'data':\n              case 'computed':\n                cpSource[m.exp] = eventValue;\n                break;\n              default:\n                throw new Error(\"Invalid namespace \" + cpSource.$namespaces[m.exp]);\n            }\n          }\n          else {\n            Data[\"default\"].startWatching();\n            (0,setExpResult[\"default\"])(cpSource, m, hash, data, true);\n            const dataObj = Data[\"default\"].getLastUsed();\n            if (!dataObj) {\n              throw new Error(\"Invalid model variable \" + m.exp);\n            }\n\n            dataObj.data.value[dataObj.name] = eventValue;\n            //bbn.fn.log([\"MODEL THROUGH BBN DATA\", dataObj.name]);\n          }\n\n          await cpSource.$tick();\n          if (cp !== cpSource) {\n            await cp.$tick();\n          }\n        }\n      });\n    }\n  }\n\n  \n  return null;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/addToElements.js\n\n\n/**\n * Adds or updates the given element to the `$elements` object property of a `bbnCp` component.\n * \n * @param {bbnCp} cp - The component instance where the element is to be added.\n * @param {HTMLElement | Text | Comment | SVGElement} ele - The HTML element, text node, or comment to be added.\n */\nfunction addToElements(cp, ele) {\n  dist[\"default\"].fn.checkType(cp, bbnCp, \"No component in addToElements\");\n  // Ensure that the element is of a valid type (HTML element, text node, or comment).\n  dist[\"default\"].fn.checkType(ele, [HTMLElement, Text, Comment, SVGElement], \"Elements should be HTML elements or text nodes\");\n\n  // Ensure that the element has a valid ID (string or symbol).\n  dist[\"default\"].fn.checkType(ele.bbnId, ['string', 'symbol'], \"In addToElements the ID should be a symbol\");\n\n  // Retrieve the element's unique identifier and hash.\n  const id = ele.bbnId;\n  const hash = ele.bbnHash;\n  // Retrieve the component ID associated with the element.\n  const origin = ele.bbnComponentId;\n\n  // If the element originates from a different component, get that component.\n  if (origin !== cp.$cid) {\n    cp = dist[\"default\"].cp.getComponent(origin).bbn;\n  }\n\n  if (!cp.$currentMap[id]) {\n    dist[\"default\"].fn.warning(\"Element does not exist in map\");\n    dist[\"default\"].fn.log([\"Element does not exist in map\", cp, id, ele]);\n  }\n  // If the element has a hash, add or update it in the $elements object using the hash.\n  if (hash) {\n    // Initialize the object for the element ID if not already present.\n    if (!cp.$elements[id]) {\n      cp.$elements[id] = dist[\"default\"].fn.createObject();\n    }\n\n    // If the element is not already present, add it; otherwise, throw an error.\n    if (cp.$elements[id][hash] !== ele) {\n      if (cp.$elements[id][hash]) {\n        let isCommentNew = dist[\"default\"].fn.isComment(ele);\n        let isCommentOld = dist[\"default\"].fn.isComment(cp.$elements[id][hash]);\n        if ((isCommentNew !== isCommentOld) || (ele.tagName !== cp.$elements[id][hash].tagName)) {\n          (0,removeDOM[\"default\"])(cp, cp.$elements[id][hash]);\n        }\n        else {\n          dist[\"default\"].fn.log([\"Element exist error with hash\", cp, cp.$elements[id][hash], ele, id, hash]);\n          (0,removeDOM[\"default\"])(cp, cp.$elements[id][hash]);\n          //throw Error(\"The element \" + id + \" with hash \" + hash + \" already exists in the DOM\");\n        }\n      }\n      cp.$elements[id][hash] = ele;\n    }\n  }\n  // If the element does not have a hash, add or update it in the $elements object using the ID.\n  else if (cp.$elements[id] !== ele) {\n    if (cp.$elements[id]) {\n      let isCommentNew = dist[\"default\"].fn.isComment(ele);\n      let isCommentOld = dist[\"default\"].fn.isComment(cp.$elements[id]);\n      if ((isCommentNew !== isCommentOld) || (ele.tagName !== cp.$elements[id].tagName)) {\n        (0,removeDOM[\"default\"])(cp, cp.$elements[id]);\n      }\n      else {\n        dist[\"default\"].fn.log([\"Element exist error\", cp, cp.$elements[id], ele, ele.bbnSchema.tag, id, cp.$numBuild, cp.$options.name]);\n        (0,removeDOM[\"default\"])(cp, cp.$elements[id]);\n        //throw Error(\"The element \" + id + \" already exists in the DOM\");\n      }\n    }\n\n    cp.$elements[id] = ele;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/addUnknownComponent.js\n/**\n * Adds the given component name to the list of unknown components if it's not already known or listed as unknown.\n *\n * @param {bbnCp} cp - The component instance where the unknown component is encountered.\n * @param {String} name - The name of the component to be added to the unknown list.\n * @returns {Boolean} - Returns true if the component name was added to the list, otherwise false.\n */\nfunction addUnknownComponent(cp, name) {\n  bbn.fn.checkType(cp, bbnCp, \"No component in addUnknownComponent\");\n  bbn.fn.checkType(name, String, \"Incorrect name in addUnknownComponent\");\n  // Check if the component name contains a hyphen, is not already known, and is not already listed as unknown.\n  if ((name.indexOf('-') > 0) && !bbn.cp.known.includes(name) && !cp.$root.$unknownComponents.includes(name)) {\n    // Add the component name to the list of unknown components at the root level of the component tree.\n    cp.$root.$unknownComponents.push(name);\n    return true; // Indicate that the name was successfully added.\n  }\n\n  return false; // Indicate that the name was not added (already known or listed as unknown).\n}\n\n// EXTERNAL MODULE: ./node_modules/tern/lib/tern.js\nvar tern = __webpack_require__(\"./node_modules/tern/lib/tern.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/buildElement.js\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates an element in the given target\n * @param {bbnCp} cp\n * @param {Object} node \n * @param {HTMLElement} parent\n * @param {Object} data \n * @returns \n */\nconst isBefore = (id1, id2) => {\n  if (id1 === id2) {\n    throw Error(\"Cannot compare the same ID in isBefore\");\n  }\n\n  const bits1 = id1.split('-');\n  const bits2 = id2.split('-');\n  for (let i = 0; i < bits1.length; i++) {\n    if (bits1[i] !== bits2[i]) {\n      return parseInt(bits1[i]) < parseInt(bits2[i]);\n    }\n  }\n\n  return true;\n}\n\nasync function buildElement(cp, node, parent, data, before, items) {\n  dist[\"default\"].fn.checkType(cp, bbnCp, \"No component in buildElement\");\n  dist[\"default\"].fn.checkType(node, \"object\", \"Props must be an object in buildElement\");\n  dist[\"default\"].fn.checkType(parent, [DocumentFragment, Element], \"Parent must be a DOM element\");\n  if (node.bbn) {\n    throw Error(\"Props cannot contain a bbn property in buildElement\");\n  }\n\n  // Check if the node represents a component and not a comment\n  let isComponent = !node.comment && cp.$isComponent(node);\n  // Retrieve the source component based on node's componentId or default to cp\n  // Attempt to retrieve an existing element with the same ID and loopHash\n  const oldEle = cp.$retrieveElement(node.id, node.loopHash);\n  // Flag to determine if the existing element should be replaced\n  let replace = false;\n  let ele; // Variable to hold the new or existing element\n  // Determine the tag name, adjusting for custom components if necessary\n  let tag = node.tag;\n  let originalTag = node.tag;\n  if (tag && cp.$cfg.componentNames[tag]) {\n    tag = cp.$cfg.componentNames[tag];\n    isComponent = true;\n  }\n  // Special handling for components and unknown components\n  if (!node.comment && isComponent) {\n    // Attempt to add unknown component for dynamic fetching if needed\n    if (addUnknownComponent(cp, tag)) {\n      // Fetch component definitions if the component is unknown\n      await fetchComponents(cp); \n    }\n    // Adjust the tag name for static components if necessary\n    if (dist[\"default\"].cp.statics[tag]?.tag) {\n      originalTag = tag;\n      tag = dist[\"default\"].cp.statics[originalTag].tag;\n    }\n  }\n  // Decide on creating a new element or reusing the old one\n  if (oldEle) {\n    // Mark for replacement if an old element exists\n    replace = true; \n  }\n  // Create the appropriate DOM element based on the node type\n  if (node.comment) {\n    // Create a comment node for placeholders\n    ele = document.createComment(\" ***_BBN_*** \"); \n  } else if (tag === 'svg') {\n    // Create an SVG element for vector graphics\n    ele = document.createElementNS(\"http://www.w3.org/2000/svg\", tag); \n    // Set the SVG content\n    ele.innerHTML = cp.$currentMap[node.id].content; \n  } else {\n    // Handle component elements or standard HTML elements\n    const constructorArgs = [tag];\n    if (originalTag !== tag) {\n      // Handle custom elements with 'is' attribute\n      constructorArgs.push({ is: originalTag }); \n    }\n\n    // Create the element\n    ele = document.createElement(...constructorArgs); \n    if (originalTag !== tag) {\n      // Set the 'is' attribute for custom elements\n      ele.setAttribute('is', originalTag); \n    }\n    // Additional setup for anonymous components (bbn-anon)\n    if (tag === 'bbn-anon' && node.cfg) {\n      // Ensure basic mixin is included in configuration\n      if (node.cfg.mixins && !node.cfg.mixins.includes(dist[\"default\"].cp.mixins.basic)) {\n        node.cfg.mixins.push(dist[\"default\"].cp.mixins.basic);\n      }\n      const tpl = (0,stringToTemplate[\"default\"])(node.cfg.template, true);\n      // Define properties for configuration, template, mapping, and inline templates\n      Object.defineProperties(ele, {\n        'bbnCfg': { value: node.cfg, writable: false, configurable: false },\n        'bbnTpl': { value: tpl.res, writable: false, configurable: false },\n        'bbnMap': { value: tpl.map, writable: false, configurable: false },\n        'bbnInlineTemplates': { value: tpl.inlineTemplates, writable: false, configurable: false }\n      });\n    }\n  }\n  // Assign a unique ID and schema to the element for tracking and management\n  Object.defineProperties(ele, {\n    'bbnId': { value: node.id, writable: false, configurable: false },\n    'bbnSchema': { value: node, writable: true, configurable: true },\n    'bbnComponentId': { value: cp.$cid, writable: false, configurable: false }\n  });\n  // Additional properties for loop handling and directives\n  if (node.loopHash) {\n    Object.defineProperties(ele, {\n      'bbnHash': { value: node.loopHash, writable: false, configurable: false },\n      'bbnIndex': { value: node.loopIndex, writable: false, configurable: false }\n    });\n  }\n  if (node.directives) {\n    Object.defineProperty(ele, 'bbnDirectives', {\n      value: dist[\"default\"].fn.createObject(), writable: false, configurable: false\n    });\n  }\n  // Set loop variables if provided\n  if (data) {\n    Object.defineProperty(ele, 'bbnLoopVars', {\n      value: data, writable: false, configurable: false\n    });\n  }\n  // Additional setup for components regarding slots and events\n  if (isComponent) {\n    let realSlots = tag === 'bbn-anon' ? (0,retrieveSlots[\"default\"])(ele.bbnTpl || cp.$currentMap[node.id].items) : dist[\"default\"].fn.clone(ele.constructor.bbnSlots);\n    if (!dist[\"default\"].fn.numProperties(realSlots)) {\n      // Ensure a default slot is always available\n      realSlots = { default: [] }; \n    }\n    if (items) {\n      dist[\"default\"].fn.warning(\"MY ITEMS ------------------\");\n      dist[\"default\"].fn.log(items)\n      dist[\"default\"].fn.each(items, c => {\n        realSlots.default.push(c);\n      })\n    }\n    Object.defineProperty(ele, 'bbnRealSlots', {\n      value: realSlots, writable: false, configurable: false\n    });\n    // Alias for accessing slots directly\n    Object.defineProperty(ele, 'bbnSlots', {\n      get() { return this.bbnRealSlots; }\n    });\n  }\n  // Apply properties and configurations to the element\n  applyPropsOnElement(cp, node, ele, data);\n  // Handle predefined content for <pre> elements\n  if (node.pre) {\n    ele.innerHTML = node.pre;\n  }\n  if ((parent !== cp.$el) && cp.$isComponent(parent)) {\n    const slot = ele.bbnSchema.props?.slot || 'default';\n    if (parent.bbnSlots?.[slot]) {\n      let search = {bbnId: ele.bbnId};\n      if (ele.bbnHash) {\n        search.bbnHash = ele.bbnHash;\n      }\n\n      let idx = dist[\"default\"].fn.search(parent.bbnSlots[slot], search);\n      if (idx > -1) {\n        const mounted = !!parent.bbnSlots[slot][idx].parentNode;\n        if (mounted) {\n          parent.bbnSlots[slot][idx].parentNode.replaceChild(ele, parent.bbnSlots[slot][idx]);\n        }\n\n        parent.bbnSlots[slot].splice(idx, 1, ele);\n      }\n      else {\n        parent.bbnSlots[slot].push(ele);\n      }\n    }\n  }\n  // Determine the insertion method based on the provided arguments\n  else if (before) {\n    // Insert before a specific sibling\n    parent.insertBefore(ele, before); \n  } else if (replace && oldEle) {\n    if (oldEle.childNodes.length && !node.comment) {\n      Array.from(oldEle.childNodes).forEach(c => {\n        ele.appendChild(c);\n      });\n    }\n    if (oldEle.parentNode === parent) {\n      // Replace an existing element\n      parent.replaceChild(ele, oldEle); \n    }\n    else {\n      // Append as a new child\n      parent.appendChild(ele); \n    }\n  }\n  // First time is done in a linear direction\n  else if (!cp.$numBuild || !parent.childNodes.length) {\n    // Append as a new child\n    parent.appendChild(ele); \n  }\n  else {\n    let after = false;\n    /*\n    const loopList = false;//cp.$retrieveElement(node.id, parent.bbnHash)?.bbnLoopList;\n    const myIdx = loopList ? loopList.indexOf(node.id + '_' + node.loopHash) : -1;\n    for (let i = parent.childNodes.length - 1; i >= 0; i--) {\n      if ((myIdx > -1) && (parent.childNodes[i].bbnId === ele.bbnId)) {\n        let idx = loopList.indexOf(parent.childNodes[i].bbnId + '_' + parent.childNodes[i].bbnHash);\n        if ((idx > -1) && (idx < myIdx)) {\n          after = parent.childNodes[i];\n          break;\n        }\n      }\n      else if ((parent.childNodes[i].bbnId !== ele.bbnId) && isBefore(parent.childNodes[i].bbnId, ele.bbnId)) {\n        after = parent.childNodes[i];\n        break;\n      }\n    }\n    */\n\n    if (after) {\n      // Insert after a specific sibling\n      after.after(ele); \n    }\n    else {\n      // Append as a new child\n      parent.appendChild(ele); \n    }\n  }\n  // Register the element in the component's tracking system\n  addToElements(cp, ele);\n  // Handle directives, model bindings, and events for the new element\n  if (!node.comment) {\n    if (dist[\"default\"].fn.numProperties(node.directives)) {\n      // Apply directives\n      dist[\"default\"].cp.insertDirectives(ele.bbnSchema.directives, ele); \n    }\n    if (node.model) {\n      // Bind model data\n      treatModel(cp, node, ele.bbnHash, ele, data); \n    }\n    if (Object.keys(node.events || {}).length) {\n      // Set up event listeners\n      treatEvents(cp, ele, data); \n    }\n  }\n  else if (dist[\"default\"].fn.numProperties(node.directives)) {\n    for (let n in node.directives) {\n      if (node.directives[n].inserted) {\n        node.directives[n].inserted = false;\n      }\n    }\n  }\n\n  // Return the created or modified element\n  return ele; \n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatCondition.js\n\n\n\n\n\n\n\n/**\n * Applies a condition to a specific element, treating it if the condition is true,\n * and deleting it if the condition is false.\n * \n * @param {bbnCp} cp - The context provider, containing methods and properties to manipulate elements.\n * @param {boolean} conditionValue - The condition value determining the action to be taken.\n * @param {Object} node - The node object representing the element to be treated or deleted.\n * @param {string} hash - A unique identifier for the element, used in conjunction with cp.\n * @param {HTMLElement} parent - The parent element of the node.\n * @param {Object} data - Additional data that might be required for processing the element.\n * @param {Array} hashList - An array of elements done through an upper loop\n * \n * @returns {Element} The treated element if the condition is true, otherwise null.\n */\nasync function treatCondition(\n  cp,\n  conditionValue,\n  node,\n  hash,\n  parent,\n  data,\n  hashList\n) {\n  let ele = null;\n  // If the condition is true, treat the element.\n  if (conditionValue) {\n    ele = await treatNode(cp, node, hash, parent, data, true, hashList);\n  }\n  // If the condition is false, delete the element if it exists.\n  else {\n    // Special handling for specific node tags like 'template', 'transition', 'slot'.\n    if (['template', 'transition', 'slot'].includes(node.tag)) {\n      if (cp.$currentMap[node.id].items) {\n        // Iterate over each item in the node.\n        dist[\"default\"].fn.each(cp.$currentMap[node.id].items, it => {\n          let e = cp.$retrieveElement(it.id, hash);\n          // Remove the element if it exists and is not a comment.\n          if (e) {\n            (0,removeDOM[\"default\"])(cp, e);\n          }\n        });\n      }\n    }\n    // Retrieve the element based on node id and hash.\n    ele = cp.$retrieveElement(node.id, hash);\n    // Check if the element is not already a comment.\n    if (!ele || !dist[\"default\"].fn.isComment(ele)) {\n      // If the element exists, remove it.\n      node.comment = true;\n      ele = await buildElement(cp, node, parent, data);\n    }\n  }\n\n  return ele;\n};\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatLoop.js\n\n\n\n\n\n\n\n\n/**\n * Processes loop directives in a component's template, iterating over data and applying conditions.\n * \n * @param {bbnCp} cp - The component instance.\n * @param {Object} node - The template node containing the loop directive.\n * @param {string} hash - A unique hash for the current scope of the component.\n * @param {HTMLElement} parent - The parent HTML element where the loop is being applied.\n * @param {Object} data - The current data scope for the component.\n * @param {Array} hashList - An array of elements done through an upper loop\n */\nasync function treatLoop(\n  cp,\n  node,\n  hash,\n  parent,\n  data,\n  hashList\n) {\n  if (node?.loop) {\n    dist[\"default\"].fn.checkType(cp, bbnCp);\n    dist[\"default\"].fn.checkType(node, Object);\n    dist[\"default\"].fn.checkType(hash, String);\n    dist[\"default\"].fn.checkType(parent, [DocumentFragment, HTMLElement], \"The parent must be an HTML Element\");\n    dist[\"default\"].fn.checkType(hashList, Array);\n    if (data) {\n      dist[\"default\"].fn.checkType(data, Object);\n    }\n\n    // Evaluate the loop expression and determine its type.\n    let loopValue = node.loop.exp ? (0,setExpResult[\"default\"])(cp, node.loop, hash, data) : node.loop.value;\n    let conditionValue = true;\n    const isNumber = dist[\"default\"].fn.isNumber(loopValue);\n    if (isNumber) {\n      // Convert number to an array of that length if loopValue is a number.\n      loopValue = Object.keys((new Array(loopValue)).fill(0)).map(a => parseInt(a));\n    }\n\n    const isArray = dist[\"default\"].fn.isArray(loopValue);\n    // Construct a unique hash for each iteration based on loop values.\n    const oHash = hash ? hash + '-' : '';\n\n\n    for (let j in loopValue) {\n      if (isArray) {\n        j = parseInt(j);\n      }\n      \n      const loopData = dist[\"default\"].fn.createObject({}, data, {[node.loop.item]: loopValue[j]});\n      if (node.loop.index) {\n        loopData[node.loop.index] = j;\n      }\n\n\n      let key = j;\n      if (node.attr?.key?.exp) {\n        key = (0,setExpResult[\"default\"])(cp, node.attr.key, oHash + node.loop.hash + '-' + j, loopData);\n      }\n\n      hash = oHash + node.loop.hash + '-' + key;\n\n      const ele = cp.$retrieveElement(node.id, hash);\n      const newNode = ele?.bbnSchema || cloneNode(cp, node.id);\n      newNode.loopHash = hash;\n\n      // Set loop item and index in the data.\n      (0,setExpResult[\"default\"])(cp, newNode.loopItem, hash, loopData);\n      if (Object.hasOwn(newNode, 'loopIndex')) {\n        (0,setExpResult[\"default\"])(cp, newNode.loopIndex, hash, loopData);\n      }\n\n      // Evaluate the condition for the current loop iteration.\n      if (newNode.condition) {\n        if (newNode.condition.type !== 'if') {\n          throw Error(\"The condition in a loop can only be of type 'if'\");\n        }\n        conditionValue = (0,setExpResult[\"default\"])(cp, newNode.condition, hash, loopData);\n      } else {\n        conditionValue = true;\n      }\n\n      //if (conditionValue) {\n        hashList.push(newNode.id + '_' + hash);\n      //}\n      // Apply the condition to the current node.\n      await treatCondition(cp, conditionValue, newNode, hash, parent, loopData, hashList);\n    }\n\n  }\n};\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/setConditionResult.js\n\n\n/**\n * Sets or updates the internal result for a given name and hash within the context of the component.\n * This method manages the state of the result, tracking changes and updates.\n * \n * @param {string} attr.hash - The name associated with the result. Acts as a key in the results object.\n * @param {*} expValue - The result or value to be set or updated.\n * @param {string} [hash='_root'] - The hash associated with this result, defaults to '_root' if not provided.\n * @returns {*} The updated result value.\n */\nfunction setConditionResult(cp, attr, expValue, hash, data) {\n  const r = cp.$expResults;\n  // Ensure the existence of a result object for the given name.\n  if (!r[attr.hash]) {\n    r[attr.hash] = bbn.fn.createObject();\n  }\n\n  // Default the hash to '_root' if not provided.\n  if (!hash) {\n    hash = '_root';\n  }\n\n  // If the result for the given name and hash doesn't exist, create it.\n  if (!r[attr.hash][hash]) {\n    r[attr.hash][hash] = bbn.fn.createObject({\n      state: 'NEW', // Mark the state as new.\n      value: expValue,   // Set the provided result.\n      num: cp.$numBuild + 1, // Set the build number.\n      old: bbnData.hash(expValue) // Store a hash of the value for comparison purposes.\n    });\n  }\n  else if (r[attr.hash][hash].num <= cp.$numBuild) {\n    // If the existing state is 'DEL', update the value and mark as new.\n    if (r[attr.hash][hash].state === 'DEL') {\n      r[attr.hash][hash].value = expValue;\n      r[attr.hash][hash].state = 'NEW';\n      r[attr.hash][hash].num = cp.$numBuild + 1;\n    }\n    // If the state is 'TMP', update the value and determine if it has been modified.\n    else if (r[attr.hash][hash].state === 'TMP') {\n      r[attr.hash][hash].value = expValue;\n      r[attr.hash][hash].num = cp.$numBuild + 1;\n      const _o = bbnData.hash(expValue);\n      // Check if the value has changed since the last update.\n      if (!bbn.fn.isSame(r[attr.hash][hash].old, _o)) {\n        r[attr.hash][hash].state = 'MOD'; // Modified state.\n        // Update the old hash to the current hash.\n        r[attr.hash][hash].old = _o;\n      }\n      else {\n        r[attr.hash][hash].state = 'OK'; // Unchanged state.\n      }\n\n    }\n  }\n\n  // Return the updated result value.\n  return r[attr.hash][hash].value;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatItem.js\n\n\n\n\n\n\n\n\n\n\nasync function treatItem(cp, item, hash, parent, data, hashList = []) {\n  if (item.loop) {\n    return await treatLoop(cp, item, hash, parent, data, hashList);\n  }\n  else {\n    const ele = cp.$retrieveElement(item.id, hash);\n    const node = ele ? ele.bbnSchema : cloneNode(cp, item.id);\n    node.loopHash = hash;\n    hashList.push(node.id + (hash ? '_' + hash : ''));\n    if (node.condition) {\n      let isConditionPossible = true;\n      // Processing all nodes with the same conditionId\n      if (!node.condition.type.indexOf('else')) {\n        let id = item.id;\n        while (id = getIdBefore(cp, id)) {\n          //bbn.fn.log(\"CHACKING CONDITION \" + id);\n          const elem = cp.$retrieveElement(id, hash);\n          if (!elem) {\n            continue;\n          }\n\n          const o = elem.bbnSchema;\n          if (o.conditionId === node.conditionId) {\n            if (cp.$expResults[o.condition.hash]?.[hash || '_root']?.value) {\n              isConditionPossible = false;\n              break;\n            }\n          }\n          else if (o.tag) {\n            break;\n          }\n        }\n      }\n\n      const conditionValue = isConditionPossible ? (\n        node.condition.type === 'else' ?\n          true : (0,setExpResult[\"default\"])(cp, node.condition, hash, data)\n      ) : false;\n      setConditionResult(cp, node.condition, conditionValue ? true : false, hash, data);\n      // Apply the condition to the current node.\n      return await treatCondition(cp, conditionValue, node, hash, parent, data, hashList);\n    }\n    else {\n      // Process nodes without conditions.\n      return await treatNode(cp, node, hash, parent, data, true, hashList);\n    }\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatItems.js\n\n\n\n\n/**\n * Processes a collection of items representing a virtual DOM structure and creates\n * HTML elements based on defined conditions and loops.\n * \n * @param {bbnCp} cp - The context provider, containing methods and properties for element manipulation.\n * @param {Array} items - An array of item objects, each representing a virtual DOM node.\n * @param {string} hash - A unique identifier used in conjunction with cp.\n * @param {HTMLElement} parent - The parent element to which new elements will be appended.\n * @param {Object} data - Additional data that might be required for processing the elements.\n * @param {Array} hashList - An array of elements done through an upper loop\n * \n * @returns {HTMLElement} The parent element with all the processed child elements appended.\n */\nasync function treatItems(\n  cp,\n  items,\n  hash,\n  parent,\n  data,\n  hashList = null\n) {\n  dist[\"default\"].fn.checkType(cp, bbnCp);\n  dist[\"default\"].fn.checkType(items, Array);\n  dist[\"default\"].fn.checkType(hash, String);\n  let hasAlreadyHashes = hashList !== null;\n  if (hashList === null) {\n    hashList = [];\n  }\n\n  dist[\"default\"].fn.checkType(hashList, Array);\n\n  let firstGo = false;\n  let isRoot = !parent || (parent === cp.$el);\n  if (isRoot) {\n    firstGo = !cp.$numBuild\n    parent = firstGo ? new DocumentFragment() : cp.$el;\n  }\n\n  dist[\"default\"].fn.checkType(parent, [HTMLElement, DocumentFragment], \"The items's parent must be an HTML Element\");\n\n  if (data) {\n    dist[\"default\"].fn.checkType(data, Object);\n  }\n  // Initialize data and parent if they are not provided.\n  else {\n    data = dist[\"default\"].fn.createObject();\n  }\n\n  // Iterate over each item in the items array.\n  for (let i = 0; i < items.length; i++) {\n    await treatItem(cp, items[i], hash, parent, data, hashList);\n  }\n\n  if (firstGo) {\n    cp.$el.appendChild(parent);\n  }\n  else if (!hasAlreadyHashes) {\n    dist[\"default\"].fn.each(parent.childNodes, ele => {\n      if (ele.bbnId\n        && ele.tagName\n        && !ele.bbnId.indexOf((isRoot ? '0' : parent.bbnId) + '-')\n        && (ele.bbnComponentId === cp.$cid)\n        && !hashList.includes(ele.bbnId + (ele.bbnHash ? '_' + ele.bbnHash : ''))\n      ) {\n        dist[\"default\"].fn.log([\"DELETING\", ele, ele.bbnId, ele.bbnHash, JSON.stringify(hashList)]);\n        (0,removeDOM[\"default\"])(cp, ele);\n      }\n    });\n  }\n\n  return parent;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatSlot.js\n\n\n\n/**\n * Processes 'slot' elements within a web component, distributing child elements into the appropriate slots.\n * It handles both named and default slots, and manages the placement of child elements into these slots.\n * \n * @param {Object} cp - The context provider (component instance) containing methods and properties.\n * @param {Object} node - The virtual DOM node representing the slot element.\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {HTMLElement} parent - The parent element where the slot content will be placed.\n * @param {Object} data - Additional data that might be required for processing the elements.\n * @returns {HTMLElement} The parent element with the slot content appended or modified.\n */\nasync function treatSlot(cp, node, hash, parent, data) {\n  // Check if the node is a 'slot' element.\n  if (node.tag === 'slot') {\n    let slot = 'default'; // Default slot name.\n\n    // Determine the name of the slot (if specified).\n    if (node.attr?.name) {\n      slot = node.attr.name.exp ? (0,setExpResult[\"default\"])(cp, node.attr.name, hash, data) : node.attr.name.value;\n    }\n\n    // Check if there are elements to be placed in this slot.\n    if (cp.$el.bbnSlots?.[slot]?.length) {\n      const filter = node.attr?.filter ? (0,setExpResult[\"default\"])(cp, node.attr.filter, hash, data) : false;\n      const filterFn = a => {\n        return filter ? filter(a) : true;\n      }\n      // Iterate over each element designated for this slot.\n      dist[\"default\"].fn.each(cp.$el.bbnSlots[slot], a => {\n        if (filterFn(a)) {\n          // Prepare a search object to find the element in the slot.\n          let search = {bbnId: a.bbnId};\n          if (a.bbnHash) {\n            search.bbnHash = a.bbnHash;\n          }\n\n          // Handle the case where the slot is inside another component.\n          if ((parent !== cp.$el) && dist[\"default\"].cp.isComponent(parent)) {\n            if (!parent.bbnSlots[slot].includes(a)) {\n              let idx = dist[\"default\"].fn.search(parent.bbnSlots[slot], search);\n              parent.bbnSlots[slot].splice(idx > -1 ? idx : parent.bbnSlots[slot].length, idx > -1 ? 1 : 0, a);\n            }\n          }\n          // Handle the case where the element is not yet mounted.\n          else if (!a.parentNode) {\n            let idx = dist[\"default\"].fn.search(parent.childNodes, search);\n            if (idx > -1) {\n              parent.replaceChild(a, parent.childNodes[idx]);\n            }\n            else {\n              parent.appendChild(a);\n            }\n          }\n        }\n      });\n    }\n\n    // Process any additional items within the slot node.\n    //await treatItems(cp, node, hash, parent, data);\n    return parent; // Return the parent element with the slot content.\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/createText.js\n\n/**\n * Creates an element in the given target\n * @param {bbnCp} cp\n * @param {HTMLElement} d \n * @param {HTMLElement} target \n * @returns \n */\nfunction createText(cp, node, target, loopInfo) {\n  const ele = document.createTextNode(node.text);\n  bbn.fn.checkType(node.id, String, \"The node id must be a string\");\n  Object.defineProperty(ele, 'bbnId', {\n    value: node.id,\n    writable: false,\n    configurable: false\n  });\n  Object.defineProperty(ele, 'bbnComponentId', {\n    value: cp.$cid,\n    writable: false,\n    configurable: false\n  });\n\n  Object.defineProperty(ele, 'bbnSchema', {\n    value: node,\n    writable: false,\n    configurable: false\n  });\n\n  if (loopInfo) {\n    Object.defineProperty(ele, 'bbnLoopVars', {\n      value: loopInfo,\n      writable: false,\n      configurable: false\n    });\n  }\n\n\n\n  if (node.loopHash) {\n    Object.defineProperty(ele, 'bbnHash', {\n      value: node.loopHash,\n      writable: false,\n      configurable: false\n    });\n    Object.defineProperty(ele, 'bbnIndex', {\n      value: node.loopIndex,\n      writable: false,\n      configurable: false\n    });\n  }\n\n  addToElements(cp, ele);\n\n  if (bbn.cp.isComponent(target)) {\n    if (target.bbnSlots?.default?.length || bbn.fn.removeExtraSpaces(ele.textContent)) {\n      target.bbnSlots.default.push(ele);\n    }\n\n    if (target.bbn && target.bbn.$isMounted) {\n      target.bbn.$tick();\n    }\n  }\n  else if (target !== cp.$el) {\n    target.appendChild(ele);\n  }\n\n  return ele;\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatText.js\n\n\n\n\nfunction treatText(cp, node, hash, parent, data) {\n  dist[\"default\"].fn.checkType(cp, bbnCp, \"No component in treatText\");\n  if (Object.hasOwn(node, 'text')) {\n    const ele = cp.$retrieveElement(node.id, hash);\n    const go = !ele;\n\n    if (node.exp) {\n      node.text = (0,setExpResult[\"default\"])(cp, node, hash, data);\n      if (ele && (ele.textContent !== node.text)) {\n        ele.textContent = node.text;\n      }\n    }\n\n    if (go) {\n      createText(cp, node, parent);\n    }\n\n    return parent;\n  }\n\n  return null;\n}\n\n// EXTERNAL MODULE: ./src/lib/Cp/private/getExpValue.js\nvar getExpValue = __webpack_require__(\"./src/lib/Cp/private/getExpValue.js\");\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatElement.js\n\n\n\n\n\n\n\n/**\n * Processes an element in the virtual DOM of a web component.\n * It handles the creation and updating of elements, binding properties and events,\n * processing slots, text nodes, and more.\n * \n * @param {Object} cp - The component instance containing methods and properties.\n * @param {Object} node - The virtual DOM node from the template to be processed (needs to be cloned for use).\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {HTMLElement} parent - The parent element where the processed element will be appended.\n * @param {Object} data - Additional data that might be required for processing the element.\n * @param {boolean} [go=false] - A flag indicating whether the element needs to be updated.\n * @returns {HTMLElement|null} The processed element or null if no element is processed.\n */\nasync function treatElement(cp, node, hash, parent, data, go = false) {\n  /** @var {null, HTMLElement} ele The element  */\n  let ele = null;\n  // Elements must be tags\n  if (node.tag) {\n    /** @var {String} id Type 0-1, 0-3-6-0-1 */\n    const id = node.id;\n    /** @var {HTMLElement, null} old The existing element if it exists */\n    const old = cp.$retrieveElement(id, hash);\n    // For the time being ele is the old element or null\n    ele = old;\n    \n    // Take care of the element if go is true\n    if (go) {\n      // Setting properties\n      // Either the element exists and the object is its bbnSchema or we clone the node\n      // Setting the new properties only when needed\n\n      // Updating the hash\n      if (hash && (node.loopHash !== hash)) {\n        node.loopHash = hash;\n      }\n\n      // With the custom node we update the props and model.value\n      if (node.model) {\n        if (node.model._default_ && old?.bbn?.$cfg) {\n          let n = old.bbn.$cfg.model?.prop || 'value';\n          if (!dist[\"default\"].fn.isSame(node.model[n], node.model._default_)) {\n            node.model[n] = node.model._default_;\n          }\n\n          if (Object.hasOwn(node.props, '_default_')) {\n            let n = old?.bbn?.$cfg?.model?.prop || 'value';\n            if (!dist[\"default\"].fn.isSame(node.props[n], node.props._default_)) {\n              node.props[n] = node.props._default_;\n            }\n            delete node.props._default_;\n          }\n\n          delete node.model._default_;\n        }\n\n        for (let n in node.model) {\n          if ((0,getExpState[\"default\"])(cp, node.model[n].hash, hash) !== 'OK') {\n            node.model[n].value = node.props[n];\n          }\n        }\n      }\n\n      // Updating also the directives\n      if (dist[\"default\"].fn.numProperties(node.directives)) {\n        for (let n in node.directives) {\n          if (node.directives[n].exp) {\n            node.directives[n].value = (0,getExpValue[\"default\"])(cp, node.directives[n].hash, hash);\n          }\n        }\n      }\n    \n      // 'component' tag is a special case\n      if (cp.$currentMap[node.id].tag === 'component') {\n        if (dist[\"default\"].fn.isObject(node.props.is)) {\n          node.tag = node.props.name ? dist[\"default\"].fn.camelToCss(node.props.name) : 'bbn-anon';\n          node.cfg = dist[\"default\"].cp.normalizeComponent(node.props.is);\n        }\n        else {\n          node.tag = dist[\"default\"].fn.camelToCss(node.props.is);\n        }\n      }\n\n    }\n  }\n\n  \n  return node;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatForgotten.js\n\n\n\n\n\n\n\n\n/**\n * Processes a virtual DOM node with the 'forget' directive.\n * If the 'forget' condition is true, the element itself is not rendered, \n * but its children are rendered directly under the parent element.\n * If the element is forgotten and already exists, it is removed from the DOM.\n * \n * @param {bbnCp} cp - The context provider (component instance) containing methods and properties.\n * @param {Object} node - The virtual DOM node to be processed.\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {HTMLElement} parent - The parent element where the processed children will be appended.\n * @param {Object} data - Additional data that might be required for processing the element.\n * @param {boolean} [go=false] - A flag indicating whether the element needs to be updated.\n * @returns {Boolean} The result of the forget value.\n */\nasync function treatForgotten(cp, node, hash, parent, data) {\n  // Check if the 'forget' directive exists and is an expression.\n  if (node.forget?.exp) {\n    // Evaluate the 'forget' directive's condition.\n    const forgotten = (0,setExpResult[\"default\"])(cp, node.forget, hash, data);\n\n    // Check if the internal state of the 'forget' directive is not 'OK'.\n    if ((0,getExpState[\"default\"])(cp, node.forget.hash, hash) !== 'OK') {\n      // Retrieve the existing element based on the node ID and hash.\n      let ele = cp.$retrieveElement(node.id, hash);\n      // If the condition is true, process the children without rendering the parent element.\n      if (forgotten) {\n        node.comment = true;\n\n        if (!ele) {\n          ele = await buildElement(cp, node, parent);\n        }\n        else if (!dist[\"default\"].fn.isComment(ele)) {\n          Array.from(ele.childNodes).forEach(child => {\n            parent.insertBefore(child, ele);\n          });\n          // Remove the existing element from the DOM.\n          await buildElement(cp, node, parent, data);\n        }\n      }\n      // If forgotten is false but has changed\n      else if (dist[\"default\"].fn.isComment(ele)) {\n        node.comment = false;\n      }\n    }\n\n    return forgotten;\n  }\n\n  return false;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/treatNode.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Processes an element in the virtual DOM of a web component.\n * It handles the creation and updating of elements, binding properties and events,\n * processing slots, text nodes, and more.\n * \n * @param {Object} cp - The component instance containing methods and properties.\n * @param {Object} node - The virtual DOM node to be processed.\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {HTMLElement} parent - The parent element where the processed element will be appended.\n * @param {Object} data - Additional data that might be required for processing the element.\n * @param {boolean} [go=false] - A flag indicating whether the element needs to be updated.\n * @param {Array} hashList - An array of elements done through an upper loop\n * @returns {HTMLElement|null} The processed element or null if no element is processed.\n */\nasync function treatNode (\n  cp,\n  node,\n  hash,\n  parent,\n  data,\n  go = false,\n  hashList\n) {\n  // Default parent to a DocumentFragment if not provided.\n  if (!parent) {\n    parent = new DocumentFragment();\n  }\n\n  // Retrieve the existing element and its virtual DOM node.\n  // Process text nodes\n  if (Object.hasOwn(node, 'text')) {\n    return treatText(cp, node, hash, parent, data);\n  }\n  // process slots content\n  else if (node.tag === 'slot') {\n    return treatSlot(cp, node, hash, parent, data);\n  }\n  else if (node.tag) {\n    const old = cp.$retrieveElement(node.id, hash);\n    let forgotten = null;\n    let ele = old;\n    let anew = false;\n  \n    // Handle 'forget' directive to conditionally remove elements.\n    forgotten = await treatForgotten(cp, node, hash, parent, data);\n    if (forgotten) {\n      go = false;\n\n    }\n    // Special handling for 'transition' and 'template' tags.\n    else if (!node.pre && ['transition', 'template'].includes(node.tag)) {\n      go = false;\n      forgotten = true;\n    }\n\n    const isOldComment = old && dist[\"default\"].fn.isComment(old);\n    // Determine if the element already exists or needs to be created.\n    if (!go && !forgotten && (!old || isOldComment || !dist[\"default\"].cp.isTag(node.tag, old))) {\n      go = true;\n    }\n\n    let isComponent;\n    // Only for showable elements (no template, transition, forget, etc.)\n    if (go) {\n      if (isOldComment && node.comment) {\n        node.comment = false;\n      }\n  \n      // Update every attributes/models/directives, and populates props accordingly (all in the node)\n      go = treatProperties(cp, node, hash, data, go);\n        // If no element we must go on\n      if (isOldComment || !old) {\n        go = true;\n      }\n\n      if (go) {\n        await treatElement(cp, node, hash, parent, data, go);\n        /** @var {Boolean} anew If true the element needs to be created */\n        // True if the element doesn't exist, is a comment, or has a different tag\n        if ((ele !== cp.$el) && (!ele || dist[\"default\"].fn.isComment(ele) || !dist[\"default\"].cp.isTag(node.tag, ele))) {\n          anew = true;\n        }\n  \n        // Create the element if needed\n        if (anew) {\n          isComponent = !node.comment && cp.$isComponent(node);\n          if (node.tag && cp.$cfg.componentNames[node.tag]) {\n            isComponent = true;\n          }\n\n          ele = await buildElement(cp, node, parent, data);\n          if (node.forget && ((0,getExpState[\"default\"])(cp, node.forget.hash, hash) !== 'OK') && (!node.comment)) {\n            Array.from(parent.childNodes).forEach(node => {\n              if (node.bbnId.indexOf(node.id + '-') === 0) {\n                ele.appendChild(node);\n              }\n            });\n          }\n\n          if (isComponent) {\n            cp.$connectors.push(ele);\n          }\n        }\n        // Or update the element\n        else {\n          if (dist[\"default\"].fn.numProperties(node.directives)) {\n            for (let n in node.directives) {\n              if (node.directives[n].exp) {\n                if ((0,getExpState[\"default\"])(cp, node.directives[n].hash, hash) !== \"OK\") {\n                  node.directives[n].value = (0,getExpValue[\"default\"])(cp, node.directives[n].hash, hash);\n                  ele.bbnSchema.directives[n].value = node.directives[n].value;\n                  dist[\"default\"].cp.updateDirectives({[n]: node.directives[n]}, ele);\n                }\n              }\n            }\n          }\n\n          applyPropsOnElement(cp, node, ele, data);\n        }\n      }\n    }\n\n    // Handle 'pre' directive or process child items.\n    if (node.pre) {\n      if (ele) {\n        if (ele.innerHTML !== node.pre) {\n          ele.innerHTML = node.pre;\n        }\n      }\n    }\n    else if (cp.$currentMap[node.id].items?.length) {\n      await treatItems(cp, cp.$currentMap[node.id].items, hash, forgotten ? parent : ele, data, forgotten ? hashList : null);\n    }\n\n    if (!ele && ['transition', 'template'].includes(node.tag)) {\n      node.comment = true;\n      ele = await buildElement(cp, node, parent, data);\n    }\n\n\n    return ele;\n  }\n\n  return null;\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/handleElement.js\n\n\nasync function handleElement(cp, id, hash) {\n  // The properties of the component\n  const props = bbn.fn.createObject();\n  const element = cp.$retrieveElement(id, hash);\n  if (!element) {\n    throw Error(\"Impossible to find the element \" + id + \" in \" + cp.$options.name);\n  }\n\n  bbn.fn.error(\"TREAT NODE ON HANDLE\")\n  await treatNode(cp, cp.$currentMap[id], element.bbnHash, element.parentNode, element.bbnLoopVars);\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/getProp.js\n\n\nfunction getProp(cp, name) {\n  if (Object.hasOwn(cp.$el.bbnSchema.props || {}, name) && (cp.$el.bbnSchema.props[name] !== cp.$props[name])) {\n    (0,setProp[\"default\"])(cp, name, cp.$el.bbnSchema.props[name]);\n  }\n\n  //let v = bbnData.getValue(cp.$props[name]);\n\n  /** @todo build2\n  if (cp.$currentComputed && !cp.$computed[cp.$currentComputed].dependencies.includes(name)) {\n    cp.$computed[cp.$currentComputed].dependencies.push(name);\n  }\n */\n\n  /*\n  if (!bbn.fn.isPrimitive(v) && (typeof v === 'object') && [Array, Object, undefined].includes(v.constructor)) {\n    const hash = bbn.fn.hash(v);\n    if (cp.$oldValues[name] !== hash) {\n      if (cp.$isInit) {\n        if (cp.$watcher?.[name]?.handler) {\n          if (!bbn.fn.isFunction(cp.$watcher[name].handler)) {\n            throw Error(bbn._(\"Watchers must be function, wrnmg parameter for %s\", name));\n          }\n          const oldV = cp.$watcher[name].value;\n          cp.$watcher[name].value = v;\n          cp.$watcher[name].handler.apply(cp, [v, oldV]);\n        }\n\n        cp.$oldValues[name] = hash;\n        cp.$tick();\n      }\n    }\n  }\n  */\n\n  return cp.$props[name];\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/updateProps.js\n\n\nfunction updateProps(cp) {\n  bbn.fn.each(cp.$namespaces, (a, n) => {\n    if (a === 'props') {\n      getProp(cp, n);\n    }\n  });\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/applySchemaOnComponent.js\n\n\n\n/**\n * Sets the props and attributes of the component element based on its combined schema\n * \n * @returns {undefined}\n */\nfunction applySchemaOnComponent (cp, props) {\n  dist[\"default\"].fn.checkType(cp, bbnCp, \"No component in applySchemaOnComponent\");\n  if (props) {\n    dist[\"default\"].fn.checkType(props, \"object\", \"Props must be an object in applySchemaOnComponent\");\n    if (props.bbn) {\n      throw new Error(\"Props cannot contain a bbn property in applySchemaOnComponent\");\n    }\n  }\n\n  if (cp.$el.bbnSchema) {\n    //bbn.fn.warning(\"applySchemaOnComponent \" + cp.$options.name);\n    // The classes on the component itself are only generated once \n    // Concatenating classes from the attributes and from componentClass\n    const cls = ['bbn-component'];\n    if (cp.componentClass) {\n      cls.push(cp.componentClass);\n    }\n    if (props?.class) {\n      cls.push(props.class);\n    }\n    if (cp.$el.bbnSchema.props?.class) {\n      cls.push(cp.$el.bbnSchema.props.class);\n    }\n\n    let textCls = dist[\"default\"].cp.convertClasses(cls);\n\n    if (cp.$el.className !== textCls) {\n      // Converting to string\n      cp.$el.className = textCls;\n    }\n    //bbn.fn.log(\"PUTTING CLASSES \" + textCls);\n\n    let stl = [cp.$el.bbnSchema.props?.style || ''];\n    if (props?.style) {\n      stl.push(props.style);\n    }\n    \n\n    if ((props?.['bbn-show'] !== undefined)) {\n      stl.push({display: props['bbn-show'] ? 'block' : 'none'});\n    }\n\n    stl = dist[\"default\"].cp.convertStyles(stl);\n    /*\n    if (cp.$options.name === 'appui-task-columns-toolbar') {\n      bbn.fn.log(['applySchemaOnComponent', stl])\n    }\n    */\n    if (!stl && cp.$el.style.cssText) {\n      cp.$el.style.cssText = '';\n    }\n    else if (stl && (stl !== cp.$el.style.cssText)) {\n      cp.$el.style.cssText = stl;\n    }\n\n    for (let n in cp.$el.bbnSchema?.props || {}) {\n      if (!['class', 'style'].includes(n)) {\n        let value = cp.$el.bbnSchema.props[n];\n\n        if (Object.hasOwn(cp.$props, n)) {\n          (0,setProp[\"default\"])(cp, n, value);\n        }\n\n        if (dist[\"default\"].fn.isPrimitive(value)) {\n          let propName = n;\n          if (dist[\"default\"].cp.badCaseAttributes[n]) {\n            propName = dist[\"default\"].cp.badCaseAttributes[n];\n          }\n\n          const isAttr = (cp.$el[propName] !== undefined);\n          // It's not a prop and it's already defined in the template\n          if (isAttr && (!Object.hasOwn(cp.$props, n) || !Object.hasOwn(props, n))) {\n            if (!value && cp.$el.hasAttribute(n)) {\n              cp.$el.removeAttribute(n);\n              // for SVG\n              if ({}.toString.apply(cp.$el[propName]).substr(0, 7) !== '[object') {\n                cp.$el[propName] = '';\n              }\n            }\n            else if (value) {\n              cp.$el.setAttribute(n, value);\n              // for SVG\n              if ({}.toString.apply(cp.$el[propName]).substr(0, 7) !== '[object') {\n                cp.$el[n] = dist[\"default\"].fn.isString(value) ? value : value?.toString() || '';\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (let n in props) {\n      if (!['class', 'style'].includes(n)) {\n        if (cp.$el[n] !== undefined) {\n          if (props[n]) {\n            cp.$el[n] = dist[\"default\"].fn.isString(props[n]) ? props[n] : props[n]?.toString() || '';\n          }\n          else if (cp.$el.hasAttribute(n)) {\n            cp.$el.removeAttribute(n);\n          }\n        }\n      }\n    }\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/handleComponent.js\n\n\n\n\n\n\n\n/**\n * Handles the initialization and setup of the component by applying schemas, directives, events, and more.\n * \n * @param {bbnCp} cp - The component instance being handled.\n */\nasync function handleComponent(cp) {\n  // Starting chrono\n  const t1 = (new Date()).getTime();\n  // Setting last launch time only if we are updating the whole component\n  cp.$lastLaunch = t1;\n  /** @var Object The properties of the component */\n  const internalProps = dist[\"default\"].fn.createObject();\n  /** @var Object The attributes of the root element */\n  const attr = cp.$tpl[0]?.attr;\n\n  // Loop through the attributes defined in the template.\n  // They should only be HTML attributes they are not the props\n  for (let n in attr) {\n    // Evaluate the expression for the attribute or take its value directly.\n    internalProps[n] = attr[n].exp ? (0,setExpResult[\"default\"])(cp, attr[n]) : attr[n].value;\n  }\n\n  for (let n in cp.$computed) {\n    cp.$computed[n].update();\n  }\n\n  const t2 = (new Date()).getTime();\n\n  // Handling directives.\n  const directives = cp.$tpl[0]?.directives;\n  if (directives) {\n    for (let n in directives) {\n      // Clone the directive from the template if not already present.\n      if (!cp.$directives[n]) {\n        cp.$directives[n] = dist[\"default\"].fn.clone(cp.$tpl[0].directives[n]);\n      }\n\n      // Evaluate and set the value for the directive.\n      if (directives[n].exp) {\n        cp.$directives[n].value = (0,setExpResult[\"default\"])(cp, directives[n]);\n      }\n\n      // Ensure there's a bbnDirectives object on the element.\n      if (!cp.$el.bbnDirectives) {\n        Object.defineProperty(cp.$el, 'bbnDirectives', {\n          value: dist[\"default\"].fn.createObject(),\n          writable: false,\n          configurable: false\n        });\n      }\n\n      // Create a directive object if not already present.\n      if (!cp.$el.bbnDirectives[n]) {\n        cp.$el.bbnDirectives[n] = dist[\"default\"].fn.createObject();\n      }\n    }\n\n    // Insert directives for the first build; update them on subsequent builds.\n    if (!cp.$numBuild) {\n      dist[\"default\"].cp.insertDirectives(cp.$directives, cp.$el);\n    }\n    else {\n      for (let n in directives) {\n        dist[\"default\"].cp.updateDirectives({[n]: cp.$directives[n]}, cp.$el);\n      }\n    }\n  }\n\n  const t3 = (new Date()).getTime();\n\n  // Applying the schema on the component.\n  applySchemaOnComponent(cp, internalProps);\n\n  const t4 = (new Date()).getTime();\n  // Setup event listeners if defined and it's the first build.\n  if (cp.$tpl[0]?.events && !cp.$numBuild) {\n    treatEvents(cp, cp.$el);\n  }\n\n  cp.$lastLaunch = (new Date()).getTime();\n  /*\n  if (cp.$lastLaunch - t1 > 1) {\n    bbn.fn.log(\n      \"UPDATED COMPONENT \" + cp.$options.name\n      + ' / ' + cp.$cid\n      + ' / ' + cp.$numBuild\n      + ' /all ' + (cp.$lastLaunch - t1) + 'ms'\n      + ' /attr ' + (t2 - t1) + 'ms'\n      + ' /dir ' + (t3 - t2) + 'ms'\n      + ' /schema ' + (t4 - t3) + 'ms'\n      + ' /events ' + (cp.$lastLaunch - t4) + 'ms'\n    );\n  }\n  */\n\n  // Handle nested items within the component template.\n  if (cp.$tpl[0]?.items) {\n    await treatItems(cp, cp.$tpl[0].items, '', cp.$el);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/launch.js\n\n\n\n\n\n/**\n * (Re)generates the whole component's vDOM and DOM if needed, picking the right root, shadow or not\n * - Updates the component element based on its own schema ($el.bbnSchema)\n * - Updates the schema\n * - Generates/update the DOM when needed\n * \n * @param {bbnCp} cp The component\n * @returns {Promise}\n */\nasync function launch (cp, id, hash) {\n  // It cannot be launched if the creation has not been completed or if the component is not in the DOM\n  if (!cp.$isCreated || !cp.$el.isConnected) {\n    return;\n  }\n\n  // If isUpdating is null it means that the component is not yet created\n  if (cp.$isUpdating === null) {\n    // It will set a new property telling that the component is being created\n    Object.defineProperty(cp, '$isCreating', {\n      writable: false,\n      configurable: true,\n      value: true\n    });\n  }\n  // If the component is already updating it will be added to the queue\n  else if (cp.$isBusy) {\n    // Will add to the queue in priority\n    return await cp.$forceUpdate();\n  }\n  else {\n    // Setting the component as being updated\n    cp.$isUpdating = true;\n  }\n\n  // The HTML component's root in the DOM\n  let root = cp.$el;\n  // Attaching shadow should be defined in the config\n  if (cp.$cfg.shadow) {\n    root = cp.$el.attachShadow({ mode: \"open\" });\n  }\n\n  // The first launch must be for the whole component\n  if (id && ((id === '0') || cp.$isCreating)) {\n    id = false;\n  }\n\n  // Setting the state of each element in $expResults to TMP except DEL state, which remains\n  for (let n1 in cp.$expResults) {\n    for (let n2 in cp.$expResults[n1]) {\n      if (!['DEL', 'TMP'].includes(cp.$expResults[n1][n2].state) && (cp.$expResults[n1][n2].num <= cp.$numBuild)) {\n        cp.$expResults[n1][n2].state = 'TMP';\n      }\n    }\n  }\n\n  if (id) {\n    dist[\"default\"].fn.log(\"element in \" + cp.$options.name)\n    await handleElement(cp, id, hash);\n  }\n  else {\n    //bbn.fn.log(\"From launch number \" + cp.$numBuild + \": component \" + cp.$options.name)\n    await handleComponent(cp);\n  }\n\n  if (!cp.$numBuild) {\n    // Init watchers\n    dist[\"default\"].fn.iterate(cp.$watcher, (a, n) => {\n      (0,updateWatcher[\"default\"])(cp, n, dist[\"default\"].fn.getProperty(cp, n), true);\n    });\n  }\n\n  while(cp.$connectors.length) {\n    let ele = cp.$connectors.shift();\n    if (ele.bbn && ele.isConnected) {\n      ele.bbn.$connected();\n    }\n    else {\n      ele.bbnConnected = true;\n    }\n  }\n\n  if (!id) {\n    cp.$numBuild++;\n  }\n\n  if (cp.$isCreating) {\n    // $isCreating will remain false from now on\n    Object.defineProperty(cp, '$isCreating', {\n      writable: false,\n      configurable: false,\n      value: false\n    });\n    // Emitted only at the component's creation\n    cp.$emit('domcreated');\n  }\n\n  // For the first launch $isUpdating is null, otherwise true\n  // setting it to false will make $isBusy false and allow to launch again\n  cp.$isUpdating = false;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/launch.js_+_28_modules?");

/***/ }),

/***/ "./src/lib/Cp/private/propagateDependencyChanges.js":
/*!**********************************************************!*\
  !*** ./src/lib/Cp/private/propagateDependencyChanges.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ propagateDependencyChanges)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\nfunction propagateDependencyChanges(cp, name, hash) {\n  _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.iterate(cp.$computed, (v, n) => {\n    if (v.dependencies && v.dependencies.includes(name)) {\n      cp.$computed[n].update();\n    };\n  });\n  let shouldTick = false;\n  _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.iterate(cp.$currentMap, (v, n) => {\n    if (v.dependencies && v.dependencies.includes(name)) {\n      if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cp.isComponent(v)) {\n        if (cp.$elements[v.id]) {\n          if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isDom(cp.$elements[v.id])) {\n            if (cp.$elements[v.id].bbn) {\n              cp.$elements[v.id].bbn.$tick();\n            }\n            else if (!shouldTick) {\n              shouldTick = true;\n            }\n          }\n          else if (hash && cp.$elementsv[v.id][hash]) {\n            if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isDom(cp.$elements[v.id][hash])) {\n              if (cp.$elements[v.id][hash].bbn) {\n                cp.$elements[v.id][hash].bbn.$tick();\n              }\n              else if (!shouldTick) {\n                shouldTick = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  if (cp.$deps[name]) {\n    cp.$deps[name].forEach((a) => {\n      if (a instanceof bbnData) {\n        a.update();\n      }\n      else if (a instanceof bbnCp) {\n        a.$nextTick(() => a.$tick());\n      }\n    });\n  }\n\n  if (shouldTick) {\n    _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.log(\"SHOULD TICK ON \" + cp.$options.name)\n    cp.$tick();\n  }\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/propagateDependencyChanges.js?");

/***/ }),

/***/ "./src/lib/Cp/private/realSetProp.js":
/*!*******************************************!*\
  !*** ./src/lib/Cp/private/realSetProp.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ realSetProp)\n/* harmony export */ });\n/* harmony import */ var _updateWatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updateWatcher.js */ \"./src/lib/Cp/private/updateWatcher.js\");\n/* harmony import */ var _propagateDependencyChanges_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./propagateDependencyChanges.js */ \"./src/lib/Cp/private/propagateDependencyChanges.js\");\n\n\n/**\n * Updates a property of a component with a new value, managing data binding and event emission.\n * \n * @param {bbnCp} cp - The component instance on which the property will be set.\n * @param {String} name - The name of the property to be set. It will be converted to camelCase if not already.\n * @param {any} value - The new value to be set for the property.\n */\nfunction realSetProp(cp, name, value) {\n  // Convert the property name to camelCase if it's not already.\n  if (!/[A-Z]/.test(name)) {\n    name = bbn.fn.camelize(name);\n  }\n\n  // Retrieve the original value of the property.\n  const original = cp.$props[name];\n\n  // Get data objects associated with the original and new values.\n  const oldObj = bbnData.getObject(original);\n  const newObj = bbnData.getObject(cp.$treatValue(value, name));\n\n  // Flag to determine if further actions are needed.\n  let todo = true;\n\n  // If the original value is a data object.\n  if (oldObj) {\n    // If the new value is also a data object.\n    if (newObj) {\n      // If they are different objects.\n      if (newObj !== oldObj) {\n        // If the old object is associated with the component, remove the association.\n        if (oldObj.hasComponent(cp, name)) {\n          oldObj.removeComponent(cp, name);\n        }\n\n        // Add the new object's association with the component.\n        newObj.addComponent(cp, name);\n      }\n    }\n    else {\n      // If the new value is not a data object, remove the old object's association.\n      if (oldObj.hasComponent(cp, name)) {\n        oldObj.removeComponent(cp, name);\n      }\n\n      // Treat the new value (possibly for reactivity or formatting).\n      value = cp.$treatValue(value, name);\n    }\n  }\n  // If the new value is a data object and different from the old value.\n  else if (newObj) {\n    newObj.addComponent(cp, name);\n  }\n  // If the new value is truthy and not a data object, treat it.\n  else if (value) {\n    value = cp.$treatValue(value, name);\n  }\n\n  // If the original value is different from the new value, update the property.\n  if (original !== value) {\n\n    Object.defineProperty(cp.$props, name, {\n      value: value,\n      writable: false,\n      configurable: true\n    });\n\n    // Update any watchers that might be observing this property.\n    (0,_updateWatcher_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(cp, name, value);\n    (0,_propagateDependencyChanges_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cp, name);\n  }\n\n  // If the component is already mounted, emit a 'propchange' event.\n  if (cp.$isMounted) {\n    cp.$emit('propchange', name, value, original);\n  }\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/realSetProp.js?");

/***/ }),

/***/ "./src/lib/Cp/private/removeDOM.js":
/*!*****************************************************!*\
  !*** ./src/lib/Cp/private/removeDOM.js + 1 modules ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ removeDOM)\n});\n\n;// CONCATENATED MODULE: ./src/lib/Cp/private/removeFromElements.js\n/**\n * Adds or updates the given element to the $elements object property\n * \n * @param {Symbol} id The ID of the element, based on the template\n * @param {HTMLElement, Text} ele The HTML element to be added\n * @param {String} hash The loop hash if any\n * @param {Number} index The loop index if any\n * @returns {undefined}\n */\nfunction removeFromElements(cp, id, hash) {\n  bbn.fn.checkType(id, ['string', 'symbol'], \"In removeFromElements the ID should be a symbol\");\n  if (hash) {\n    const row = cp.$elements[id];\n    if (row) {\n      delete cp.$elements[id][hash];\n    }\n    else{\n      bbn.fn.log([\"HASH BUT NO ROW IN \" + cp.$options.name, id, hash, cp.$elements[id]]);\n    }\n  }\n  else {\n    delete cp.$elements[id];\n  }\n}\n;// CONCATENATED MODULE: ./src/lib/Cp/private/removeDOM.js\n\n\n/**\n * Remove an element from the DOM\n * @param {HTMLElement} ele\n */\nfunction removeDOM(cp, ele) {\n  //bbn.fn.log([cp, \"REMOVING \" + (ele.bbn ? ele.bbn.$options.name + ' ': '') + ele.bbnId]);\n  if (ele.bbnId === \"0-1-0-0-0\") {\n    bbn.fn.warning(\"----- removeDOM -----\");\n    bbn.fn.log(['removeDOM', ele, cp]);\n  }\n\n  const id = ele.bbnId;\n  const hash = ele.bbnHash;\n  // It won't have an ID if it's a bbn-text or bbn-html or creaated by an external component/widget\n  if (id) {\n    if (ele.bbnSlots) {\n      for (let n in ele.bbnSlots) {\n        let slot = ele.bbnSlots[n].splice(0, ele.bbnSlots[n].length);\n        for (let i = 0; i < slot.length; i++) {\n          let o = slot[i];\n          //bbn.fn.log(\"REMOVE FROM SLOT\", o);\n          let myCp = o.bbnComponentId !== cp.$cid ? bbn.cp.getComponent(o.bbnComponentId)?.bbn || cp : cp;\n          removeDOM(myCp, o);\n        }\n      }\n    }\n\n    if (ele.childNodes && ele.bbnSchema && !Object.hasOwn(ele.bbnSchema.props || {}, 'bbn-text') && !Object.hasOwn(ele.bbnSchema.props || {}, 'bbn-html') && (ele.bbnSchema.tag !== 'svg')) {\n      while (ele.childNodes.length) {\n        let node = ele.childNodes[0];\n        let myCp = ele.bbnComponentId !== cp.$cid ? bbn.cp.getComponent(ele.bbnComponentId)?.bbn || cp : cp;\n        removeDOM(myCp, node);\n      }\n    }\n\n    if (hash) {\n      if (cp.$elements[id]?.[hash] === ele) {\n        removeFromElements(cp, id, hash);\n      }\n    }\n    else if (cp.$elements[id] === ele) {\n      removeFromElements(cp, id);\n    }\n  }\n\n  if (ele.parentNode) {\n    ele.parentNode.removeChild(ele);\n  }\n}\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/removeDOM.js_+_1_modules?");

/***/ }),

/***/ "./src/lib/Cp/private/setExpResult.js":
/*!********************************************!*\
  !*** ./src/lib/Cp/private/setExpResult.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setExpResult)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n/* harmony import */ var _treatArgument_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./treatArgument.js */ \"./src/lib/Cp/private/treatArgument.js\");\n\n\n\n/**\n * Sets or updates the internal result for a given name and hash within the context of the component.\n * This method manages the state of the result, tracking changes and updates.\n * \n * @param {string} attr.hash - The name associated with the result. Acts as a key in the results object.\n * @param {*} expValue - The result or value to be set or updated.\n * @param {string} [hash='_root'] - The hash associated with this result, defaults to '_root' if not provided.\n * @returns {*} The updated result value.\n */\nfunction setExpResult(cp, attr, hash, data, force) {\n  const r = cp.$expResults;\n  // Ensure the existence of a result object for the given name.\n  if (!r[attr.hash]) {\n    r[attr.hash] = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.createObject();\n  }\n\n  // Default the hash to '_root' if not provided.\n  if (!hash) {\n    hash = '_root';\n  }\n\n  if (!r[attr.hash][hash] || force || (r[attr.hash][hash].num <= cp.$numBuild)) {\n    const v = () => {\n      const args = attr.args ? attr.args.map(a => {\n        let res;\n        try {\n          // Process each argument using treatArgument.\n          res = (0,_treatArgument_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cp, a, hash, data);\n        }\n        catch(e) {\n          // Log and rethrow any errors encountered during argument processing.\n          _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.log([\"ERROR IN TREAT ARGUMENT\", e, a, cp, hash, attr, data]);\n          throw Error(e.message + ' (' + _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Expression\") + ': ' + attr.exp + ')');\n        }\n    \n        return res; // Return the processed argument.\n      }) : [];\n\n      return attr.fn.bind(cp)(...args);\n    };\n    bbnData.startWatching();\n    const expValue = v();\n    const sequence = bbnData.stopWatching();\n    for (let i = 0; i < sequence.length; i++) {\n      let a = sequence[i];\n      if (a.data instanceof bbnData) {\n        if (!a.data.deps.includes(cp)) {\n          a.data.deps.push(cp);\n        }\n\n        if (!a.cp.$deps.__bbnDataRegister.has(a.data.id)) {\n          a.cp.$deps.__bbnDataRegister.set(a.data.id, cp);\n        }\n      }\n      else {\n        if (!a.cp.$deps[a.name]) {\n          a.cp.$deps[a.name] = [];\n        }\n\n        if (!a.cp.$deps[a.name].includes(cp)) {\n          a.cp.$deps[a.name].push(cp);\n        }\n      }\n    }\n\n    // If the result for the given name and hash doesn't exist, create it.\n    if (!r[attr.hash][hash]) {\n      r[attr.hash][hash] = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.createObject({\n        state: 'NEW', // Mark the state as new.\n        value: expValue,   // Set the provided result.\n        old: bbnData.hash(expValue), // Store a hash of the value for comparison purposes.\n      });\n      cp.$tick();\n    }\n    // If the existing state is 'DEL', update the value and mark as new.\n    else if (r[attr.hash][hash].state === 'DEL') {\n      r[attr.hash][hash].value = expValue;\n      r[attr.hash][hash].state = 'NEW';\n      cp.$tick();\n    }\n    // If the state is 'TMP', update the value and determine if it has been modified.\n    else if (r[attr.hash][hash].state === 'TMP') {\n      r[attr.hash][hash].value = expValue;\n      const _o = bbnData.hash(expValue);\n      // Check if the value has changed since the last update.\n      if (!_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isSame(r[attr.hash][hash].old, _o)) {\n        r[attr.hash][hash].state = 'MOD'; // Modified state.\n        // Update the old hash to the current hash.\n        r[attr.hash][hash].old = _o;\n        cp.$tick();\n      }\n      else {\n        r[attr.hash][hash].state = 'OK'; // Unchanged state.\n      }\n\n    }\n\n    if (!force) {\n      r[attr.hash][hash].num = cp.$numBuild + 1;\n    }\n    //r[attr.hash][hash].dependencies = dependencies;\n  }\n\n  // Return the updated result value.\n  return r[attr.hash][hash].value;\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/setExpResult.js?");

/***/ }),

/***/ "./src/lib/Cp/private/setProp.js":
/*!***************************************!*\
  !*** ./src/lib/Cp/private/setProp.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setProp)\n/* harmony export */ });\n/* harmony import */ var _realSetProp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./realSetProp.js */ \"./src/lib/Cp/private/realSetProp.js\");\n/* harmony import */ var _checkPropValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkPropValue.js */ \"./src/lib/Cp/private/checkPropValue.js\");\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\n\n\n/**\n * Sets a property value on a given component, performing necessary checks and transformations.\n *\n * @param {Object} cp - The component on which the property is to be set.\n * @param {string} name - The name of the property. It will be camelized if not already.\n * @param {*} value - The value to be set for the property.\n * @returns {void} This function doesn't explicitly return a value but sets the property on the component.\n * @throws {Error} Throws an error if the validation in `checkPropValue` fails.\n */\nfunction setProp(cp, name, value) {\n  // Convert the property name to camelCase if it's not already.\n  if (!/[A-Z]/.test(name)) {\n    name = _bbn_bbn__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fn.camelize(name);\n  }\n\n  // Retrieve the configuration for the specified property.\n  const cfg = cp.$cfg.props[name];\n\n  // Check if the property is a standard one or starts with 'bbn'. If not, issue a warning.\n  if (!cp.$el.constructor.bbnFn.acceptedAttributes.includes(name) && (name.indexOf('bbn') !== 0)) {\n    _bbn_bbn__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fn.warning(_bbn_bbn__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._(\"The attribute %s in %s is not a property\", name, cp.$options.name));\n    return;\n  }\n\n  // Check if the property is defined in the component. If not, issue a warning.\n  if (!Object.hasOwn(cp.$props, name)) {\n    _bbn_bbn__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fn.warning(_bbn_bbn__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._(\"The attribute %s in %s is not defined\", name, cp.$options.name));\n    return;\n  }\n\n  // Validate the property value against its configuration.\n  let v = (0,_checkPropValue_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cp, name, cfg, value);\n\n  // If the validated value is the same as the current value, no further action is needed.\n  if (v === cp[name]) {\n    return;\n  }\n\n  // Set the property with the validated value.\n  (0,_realSetProp_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(cp, name, v);\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/setProp.js?");

/***/ }),

/***/ "./src/lib/Cp/private/setUpProp.js":
/*!*****************************************!*\
  !*** ./src/lib/Cp/private/setUpProp.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setUpProp)\n/* harmony export */ });\n/* harmony import */ var _addNamespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addNamespace.js */ \"./src/lib/Cp/private/addNamespace.js\");\n/* harmony import */ var _realSetProp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./realSetProp.js */ \"./src/lib/Cp/private/realSetProp.js\");\n/* harmony import */ var _checkPropValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checkPropValue.js */ \"./src/lib/Cp/private/checkPropValue.js\");\n\n\n\n\n//const globalAttributes = [\"accesskey\",\"autocapitalize\",\"autofocus\",\"class\",\"contenteditable\",\"contextmenu\",\"dir\",\"draggable\",\"enterkeyhint\",\"exportparts\",\"hidden\",\"id\",\"inert\",\"inputmode\",\"contenteditable\",\"is\",\"itemid\",\"itemprop\",\"itemref\",\"itemscope\",\"itemscope\",\"lang\",\"nonce\",\"part\",\"popover\",\"popovertarget\",\"role\",\"slot\",\"name\",\"spellcheck\",\"style\",\"tabindex\",\"title\",\"translate\",\"Text\",\"virtualkeyboardpolicy\",\"contenteditable\"];\n\nfunction setUpProp(cp, name, cfg) {\n  \n  if (!/[A-Z]/.test(name)) {\n    name = bbn.fn.camelize(name);\n  }\n\n  if (name.indexOf('data-') === 0) {\n    throw Error(bbn._(\"The name of the property cannot start with %s\", 'data-'));\n  }\n\n  if (name.indexOf('aria-') === 0) {\n    throw Error(bbn._(\"The name of the property cannot start with %s\", 'aria-'));\n  }\n\n  /*\n  if (globalAttributes.includes(name)) {\n    throw Error(bbn._(\"The name of the property cannot be a global attribute: %s\", name));\n  }\n  */\n\n  if (Object.hasOwn(cp.$cfg.props, name)) {\n    if (!Object.hasOwn(cp.$props, name)) {\n      Object.defineProperty(cp.$props, name, {\n        value: undefined,\n        writable: false,\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    (0,_addNamespace_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(cp, name, 'props');\n  }\n\n  const value = (0,_checkPropValue_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cp, name, cfg);\n  (0,_realSetProp_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cp, name, value);\n}\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/setUpProp.js?");

/***/ }),

/***/ "./src/lib/Cp/private/treatArgument.js":
/*!*********************************************!*\
  !*** ./src/lib/Cp/private/treatArgument.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ treatArgument)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\n/**\n * Processes an argument for a function call within the context of a web component.\n * It attempts to resolve the argument's value from the component's current results,\n * provided data, or the component's properties and methods.\n * \n * @param {bbnCp} cp - The context provider (component instance) containing methods and properties.\n * @param {*} a - The argument to be processed. It can be a string identifier or any other type.\n * @param {string} hash - A unique identifier used in conjunction with cp for state management.\n * @param {Object} data - Additional data that might be required for processing the argument.\n * @returns {*} The resolved value of the argument.\n * @throws {Error} Throws an error if the argument cannot be resolved.\n */\nfunction treatArgument(cp, a, hash, data) {\n  // Check if the argument is a key in the component's current results and the hash exists.\n  if (hash && _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isObject(cp.$expResults[a]) && Object.hasOwn(cp.$expResults[a], hash)) {\n    // Return the value from the component's current results.\n    return cp.$expResults[a][hash].value;\n  }\n  // Check if the argument is a key in the provided data.\n  else if (Object.hasOwn(data || {}, a)) {\n    // Return the value from the provided data.\n    return data[a];\n  }\n  // Check if the argument corresponds to a function in the component.\n  else if (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(cp[a])) {\n    // Return the function bound to the component's context.\n    return cp[a].bind(cp);\n  }\n  // Check if the component has a property or method with the given argument name.\n  else if (cp.$has(a)) {\n    // Return the property or method from the component.\n    return cp[a];\n  }\n  // If none of the above conditions are met, throw an error.\n  else {\n    _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.log([hash, data]);\n    throw Error(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Impossible to find the argument %s in component %s\", a, cp.$options.name));\n  }\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/treatArgument.js?");

/***/ }),

/***/ "./src/lib/Cp/private/updateWatcher.js":
/*!*********************************************!*\
  !*** ./src/lib/Cp/private/updateWatcher.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateWatcher)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\nfunction updateWatcher(cp, name, v, init) {\n  if (!cp.$watcher) {\n    return;\n  }\n\n\n  let lev = 0;\n  const bits = name.split(\".\");\n  for (let i = 0; i < bits.length; i++) {\n    let name = bits.join('.');\n    //bbn.fn.log(\"WATCHER ON \" + name + \" IN \" + cp.$options.name);\n    if (cp.$watcher[name]?.handler) {\n      if (!_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.isFunction(cp.$watcher[name].handler)) {\n        throw Error(_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._(\"Watchers must be function, wrong parameter for %s\", name));\n      }\n\n      const hash = bbnData.hash(v);\n      if ((!lev || cp.$watcher[name].deep) && (hash !== cp.$watcher[name].hash)) {\n        let oldDataObj = bbnData.getObject(cp.$watcher[name].value);\n        let oldV = oldDataObj ? oldDataObj.value : cp.$watcher[name].value;\n        cp.$watcher[name].value = lev ? _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn.getProperty(cp, name) : v;\n        cp.$watcher[name].hash = bbnData.hash(cp.$watcher[name].value);\n        if ((init && cp.$watcher[name].immediate) || (!init && cp.$isInit)) {\n          cp.$watcher[name].num++;\n          cp.$watcher[name].handler.apply(cp, [cp.$watcher[name].value, oldV]);\n        }\n      }\n    }\n    bits.pop();\n    lev++\n  }\n}\n\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Cp/private/updateWatcher.js?");

/***/ }),

/***/ "./src/lib/Data/Data.js":
/*!******************************!*\
  !*** ./src/lib/Data/Data.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bbn/bbn */ \"./node_modules/@bbn/bbn/dist/index.js\");\n\n\n/**\n * Takes care of the data reactivity for non primitive values.\n */\nclass bbnData/* extends EventTarget*/ {\n\n  /**\n   * Returns a unique identifier from any type of value (hashes only simple objects and arrays)\n   * \n   * @param {*} v Value to hash\n   * @returns {String} The hash\n   */\n  static hash = _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.hash;\n\n  static inventory = new Map();\n\n  static watchSequence = [];\n\n  static isWatching = false;\n\n  static watchStarted = false;\n\n  static lastSequence = null;\n\n  static stoppers = [];\n\n  static startWatching() {\n    const currentSequence = this.watchSequence.splice(0, this.watchSequence.length);\n    this.stoppers.push(() => {\n      this.watchSequence.splice(0, 0, ...currentSequence);\n    });\n    if (!this.isWatching) {\n      this.lastSequence = null;\n    this.isWatching = true;\n  }\n  }\n\n  static stopWatching() {\n    const res = this.watchSequence.splice(0, this.watchSequence.length);\n    this.lastSequence = res.length ? res[res.length - 1] : null;\n    this.stoppers.pop()();\n    this.isWatching = !!this.stoppers.length;\n    return res;\n  }\n\n  static getLastUsed() {\n    return this.lastSequence;\n  }\n\n  static addSequence(cp, name, data) {\n    if (this.watchStarted && (_bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.isString(name) || _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.isInt(name))) {\n      this.watchSequence.push({cp, name, data});\n    }\n  }\n\n\n  /**\n   * Constructor\n   * @param {Object} data A regular object or array i.e. it mustn't be a class instance\n   * @param {bbnCp} component The bbn component that contains the data\n   * @param {String} path The path of the data in the component\n   * @param {bbnData} parent If the data is a sub-object of another bbnData object, the parent object\n   */\n  constructor(data, component, path, parent) {\n    //super();\n    if (path === 'computed') {\n      _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.log([component, path, parent, data]);\n      throw Error(\"bbnData cannot be initialized with a computed property\");\n    }\n\n    if (data instanceof bbnData) {\n      throw Error(\"bbnData cannot be initialized with a bbnData\");\n    }\n\n    if (!(component instanceof bbnCp)) {\n      throw Error(\"bbnData must be initialized with a bbn component\");\n    }\n\n    if (!data || (typeof data !== 'object') || ![undefined, Object, Array].includes(data.constructor)) {\n      _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.log(data);\n      throw Error(\"The object given is not compatible with bbnData\");\n    }\n\n    if (data?.__bbnData) {\n      throw Error(\"bbnData cannot be initialized multiple times\");\n    }\n\n    if (parent && !(parent instanceof bbnData)) {\n      throw Error(\"parent must be a bbnData\");\n    }\n\n    /**\n     * @var {Symbol} id The unique id of the bbnData object\n     */\n    const id = Symbol();\n    // The object is added to the data inventory\n    bbnData.inventory.set(id, this);\n    Object.defineProperty(this, 'id', {\n      writable: false,\n      configurable: false,\n      value: id\n    });\n\n    /**\n     * @var {Array} children The children bbnData objects (which have this object as parent)\n     */\n    Object.defineProperty(this, 'children', {\n      value: [],\n      writable: false,\n      configurable: false\n    });\n\n    /**\n     * @var {Symbol} __bbnData The special property added to the data object to identify it as being part of a bbnData object\n     */\n    Object.defineProperty(data, '__bbnData', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: this.id\n    });\n\n    /**\n     * @var {Object|Array} data The original data object\n     */\n    Object.defineProperty(this, 'data', {\n      value: data,\n      writable: false,\n      configurable: true\n    });\n\n    /**\n     * @var {Proxy} value The proxy takes care of subreactivity\n     */\n    Object.defineProperty(this, 'value', {\n      value: new Proxy(this.data, this.constructor.proxy(component, path, this)),\n      writable: false,\n      configurable: false\n    });\n\n    /**\n     * @var {Boolean} isArray If the data is an array\n     */\n    Object.defineProperty(this, 'isArray', {\n      value: data instanceof Array,\n      writable: false,\n      configurable: true\n    });\n\n    /**\n     * @var {String} old The hash of the data object\n     */\n    Object.defineProperty(this, 'old', {\n      value: _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.hash(data),\n      writable: true,\n      configurable: true\n    });\n\n    /**\n     * @var {Object} components The components that use this data object, indexed by their unique id (cid)\n     */\n    Object.defineProperty(this, 'components', {\n      value: _bbn_bbn__WEBPACK_IMPORTED_MODULE_0__.bbn.fn.createObject(),\n      writable: false,\n      configurable: false\n    });\n\n    Object.defineProperty(this, 'deps', {\n      value: [],\n      writable: false,\n      configurable: false\n    });\n\n    Object.defineProperty(this, 'refs', {\n      value: [],\n      writable: false,\n      configurable: false\n    });\n\n    this.refs.push({\n      component,\n      path,\n      root: true,\n      parent: parent || null\n    });\n\n    if (component.$values.indexOf(this.id) === -1) {\n      component.$values.push(this.id);\n    }\n\n    // If the object has a parent, the current object is added to the parent's children\n    if (parent) {\n      //bbn.fn.log(bbn._(\"ADDING CHILDREN for %s : %s\", path.toString ? path.toString() : path || '<unknown>', JSON.stringify(this.data)))\n      parent.children.push(this);\n    }\n\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bbnData);\n\n//# sourceURL=webpack://@bbn/bbn-cp/./src/lib/Data/Data.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "@bbn/bbn-cp:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"bbn-cp": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_bbn_bbn_cp"] = self["webpackChunk_bbn_bbn_cp"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	var __webpack_export_target__ = self;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;